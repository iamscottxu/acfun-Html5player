/*!
MIT License

Copyright (c) 2018-2019 Scott Xu

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

Home: https://iamscottxu.github.io/openBSE/
*/
(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],2:[function(require,module,exports){
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./_wks')('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) require('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

},{"./_hide":32,"./_wks":88}],3:[function(require,module,exports){
'use strict';
var at = require('./_string-at')(true);

 // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};

},{"./_string-at":73}],4:[function(require,module,exports){
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],5:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":40}],6:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};

},{"./_to-absolute-index":74,"./_to-length":78,"./_to-object":79}],7:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

},{"./_to-absolute-index":74,"./_to-length":78,"./_to-object":79}],8:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":74,"./_to-iobject":77,"./_to-length":78}],9:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = require('./_ctx');
var IObject = require('./_iobject');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var asc = require('./_array-species-create');
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

},{"./_array-species-create":11,"./_ctx":18,"./_iobject":37,"./_to-length":78,"./_to-object":79}],10:[function(require,module,exports){
var isObject = require('./_is-object');
var isArray = require('./_is-array');
var SPECIES = require('./_wks')('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};

},{"./_is-array":39,"./_is-object":40,"./_wks":88}],11:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

},{"./_array-species-constructor":10}],12:[function(require,module,exports){
'use strict';
var aFunction = require('./_a-function');
var isObject = require('./_is-object');
var invoke = require('./_invoke');
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

},{"./_a-function":1,"./_invoke":36,"./_is-object":40}],13:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":14,"./_wks":88}],14:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],15:[function(require,module,exports){
'use strict';
var dP = require('./_object-dp').f;
var create = require('./_object-create');
var redefineAll = require('./_redefine-all');
var ctx = require('./_ctx');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var $iterDefine = require('./_iter-define');
var step = require('./_iter-step');
var setSpecies = require('./_set-species');
var DESCRIPTORS = require('./_descriptors');
var fastKey = require('./_meta').fastKey;
var validate = require('./_validate-collection');
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

},{"./_an-instance":4,"./_ctx":18,"./_descriptors":20,"./_for-of":28,"./_iter-define":44,"./_iter-step":46,"./_meta":49,"./_object-create":50,"./_object-dp":51,"./_redefine-all":62,"./_set-species":67,"./_validate-collection":85}],16:[function(require,module,exports){
'use strict';
var global = require('./_global');
var $export = require('./_export');
var redefine = require('./_redefine');
var redefineAll = require('./_redefine-all');
var meta = require('./_meta');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var fails = require('./_fails');
var $iterDetect = require('./_iter-detect');
var setToStringTag = require('./_set-to-string-tag');
var inheritIfRequired = require('./_inherit-if-required');

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

},{"./_an-instance":4,"./_export":24,"./_fails":25,"./_for-of":28,"./_global":30,"./_inherit-if-required":35,"./_is-object":40,"./_iter-detect":45,"./_meta":49,"./_redefine":63,"./_redefine-all":62,"./_set-to-string-tag":68}],17:[function(require,module,exports){
var core = module.exports = { version: '2.6.5' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],18:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":1}],19:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],20:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":25}],21:[function(require,module,exports){
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":30,"./_is-object":40}],22:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],23:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-gops":56,"./_object-keys":59,"./_object-pie":60}],24:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var hide = require('./_hide');
var redefine = require('./_redefine');
var ctx = require('./_ctx');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":17,"./_ctx":18,"./_global":30,"./_hide":32,"./_redefine":63}],25:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],26:[function(require,module,exports){
'use strict';
require('./es6.regexp.exec');
var redefine = require('./_redefine');
var hide = require('./_hide');
var fails = require('./_fails');
var defined = require('./_defined');
var wks = require('./_wks');
var regexpExec = require('./_regexp-exec');

var SPECIES = wks('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
})();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;
    re.exec = function () { execCalled = true; return null; };
    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
    }
    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(
      defined,
      SYMBOL,
      ''[KEY],
      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === regexpExec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
        }
        return { done: false };
      }
    );
    var strfn = fns[0];
    var rxfn = fns[1];

    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};

},{"./_defined":19,"./_fails":25,"./_hide":32,"./_redefine":63,"./_regexp-exec":65,"./_wks":88,"./es6.regexp.exec":103}],27:[function(require,module,exports){
'use strict';
// 21.2.5.3 get RegExp.prototype.flags
var anObject = require('./_an-object');
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

},{"./_an-object":5}],28:[function(require,module,exports){
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_an-object":5,"./_ctx":18,"./_is-array-iter":38,"./_iter-call":42,"./_to-length":78,"./core.get-iterator-method":89}],29:[function(require,module,exports){
module.exports = require('./_shared')('native-function-to-string', Function.toString);

},{"./_shared":70}],30:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],31:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],32:[function(require,module,exports){
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":20,"./_object-dp":51,"./_property-desc":61}],33:[function(require,module,exports){
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":30}],34:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":20,"./_dom-create":21,"./_fails":25}],35:[function(require,module,exports){
var isObject = require('./_is-object');
var setPrototypeOf = require('./_set-proto').set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};

},{"./_is-object":40,"./_set-proto":66}],36:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};

},{}],37:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":14}],38:[function(require,module,exports){
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":47,"./_wks":88}],39:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":14}],40:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],41:[function(require,module,exports){
// 7.2.8 IsRegExp(argument)
var isObject = require('./_is-object');
var cof = require('./_cof');
var MATCH = require('./_wks')('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

},{"./_cof":14,"./_is-object":40,"./_wks":88}],42:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":5}],43:[function(require,module,exports){
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_hide":32,"./_object-create":50,"./_property-desc":61,"./_set-to-string-tag":68,"./_wks":88}],44:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_export":24,"./_hide":32,"./_iter-create":43,"./_iterators":47,"./_library":48,"./_object-gpo":57,"./_redefine":63,"./_set-to-string-tag":68,"./_wks":88}],45:[function(require,module,exports){
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":88}],46:[function(require,module,exports){
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],47:[function(require,module,exports){
module.exports = {};

},{}],48:[function(require,module,exports){
module.exports = false;

},{}],49:[function(require,module,exports){
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_fails":25,"./_has":31,"./_is-object":40,"./_object-dp":51,"./_uid":84}],50:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":5,"./_dom-create":21,"./_enum-bug-keys":22,"./_html":33,"./_object-dps":52,"./_shared-key":69}],51:[function(require,module,exports){
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":5,"./_descriptors":20,"./_ie8-dom-define":34,"./_to-primitive":80}],52:[function(require,module,exports){
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_an-object":5,"./_descriptors":20,"./_object-dp":51,"./_object-keys":59}],53:[function(require,module,exports){
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_descriptors":20,"./_has":31,"./_ie8-dom-define":34,"./_object-pie":60,"./_property-desc":61,"./_to-iobject":77,"./_to-primitive":80}],54:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":55,"./_to-iobject":77}],55:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_enum-bug-keys":22,"./_object-keys-internal":58}],56:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],57:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":31,"./_shared-key":69,"./_to-object":79}],58:[function(require,module,exports){
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_array-includes":8,"./_has":31,"./_shared-key":69,"./_to-iobject":77}],59:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":22,"./_object-keys-internal":58}],60:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],61:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],62:[function(require,module,exports){
var redefine = require('./_redefine');
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};

},{"./_redefine":63}],63:[function(require,module,exports){
var global = require('./_global');
var hide = require('./_hide');
var has = require('./_has');
var SRC = require('./_uid')('src');
var $toString = require('./_function-to-string');
var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

},{"./_core":17,"./_function-to-string":29,"./_global":30,"./_has":31,"./_hide":32,"./_uid":84}],64:[function(require,module,exports){
'use strict';

var classof = require('./_classof');
var builtinExec = RegExp.prototype.exec;

 // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }
  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }
  return builtinExec.call(R, S);
};

},{"./_classof":13}],65:[function(require,module,exports){
'use strict';

var regexpFlags = require('./_flags');

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
})();

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];

    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;

},{"./_flags":27}],66:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object');
var anObject = require('./_an-object');
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

},{"./_an-object":5,"./_ctx":18,"./_is-object":40,"./_object-gopd":53}],67:[function(require,module,exports){
'use strict';
var global = require('./_global');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_descriptors":20,"./_global":30,"./_object-dp":51,"./_wks":88}],68:[function(require,module,exports){
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_has":31,"./_object-dp":51,"./_wks":88}],69:[function(require,module,exports){
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":70,"./_uid":84}],70:[function(require,module,exports){
var core = require('./_core');
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: require('./_library') ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});

},{"./_core":17,"./_global":30,"./_library":48}],71:[function(require,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var SPECIES = require('./_wks')('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

},{"./_a-function":1,"./_an-object":5,"./_wks":88}],72:[function(require,module,exports){
'use strict';
var fails = require('./_fails');

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};

},{"./_fails":25}],73:[function(require,module,exports){
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_defined":19,"./_to-integer":76}],74:[function(require,module,exports){
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":76}],75:[function(require,module,exports){
// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

},{"./_to-integer":76,"./_to-length":78}],76:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],77:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":19,"./_iobject":37}],78:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":76}],79:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":19}],80:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":40}],81:[function(require,module,exports){
'use strict';
if (require('./_descriptors')) {
  var LIBRARY = require('./_library');
  var global = require('./_global');
  var fails = require('./_fails');
  var $export = require('./_export');
  var $typed = require('./_typed');
  var $buffer = require('./_typed-buffer');
  var ctx = require('./_ctx');
  var anInstance = require('./_an-instance');
  var propertyDesc = require('./_property-desc');
  var hide = require('./_hide');
  var redefineAll = require('./_redefine-all');
  var toInteger = require('./_to-integer');
  var toLength = require('./_to-length');
  var toIndex = require('./_to-index');
  var toAbsoluteIndex = require('./_to-absolute-index');
  var toPrimitive = require('./_to-primitive');
  var has = require('./_has');
  var classof = require('./_classof');
  var isObject = require('./_is-object');
  var toObject = require('./_to-object');
  var isArrayIter = require('./_is-array-iter');
  var create = require('./_object-create');
  var getPrototypeOf = require('./_object-gpo');
  var gOPN = require('./_object-gopn').f;
  var getIterFn = require('./core.get-iterator-method');
  var uid = require('./_uid');
  var wks = require('./_wks');
  var createArrayMethod = require('./_array-methods');
  var createArrayIncludes = require('./_array-includes');
  var speciesConstructor = require('./_species-constructor');
  var ArrayIterators = require('./es6.array.iterator');
  var Iterators = require('./_iterators');
  var $iterDetect = require('./_iter-detect');
  var setSpecies = require('./_set-species');
  var arrayFill = require('./_array-fill');
  var arrayCopyWithin = require('./_array-copy-within');
  var $DP = require('./_object-dp');
  var $GOPD = require('./_object-gopd');
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };

},{"./_an-instance":4,"./_array-copy-within":6,"./_array-fill":7,"./_array-includes":8,"./_array-methods":9,"./_classof":13,"./_ctx":18,"./_descriptors":20,"./_export":24,"./_fails":25,"./_global":30,"./_has":31,"./_hide":32,"./_is-array-iter":38,"./_is-object":40,"./_iter-detect":45,"./_iterators":47,"./_library":48,"./_object-create":50,"./_object-dp":51,"./_object-gopd":53,"./_object-gopn":55,"./_object-gpo":57,"./_property-desc":61,"./_redefine-all":62,"./_set-species":67,"./_species-constructor":71,"./_to-absolute-index":74,"./_to-index":75,"./_to-integer":76,"./_to-length":78,"./_to-object":79,"./_to-primitive":80,"./_typed":83,"./_typed-buffer":82,"./_uid":84,"./_wks":88,"./core.get-iterator-method":89,"./es6.array.iterator":93}],82:[function(require,module,exports){
'use strict';
var global = require('./_global');
var DESCRIPTORS = require('./_descriptors');
var LIBRARY = require('./_library');
var $typed = require('./_typed');
var hide = require('./_hide');
var redefineAll = require('./_redefine-all');
var fails = require('./_fails');
var anInstance = require('./_an-instance');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var toIndex = require('./_to-index');
var gOPN = require('./_object-gopn').f;
var dP = require('./_object-dp').f;
var arrayFill = require('./_array-fill');
var setToStringTag = require('./_set-to-string-tag');
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

},{"./_an-instance":4,"./_array-fill":7,"./_descriptors":20,"./_fails":25,"./_global":30,"./_hide":32,"./_library":48,"./_object-dp":51,"./_object-gopn":55,"./_redefine-all":62,"./_set-to-string-tag":68,"./_to-index":75,"./_to-integer":76,"./_to-length":78,"./_typed":83}],83:[function(require,module,exports){
var global = require('./_global');
var hide = require('./_hide');
var uid = require('./_uid');
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

},{"./_global":30,"./_hide":32,"./_uid":84}],84:[function(require,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],85:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

},{"./_is-object":40}],86:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_core":17,"./_global":30,"./_library":48,"./_object-dp":51,"./_wks-ext":87}],87:[function(require,module,exports){
exports.f = require('./_wks');

},{"./_wks":88}],88:[function(require,module,exports){
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_global":30,"./_shared":70,"./_uid":84}],89:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":13,"./_core":17,"./_iterators":47,"./_wks":88}],90:[function(require,module,exports){
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_add-to-unscopables":2,"./_array-methods":9,"./_export":24}],91:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $forEach = require('./_array-methods')(0);
var STRICT = require('./_strict-method')([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":9,"./_export":24,"./_strict-method":72}],92:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $indexOf = require('./_array-includes')(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});

},{"./_array-includes":8,"./_export":24,"./_strict-method":72}],93:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":2,"./_iter-define":44,"./_iter-step":46,"./_iterators":47,"./_to-iobject":77}],94:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var fails = require('./_fails');
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !require('./_strict-method')($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});

},{"./_a-function":1,"./_export":24,"./_fails":25,"./_strict-method":72,"./_to-object":79}],95:[function(require,module,exports){
var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  require('./_redefine')(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

},{"./_redefine":63}],96:[function(require,module,exports){
// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = require('./_export');

$export($export.P, 'Function', { bind: require('./_bind') });

},{"./_bind":12,"./_export":24}],97:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var MAP = 'Map';

// 23.1 Map Objects
module.exports = require('./_collection')(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

},{"./_collection":16,"./_collection-strong":15,"./_validate-collection":85}],98:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: require('./_object-create') });

},{"./_export":24,"./_object-create":50}],99:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });

},{"./_descriptors":20,"./_export":24,"./_object-dp":51}],100:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });

},{"./_export":24,"./_set-proto":66}],101:[function(require,module,exports){
// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = require('./_export');
var create = require('./_object-create');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var fails = require('./_fails');
var bind = require('./_bind');
var rConstruct = (require('./_global').Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

},{"./_a-function":1,"./_an-object":5,"./_bind":12,"./_export":24,"./_fails":25,"./_global":30,"./_is-object":40,"./_object-create":50}],102:[function(require,module,exports){
var global = require('./_global');
var inheritIfRequired = require('./_inherit-if-required');
var dP = require('./_object-dp').f;
var gOPN = require('./_object-gopn').f;
var isRegExp = require('./_is-regexp');
var $flags = require('./_flags');
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (require('./_descriptors') && (!CORRECT_NEW || require('./_fails')(function () {
  re2[require('./_wks')('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  require('./_redefine')(global, 'RegExp', $RegExp);
}

require('./_set-species')('RegExp');

},{"./_descriptors":20,"./_fails":25,"./_flags":27,"./_global":30,"./_inherit-if-required":35,"./_is-regexp":41,"./_object-dp":51,"./_object-gopn":55,"./_redefine":63,"./_set-species":67,"./_wks":88}],103:[function(require,module,exports){
'use strict';
var regexpExec = require('./_regexp-exec');
require('./_export')({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});

},{"./_export":24,"./_regexp-exec":65}],104:[function(require,module,exports){
// 21.2.5.3 get RegExp.prototype.flags()
if (require('./_descriptors') && /./g.flags != 'g') require('./_object-dp').f(RegExp.prototype, 'flags', {
  configurable: true,
  get: require('./_flags')
});

},{"./_descriptors":20,"./_flags":27,"./_object-dp":51}],105:[function(require,module,exports){
'use strict';

var anObject = require('./_an-object');
var toLength = require('./_to-length');
var advanceStringIndex = require('./_advance-string-index');
var regExpExec = require('./_regexp-exec-abstract');

// @@match logic
require('./_fix-re-wks')('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[MATCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative($match, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      if (!rx.global) return regExpExec(rx, S);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});

},{"./_advance-string-index":3,"./_an-object":5,"./_fix-re-wks":26,"./_regexp-exec-abstract":64,"./_to-length":78}],106:[function(require,module,exports){
'use strict';

var anObject = require('./_an-object');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var toInteger = require('./_to-integer');
var advanceStringIndex = require('./_advance-string-index');
var regExpExec = require('./_regexp-exec-abstract');
var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
require('./_fix-re-wks')('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = defined(this);
      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined
        ? fn.call(searchValue, O, replaceValue)
        : $replace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      var res = maybeCallNative($replace, regexp, this, replaceValue);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);
      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;
        results.push(result);
        if (!global) break;
        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

    // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});

},{"./_advance-string-index":3,"./_an-object":5,"./_fix-re-wks":26,"./_regexp-exec-abstract":64,"./_to-integer":76,"./_to-length":78,"./_to-object":79}],107:[function(require,module,exports){
'use strict';

var isRegExp = require('./_is-regexp');
var anObject = require('./_an-object');
var speciesConstructor = require('./_species-constructor');
var advanceStringIndex = require('./_advance-string-index');
var toLength = require('./_to-length');
var callRegExpExec = require('./_regexp-exec-abstract');
var regexpExec = require('./_regexp-exec');
var fails = require('./_fails');
var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex';
var MAX_UINT32 = 0xffffffff;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function () { RegExp(MAX_UINT32, 'y'); });

// @@split logic
require('./_fix-re-wks')('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = defined(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
});

},{"./_advance-string-index":3,"./_an-object":5,"./_fails":25,"./_fix-re-wks":26,"./_is-regexp":41,"./_regexp-exec":65,"./_regexp-exec-abstract":64,"./_species-constructor":71,"./_to-length":78}],108:[function(require,module,exports){
'use strict';
require('./es6.regexp.flags');
var anObject = require('./_an-object');
var $flags = require('./_flags');
var DESCRIPTORS = require('./_descriptors');
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  require('./_redefine')(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (require('./_fails')(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

},{"./_an-object":5,"./_descriptors":20,"./_fails":25,"./_flags":27,"./_redefine":63,"./es6.regexp.flags":104}],109:[function(require,module,exports){
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_iter-define":44,"./_string-at":73}],110:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_an-object":5,"./_descriptors":20,"./_enum-keys":23,"./_export":24,"./_fails":25,"./_global":30,"./_has":31,"./_hide":32,"./_is-array":39,"./_is-object":40,"./_library":48,"./_meta":49,"./_object-create":50,"./_object-dp":51,"./_object-gopd":53,"./_object-gopn":55,"./_object-gopn-ext":54,"./_object-gops":56,"./_object-keys":59,"./_object-pie":60,"./_property-desc":61,"./_redefine":63,"./_set-to-string-tag":68,"./_shared":70,"./_to-iobject":77,"./_to-primitive":80,"./_uid":84,"./_wks":88,"./_wks-define":86,"./_wks-ext":87}],111:[function(require,module,exports){
require('./_typed-array')('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":81}],112:[function(require,module,exports){
require('./_wks-define')('asyncIterator');

},{"./_wks-define":86}],113:[function(require,module,exports){
var $iterators = require('./es6.array.iterator');
var getKeys = require('./_object-keys');
var redefine = require('./_redefine');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var wks = require('./_wks');
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}

},{"./_global":30,"./_hide":32,"./_iterators":47,"./_object-keys":59,"./_redefine":63,"./_wks":88,"./es6.array.iterator":93}],114:[function(require,module,exports){
typeof window !== "undefined" &&
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Hls"] = factory();
	else
		root["Hls"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/hls.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/events/events.js":
/*!**********************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/events/events.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}


/***/ }),

/***/ "./node_modules/url-toolkit/src/url-toolkit.js":
/*!*****************************************************!*\
  !*** ./node_modules/url-toolkit/src/url-toolkit.js ***!
  \*****************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

// see https://tools.ietf.org/html/rfc1808

/* jshint ignore:start */
(function(root) { 
/* jshint ignore:end */

  var URL_REGEX = /^((?:[a-zA-Z0-9+\-.]+:)?)(\/\/[^\/?#]*)?((?:[^\/\?#]*\/)*.*?)??(;.*?)?(\?.*?)?(#.*?)?$/;
  var FIRST_SEGMENT_REGEX = /^([^\/?#]*)(.*)$/;
  var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
  var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/).*?(?=\/)/g;

  var URLToolkit = { // jshint ignore:line
    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
    // E.g
    // With opts.alwaysNormalize = false (default, spec compliant)
    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
    // With opts.alwaysNormalize = true (not spec compliant)
    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
    buildAbsoluteURL: function(baseURL, relativeURL, opts) {
      opts = opts || {};
      // remove any remaining space and CRLF
      baseURL = baseURL.trim();
      relativeURL = relativeURL.trim();
      if (!relativeURL) {
        // 2a) If the embedded URL is entirely empty, it inherits the
        // entire base URL (i.e., is set equal to the base URL)
        // and we are done.
        if (!opts.alwaysNormalize) {
          return baseURL;
        }
        var basePartsForNormalise = URLToolkit.parseURL(baseURL);
        if (!basePartsForNormalise) {
          throw new Error('Error trying to parse base URL.');
        }
        basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);
        return URLToolkit.buildURLFromParts(basePartsForNormalise);
      }
      var relativeParts = URLToolkit.parseURL(relativeURL);
      if (!relativeParts) {
        throw new Error('Error trying to parse relative URL.');
      }
      if (relativeParts.scheme) {
        // 2b) If the embedded URL starts with a scheme name, it is
        // interpreted as an absolute URL and we are done.
        if (!opts.alwaysNormalize) {
          return relativeURL;
        }
        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
        return URLToolkit.buildURLFromParts(relativeParts);
      }
      var baseParts = URLToolkit.parseURL(baseURL);
      if (!baseParts) {
        throw new Error('Error trying to parse base URL.');
      }
      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {
        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc
        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'
        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
        baseParts.netLoc = pathParts[1];
        baseParts.path = pathParts[2];
      }
      if (baseParts.netLoc && !baseParts.path) {
        baseParts.path = '/';
      }
      var builtParts = {
        // 2c) Otherwise, the embedded URL inherits the scheme of
        // the base URL.
        scheme: baseParts.scheme,
        netLoc: relativeParts.netLoc,
        path: null,
        params: relativeParts.params,
        query: relativeParts.query,
        fragment: relativeParts.fragment
      };
      if (!relativeParts.netLoc) {
        // 3) If the embedded URL's <net_loc> is non-empty, we skip to
        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>
        // (if any) of the base URL.
        builtParts.netLoc = baseParts.netLoc;
        // 4) If the embedded URL path is preceded by a slash "/", the
        // path is not relative and we skip to Step 7.
        if (relativeParts.path[0] !== '/') {
          if (!relativeParts.path) {
            // 5) If the embedded URL path is empty (and not preceded by a
            // slash), then the embedded URL inherits the base URL path
            builtParts.path = baseParts.path;
            // 5a) if the embedded URL's <params> is non-empty, we skip to
            // step 7; otherwise, it inherits the <params> of the base
            // URL (if any) and
            if (!relativeParts.params) {
              builtParts.params = baseParts.params;
              // 5b) if the embedded URL's <query> is non-empty, we skip to
              // step 7; otherwise, it inherits the <query> of the base
              // URL (if any) and we skip to step 7.
              if (!relativeParts.query) {
                builtParts.query = baseParts.query;
              }
            }
          } else {
            // 6) The last segment of the base URL's path (anything
            // following the rightmost slash "/", or the entire path if no
            // slash is present) is removed and the embedded URL's path is
            // appended in its place.
            var baseURLPath = baseParts.path;
            var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) + relativeParts.path;
            builtParts.path = URLToolkit.normalizePath(newPath);
          }
        }
      }
      if (builtParts.path === null) {
        builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;
      }
      return URLToolkit.buildURLFromParts(builtParts);
    },
    parseURL: function(url) {
      var parts = URL_REGEX.exec(url);
      if (!parts) {
        return null;
      }
      return {
        scheme: parts[1] || '',
        netLoc: parts[2] || '',
        path: parts[3] || '',
        params: parts[4] || '',
        query: parts[5] || '',
        fragment: parts[6] || ''
      };
    },
    normalizePath: function(path) {
      // The following operations are
      // then applied, in order, to the new path:
      // 6a) All occurrences of "./", where "." is a complete path
      // segment, are removed.
      // 6b) If the path ends with "." as a complete path segment,
      // that "." is removed.
      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');
      // 6c) All occurrences of "<segment>/../", where <segment> is a
      // complete path segment not equal to "..", are removed.
      // Removal of these path segments is performed iteratively,
      // removing the leftmost matching pattern on each iteration,
      // until no matching pattern remains.
      // 6d) If the path ends with "<segment>/..", where <segment> is a
      // complete path segment not equal to "..", that
      // "<segment>/.." is removed.
      while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) {} // jshint ignore:line
      return path.split('').reverse().join('');
    },
    buildURLFromParts: function(parts) {
      return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
    }
  };

/* jshint ignore:start */
  if(true)
    module.exports = URLToolkit;
  else {}
})(this);
/* jshint ignore:end */


/***/ }),

/***/ "./node_modules/webworkify-webpack/index.js":
/*!**************************************************!*\
  !*** ./node_modules/webworkify-webpack/index.js ***!
  \**************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

function webpackBootstrapFunc (modules) {
/******/  // The module cache
/******/  var installedModules = {};

/******/  // The require function
/******/  function __webpack_require__(moduleId) {

/******/    // Check if module is in cache
/******/    if(installedModules[moduleId])
/******/      return installedModules[moduleId].exports;

/******/    // Create a new module (and put it into the cache)
/******/    var module = installedModules[moduleId] = {
/******/      i: moduleId,
/******/      l: false,
/******/      exports: {}
/******/    };

/******/    // Execute the module function
/******/    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/    // Flag the module as loaded
/******/    module.l = true;

/******/    // Return the exports of the module
/******/    return module.exports;
/******/  }

/******/  // expose the modules object (__webpack_modules__)
/******/  __webpack_require__.m = modules;

/******/  // expose the module cache
/******/  __webpack_require__.c = installedModules;

/******/  // identity function for calling harmony imports with the correct context
/******/  __webpack_require__.i = function(value) { return value; };

/******/  // define getter function for harmony exports
/******/  __webpack_require__.d = function(exports, name, getter) {
/******/    if(!__webpack_require__.o(exports, name)) {
/******/      Object.defineProperty(exports, name, {
/******/        configurable: false,
/******/        enumerable: true,
/******/        get: getter
/******/      });
/******/    }
/******/  };

/******/  // define __esModule on exports
/******/  __webpack_require__.r = function(exports) {
/******/    Object.defineProperty(exports, '__esModule', { value: true });
/******/  };

/******/  // getDefaultExport function for compatibility with non-harmony modules
/******/  __webpack_require__.n = function(module) {
/******/    var getter = module && module.__esModule ?
/******/      function getDefault() { return module['default']; } :
/******/      function getModuleExports() { return module; };
/******/    __webpack_require__.d(getter, 'a', getter);
/******/    return getter;
/******/  };

/******/  // Object.prototype.hasOwnProperty.call
/******/  __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/  // __webpack_public_path__
/******/  __webpack_require__.p = "/";

/******/  // on error function for async loading
/******/  __webpack_require__.oe = function(err) { console.error(err); throw err; };

  var f = __webpack_require__(__webpack_require__.s = ENTRY_MODULE)
  return f.default || f // try to call default if defined to also support babel esmodule exports
}

var moduleNameReqExp = '[\\.|\\-|\\+|\\w|\/|@]+'
var dependencyRegExp = '\\((\/\\*.*?\\*\/)?\s?.*?(' + moduleNameReqExp + ').*?\\)' // additional chars when output.pathinfo is true

// http://stackoverflow.com/a/2593661/130442
function quoteRegExp (str) {
  return (str + '').replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&')
}

function isNumeric(n) {
  return !isNaN(1 * n); // 1 * n converts integers, integers as string ("123"), 1e3 and "1e3" to integers and strings to NaN
}

function getModuleDependencies (sources, module, queueName) {
  var retval = {}
  retval[queueName] = []

  var fnString = module.toString()
  var wrapperSignature = fnString.match(/^function\s?\(\w+,\s*\w+,\s*(\w+)\)/)
  if (!wrapperSignature) return retval
  var webpackRequireName = wrapperSignature[1]

  // main bundle deps
  var re = new RegExp('(\\\\n|\\W)' + quoteRegExp(webpackRequireName) + dependencyRegExp, 'g')
  var match
  while ((match = re.exec(fnString))) {
    if (match[3] === 'dll-reference') continue
    retval[queueName].push(match[3])
  }

  // dll deps
  re = new RegExp('\\(' + quoteRegExp(webpackRequireName) + '\\("(dll-reference\\s(' + moduleNameReqExp + '))"\\)\\)' + dependencyRegExp, 'g')
  while ((match = re.exec(fnString))) {
    if (!sources[match[2]]) {
      retval[queueName].push(match[1])
      sources[match[2]] = __webpack_require__(match[1]).m
    }
    retval[match[2]] = retval[match[2]] || []
    retval[match[2]].push(match[4])
  }

  // convert 1e3 back to 1000 - this can be important after uglify-js converted 1000 to 1e3
  var keys = Object.keys(retval);
  for (var i = 0; i < keys.length; i++) {
    for (var j = 0; j < retval[keys[i]].length; j++) {
      if (isNumeric(retval[keys[i]][j])) {
        retval[keys[i]][j] = 1 * retval[keys[i]][j];
      }
    }
  }

  return retval
}

function hasValuesInQueues (queues) {
  var keys = Object.keys(queues)
  return keys.reduce(function (hasValues, key) {
    return hasValues || queues[key].length > 0
  }, false)
}

function getRequiredModules (sources, moduleId) {
  var modulesQueue = {
    main: [moduleId]
  }
  var requiredModules = {
    main: []
  }
  var seenModules = {
    main: {}
  }

  while (hasValuesInQueues(modulesQueue)) {
    var queues = Object.keys(modulesQueue)
    for (var i = 0; i < queues.length; i++) {
      var queueName = queues[i]
      var queue = modulesQueue[queueName]
      var moduleToCheck = queue.pop()
      seenModules[queueName] = seenModules[queueName] || {}
      if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) continue
      seenModules[queueName][moduleToCheck] = true
      requiredModules[queueName] = requiredModules[queueName] || []
      requiredModules[queueName].push(moduleToCheck)
      var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName)
      var newModulesKeys = Object.keys(newModules)
      for (var j = 0; j < newModulesKeys.length; j++) {
        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || []
        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]])
      }
    }
  }

  return requiredModules
}

module.exports = function (moduleId, options) {
  options = options || {}
  var sources = {
    main: __webpack_require__.m
  }

  var requiredModules = options.all ? { main: Object.keys(sources.main) } : getRequiredModules(sources, moduleId)

  var src = ''

  Object.keys(requiredModules).filter(function (m) { return m !== 'main' }).forEach(function (module) {
    var entryModule = 0
    while (requiredModules[module][entryModule]) {
      entryModule++
    }
    requiredModules[module].push(entryModule)
    sources[module][entryModule] = '(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })'
    src = src + 'var ' + module + ' = (' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(entryModule)) + ')({' + requiredModules[module].map(function (id) { return '' + JSON.stringify(id) + ': ' + sources[module][id].toString() }).join(',') + '});\n'
  })

  src = src + 'new ((' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(moduleId)) + ')({' + requiredModules.main.map(function (id) { return '' + JSON.stringify(id) + ': ' + sources.main[id].toString() }).join(',') + '}))(self);'

  var blob = new window.Blob([src], { type: 'text/javascript' })
  if (options.bare) { return blob }

  var URL = window.URL || window.webkitURL || window.mozURL || window.msURL

  var workerUrl = URL.createObjectURL(blob)
  var worker = new window.Worker(workerUrl)
  worker.objectURL = workerUrl

  return worker
}


/***/ }),

/***/ "./src/config.js":
/*!***********************!*\
  !*** ./src/config.js ***!
  \***********************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * HLS config
 */
Object.defineProperty(exports, "__esModule", { value: true });
var abr_controller_1 = __webpack_require__(/*! ./controller/abr-controller */ "./src/controller/abr-controller.js");
var buffer_controller_1 = __webpack_require__(/*! ./controller/buffer-controller */ "./src/controller/buffer-controller.js");
var cap_level_controller_1 = __webpack_require__(/*! ./controller/cap-level-controller */ "./src/controller/cap-level-controller.js");
var fps_controller_1 = __webpack_require__(/*! ./controller/fps-controller */ "./src/controller/fps-controller.js");
var xhr_loader_1 = __webpack_require__(/*! ./utils/xhr-loader */ "./src/utils/xhr-loader.js");
// import FetchLoader from './utils/fetch-loader';
var audio_track_controller_1 = __webpack_require__(/*! ./controller/audio-track-controller */ "./src/controller/audio-track-controller.js");
var audio_stream_controller_1 = __webpack_require__(/*! ./controller/audio-stream-controller */ "./src/controller/audio-stream-controller.js");
var Cues = __webpack_require__(/*! ./utils/cues */ "./src/utils/cues.js");
var timeline_controller_1 = __webpack_require__(/*! ./controller/timeline-controller */ "./src/controller/timeline-controller.js");
var subtitle_track_controller_1 = __webpack_require__(/*! ./controller/subtitle-track-controller */ "./src/controller/subtitle-track-controller.js");
var subtitle_stream_controller_1 = __webpack_require__(/*! ./controller/subtitle-stream-controller */ "./src/controller/subtitle-stream-controller.js");
var eme_controller_1 = __webpack_require__(/*! ./controller/eme-controller */ "./src/controller/eme-controller.js");
var mediakeys_helper_1 = __webpack_require__(/*! ./utils/mediakeys-helper */ "./src/utils/mediakeys-helper.js");
exports.hlsDefaultConfig = {
    autoStartLoad: true,
    startPosition: -1,
    defaultAudioCodec: undefined,
    debug: false,
    capLevelOnFPSDrop: false,
    capLevelToPlayerSize: false,
    initialLiveManifestSize: 1,
    maxBufferLength: 30,
    maxBufferSize: 60 * 1000 * 1000,
    maxBufferHole: 0.5,
    lowBufferWatchdogPeriod: 0.5,
    highBufferWatchdogPeriod: 3,
    nudgeOffset: 0.1,
    nudgeMaxRetry: 3,
    maxFragLookUpTolerance: 0.25,
    liveSyncDurationCount: 3,
    liveMaxLatencyDurationCount: Infinity,
    liveSyncDuration: undefined,
    liveMaxLatencyDuration: undefined,
    liveDurationInfinity: false,
    liveBackBufferLength: Infinity,
    maxMaxBufferLength: 600,
    enableWorker: true,
    enableSoftwareAES: true,
    manifestLoadingTimeOut: 10000,
    manifestLoadingMaxRetry: 1,
    manifestLoadingRetryDelay: 1000,
    manifestLoadingMaxRetryTimeout: 64000,
    startLevel: undefined,
    levelLoadingTimeOut: 10000,
    levelLoadingMaxRetry: 4,
    levelLoadingRetryDelay: 1000,
    levelLoadingMaxRetryTimeout: 64000,
    fragLoadingTimeOut: 20000,
    fragLoadingMaxRetry: 6,
    fragLoadingRetryDelay: 1000,
    fragLoadingMaxRetryTimeout: 64000,
    startFragPrefetch: false,
    fpsDroppedMonitoringPeriod: 5000,
    fpsDroppedMonitoringThreshold: 0.2,
    appendErrorMaxRetry: 3,
    loader: xhr_loader_1.default,
    // loader: FetchLoader,
    fLoader: undefined,
    pLoader: undefined,
    xhrSetup: undefined,
    licenseXhrSetup: undefined,
    // fetchSetup: undefined,
    abrController: abr_controller_1.default,
    bufferController: buffer_controller_1.default,
    capLevelController: cap_level_controller_1.default,
    fpsController: fps_controller_1.default,
    stretchShortVideoTrack: false,
    maxAudioFramesDrift: 1,
    forceKeyFrameOnDiscontinuity: true,
    abrEwmaFastLive: 3,
    abrEwmaSlowLive: 9,
    abrEwmaFastVoD: 3,
    abrEwmaSlowVoD: 9,
    abrEwmaDefaultEstimate: 5e5,
    abrBandWidthFactor: 0.95,
    abrBandWidthUpFactor: 0.7,
    abrMaxWithRealBitrate: false,
    maxStarvationDelay: 4,
    maxLoadingDelay: 4,
    minAutoBitrate: 0,
    emeEnabled: false,
    widevineLicenseUrl: undefined,
    requestMediaKeySystemAccessFunc: mediakeys_helper_1.requestMediaKeySystemAccess // used by eme-controller
};
if (true) {
    exports.hlsDefaultConfig.subtitleStreamController = subtitle_stream_controller_1.SubtitleStreamController;
    exports.hlsDefaultConfig.subtitleTrackController = subtitle_track_controller_1.default;
    exports.hlsDefaultConfig.timelineController = timeline_controller_1.default;
    exports.hlsDefaultConfig.cueHandler = Cues; // used by timeline-controller
    exports.hlsDefaultConfig.enableCEA708Captions = true; // used by timeline-controller
    exports.hlsDefaultConfig.enableWebVTT = true; // used by timeline-controller
    exports.hlsDefaultConfig.captionsTextTrack1Label = 'English'; // used by timeline-controller
    exports.hlsDefaultConfig.captionsTextTrack1LanguageCode = 'en'; // used by timeline-controller
    exports.hlsDefaultConfig.captionsTextTrack2Label = 'Spanish'; // used by timeline-controller
    exports.hlsDefaultConfig.captionsTextTrack2LanguageCode = 'es'; // used by timeline-controller
}
if (true) {
    exports.hlsDefaultConfig.audioStreamController = audio_stream_controller_1.default;
    exports.hlsDefaultConfig.audioTrackController = audio_track_controller_1.default;
}
if (true) {
    exports.hlsDefaultConfig.emeController = eme_controller_1.default;
}


/***/ }),

/***/ "./src/controller/abr-controller.js":
/*!******************************************!*\
  !*** ./src/controller/abr-controller.js ***!
  \******************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
/*
 * simple ABR Controller
 *  - compute next level based on last fragment bw heuristics
 *  - implement an abandon rules triggered if we have less than 2 frag buffered and if computed bw shows that we risk buffer stalling
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var event_handler_1 = __webpack_require__(/*! ../event-handler */ "./src/event-handler.js");
var buffer_helper_1 = __webpack_require__(/*! ../utils/buffer-helper */ "./src/utils/buffer-helper.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var ewma_bandwidth_estimator_1 = __webpack_require__(/*! ../utils/ewma-bandwidth-estimator */ "./src/utils/ewma-bandwidth-estimator.js");
var performance = window.performance;
var AbrController = /** @class */ (function (_super) {
    __extends(AbrController, _super);
    function AbrController(hls) {
        var _this = _super.call(this, hls, events_1.default.FRAG_LOADING, events_1.default.FRAG_LOADED, events_1.default.FRAG_BUFFERED, events_1.default.ERROR) || this;
        _this.lastLoadedFragLevel = 0;
        _this._nextAutoLevel = -1;
        _this.hls = hls;
        _this.timer = null;
        _this._bwEstimator = null;
        _this.onCheck = _this._abandonRulesCheck.bind(_this);
        return _this;
    }
    AbrController.prototype.destroy = function () {
        this.clearTimer();
        event_handler_1.default.prototype.destroy.call(this);
    };
    AbrController.prototype.onFragLoading = function (data) {
        var frag = data.frag;
        if (frag.type === 'main') {
            if (!this.timer) {
                this.fragCurrent = frag;
                this.timer = setInterval(this.onCheck, 100);
            }
            // lazy init of BwEstimator, rationale is that we use different params for Live/VoD
            // so we need to wait for stream manifest / playlist type to instantiate it.
            if (!this._bwEstimator) {
                var hls_1 = this.hls;
                var config = hls_1.config;
                var level = frag.level;
                var isLive = hls_1.levels[level].details.live;
                var ewmaFast = void 0, ewmaSlow = void 0;
                if (isLive) {
                    ewmaFast = config.abrEwmaFastLive;
                    ewmaSlow = config.abrEwmaSlowLive;
                }
                else {
                    ewmaFast = config.abrEwmaFastVoD;
                    ewmaSlow = config.abrEwmaSlowVoD;
                }
                this._bwEstimator = new ewma_bandwidth_estimator_1.default(hls_1, ewmaSlow, ewmaFast, config.abrEwmaDefaultEstimate);
            }
        }
    };
    AbrController.prototype._abandonRulesCheck = function () {
        /*
          monitor fragment retrieval time...
          we compute expected time of arrival of the complete fragment.
          we compare it to expected time of buffer starvation
        */
        var hls = this.hls;
        var video = hls.media;
        var frag = this.fragCurrent;
        if (!frag) {
            return;
        }
        var loader = frag.loader;
        var minAutoLevel = hls.minAutoLevel;
        // if loader has been destroyed or loading has been aborted, stop timer and return
        if (!loader || (loader.stats && loader.stats.aborted)) {
            logger_1.logger.warn('frag loader destroy or aborted, disarm abandonRules');
            this.clearTimer();
            // reset forced auto level value so that next level will be selected
            this._nextAutoLevel = -1;
            return;
        }
        var stats = loader.stats;
        /* only monitor frag retrieval time if
        (video not paused OR first fragment being loaded(ready state === HAVE_NOTHING = 0)) AND autoswitching enabled AND not lowest level (=> means that we have several levels) */
        if (video && stats && ((!video.paused && (video.playbackRate !== 0)) || !video.readyState) && frag.autoLevel && frag.level) {
            var requestDelay = performance.now() - stats.trequest, playbackRate = Math.abs(video.playbackRate);
            // monitor fragment load progress after half of expected fragment duration,to stabilize bitrate
            if (requestDelay > (500 * frag.duration / playbackRate)) {
                var levels = hls.levels, loadRate = Math.max(1, stats.bw ? stats.bw / 8 : stats.loaded * 1000 / requestDelay), // byte/s; at least 1 byte/s to avoid division by zero
                // compute expected fragment length using frag duration and level bitrate. also ensure that expected len is gte than already loaded size
                level = levels[frag.level], levelBitrate = level.realBitrate ? Math.max(level.realBitrate, level.bitrate) : level.bitrate, expectedLen = stats.total ? stats.total : Math.max(stats.loaded, Math.round(frag.duration * levelBitrate / 8)), pos = video.currentTime, fragLoadedDelay = (expectedLen - stats.loaded) / loadRate, bufferStarvationDelay = (buffer_helper_1.BufferHelper.bufferInfo(video, pos, hls.config.maxBufferHole).end - pos) / playbackRate;
                // consider emergency switch down only if we have less than 2 frag buffered AND
                // time to finish loading current fragment is bigger than buffer starvation delay
                // ie if we risk buffer starvation if bw does not increase quickly
                if ((bufferStarvationDelay < (2 * frag.duration / playbackRate)) && (fragLoadedDelay > bufferStarvationDelay)) {
                    var fragLevelNextLoadedDelay = void 0, nextLoadLevel = void 0;
                    // lets iterate through lower level and try to find the biggest one that could avoid rebuffering
                    // we start from current level - 1 and we step down , until we find a matching level
                    for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {
                        // compute time to load next fragment at lower level
                        // 0.8 : consider only 80% of current bw to be conservative
                        // 8 = bits per byte (bps/Bps)
                        var levelNextBitrate = levels[nextLoadLevel].realBitrate ? Math.max(levels[nextLoadLevel].realBitrate, levels[nextLoadLevel].bitrate) : levels[nextLoadLevel].bitrate;
                        fragLevelNextLoadedDelay = frag.duration * levelNextBitrate / (8 * 0.8 * loadRate);
                        if (fragLevelNextLoadedDelay < bufferStarvationDelay) {
                            // we found a lower level that be rebuffering free with current estimated bw !
                            break;
                        }
                    }
                    // only emergency switch down if it takes less time to load new fragment at lowest level instead
                    // of finishing loading current one ...
                    if (fragLevelNextLoadedDelay < fragLoadedDelay) {
                        logger_1.logger.warn("loading too slow, abort fragment loading and switch to level " + nextLoadLevel + ":fragLoadedDelay[" + nextLoadLevel + "]<fragLoadedDelay[" + (frag.level - 1) + "];bufferStarvationDelay:" + fragLevelNextLoadedDelay.toFixed(1) + "<" + fragLoadedDelay.toFixed(1) + ":" + bufferStarvationDelay.toFixed(1));
                        // force next load level in auto mode
                        hls.nextLoadLevel = nextLoadLevel;
                        // update bw estimate for this fragment before cancelling load (this will help reducing the bw)
                        this._bwEstimator.sample(requestDelay, stats.loaded);
                        // abort fragment loading
                        loader.abort();
                        // stop abandon rules timer
                        this.clearTimer();
                        hls.trigger(events_1.default.FRAG_LOAD_EMERGENCY_ABORTED, { frag: frag, stats: stats });
                    }
                }
            }
        }
    };
    AbrController.prototype.onFragLoaded = function (data) {
        var frag = data.frag;
        if (frag.type === 'main' && Number.isFinite(frag.sn)) {
            // stop monitoring bw once frag loaded
            this.clearTimer();
            // store level id after successful fragment load
            this.lastLoadedFragLevel = frag.level;
            // reset forced auto level value so that next level will be selected
            this._nextAutoLevel = -1;
            // compute level average bitrate
            if (this.hls.config.abrMaxWithRealBitrate) {
                var level = this.hls.levels[frag.level];
                var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + data.stats.loaded;
                var loadedDuration = (level.loaded ? level.loaded.duration : 0) + data.frag.duration;
                level.loaded = { bytes: loadedBytes, duration: loadedDuration };
                level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);
            }
            // if fragment has been loaded to perform a bitrate test,
            if (data.frag.bitrateTest) {
                var stats = data.stats;
                stats.tparsed = stats.tbuffered = stats.tload;
                this.onFragBuffered(data);
            }
        }
    };
    AbrController.prototype.onFragBuffered = function (data) {
        var stats = data.stats;
        var frag = data.frag;
        // only update stats on first frag buffering
        // if same frag is loaded multiple times, it might be in browser cache, and loaded quickly
        // and leading to wrong bw estimation
        // on bitrate test, also only update stats once (if tload = tbuffered == on FRAG_LOADED)
        if (stats.aborted !== true && frag.type === 'main' && Number.isFinite(frag.sn) && ((!frag.bitrateTest || stats.tload === stats.tbuffered))) {
            // use tparsed-trequest instead of tbuffered-trequest to compute fragLoadingProcessing; rationale is that  buffer appending only happens once media is attached
            // in case we use config.startFragPrefetch while media is not attached yet, fragment might be parsed while media not attached yet, but it will only be buffered on media attached
            // as a consequence it could happen really late in the process. meaning that appending duration might appears huge ... leading to underestimated throughput estimation
            var fragLoadingProcessingMs = stats.tparsed - stats.trequest;
            logger_1.logger.log("latency/loading/parsing/append/kbps:" + Math.round(stats.tfirst - stats.trequest) + "/" + Math.round(stats.tload - stats.tfirst) + "/" + Math.round(stats.tparsed - stats.tload) + "/" + Math.round(stats.tbuffered - stats.tparsed) + "/" + Math.round(8 * stats.loaded / (stats.tbuffered - stats.trequest)));
            this._bwEstimator.sample(fragLoadingProcessingMs, stats.loaded);
            stats.bwEstimate = this._bwEstimator.getEstimate();
            // if fragment has been loaded to perform a bitrate test, (hls.startLevel = -1), store bitrate test delay duration
            if (frag.bitrateTest) {
                this.bitrateTestDelay = fragLoadingProcessingMs / 1000;
            }
            else {
                this.bitrateTestDelay = 0;
            }
        }
    };
    AbrController.prototype.onError = function (data) {
        // stop timer in case of frag loading error
        switch (data.details) {
            case errors_1.ErrorDetails.FRAG_LOAD_ERROR:
            case errors_1.ErrorDetails.FRAG_LOAD_TIMEOUT:
                this.clearTimer();
                break;
            default:
                break;
        }
    };
    AbrController.prototype.clearTimer = function () {
        clearInterval(this.timer);
        this.timer = null;
    };
    Object.defineProperty(AbrController.prototype, "nextAutoLevel", {
        // return next auto level
        get: function () {
            var forcedAutoLevel = this._nextAutoLevel;
            var bwEstimator = this._bwEstimator;
            // in case next auto level has been forced, and bw not available or not reliable, return forced value
            if (forcedAutoLevel !== -1 && (!bwEstimator || !bwEstimator.canEstimate())) {
                return forcedAutoLevel;
            }
            // compute next level using ABR logic
            var nextABRAutoLevel = this._nextABRAutoLevel;
            // if forced auto level has been defined, use it to cap ABR computed quality level
            if (forcedAutoLevel !== -1) {
                nextABRAutoLevel = Math.min(forcedAutoLevel, nextABRAutoLevel);
            }
            return nextABRAutoLevel;
        },
        set: function (nextLevel) {
            this._nextAutoLevel = nextLevel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbrController.prototype, "_nextABRAutoLevel", {
        get: function () {
            var hls = this.hls, maxAutoLevel = hls.maxAutoLevel, levels = hls.levels, config = hls.config, minAutoLevel = hls.minAutoLevel;
            var video = hls.media, currentLevel = this.lastLoadedFragLevel, currentFragDuration = this.fragCurrent ? this.fragCurrent.duration : 0, pos = (video ? video.currentTime : 0), 
            // playbackRate is the absolute value of the playback rate; if video.playbackRate is 0, we use 1 to load as
            // if we're playing back at the normal rate.
            playbackRate = ((video && (video.playbackRate !== 0)) ? Math.abs(video.playbackRate) : 1.0), avgbw = this._bwEstimator ? this._bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate, 
            // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.
            bufferStarvationDelay = (buffer_helper_1.BufferHelper.bufferInfo(video, pos, config.maxBufferHole).end - pos) / playbackRate;
            // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all
            var bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor, levels);
            if (bestLevel >= 0) {
                return bestLevel;
            }
            else {
                logger_1.logger.trace('rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering');
                // not possible to get rid of rebuffering ... let's try to find level that will guarantee less than maxStarvationDelay of rebuffering
                // if no matching level found, logic will return 0
                var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay, bwFactor = config.abrBandWidthFactor, bwUpFactor = config.abrBandWidthUpFactor;
                if (bufferStarvationDelay === 0) {
                    // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test
                    var bitrateTestDelay = this.bitrateTestDelay;
                    if (bitrateTestDelay) {
                        // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value
                        // max video loading delay used in  automatic start level selection :
                        // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +
                        // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )
                        // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration
                        var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;
                        maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;
                        logger_1.logger.trace("bitrate test took " + Math.round(1000 * bitrateTestDelay) + "ms, set first fragment max fetchDuration to " + Math.round(1000 * maxStarvationDelay) + " ms");
                        // don't use conservative factor on bitrate test
                        bwFactor = bwUpFactor = 1;
                    }
                }
                bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor, levels);
                return Math.max(bestLevel, 0);
            }
        },
        enumerable: true,
        configurable: true
    });
    AbrController.prototype._findBestLevel = function (currentLevel, currentFragDuration, currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor, levels) {
        for (var i = maxAutoLevel; i >= minAutoLevel; i--) {
            var levelInfo = levels[i];
            if (!levelInfo) {
                continue;
            }
            var levelDetails = levelInfo.details, avgDuration = levelDetails ? levelDetails.totalduration / levelDetails.fragments.length : currentFragDuration, live = levelDetails ? levelDetails.live : false, adjustedbw = void 0;
            // follow algorithm captured from stagefright :
            // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp
            // Pick the highest bandwidth stream below or equal to estimated bandwidth.
            // consider only 80% of the available bandwidth, but if we are switching up,
            // be even more conservative (70%) to avoid overestimating and immediately
            // switching back.
            if (i <= currentLevel) {
                adjustedbw = bwFactor * currentBw;
            }
            else {
                adjustedbw = bwUpFactor * currentBw;
            }
            var bitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate, fetchDuration = bitrate * avgDuration / adjustedbw;
            logger_1.logger.trace("level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: " + i + "/" + Math.round(adjustedbw) + "/" + bitrate + "/" + avgDuration + "/" + maxFetchDuration + "/" + fetchDuration);
            // if adjusted bw is greater than level bitrate AND
            if (adjustedbw > bitrate &&
                // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
                // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
                // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that _findBestLevel will return -1
                (!fetchDuration || (live && !this.bitrateTestDelay) || fetchDuration < maxFetchDuration)) {
                // as we are looping from highest to lowest, this will return the best achievable quality level
                return i;
            }
        }
        // not enough time budget even with quality level 0 ... rebuffering might happen
        return -1;
    };
    return AbrController;
}(event_handler_1.default));
exports.default = AbrController;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/controller/audio-stream-controller.js":
/*!***************************************************!*\
  !*** ./src/controller/audio-stream-controller.js ***!
  \***************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
/*
 * Audio Stream Controller
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var binary_search_1 = __webpack_require__(/*! ../utils/binary-search */ "./src/utils/binary-search.js");
var buffer_helper_1 = __webpack_require__(/*! ../utils/buffer-helper */ "./src/utils/buffer-helper.js");
var demuxer_1 = __webpack_require__(/*! ../demux/demuxer */ "./src/demux/demuxer.js");
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var LevelHelper = __webpack_require__(/*! ./level-helper */ "./src/controller/level-helper.js");
var time_ranges_1 = __webpack_require__(/*! ../utils/time-ranges */ "./src/utils/time-ranges.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var discontinuities_1 = __webpack_require__(/*! ../utils/discontinuities */ "./src/utils/discontinuities.js");
var fragment_tracker_1 = __webpack_require__(/*! ./fragment-tracker */ "./src/controller/fragment-tracker.js");
var fragment_1 = __webpack_require__(/*! ../loader/fragment */ "./src/loader/fragment.js");
var base_stream_controller_1 = __webpack_require__(/*! ./base-stream-controller */ "./src/controller/base-stream-controller.js");
var performance = window.performance;
var TICK_INTERVAL = 100; // how often to tick in ms
var AudioStreamController = /** @class */ (function (_super) {
    __extends(AudioStreamController, _super);
    function AudioStreamController(hls, fragmentTracker) {
        var _this = _super.call(this, hls, events_1.default.MEDIA_ATTACHED, events_1.default.MEDIA_DETACHING, events_1.default.AUDIO_TRACKS_UPDATED, events_1.default.AUDIO_TRACK_SWITCHING, events_1.default.AUDIO_TRACK_LOADED, events_1.default.KEY_LOADED, events_1.default.FRAG_LOADED, events_1.default.FRAG_PARSING_INIT_SEGMENT, events_1.default.FRAG_PARSING_DATA, events_1.default.FRAG_PARSED, events_1.default.ERROR, events_1.default.BUFFER_RESET, events_1.default.BUFFER_CREATED, events_1.default.BUFFER_APPENDED, events_1.default.BUFFER_FLUSHED, events_1.default.INIT_PTS_FOUND) || this;
        _this.fragmentTracker = fragmentTracker;
        _this.config = hls.config;
        _this.audioCodecSwap = false;
        _this._state = base_stream_controller_1.State.STOPPED;
        _this.initPTS = [];
        _this.waitingFragment = null;
        _this.videoTrackCC = null;
        return _this;
    }
    AudioStreamController.prototype.onHandlerDestroying = function () {
        this.stopLoad();
        _super.prototype.onHandlerDestroying.call(this);
    };
    AudioStreamController.prototype.onHandlerDestroyed = function () {
        this.state = base_stream_controller_1.State.STOPPED;
        this.fragmentTracker = null;
        _super.prototype.onHandlerDestroyed.call(this);
    };
    // Signal that video PTS was found
    AudioStreamController.prototype.onInitPtsFound = function (data) {
        var demuxerId = data.id, cc = data.frag.cc, initPTS = data.initPTS;
        if (demuxerId === 'main') {
            // Always update the new INIT PTS
            // Can change due level switch
            this.initPTS[cc] = initPTS;
            this.videoTrackCC = cc;
            logger_1.logger.log("InitPTS for cc: " + cc + " found from video track: " + initPTS);
            // If we are waiting we need to demux/remux the waiting frag
            // With the new initPTS
            if (this.state === base_stream_controller_1.State.WAITING_INIT_PTS) {
                this.tick();
            }
        }
    };
    AudioStreamController.prototype.startLoad = function (startPosition) {
        if (this.tracks) {
            var lastCurrentTime = this.lastCurrentTime;
            this.stopLoad();
            this.setInterval(TICK_INTERVAL);
            this.fragLoadError = 0;
            if (lastCurrentTime > 0 && startPosition === -1) {
                logger_1.logger.log("audio:override startPosition with lastCurrentTime @" + lastCurrentTime.toFixed(3));
                this.state = base_stream_controller_1.State.IDLE;
            }
            else {
                this.lastCurrentTime = this.startPosition ? this.startPosition : startPosition;
                this.state = base_stream_controller_1.State.STARTING;
            }
            this.nextLoadPosition = this.startPosition = this.lastCurrentTime;
            this.tick();
        }
        else {
            this.startPosition = startPosition;
            this.state = base_stream_controller_1.State.STOPPED;
        }
    };
    AudioStreamController.prototype.stopLoad = function () {
        var frag = this.fragCurrent;
        if (frag) {
            if (frag.loader) {
                frag.loader.abort();
            }
            this.fragmentTracker.removeFragment(frag);
            this.fragCurrent = null;
        }
        this.fragPrevious = null;
        if (this.demuxer) {
            this.demuxer.destroy();
            this.demuxer = null;
        }
        this.state = base_stream_controller_1.State.STOPPED;
    };
    Object.defineProperty(AudioStreamController.prototype, "state", {
        get: function () {
            return this._state;
        },
        set: function (nextState) {
            if (this.state !== nextState) {
                var previousState = this.state;
                this._state = nextState;
                logger_1.logger.log("audio stream:" + previousState + "->" + nextState);
            }
        },
        enumerable: true,
        configurable: true
    });
    AudioStreamController.prototype.doTick = function () {
        var pos, track, trackDetails, hls = this.hls, config = hls.config;
        // logger.log('audioStream:' + this.state);
        switch (this.state) {
            case base_stream_controller_1.State.ERROR:
            // don't do anything in error state to avoid breaking further ...
            case base_stream_controller_1.State.PAUSED:
            // don't do anything in paused state either ...
            case base_stream_controller_1.State.BUFFER_FLUSHING:
                break;
            case base_stream_controller_1.State.STARTING:
                this.state = base_stream_controller_1.State.WAITING_TRACK;
                this.loadedmetadata = false;
                break;
            case base_stream_controller_1.State.IDLE:
                var tracks = this.tracks;
                // audio tracks not received => exit loop
                if (!tracks) {
                    break;
                }
                // if video not attached AND
                // start fragment already requested OR start frag prefetch disable
                // exit loop
                // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
                if (!this.media &&
                    (this.startFragRequested || !config.startFragPrefetch)) {
                    break;
                }
                // determine next candidate fragment to be loaded, based on current position and
                //  end of buffer position
                // if we have not yet loaded any fragment, start loading from start position
                if (this.loadedmetadata) {
                    pos = this.media.currentTime;
                }
                else {
                    pos = this.nextLoadPosition;
                    if (pos === undefined) {
                        break;
                    }
                }
                var media = this.mediaBuffer ? this.mediaBuffer : this.media, videoBuffer = this.videoBuffer ? this.videoBuffer : this.media, bufferInfo = buffer_helper_1.BufferHelper.bufferInfo(media, pos, config.maxBufferHole), mainBufferInfo = buffer_helper_1.BufferHelper.bufferInfo(videoBuffer, pos, config.maxBufferHole), bufferLen = bufferInfo.len, bufferEnd_1 = bufferInfo.end, fragPrevious = this.fragPrevious, 
                // ensure we buffer at least config.maxBufferLength (default 30s) or config.maxMaxBufferLength (default: 600s)
                // whichever is smaller.
                // once we reach that threshold, don't buffer more than video (mainBufferInfo.len)
                maxConfigBuffer = Math.min(config.maxBufferLength, config.maxMaxBufferLength), maxBufLen = Math.max(maxConfigBuffer, mainBufferInfo.len), audioSwitch = this.audioSwitch, trackId = this.trackId;
                // if buffer length is less than maxBufLen try to load a new fragment
                if ((bufferLen < maxBufLen || audioSwitch) && trackId < tracks.length) {
                    trackDetails = tracks[trackId].details;
                    // if track info not retrieved yet, switch state and wait for track retrieval
                    if (typeof trackDetails === 'undefined') {
                        this.state = base_stream_controller_1.State.WAITING_TRACK;
                        break;
                    }
                    if (!audioSwitch && this._streamEnded(bufferInfo, trackDetails)) {
                        this.hls.trigger(events_1.default.BUFFER_EOS, { type: 'audio' });
                        this.state = base_stream_controller_1.State.ENDED;
                        return;
                    }
                    // find fragment index, contiguous with end of buffer position
                    var fragments = trackDetails.fragments, fragLen = fragments.length, start = fragments[0].start, end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration, frag = void 0;
                    // When switching audio track, reload audio as close as possible to currentTime
                    if (audioSwitch) {
                        if (trackDetails.live && !trackDetails.PTSKnown) {
                            logger_1.logger.log('switching audiotrack, live stream, unknown PTS,load first fragment');
                            bufferEnd_1 = 0;
                        }
                        else {
                            bufferEnd_1 = pos;
                            // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime
                            if (trackDetails.PTSKnown && pos < start) {
                                // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start
                                if (bufferInfo.end > start || bufferInfo.nextStart) {
                                    logger_1.logger.log('alt audio track ahead of main track, seek to start of alt audio track');
                                    this.media.currentTime = start + 0.05;
                                }
                                else {
                                    return;
                                }
                            }
                        }
                    }
                    if (trackDetails.initSegment && !trackDetails.initSegment.data) {
                        frag = trackDetails.initSegment;
                    } // eslint-disable-line brace-style
                    // if bufferEnd before start of playlist, load first fragment
                    else if (bufferEnd_1 <= start) {
                        frag = fragments[0];
                        if (this.videoTrackCC !== null && frag.cc !== this.videoTrackCC) {
                            // Ensure we find a fragment which matches the continuity of the video track
                            frag = discontinuities_1.findFragWithCC(fragments, this.videoTrackCC);
                        }
                        if (trackDetails.live && frag.loadIdx && frag.loadIdx === this.fragLoadIdx) {
                            // we just loaded this first fragment, and we are still lagging behind the start of the live playlist
                            // let's force seek to start
                            var nextBuffered = bufferInfo.nextStart ? bufferInfo.nextStart : start;
                            logger_1.logger.log("no alt audio available @currentTime:" + this.media.currentTime + ", seeking @" + (nextBuffered + 0.05));
                            this.media.currentTime = nextBuffered + 0.05;
                            return;
                        }
                    }
                    else {
                        var foundFrag = void 0;
                        var maxFragLookUpTolerance_1 = config.maxFragLookUpTolerance;
                        var fragNext = fragPrevious ? fragments[fragPrevious.sn - fragments[0].sn + 1] : undefined;
                        var fragmentWithinToleranceTest = function (candidate) {
                            // offset should be within fragment boundary - config.maxFragLookUpTolerance
                            // this is to cope with situations like
                            // bufferEnd = 9.991
                            // frag[Ø] : [0,10]
                            // frag[1] : [10,20]
                            // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
                            //              frag start               frag start+duration
                            //                  |-----------------------------|
                            //              <--->                         <--->
                            //  ...--------><-----------------------------><---------....
                            // previous frag         matching fragment         next frag
                            //  return -1             return 0                 return 1
                            // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
                            // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
                            var candidateLookupTolerance = Math.min(maxFragLookUpTolerance_1, candidate.duration);
                            if ((candidate.start + candidate.duration - candidateLookupTolerance) <= bufferEnd_1) {
                                return 1;
                            }
                            else if (candidate.start - candidateLookupTolerance > bufferEnd_1 && candidate.start) {
                                // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
                                return -1;
                            }
                            return 0;
                        };
                        if (bufferEnd_1 < end) {
                            if (bufferEnd_1 > end - maxFragLookUpTolerance_1) {
                                maxFragLookUpTolerance_1 = 0;
                            }
                            // Prefer the next fragment if it's within tolerance
                            if (fragNext && !fragmentWithinToleranceTest(fragNext)) {
                                foundFrag = fragNext;
                            }
                            else {
                                foundFrag = binary_search_1.default.search(fragments, fragmentWithinToleranceTest);
                            }
                        }
                        else {
                            // reach end of playlist
                            foundFrag = fragments[fragLen - 1];
                        }
                        if (foundFrag) {
                            frag = foundFrag;
                            start = foundFrag.start;
                            // logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
                            if (fragPrevious && frag.level === fragPrevious.level && frag.sn === fragPrevious.sn) {
                                if (frag.sn < trackDetails.endSN) {
                                    frag = fragments[frag.sn + 1 - trackDetails.startSN];
                                    logger_1.logger.log("SN just loaded, load next one: " + frag.sn);
                                }
                                else {
                                    frag = null;
                                }
                            }
                        }
                    }
                    if (frag) {
                        // logger.log('      loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
                        if (frag.encrypted) {
                            logger_1.logger.log("Loading key for " + frag.sn + " of [" + trackDetails.startSN + " ," + trackDetails.endSN + "],track " + trackId);
                            this.state = base_stream_controller_1.State.KEY_LOADING;
                            hls.trigger(events_1.default.KEY_LOADING, { frag: frag });
                        }
                        else {
                            logger_1.logger.log("Loading " + frag.sn + ", cc: " + frag.cc + " of [" + trackDetails.startSN + " ," + trackDetails.endSN + "],track " + trackId + ", currentTime:" + pos + ",bufferEnd:" + bufferEnd_1.toFixed(3));
                            // only load if fragment is not loaded or if in audio switch
                            // we force a frag loading in audio switch as fragment tracker might not have evicted previous frags in case of quick audio switch
                            this.fragCurrent = frag;
                            if (audioSwitch || this.fragmentTracker.getState(frag) === fragment_tracker_1.FragmentState.NOT_LOADED) {
                                this.startFragRequested = true;
                                if (Number.isFinite(frag.sn)) {
                                    this.nextLoadPosition = frag.start + frag.duration;
                                }
                                hls.trigger(events_1.default.FRAG_LOADING, { frag: frag });
                                this.state = base_stream_controller_1.State.FRAG_LOADING;
                            }
                        }
                    }
                }
                break;
            case base_stream_controller_1.State.WAITING_TRACK:
                track = this.tracks[this.trackId];
                // check if playlist is already loaded
                if (track && track.details) {
                    this.state = base_stream_controller_1.State.IDLE;
                }
                break;
            case base_stream_controller_1.State.FRAG_LOADING_WAITING_RETRY:
                var now = performance.now();
                var retryDate = this.retryDate;
                media = this.media;
                var isSeeking = media && media.seeking;
                // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
                if (!retryDate || (now >= retryDate) || isSeeking) {
                    logger_1.logger.log('audioStreamController: retryDate reached, switch back to IDLE state');
                    this.state = base_stream_controller_1.State.IDLE;
                }
                break;
            case base_stream_controller_1.State.WAITING_INIT_PTS:
                var videoTrackCC = this.videoTrackCC;
                if (this.initPTS[videoTrackCC] === undefined) {
                    break;
                }
                // Ensure we don't get stuck in the WAITING_INIT_PTS state if the waiting frag CC doesn't match any initPTS
                var waitingFrag = this.waitingFragment;
                if (waitingFrag) {
                    var waitingFragCC = waitingFrag.frag.cc;
                    if (videoTrackCC !== waitingFragCC) {
                        track = this.tracks[this.trackId];
                        if (track.details && track.details.live) {
                            logger_1.logger.warn("Waiting fragment CC (" + waitingFragCC + ") does not match video track CC (" + videoTrackCC + ")");
                            this.waitingFragment = null;
                            this.state = base_stream_controller_1.State.IDLE;
                        }
                    }
                    else {
                        this.state = base_stream_controller_1.State.FRAG_LOADING;
                        this.onFragLoaded(this.waitingFragment);
                        this.waitingFragment = null;
                    }
                }
                else {
                    this.state = base_stream_controller_1.State.IDLE;
                }
                break;
            case base_stream_controller_1.State.STOPPED:
            case base_stream_controller_1.State.FRAG_LOADING:
            case base_stream_controller_1.State.PARSING:
            case base_stream_controller_1.State.PARSED:
            case base_stream_controller_1.State.ENDED:
                break;
            default:
                break;
        }
    };
    AudioStreamController.prototype.onMediaAttached = function (data) {
        var media = this.media = this.mediaBuffer = data.media;
        this.onvseeking = this.onMediaSeeking.bind(this);
        this.onvended = this.onMediaEnded.bind(this);
        media.addEventListener('seeking', this.onvseeking);
        media.addEventListener('ended', this.onvended);
        var config = this.config;
        if (this.tracks && config.autoStartLoad) {
            this.startLoad(config.startPosition);
        }
    };
    AudioStreamController.prototype.onMediaDetaching = function () {
        var media = this.media;
        if (media && media.ended) {
            logger_1.logger.log('MSE detaching and video ended, reset startPosition');
            this.startPosition = this.lastCurrentTime = 0;
        }
        // remove video listeners
        if (media) {
            media.removeEventListener('seeking', this.onvseeking);
            media.removeEventListener('ended', this.onvended);
            this.onvseeking = this.onvseeked = this.onvended = null;
        }
        this.media = this.mediaBuffer = this.videoBuffer = null;
        this.loadedmetadata = false;
        this.stopLoad();
    };
    AudioStreamController.prototype.onAudioTracksUpdated = function (data) {
        logger_1.logger.log('audio tracks updated');
        this.tracks = data.audioTracks;
    };
    AudioStreamController.prototype.onAudioTrackSwitching = function (data) {
        // if any URL found on new audio track, it is an alternate audio track
        var altAudio = !!data.url;
        this.trackId = data.id;
        this.fragCurrent = null;
        this.state = base_stream_controller_1.State.PAUSED;
        this.waitingFragment = null;
        // destroy useless demuxer when switching audio to main
        if (!altAudio) {
            if (this.demuxer) {
                this.demuxer.destroy();
                this.demuxer = null;
            }
        }
        else {
            // switching to audio track, start timer if not already started
            this.setInterval(TICK_INTERVAL);
        }
        // should we switch tracks ?
        if (altAudio) {
            this.audioSwitch = true;
            // main audio track are handled by stream-controller, just do something if switching to alt audio track
            this.state = base_stream_controller_1.State.IDLE;
        }
        this.tick();
    };
    AudioStreamController.prototype.onAudioTrackLoaded = function (data) {
        var newDetails = data.details, trackId = data.id, track = this.tracks[trackId], duration = newDetails.totalduration, sliding = 0;
        logger_1.logger.log("track " + trackId + " loaded [" + newDetails.startSN + "," + newDetails.endSN + "],duration:" + duration);
        if (newDetails.live) {
            var curDetails = track.details;
            if (curDetails && newDetails.fragments.length > 0) {
                // we already have details for that level, merge them
                LevelHelper.mergeDetails(curDetails, newDetails);
                sliding = newDetails.fragments[0].start;
                // TODO
                // this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
                if (newDetails.PTSKnown) {
                    logger_1.logger.log("live audio playlist sliding:" + sliding.toFixed(3));
                }
                else {
                    logger_1.logger.log('live audio playlist - outdated PTS, unknown sliding');
                }
            }
            else {
                newDetails.PTSKnown = false;
                logger_1.logger.log('live audio playlist - first load, unknown sliding');
            }
        }
        else {
            newDetails.PTSKnown = false;
        }
        track.details = newDetails;
        // compute start position
        if (!this.startFragRequested) {
            // compute start position if set to -1. use it straight away if value is defined
            if (this.startPosition === -1) {
                // first, check if start time offset has been set in playlist, if yes, use this value
                var startTimeOffset = newDetails.startTimeOffset;
                if (Number.isFinite(startTimeOffset)) {
                    logger_1.logger.log("start time offset found in playlist, adjust startPosition to " + startTimeOffset);
                    this.startPosition = startTimeOffset;
                }
                else {
                    this.startPosition = 0;
                }
            }
            this.nextLoadPosition = this.startPosition;
        }
        // only switch batck to IDLE state if we were waiting for track to start downloading a new fragment
        if (this.state === base_stream_controller_1.State.WAITING_TRACK) {
            this.state = base_stream_controller_1.State.IDLE;
        }
        // trigger handler right now
        this.tick();
    };
    AudioStreamController.prototype.onKeyLoaded = function () {
        if (this.state === base_stream_controller_1.State.KEY_LOADING) {
            this.state = base_stream_controller_1.State.IDLE;
            this.tick();
        }
    };
    AudioStreamController.prototype.onFragLoaded = function (data) {
        var fragCurrent = this.fragCurrent, fragLoaded = data.frag;
        if (this.state === base_stream_controller_1.State.FRAG_LOADING &&
            fragCurrent &&
            fragLoaded.type === 'audio' &&
            fragLoaded.level === fragCurrent.level &&
            fragLoaded.sn === fragCurrent.sn) {
            var track = this.tracks[this.trackId], details = track.details, duration = details.totalduration, trackId = fragCurrent.level, sn = fragCurrent.sn, cc = fragCurrent.cc, audioCodec = this.config.defaultAudioCodec || track.audioCodec || 'mp4a.40.2', stats = this.stats = data.stats;
            if (sn === 'initSegment') {
                this.state = base_stream_controller_1.State.IDLE;
                stats.tparsed = stats.tbuffered = performance.now();
                details.initSegment.data = data.payload;
                this.hls.trigger(events_1.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'audio' });
                this.tick();
            }
            else {
                this.state = base_stream_controller_1.State.PARSING;
                // transmux the MPEG-TS data to ISO-BMFF segments
                this.appended = false;
                if (!this.demuxer) {
                    this.demuxer = new demuxer_1.default(this.hls, 'audio');
                }
                // Check if we have video initPTS
                // If not we need to wait for it
                var initPTS = this.initPTS[cc];
                var initSegmentData = details.initSegment ? details.initSegment.data : [];
                if (details.initSegment || initPTS !== undefined) {
                    this.pendingBuffering = true;
                    logger_1.logger.log("Demuxing " + sn + " of [" + details.startSN + " ," + details.endSN + "],track " + trackId);
                    // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)
                    var accurateTimeOffset = false; // details.PTSKnown || !details.live;
                    this.demuxer.push(data.payload, initSegmentData, audioCodec, null, fragCurrent, duration, accurateTimeOffset, initPTS);
                }
                else {
                    logger_1.logger.log("unknown video PTS for continuity counter " + cc + ", waiting for video PTS before demuxing audio frag " + sn + " of [" + details.startSN + " ," + details.endSN + "],track " + trackId);
                    this.waitingFragment = data;
                    this.state = base_stream_controller_1.State.WAITING_INIT_PTS;
                }
            }
        }
        this.fragLoadError = 0;
    };
    AudioStreamController.prototype.onFragParsingInitSegment = function (data) {
        var fragCurrent = this.fragCurrent;
        var fragNew = data.frag;
        if (fragCurrent &&
            data.id === 'audio' &&
            fragNew.sn === fragCurrent.sn &&
            fragNew.level === fragCurrent.level &&
            this.state === base_stream_controller_1.State.PARSING) {
            var tracks = data.tracks, track = void 0;
            // delete any video track found on audio demuxer
            if (tracks.video) {
                delete tracks.video;
            }
            // include levelCodec in audio and video tracks
            track = tracks.audio;
            if (track) {
                track.levelCodec = track.codec;
                track.id = data.id;
                this.hls.trigger(events_1.default.BUFFER_CODECS, tracks);
                logger_1.logger.log("audio track:audio,container:" + track.container + ",codecs[level/parsed]=[" + track.levelCodec + "/" + track.codec + "]");
                var initSegment = track.initSegment;
                if (initSegment) {
                    var appendObj = { type: 'audio', data: initSegment, parent: 'audio', content: 'initSegment' };
                    if (this.audioSwitch) {
                        this.pendingData = [appendObj];
                    }
                    else {
                        this.appended = true;
                        // arm pending Buffering flag before appending a segment
                        this.pendingBuffering = true;
                        this.hls.trigger(events_1.default.BUFFER_APPENDING, appendObj);
                    }
                }
                // trigger handler right now
                this.tick();
            }
        }
    };
    AudioStreamController.prototype.onFragParsingData = function (data) {
        var _this = this;
        var fragCurrent = this.fragCurrent;
        var fragNew = data.frag;
        if (fragCurrent &&
            data.id === 'audio' &&
            data.type === 'audio' &&
            fragNew.sn === fragCurrent.sn &&
            fragNew.level === fragCurrent.level &&
            this.state === base_stream_controller_1.State.PARSING) {
            var trackId = this.trackId, track = this.tracks[trackId], hls_1 = this.hls;
            if (!Number.isFinite(data.endPTS)) {
                data.endPTS = data.startPTS + fragCurrent.duration;
                data.endDTS = data.startDTS + fragCurrent.duration;
            }
            fragCurrent.addElementaryStream(fragment_1.default.ElementaryStreamTypes.AUDIO);
            logger_1.logger.log("parsed " + data.type + ",PTS:[" + data.startPTS.toFixed(3) + "," + data.endPTS.toFixed(3) + "],DTS:[" + data.startDTS.toFixed(3) + "/" + data.endDTS.toFixed(3) + "],nb:" + data.nb);
            LevelHelper.updateFragPTSDTS(track.details, fragCurrent, data.startPTS, data.endPTS);
            var audioSwitch = this.audioSwitch, media = this.media, appendOnBufferFlush = false;
            // Only flush audio from old audio tracks when PTS is known on new audio track
            if (audioSwitch && media) {
                if (media.readyState) {
                    var currentTime = media.currentTime;
                    logger_1.logger.log('switching audio track : currentTime:' + currentTime);
                    if (currentTime >= data.startPTS) {
                        logger_1.logger.log('switching audio track : flushing all audio');
                        this.state = base_stream_controller_1.State.BUFFER_FLUSHING;
                        hls_1.trigger(events_1.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
                        appendOnBufferFlush = true;
                        // Lets announce that the initial audio track switch flush occur
                        this.audioSwitch = false;
                        hls_1.trigger(events_1.default.AUDIO_TRACK_SWITCHED, { id: trackId });
                    }
                }
                else {
                    // Lets announce that the initial audio track switch flush occur
                    this.audioSwitch = false;
                    hls_1.trigger(events_1.default.AUDIO_TRACK_SWITCHED, { id: trackId });
                }
            }
            var pendingData_1 = this.pendingData;
            if (!pendingData_1) {
                logger_1.logger.warn('Apparently attempt to enqueue media payload without codec initialization data upfront');
                hls_1.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.MEDIA_ERROR, details: null, fatal: true });
                return;
            }
            if (!this.audioSwitch) {
                [data.data1, data.data2].forEach(function (buffer) {
                    if (buffer && buffer.length) {
                        pendingData_1.push({ type: data.type, data: buffer, parent: 'audio', content: 'data' });
                    }
                });
                if (!appendOnBufferFlush && pendingData_1.length) {
                    pendingData_1.forEach(function (appendObj) {
                        // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)
                        // in that case it is useless to append following segments
                        if (_this.state === base_stream_controller_1.State.PARSING) {
                            // arm pending Buffering flag before appending a segment
                            _this.pendingBuffering = true;
                            _this.hls.trigger(events_1.default.BUFFER_APPENDING, appendObj);
                        }
                    });
                    this.pendingData = [];
                    this.appended = true;
                }
            }
            // trigger handler right now
            this.tick();
        }
    };
    AudioStreamController.prototype.onFragParsed = function (data) {
        var fragCurrent = this.fragCurrent;
        var fragNew = data.frag;
        if (fragCurrent &&
            data.id === 'audio' &&
            fragNew.sn === fragCurrent.sn &&
            fragNew.level === fragCurrent.level &&
            this.state === base_stream_controller_1.State.PARSING) {
            this.stats.tparsed = performance.now();
            this.state = base_stream_controller_1.State.PARSED;
            this._checkAppendedParsed();
        }
    };
    AudioStreamController.prototype.onBufferReset = function () {
        // reset reference to sourcebuffers
        this.mediaBuffer = this.videoBuffer = null;
        this.loadedmetadata = false;
    };
    AudioStreamController.prototype.onBufferCreated = function (data) {
        var audioTrack = data.tracks.audio;
        if (audioTrack) {
            this.mediaBuffer = audioTrack.buffer;
            this.loadedmetadata = true;
        }
        if (data.tracks.video) {
            this.videoBuffer = data.tracks.video.buffer;
        }
    };
    AudioStreamController.prototype.onBufferAppended = function (data) {
        if (data.parent === 'audio') {
            var state = this.state;
            if (state === base_stream_controller_1.State.PARSING || state === base_stream_controller_1.State.PARSED) {
                // check if all buffers have been appended
                this.pendingBuffering = (data.pending > 0);
                this._checkAppendedParsed();
            }
        }
    };
    AudioStreamController.prototype._checkAppendedParsed = function () {
        // trigger handler right now
        if (this.state === base_stream_controller_1.State.PARSED && (!this.appended || !this.pendingBuffering)) {
            var frag = this.fragCurrent, stats = this.stats, hls_2 = this.hls;
            if (frag) {
                this.fragPrevious = frag;
                stats.tbuffered = performance.now();
                hls_2.trigger(events_1.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'audio' });
                var media = this.mediaBuffer ? this.mediaBuffer : this.media;
                logger_1.logger.log("audio buffered : " + time_ranges_1.default.toString(media.buffered));
                if (this.audioSwitch && this.appended) {
                    this.audioSwitch = false;
                    hls_2.trigger(events_1.default.AUDIO_TRACK_SWITCHED, { id: this.trackId });
                }
                this.state = base_stream_controller_1.State.IDLE;
            }
            this.tick();
        }
    };
    AudioStreamController.prototype.onError = function (data) {
        var frag = data.frag;
        // don't handle frag error not related to audio fragment
        if (frag && frag.type !== 'audio') {
            return;
        }
        switch (data.details) {
            case errors_1.ErrorDetails.FRAG_LOAD_ERROR:
            case errors_1.ErrorDetails.FRAG_LOAD_TIMEOUT:
                var frag_1 = data.frag;
                // don't handle frag error not related to audio fragment
                if (frag_1 && frag_1.type !== 'audio') {
                    break;
                }
                if (!data.fatal) {
                    var loadError = this.fragLoadError;
                    if (loadError) {
                        loadError++;
                    }
                    else {
                        loadError = 1;
                    }
                    var config = this.config;
                    if (loadError <= config.fragLoadingMaxRetry) {
                        this.fragLoadError = loadError;
                        // exponential backoff capped to config.fragLoadingMaxRetryTimeout
                        var delay = Math.min(Math.pow(2, loadError - 1) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);
                        logger_1.logger.warn("AudioStreamController: frag loading failed, retry in " + delay + " ms");
                        this.retryDate = performance.now() + delay;
                        // retry loading state
                        this.state = base_stream_controller_1.State.FRAG_LOADING_WAITING_RETRY;
                    }
                    else {
                        logger_1.logger.error("AudioStreamController: " + data.details + " reaches max retry, redispatch as fatal ...");
                        // switch error to fatal
                        data.fatal = true;
                        this.state = base_stream_controller_1.State.ERROR;
                    }
                }
                break;
            case errors_1.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
            case errors_1.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
            case errors_1.ErrorDetails.KEY_LOAD_ERROR:
            case errors_1.ErrorDetails.KEY_LOAD_TIMEOUT:
                //  when in ERROR state, don't switch back to IDLE state in case a non-fatal error is received
                if (this.state !== base_stream_controller_1.State.ERROR) {
                    // if fatal error, stop processing, otherwise move to IDLE to retry loading
                    this.state = data.fatal ? base_stream_controller_1.State.ERROR : base_stream_controller_1.State.IDLE;
                    logger_1.logger.warn("AudioStreamController: " + data.details + " while loading frag, now switching to " + this.state + " state ...");
                }
                break;
            case errors_1.ErrorDetails.BUFFER_FULL_ERROR:
                // if in appending state
                if (data.parent === 'audio' && (this.state === base_stream_controller_1.State.PARSING || this.state === base_stream_controller_1.State.PARSED)) {
                    var media = this.mediaBuffer, currentTime = this.media.currentTime, mediaBuffered = media && buffer_helper_1.BufferHelper.isBuffered(media, currentTime) && buffer_helper_1.BufferHelper.isBuffered(media, currentTime + 0.5);
                    // reduce max buf len if current position is buffered
                    if (mediaBuffered) {
                        var config = this.config;
                        if (config.maxMaxBufferLength >= config.maxBufferLength) {
                            // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
                            config.maxMaxBufferLength /= 2;
                            logger_1.logger.warn("AudioStreamController: reduce max buffer length to " + config.maxMaxBufferLength + "s");
                        }
                        this.state = base_stream_controller_1.State.IDLE;
                    }
                    else {
                        // current position is not buffered, but browser is still complaining about buffer full error
                        // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
                        // in that case flush the whole audio buffer to recover
                        logger_1.logger.warn('AudioStreamController: buffer full error also media.currentTime is not buffered, flush audio buffer');
                        this.fragCurrent = null;
                        // flush everything
                        this.state = base_stream_controller_1.State.BUFFER_FLUSHING;
                        this.hls.trigger(events_1.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
                    }
                }
                break;
            default:
                break;
        }
    };
    AudioStreamController.prototype.onBufferFlushed = function () {
        var _this = this;
        var pendingData = this.pendingData;
        if (pendingData && pendingData.length) {
            logger_1.logger.log('AudioStreamController: appending pending audio data after buffer flushed');
            pendingData.forEach(function (appendObj) {
                _this.hls.trigger(events_1.default.BUFFER_APPENDING, appendObj);
            });
            this.appended = true;
            this.pendingData = [];
            this.state = base_stream_controller_1.State.PARSED;
        }
        else {
            // move to IDLE once flush complete. this should trigger new fragment loading
            this.state = base_stream_controller_1.State.IDLE;
            // reset reference to frag
            this.fragPrevious = null;
            this.tick();
        }
    };
    return AudioStreamController;
}(base_stream_controller_1.default));
exports.default = AudioStreamController;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/controller/audio-track-controller.js":
/*!**************************************************!*\
  !*** ./src/controller/audio-track-controller.js ***!
  \**************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var task_loop_1 = __webpack_require__(/*! ../task-loop */ "./src/task-loop.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
/**
 * @class AudioTrackController
 * @implements {EventHandler}
 *
 * Handles main manifest and audio-track metadata loaded,
 * owns and exposes the selectable audio-tracks data-models.
 *
 * Exposes internal interface to select available audio-tracks.
 *
 * Handles errors on loading audio-track playlists. Manages fallback mechanism
 * with redundants tracks (group-IDs).
 *
 * Handles level-loading and group-ID switches for video (fallback on video levels),
 * and eventually adapts the audio-track group-ID to match.
 *
 * @fires AUDIO_TRACK_LOADING
 * @fires AUDIO_TRACK_SWITCHING
 * @fires AUDIO_TRACKS_UPDATED
 * @fires ERROR
 *
 */
var AudioTrackController = /** @class */ (function (_super) {
    __extends(AudioTrackController, _super);
    function AudioTrackController(hls) {
        var _this = _super.call(this, hls, events_1.default.MANIFEST_LOADING, events_1.default.MANIFEST_PARSED, events_1.default.AUDIO_TRACK_LOADED, events_1.default.AUDIO_TRACK_SWITCHED, events_1.default.LEVEL_LOADED, events_1.default.ERROR) || this;
        /**
         * @private
         * Currently selected index in `tracks`
         * @member {number} trackId
         */
        _this._trackId = -1;
        /**
         * @private
         * If should select tracks according to default track attribute
         * @member {boolean} _selectDefaultTrack
         */
        _this._selectDefaultTrack = true;
        /**
         * @public
         * All tracks available
         * @member {AudioTrack[]}
         */
        _this.tracks = [];
        /**
         * @public
         * List of blacklisted audio track IDs (that have caused failure)
         * @member {number[]}
         */
        _this.trackIdBlacklist = Object.create(null);
        /**
         * @public
         * The currently running group ID for audio
         * (we grab this on manifest-parsed and new level-loaded)
         * @member {string}
         */
        _this.audioGroupId = null;
        return _this;
    }
    /**
     * Reset audio tracks on new manifest loading.
     */
    AudioTrackController.prototype.onManifestLoading = function () {
        this.tracks = [];
        this._trackId = -1;
        this._selectDefaultTrack = true;
    };
    /**
     * Store tracks data from manifest parsed data.
     *
     * Trigger AUDIO_TRACKS_UPDATED event.
     *
     * @param {*} data
     */
    AudioTrackController.prototype.onManifestParsed = function (data) {
        var tracks = this.tracks = data.audioTracks || [];
        this.hls.trigger(events_1.default.AUDIO_TRACKS_UPDATED, { audioTracks: tracks });
    };
    /**
     * Store track details of loaded track in our data-model.
     *
     * Set-up metadata update interval task for live-mode streams.
     *
     * @param {} data
     */
    AudioTrackController.prototype.onAudioTrackLoaded = function (data) {
        if (data.id >= this.tracks.length) {
            logger_1.logger.warn('Invalid audio track id:', data.id);
            return;
        }
        logger_1.logger.log("audioTrack " + data.id + " loaded");
        this.tracks[data.id].details = data.details;
        // check if current playlist is a live playlist
        // and if we have already our reload interval setup
        if (data.details.live && !this.hasInterval()) {
            // if live playlist we will have to reload it periodically
            // set reload period to playlist target duration
            var updatePeriodMs = data.details.targetduration * 1000;
            this.setInterval(updatePeriodMs);
        }
        if (!data.details.live && this.hasInterval()) {
            // playlist is not live and timer is scheduled: cancel it
            this.clearInterval();
        }
    };
    /**
     * Update the internal group ID to any audio-track we may have set manually
     * or because of a failure-handling fallback.
     *
     * Quality-levels should update to that group ID in this case.
     *
     * @param {*} data
     */
    AudioTrackController.prototype.onAudioTrackSwitched = function (data) {
        var audioGroupId = this.tracks[data.id].groupId;
        if (audioGroupId && (this.audioGroupId !== audioGroupId)) {
            this.audioGroupId = audioGroupId;
        }
    };
    /**
     * When a level gets loaded, if it has redundant audioGroupIds (in the same ordinality as it's redundant URLs)
     * we are setting our audio-group ID internally to the one set, if it is different from the group ID currently set.
     *
     * If group-ID got update, we re-select the appropriate audio-track with this group-ID matching the currently
     * selected one (based on NAME property).
     *
     * @param {*} data
     */
    AudioTrackController.prototype.onLevelLoaded = function (data) {
        // FIXME: crashes because currentLevel is undefined
        // const levelInfo = this.hls.levels[this.hls.currentLevel];
        var levelInfo = this.hls.levels[data.level];
        if (!levelInfo.audioGroupIds) {
            return;
        }
        var audioGroupId = levelInfo.audioGroupIds[levelInfo.urlId];
        if (this.audioGroupId !== audioGroupId) {
            this.audioGroupId = audioGroupId;
            this._selectInitialAudioTrack();
        }
    };
    /**
     * Handle network errors loading audio track manifests
     * and also pausing on any netwok errors.
     *
     * @param {ErrorEventData} data
     */
    AudioTrackController.prototype.onError = function (data) {
        // Only handle network errors
        if (data.type !== errors_1.ErrorTypes.NETWORK_ERROR) {
            return;
        }
        // If fatal network error, cancel update task
        if (data.fatal) {
            this.clearInterval();
        }
        // If not an audio-track loading error don't handle further
        if (data.details !== errors_1.ErrorDetails.AUDIO_TRACK_LOAD_ERROR) {
            return;
        }
        logger_1.logger.warn('Network failure on audio-track id:', data.context.id);
        this._handleLoadError();
    };
    Object.defineProperty(AudioTrackController.prototype, "audioTracks", {
        /**
         * @type {AudioTrack[]} Audio-track list we own
         */
        get: function () {
            return this.tracks;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AudioTrackController.prototype, "audioTrack", {
        /**
         * @type {number} Index into audio-tracks list of currently selected track.
         */
        get: function () {
            return this._trackId;
        },
        /**
         * Select current track by index
         */
        set: function (newId) {
            this._setAudioTrack(newId);
            // If audio track is selected from API then don't choose from the manifest default track
            this._selectDefaultTrack = false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @param {number} newId
     */
    AudioTrackController.prototype._setAudioTrack = function (newId) {
        // noop on same audio track id as already set
        if (this._trackId === newId && this.tracks[this._trackId].details) {
            logger_1.logger.debug('Same id as current audio-track passed, and track details available -> no-op');
            return;
        }
        // check if level idx is valid
        if (newId < 0 || newId >= this.tracks.length) {
            logger_1.logger.warn('Invalid id passed to audio-track controller');
            return;
        }
        var audioTrack = this.tracks[newId];
        logger_1.logger.log("Now switching to audio-track index " + newId);
        // stopping live reloading timer if any
        this.clearInterval();
        this._trackId = newId;
        var url = audioTrack.url, type = audioTrack.type, id = audioTrack.id;
        this.hls.trigger(events_1.default.AUDIO_TRACK_SWITCHING, { id: id, type: type, url: url });
        this._loadTrackDetailsIfNeeded(audioTrack);
    };
    /**
     * @override
     */
    AudioTrackController.prototype.doTick = function () {
        this._updateTrack(this._trackId);
    };
    /**
     * Select initial track
     * @private
     */
    AudioTrackController.prototype._selectInitialAudioTrack = function () {
        var _this = this;
        var tracks = this.tracks;
        if (!tracks.length) {
            return;
        }
        var currentAudioTrack = this.tracks[this._trackId];
        var name = null;
        if (currentAudioTrack) {
            name = currentAudioTrack.name;
        }
        // Pre-select default tracks if there are any
        if (this._selectDefaultTrack) {
            var defaultTracks = tracks.filter(function (track) { return track.default; });
            if (defaultTracks.length) {
                tracks = defaultTracks;
            }
            else {
                logger_1.logger.warn('No default audio tracks defined');
            }
        }
        var trackFound = false;
        var traverseTracks = function () {
            // Select track with right group ID
            tracks.forEach(function (track) {
                if (trackFound) {
                    return;
                }
                // We need to match the (pre-)selected group ID
                // and the NAME of the current track.
                if ((!_this.audioGroupId || track.groupId === _this.audioGroupId) &&
                    (!name || name === track.name)) {
                    // If there was a previous track try to stay with the same `NAME`.
                    // It should be unique across tracks of same group, and consistent through redundant track groups.
                    _this._setAudioTrack(track.id);
                    trackFound = true;
                }
            });
        };
        traverseTracks();
        if (!trackFound) {
            name = null;
            traverseTracks();
        }
        if (!trackFound) {
            logger_1.logger.error("No track found for running audio group-ID: " + this.audioGroupId);
            this.hls.trigger(events_1.default.ERROR, {
                type: errors_1.ErrorTypes.MEDIA_ERROR,
                details: errors_1.ErrorDetails.AUDIO_TRACK_LOAD_ERROR,
                fatal: true
            });
        }
    };
    /**
     * @private
     * @param {AudioTrack} audioTrack
     * @returns {boolean}
     */
    AudioTrackController.prototype._needsTrackLoading = function (audioTrack) {
        var details = audioTrack.details, url = audioTrack.url;
        if (!details || details.live) {
            // check if we face an audio track embedded in main playlist (audio track without URI attribute)
            return !!url;
        }
        return false;
    };
    /**
     * @private
     * @param {AudioTrack} audioTrack
     */
    AudioTrackController.prototype._loadTrackDetailsIfNeeded = function (audioTrack) {
        if (this._needsTrackLoading(audioTrack)) {
            var url = audioTrack.url, id = audioTrack.id;
            // track not retrieved yet, or live playlist we need to (re)load it
            logger_1.logger.log("loading audio-track playlist for id: " + id);
            this.hls.trigger(events_1.default.AUDIO_TRACK_LOADING, { url: url, id: id });
        }
    };
    /**
     * @private
     * @param {number} newId
     */
    AudioTrackController.prototype._updateTrack = function (newId) {
        // check if level idx is valid
        if (newId < 0 || newId >= this.tracks.length) {
            return;
        }
        // stopping live reloading timer if any
        this.clearInterval();
        this._trackId = newId;
        logger_1.logger.log("trying to update audio-track " + newId);
        var audioTrack = this.tracks[newId];
        this._loadTrackDetailsIfNeeded(audioTrack);
    };
    /**
     * @private
     */
    AudioTrackController.prototype._handleLoadError = function () {
        // First, let's black list current track id
        this.trackIdBlacklist[this._trackId] = true;
        // Let's try to fall back on a functional audio-track with the same group ID
        var previousId = this._trackId;
        var _a = this.tracks[previousId], name = _a.name, language = _a.language, groupId = _a.groupId;
        logger_1.logger.warn("Loading failed on audio track id: " + previousId + ", group-id: " + groupId + ", name/language: \"" + name + "\" / \"" + language + "\"");
        // Find a non-blacklisted track ID with the same NAME
        // At least a track that is not blacklisted, thus on another group-ID.
        var newId = previousId;
        for (var i = 0; i < this.tracks.length; i++) {
            if (this.trackIdBlacklist[i]) {
                continue;
            }
            var newTrack = this.tracks[i];
            if (newTrack.name === name) {
                newId = i;
                break;
            }
        }
        if (newId === previousId) {
            logger_1.logger.warn("No fallback audio-track found for name/language: \"" + name + "\" / \"" + language + "\"");
            return;
        }
        logger_1.logger.log('Attempting audio-track fallback id:', newId, 'group-id:', this.tracks[newId].groupId);
        this._setAudioTrack(newId);
    };
    return AudioTrackController;
}(task_loop_1.default));
exports.default = AudioTrackController;


/***/ }),

/***/ "./src/controller/base-stream-controller.js":
/*!**************************************************!*\
  !*** ./src/controller/base-stream-controller.js ***!
  \**************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var task_loop_1 = __webpack_require__(/*! ../task-loop */ "./src/task-loop.js");
var fragment_tracker_1 = __webpack_require__(/*! ./fragment-tracker */ "./src/controller/fragment-tracker.js");
var buffer_helper_1 = __webpack_require__(/*! ../utils/buffer-helper */ "./src/utils/buffer-helper.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
exports.State = {
    STOPPED: 'STOPPED',
    STARTING: 'STARTING',
    IDLE: 'IDLE',
    PAUSED: 'PAUSED',
    KEY_LOADING: 'KEY_LOADING',
    FRAG_LOADING: 'FRAG_LOADING',
    FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
    WAITING_TRACK: 'WAITING_TRACK',
    PARSING: 'PARSING',
    PARSED: 'PARSED',
    BUFFER_FLUSHING: 'BUFFER_FLUSHING',
    ENDED: 'ENDED',
    ERROR: 'ERROR',
    WAITING_INIT_PTS: 'WAITING_INIT_PTS',
    WAITING_LEVEL: 'WAITING_LEVEL'
};
var BaseStreamController = /** @class */ (function (_super) {
    __extends(BaseStreamController, _super);
    function BaseStreamController() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BaseStreamController.prototype.doTick = function () { };
    BaseStreamController.prototype._streamEnded = function (bufferInfo, levelDetails) {
        var _a = this, fragCurrent = _a.fragCurrent, fragmentTracker = _a.fragmentTracker;
        // we just got done loading the final fragment and there is no other buffered range after ...
        // rationale is that in case there are any buffered ranges after, it means that there are unbuffered portion in between
        // so we should not switch to ENDED in that case, to be able to buffer them
        // dont switch to ENDED if we need to backtrack last fragment
        if (!levelDetails.live && fragCurrent && !fragCurrent.backtracked && fragCurrent.sn === levelDetails.endSN && !bufferInfo.nextStart) {
            var fragState = fragmentTracker.getState(fragCurrent);
            return fragState === fragment_tracker_1.FragmentState.PARTIAL || fragState === fragment_tracker_1.FragmentState.OK;
        }
        return false;
    };
    BaseStreamController.prototype.onMediaSeeking = function () {
        var _a = this, config = _a.config, media = _a.media, mediaBuffer = _a.mediaBuffer, state = _a.state;
        var currentTime = media ? media.currentTime : null;
        var bufferInfo = buffer_helper_1.BufferHelper.bufferInfo(mediaBuffer || media, currentTime, this.config.maxBufferHole);
        if (Number.isFinite(currentTime)) {
            logger_1.logger.log("media seeking to " + currentTime.toFixed(3));
        }
        if (state === exports.State.FRAG_LOADING) {
            var fragCurrent = this.fragCurrent;
            // check if we are seeking to a unbuffered area AND if frag loading is in progress
            if (bufferInfo.len === 0 && fragCurrent) {
                var tolerance = config.maxFragLookUpTolerance;
                var fragStartOffset = fragCurrent.start - tolerance;
                var fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;
                // check if we seek position will be out of currently loaded frag range : if out cancel frag load, if in, don't do anything
                if (currentTime < fragStartOffset || currentTime > fragEndOffset) {
                    if (fragCurrent.loader) {
                        logger_1.logger.log('seeking outside of buffer while fragment load in progress, cancel fragment load');
                        fragCurrent.loader.abort();
                    }
                    this.fragCurrent = null;
                    this.fragPrevious = null;
                    // switch to IDLE state to load new fragment
                    this.state = exports.State.IDLE;
                }
                else {
                    logger_1.logger.log('seeking outside of buffer but within currently loaded fragment range');
                }
            }
        }
        else if (state === exports.State.ENDED) {
            // if seeking to unbuffered area, clean up fragPrevious
            if (bufferInfo.len === 0) {
                this.fragPrevious = null;
                this.fragCurrent = null;
            }
            // switch to IDLE state to check for potential new fragment
            this.state = exports.State.IDLE;
        }
        if (media) {
            this.lastCurrentTime = currentTime;
        }
        // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target
        if (!this.loadedmetadata) {
            this.nextLoadPosition = this.startPosition = currentTime;
        }
        // tick to speed up processing
        this.tick();
    };
    BaseStreamController.prototype.onMediaEnded = function () {
        // reset startPosition and lastCurrentTime to restart playback @ stream beginning
        this.startPosition = this.lastCurrentTime = 0;
    };
    return BaseStreamController;
}(task_loop_1.default));
exports.default = BaseStreamController;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/controller/buffer-controller.js":
/*!*********************************************!*\
  !*** ./src/controller/buffer-controller.js ***!
  \*********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
/*
 * Buffer Controller
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var event_handler_1 = __webpack_require__(/*! ../event-handler */ "./src/event-handler.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var mediasource_helper_1 = __webpack_require__(/*! ../utils/mediasource-helper */ "./src/utils/mediasource-helper.js");
var MediaSource = mediasource_helper_1.getMediaSource();
var BufferController = /** @class */ (function (_super) {
    __extends(BufferController, _super);
    function BufferController(hls) {
        var _this = _super.call(this, hls, events_1.default.MEDIA_ATTACHING, events_1.default.MEDIA_DETACHING, events_1.default.MANIFEST_PARSED, events_1.default.BUFFER_RESET, events_1.default.BUFFER_APPENDING, events_1.default.BUFFER_CODECS, events_1.default.BUFFER_EOS, events_1.default.BUFFER_FLUSHING, events_1.default.LEVEL_PTS_UPDATED, events_1.default.LEVEL_UPDATED) || this;
        // the value that we have set mediasource.duration to
        // (the actual duration may be tweaked slighly by the browser)
        _this._msDuration = null;
        // the value that we want to set mediaSource.duration to
        _this._levelDuration = null;
        // the target duration of the current media playlist
        _this._levelTargetDuration = 10;
        // current stream state: true - for live broadcast, false - for VoD content
        _this._live = null;
        // cache the self generated object url to detect hijack of video tag
        _this._objectUrl = null;
        // The number of BUFFER_CODEC events received before any sourceBuffers are created
        _this.bufferCodecEventsExpected = 0;
        // Source Buffer listeners
        _this.onsbue = _this.onSBUpdateEnd.bind(_this);
        _this.onsbe = _this.onSBUpdateError.bind(_this);
        _this.pendingTracks = {};
        _this.tracks = {};
        return _this;
    }
    BufferController.prototype.destroy = function () {
        event_handler_1.default.prototype.destroy.call(this);
    };
    BufferController.prototype.onLevelPtsUpdated = function (data) {
        var type = data.type;
        var audioTrack = this.tracks.audio;
        // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)
        // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`
        // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos). At the time of change we issue
        // `SourceBuffer.abort()` and adjusting `SourceBuffer.timestampOffset` if `SourceBuffer.updating` is false or awaiting `updateend`
        // event if SB is in updating state.
        // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486
        if (type === 'audio' && audioTrack && audioTrack.container === 'audio/mpeg') { // Chrome audio mp3 track
            var audioBuffer = this.sourceBuffer.audio;
            var delta = Math.abs(audioBuffer.timestampOffset - data.start);
            // adjust timestamp offset if time delta is greater than 100ms
            if (delta > 0.1) {
                var updating = audioBuffer.updating;
                try {
                    audioBuffer.abort();
                }
                catch (err) {
                    logger_1.logger.warn('can not abort audio buffer: ' + err);
                }
                if (!updating) {
                    logger_1.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + data.start);
                    audioBuffer.timestampOffset = data.start;
                }
                else {
                    this.audioTimestampOffset = data.start;
                }
            }
        }
    };
    BufferController.prototype.onManifestParsed = function (data) {
        // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller
        // sourcebuffers will be created all at once when the expected nb of tracks will be reached
        // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller
        // it will contain the expected nb of source buffers, no need to compute it
        this.bufferCodecEventsExpected = data.altAudio ? 2 : 1;
        logger_1.logger.log(this.bufferCodecEventsExpected + " bufferCodec event(s) expected");
    };
    BufferController.prototype.onMediaAttaching = function (data) {
        var media = this.media = data.media;
        if (media) {
            // setup the media source
            var ms = this.mediaSource = new MediaSource();
            // Media Source listeners
            this.onmso = this.onMediaSourceOpen.bind(this);
            this.onmse = this.onMediaSourceEnded.bind(this);
            this.onmsc = this.onMediaSourceClose.bind(this);
            ms.addEventListener('sourceopen', this.onmso);
            ms.addEventListener('sourceended', this.onmse);
            ms.addEventListener('sourceclose', this.onmsc);
            // link video and media Source
            media.src = window.URL.createObjectURL(ms);
            // cache the locally generated object url
            this._objectUrl = media.src;
        }
    };
    BufferController.prototype.onMediaDetaching = function () {
        logger_1.logger.log('media source detaching');
        var ms = this.mediaSource;
        if (ms) {
            if (ms.readyState === 'open') {
                try {
                    // endOfStream could trigger exception if any sourcebuffer is in updating state
                    // we don't really care about checking sourcebuffer state here,
                    // as we are anyway detaching the MediaSource
                    // let's just avoid this exception to propagate
                    ms.endOfStream();
                }
                catch (err) {
                    logger_1.logger.warn("onMediaDetaching:" + err.message + " while calling endOfStream");
                }
            }
            ms.removeEventListener('sourceopen', this.onmso);
            ms.removeEventListener('sourceended', this.onmse);
            ms.removeEventListener('sourceclose', this.onmsc);
            // Detach properly the MediaSource from the HTMLMediaElement as
            // suggested in https://github.com/w3c/media-source/issues/53.
            if (this.media) {
                window.URL.revokeObjectURL(this._objectUrl);
                // clean up video tag src only if it's our own url. some external libraries might
                // hijack the video tag and change its 'src' without destroying the Hls instance first
                if (this.media.src === this._objectUrl) {
                    this.media.removeAttribute('src');
                    this.media.load();
                }
                else {
                    logger_1.logger.warn('media.src was changed by a third party - skip cleanup');
                }
            }
            this.mediaSource = null;
            this.media = null;
            this._objectUrl = null;
            this.pendingTracks = {};
            this.tracks = {};
            this.sourceBuffer = {};
            this.flushRange = [];
            this.segments = [];
            this.appended = 0;
        }
        this.onmso = this.onmse = this.onmsc = null;
        this.hls.trigger(events_1.default.MEDIA_DETACHED);
    };
    BufferController.prototype.onMediaSourceOpen = function () {
        logger_1.logger.log('media source opened');
        this.hls.trigger(events_1.default.MEDIA_ATTACHED, { media: this.media });
        var mediaSource = this.mediaSource;
        if (mediaSource) {
            // once received, don't listen anymore to sourceopen event
            mediaSource.removeEventListener('sourceopen', this.onmso);
        }
        this.checkPendingTracks();
    };
    BufferController.prototype.checkPendingTracks = function () {
        var _a = this, bufferCodecEventsExpected = _a.bufferCodecEventsExpected, pendingTracks = _a.pendingTracks;
        // Check if we've received all of the expected bufferCodec events. When none remain, create all the sourceBuffers at once.
        // This is important because the MSE spec allows implementations to throw QuotaExceededErrors if creating new sourceBuffers after
        // data has been appended to existing ones.
        // 2 tracks is the max (one for audio, one for video). If we've reach this max go ahead and create the buffers.
        var pendingTracksCount = Object.keys(pendingTracks).length;
        if ((pendingTracksCount && !bufferCodecEventsExpected) || pendingTracksCount === 2) {
            // ok, let's create them now !
            this.createSourceBuffers(pendingTracks);
            this.pendingTracks = {};
            // append any pending segments now !
            this.doAppending();
        }
    };
    BufferController.prototype.onMediaSourceClose = function () {
        logger_1.logger.log('media source closed');
    };
    BufferController.prototype.onMediaSourceEnded = function () {
        logger_1.logger.log('media source ended');
    };
    BufferController.prototype.onSBUpdateEnd = function () {
        // update timestampOffset
        if (this.audioTimestampOffset) {
            var audioBuffer = this.sourceBuffer.audio;
            logger_1.logger.warn("change mpeg audio timestamp offset from " + audioBuffer.timestampOffset + " to " + this.audioTimestampOffset);
            audioBuffer.timestampOffset = this.audioTimestampOffset;
            delete this.audioTimestampOffset;
        }
        if (this._needsFlush) {
            this.doFlush();
        }
        if (this._needsEos) {
            this.checkEos();
        }
        this.appending = false;
        var parent = this.parent;
        // count nb of pending segments waiting for appending on this sourcebuffer
        var pending = this.segments.reduce(function (counter, segment) { return (segment.parent === parent) ? counter + 1 : counter; }, 0);
        // this.sourceBuffer is better to use than media.buffered as it is closer to the PTS data from the fragments
        var timeRanges = {};
        var sourceBuffer = this.sourceBuffer;
        for (var streamType in sourceBuffer) {
            timeRanges[streamType] = sourceBuffer[streamType].buffered;
        }
        this.hls.trigger(events_1.default.BUFFER_APPENDED, { parent: parent, pending: pending, timeRanges: timeRanges });
        // don't append in flushing mode
        if (!this._needsFlush) {
            this.doAppending();
        }
        this.updateMediaElementDuration();
        // appending goes first
        if (pending === 0) {
            this.flushLiveBackBuffer();
        }
    };
    BufferController.prototype.onSBUpdateError = function (event) {
        logger_1.logger.error('sourceBuffer error:', event);
        // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
        // this error might not always be fatal (it is fatal if decode error is set, in that case
        // it will be followed by a mediaElement error ...)
        this.hls.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.MEDIA_ERROR, details: errors_1.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });
        // we don't need to do more than that, as accordin to the spec, updateend will be fired just after
    };
    BufferController.prototype.onBufferReset = function () {
        var sourceBuffer = this.sourceBuffer;
        for (var type in sourceBuffer) {
            var sb = sourceBuffer[type];
            try {
                this.mediaSource.removeSourceBuffer(sb);
                sb.removeEventListener('updateend', this.onsbue);
                sb.removeEventListener('error', this.onsbe);
            }
            catch (err) {
            }
        }
        this.sourceBuffer = {};
        this.flushRange = [];
        this.segments = [];
        this.appended = 0;
    };
    BufferController.prototype.onBufferCodecs = function (tracks) {
        var _this = this;
        // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks
        // if sourcebuffers already created, do nothing ...
        if (Object.keys(this.sourceBuffer).length) {
            return;
        }
        Object.keys(tracks).forEach(function (trackName) {
            _this.pendingTracks[trackName] = tracks[trackName];
        });
        var mediaSource = this.mediaSource;
        this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0);
        if (mediaSource && mediaSource.readyState === 'open') {
            this.checkPendingTracks();
        }
    };
    BufferController.prototype.createSourceBuffers = function (tracks) {
        var sourceBuffer = this.sourceBuffer, mediaSource = this.mediaSource;
        for (var trackName in tracks) {
            if (!sourceBuffer[trackName]) {
                var track = tracks[trackName];
                // use levelCodec as first priority
                var codec = track.levelCodec || track.codec;
                var mimeType = track.container + ";codecs=" + codec;
                logger_1.logger.log("creating sourceBuffer(" + mimeType + ")");
                try {
                    var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);
                    sb.addEventListener('updateend', this.onsbue);
                    sb.addEventListener('error', this.onsbe);
                    this.tracks[trackName] = { codec: codec, container: track.container };
                    track.buffer = sb;
                }
                catch (err) {
                    logger_1.logger.error("error while trying to add sourceBuffer:" + err.message);
                    this.hls.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.MEDIA_ERROR, details: errors_1.ErrorDetails.BUFFER_ADD_CODEC_ERROR, fatal: false, err: err, mimeType: mimeType });
                }
            }
        }
        this.hls.trigger(events_1.default.BUFFER_CREATED, { tracks: tracks });
    };
    BufferController.prototype.onBufferAppending = function (data) {
        if (!this._needsFlush) {
            if (!this.segments) {
                this.segments = [data];
            }
            else {
                this.segments.push(data);
            }
            this.doAppending();
        }
    };
    BufferController.prototype.onBufferAppendFail = function (data) {
        logger_1.logger.error('sourceBuffer error:', data.event);
        // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
        // this error might not always be fatal (it is fatal if decode error is set, in that case
        // it will be followed by a mediaElement error ...)
        this.hls.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.MEDIA_ERROR, details: errors_1.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });
    };
    // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()
    BufferController.prototype.onBufferEos = function (data) {
        var sb = this.sourceBuffer;
        var dataType = data.type;
        for (var type in sb) {
            if (!dataType || type === dataType) {
                if (!sb[type].ended) {
                    sb[type].ended = true;
                    logger_1.logger.log(type + " sourceBuffer now EOS");
                }
            }
        }
        this.checkEos();
    };
    // if all source buffers are marked as ended, signal endOfStream() to MediaSource.
    BufferController.prototype.checkEos = function () {
        var sb = this.sourceBuffer, mediaSource = this.mediaSource;
        if (!mediaSource || mediaSource.readyState !== 'open') {
            this._needsEos = false;
            return;
        }
        for (var type in sb) {
            var sbobj = sb[type];
            if (!sbobj.ended) {
                return;
            }
            if (sbobj.updating) {
                this._needsEos = true;
                return;
            }
        }
        logger_1.logger.log('all media data are available, signal endOfStream() to MediaSource and stop loading fragment');
        // Notify the media element that it now has all of the media data
        try {
            mediaSource.endOfStream();
        }
        catch (e) {
            logger_1.logger.warn('exception while calling mediaSource.endOfStream()');
        }
        this._needsEos = false;
    };
    BufferController.prototype.onBufferFlushing = function (data) {
        this.flushRange.push({ start: data.startOffset, end: data.endOffset, type: data.type });
        // attempt flush immediately
        this.flushBufferCounter = 0;
        this.doFlush();
    };
    BufferController.prototype.flushLiveBackBuffer = function () {
        // clear back buffer for live only
        if (!this._live) {
            return;
        }
        var liveBackBufferLength = this.hls.config.liveBackBufferLength;
        if (!isFinite(liveBackBufferLength) || liveBackBufferLength < 0) {
            return;
        }
        var currentTime = this.media.currentTime;
        var sourceBuffer = this.sourceBuffer;
        var bufferTypes = Object.keys(sourceBuffer);
        var targetBackBufferPosition = currentTime - Math.max(liveBackBufferLength, this._levelTargetDuration);
        for (var index = bufferTypes.length - 1; index >= 0; index--) {
            var bufferType = bufferTypes[index], buffered = sourceBuffer[bufferType].buffered;
            // when target buffer start exceeds actual buffer start
            if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {
                // remove buffer up until current time minus minimum back buffer length (removing buffer too close to current
                // time will lead to playback freezing)
                // credits for level target duration - https://github.com/videojs/http-streaming/blob/3132933b6aa99ddefab29c10447624efd6fd6e52/src/segment-loader.js#L91
                this.removeBufferRange(bufferType, sourceBuffer[bufferType], 0, targetBackBufferPosition);
            }
        }
    };
    BufferController.prototype.onLevelUpdated = function (_a) {
        var details = _a.details;
        if (details.fragments.length > 0) {
            this._levelDuration = details.totalduration + details.fragments[0].start;
            this._levelTargetDuration = details.averagetargetduration || details.targetduration || 10;
            this._live = details.live;
            this.updateMediaElementDuration();
        }
    };
    /**
     * Update Media Source duration to current level duration or override to Infinity if configuration parameter
     * 'liveDurationInfinity` is set to `true`
     * More details: https://github.com/video-dev/hls.js/issues/355
     */
    BufferController.prototype.updateMediaElementDuration = function () {
        var config = this.hls.config;
        var duration;
        if (this._levelDuration === null ||
            !this.media ||
            !this.mediaSource ||
            !this.sourceBuffer ||
            this.media.readyState === 0 ||
            this.mediaSource.readyState !== 'open') {
            return;
        }
        for (var type in this.sourceBuffer) {
            if (this.sourceBuffer[type].updating === true) {
                // can't set duration whilst a buffer is updating
                return;
            }
        }
        duration = this.media.duration;
        // initialise to the value that the media source is reporting
        if (this._msDuration === null) {
            this._msDuration = this.mediaSource.duration;
        }
        if (this._live === true && config.liveDurationInfinity === true) {
            // Override duration to Infinity
            logger_1.logger.log('Media Source duration is set to Infinity');
            this._msDuration = this.mediaSource.duration = Infinity;
        }
        else if ((this._levelDuration > this._msDuration && this._levelDuration > duration) || !Number.isFinite(duration)) {
            // levelDuration was the last value we set.
            // not using mediaSource.duration as the browser may tweak this value
            // only update Media Source duration if its value increase, this is to avoid
            // flushing already buffered portion when switching between quality level
            logger_1.logger.log("Updating Media Source duration to " + this._levelDuration.toFixed(3));
            this._msDuration = this.mediaSource.duration = this._levelDuration;
        }
    };
    BufferController.prototype.doFlush = function () {
        // loop through all buffer ranges to flush
        while (this.flushRange.length) {
            var range = this.flushRange[0];
            // flushBuffer will abort any buffer append in progress and flush Audio/Video Buffer
            if (this.flushBuffer(range.start, range.end, range.type)) {
                // range flushed, remove from flush array
                this.flushRange.shift();
                this.flushBufferCounter = 0;
            }
            else {
                this._needsFlush = true;
                // avoid looping, wait for SB update end to retrigger a flush
                return;
            }
        }
        if (this.flushRange.length === 0) {
            // everything flushed
            this._needsFlush = false;
            // let's recompute this.appended, which is used to avoid flush looping
            var appended = 0;
            var sourceBuffer = this.sourceBuffer;
            try {
                for (var type in sourceBuffer) {
                    appended += sourceBuffer[type].buffered.length;
                }
            }
            catch (error) {
                // error could be thrown while accessing buffered, in case sourcebuffer has already been removed from MediaSource
                // this is harmess at this stage, catch this to avoid reporting an internal exception
                logger_1.logger.error('error while accessing sourceBuffer.buffered');
            }
            this.appended = appended;
            this.hls.trigger(events_1.default.BUFFER_FLUSHED);
        }
    };
    BufferController.prototype.doAppending = function () {
        var _a = this, hls = _a.hls, segments = _a.segments, sourceBuffer = _a.sourceBuffer;
        if (Object.keys(sourceBuffer).length) {
            if (this.media.error) {
                this.segments = [];
                logger_1.logger.error('trying to append although a media error occured, flush segment and abort');
                return;
            }
            if (this.appending) {
                // logger.log(`sb appending in progress`);
                return;
            }
            if (segments && segments.length) {
                var segment = segments.shift();
                try {
                    var type = segment.type, sb = sourceBuffer[type];
                    if (sb) {
                        if (!sb.updating) {
                            // reset sourceBuffer ended flag before appending segment
                            sb.ended = false;
                            // logger.log(`appending ${segment.content} ${type} SB, size:${segment.data.length}, ${segment.parent}`);
                            this.parent = segment.parent;
                            sb.appendBuffer(segment.data);
                            this.appendError = 0;
                            this.appended++;
                            this.appending = true;
                        }
                        else {
                            segments.unshift(segment);
                        }
                    }
                    else {
                        // in case we don't have any source buffer matching with this segment type,
                        // it means that Mediasource fails to create sourcebuffer
                        // discard this segment, and trigger update end
                        this.onSBUpdateEnd();
                    }
                }
                catch (err) {
                    // in case any error occured while appending, put back segment in segments table
                    logger_1.logger.error("error while trying to append buffer:" + err.message);
                    segments.unshift(segment);
                    var event_1 = { type: errors_1.ErrorTypes.MEDIA_ERROR, parent: segment.parent };
                    if (err.code !== 22) {
                        if (this.appendError) {
                            this.appendError++;
                        }
                        else {
                            this.appendError = 1;
                        }
                        event_1.details = errors_1.ErrorDetails.BUFFER_APPEND_ERROR;
                        /* with UHD content, we could get loop of quota exceeded error until
                          browser is able to evict some data from sourcebuffer. retrying help recovering this
                        */
                        if (this.appendError > hls.config.appendErrorMaxRetry) {
                            logger_1.logger.log("fail " + hls.config.appendErrorMaxRetry + " times to append segment in sourceBuffer");
                            this.segments = [];
                            event_1.fatal = true;
                            hls.trigger(events_1.default.ERROR, event_1);
                        }
                        else {
                            event_1.fatal = false;
                            hls.trigger(events_1.default.ERROR, event_1);
                        }
                    }
                    else {
                        // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror
                        // let's stop appending any segments, and report BUFFER_FULL_ERROR error
                        this.segments = [];
                        event_1.details = errors_1.ErrorDetails.BUFFER_FULL_ERROR;
                        event_1.fatal = false;
                        hls.trigger(events_1.default.ERROR, event_1);
                    }
                }
            }
        }
    };
    /*
      flush specified buffered range,
      return true once range has been flushed.
      as sourceBuffer.remove() is asynchronous, flushBuffer will be retriggered on sourceBuffer update end
    */
    BufferController.prototype.flushBuffer = function (startOffset, endOffset, typeIn) {
        var sb;
        var sourceBuffer = this.sourceBuffer;
        if (Object.keys(sourceBuffer).length) {
            logger_1.logger.log("flushBuffer,pos/start/end: " + this.media.currentTime.toFixed(3) + "/" + startOffset + "/" + endOffset);
            // safeguard to avoid infinite looping : don't try to flush more than the nb of appended segments
            if (this.flushBufferCounter < this.appended) {
                for (var type in sourceBuffer) {
                    // check if sourcebuffer type is defined (typeIn): if yes, let's only flush this one
                    // if no, let's flush all sourcebuffers
                    if (typeIn && type !== typeIn) {
                        continue;
                    }
                    sb = sourceBuffer[type];
                    // we are going to flush buffer, mark source buffer as 'not ended'
                    sb.ended = false;
                    if (!sb.updating) {
                        if (this.removeBufferRange(type, sb, startOffset, endOffset)) {
                            this.flushBufferCounter++;
                            return false;
                        }
                    }
                    else {
                        logger_1.logger.warn('cannot flush, sb updating in progress');
                        return false;
                    }
                }
            }
            else {
                logger_1.logger.warn('abort flushing too many retries');
            }
            logger_1.logger.log('buffer flushed');
        }
        // everything flushed !
        return true;
    };
    /**
     * Removes first buffered range from provided source buffer that lies within given start and end offsets.
     *
     * @param type Type of the source buffer, logging purposes only.
     * @param sb Target SourceBuffer instance.
     * @param startOffset
     * @param endOffset
     *
     * @returns {boolean} True when source buffer remove requested.
     */
    BufferController.prototype.removeBufferRange = function (type, sb, startOffset, endOffset) {
        try {
            for (var i = 0; i < sb.buffered.length; i++) {
                var bufStart = sb.buffered.start(i);
                var bufEnd = sb.buffered.end(i);
                var removeStart = Math.max(bufStart, startOffset);
                var removeEnd = Math.min(bufEnd, endOffset);
                /* sometimes sourcebuffer.remove() does not flush
                  the exact expected time range.
                  to avoid rounding issues/infinite loop,
                  only flush buffer range of length greater than 500ms.
                */
                if (Math.min(removeEnd, bufEnd) - removeStart > 0.5) {
                    logger_1.logger.log("sb remove " + type + " [" + removeStart + "," + removeEnd + "], of [" + bufStart + "," + bufEnd + "], pos:" + this.media.currentTime);
                    sb.remove(removeStart, removeEnd);
                    return true;
                }
            }
        }
        catch (error) {
            logger_1.logger.warn('removeBufferRange failed', error);
        }
        return false;
    };
    return BufferController;
}(event_handler_1.default));
exports.default = BufferController;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/controller/cap-level-controller.js":
/*!************************************************!*\
  !*** ./src/controller/cap-level-controller.js ***!
  \************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
/*
 * cap stream level to media size dimension controller
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var event_handler_1 = __webpack_require__(/*! ../event-handler */ "./src/event-handler.js");
var CapLevelController = /** @class */ (function (_super) {
    __extends(CapLevelController, _super);
    function CapLevelController(hls) {
        var _this = _super.call(this, hls, events_1.default.FPS_DROP_LEVEL_CAPPING, events_1.default.MEDIA_ATTACHING, events_1.default.MANIFEST_PARSED, events_1.default.BUFFER_CODECS, events_1.default.MEDIA_DETACHING) || this;
        _this.autoLevelCapping = Number.POSITIVE_INFINITY;
        _this.firstLevel = null;
        _this.levels = [];
        _this.media = null;
        _this.restrictedLevels = [];
        _this.timer = null;
        return _this;
    }
    CapLevelController.prototype.destroy = function () {
        if (this.hls.config.capLevelToPlayerSize) {
            this.media = null;
            this._stopCapping();
        }
    };
    CapLevelController.prototype.onFpsDropLevelCapping = function (data) {
        // Don't add a restricted level more than once
        if (CapLevelController.isLevelAllowed(data.droppedLevel, this.restrictedLevels)) {
            this.restrictedLevels.push(data.droppedLevel);
        }
    };
    CapLevelController.prototype.onMediaAttaching = function (data) {
        this.media = data.media instanceof window.HTMLVideoElement ? data.media : null;
    };
    CapLevelController.prototype.onManifestParsed = function (data) {
        var hls = this.hls;
        this.restrictedLevels = [];
        this.levels = data.levels;
        this.firstLevel = data.firstLevel;
        if (hls.config.capLevelToPlayerSize && data.video) {
            // Start capping immediately if the manifest has signaled video codecs
            this._startCapping();
        }
    };
    // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted
    // to the first level
    CapLevelController.prototype.onBufferCodecs = function (data) {
        var hls = this.hls;
        if (hls.config.capLevelToPlayerSize && data.video) {
            // If the manifest did not signal a video codec capping has been deferred until we're certain video is present
            this._startCapping();
        }
    };
    CapLevelController.prototype.onLevelsUpdated = function (data) {
        this.levels = data.levels;
    };
    CapLevelController.prototype.onMediaDetaching = function () {
        this._stopCapping();
    };
    CapLevelController.prototype.detectPlayerSize = function () {
        if (this.media) {
            var levelsLength = this.levels ? this.levels.length : 0;
            if (levelsLength) {
                var hls_1 = this.hls;
                hls_1.autoLevelCapping = this.getMaxLevel(levelsLength - 1);
                if (hls_1.autoLevelCapping > this.autoLevelCapping) {
                    // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch
                    // usually happen when the user go to the fullscreen mode.
                    hls_1.streamController.nextLevelSwitch();
                }
                this.autoLevelCapping = hls_1.autoLevelCapping;
            }
        }
    };
    /*
    * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
    */
    CapLevelController.prototype.getMaxLevel = function (capLevelIndex) {
        var _this = this;
        if (!this.levels) {
            return -1;
        }
        var validLevels = this.levels.filter(function (level, index) {
            return CapLevelController.isLevelAllowed(index, _this.restrictedLevels) && index <= capLevelIndex;
        });
        return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);
    };
    CapLevelController.prototype._startCapping = function () {
        if (this.timer) {
            // Don't reset capping if started twice; this can happen if the manifest signals a video codec
            return;
        }
        this.autoLevelCapping = Number.POSITIVE_INFINITY;
        this.hls.firstLevel = this.getMaxLevel(this.firstLevel);
        clearInterval(this.timer);
        this.timer = setInterval(this.detectPlayerSize.bind(this), 1000);
        this.detectPlayerSize();
    };
    CapLevelController.prototype._stopCapping = function () {
        this.restrictedLevels = [];
        this.firstLevel = null;
        this.autoLevelCapping = Number.POSITIVE_INFINITY;
        if (this.timer) {
            this.timer = clearInterval(this.timer);
            this.timer = null;
        }
    };
    Object.defineProperty(CapLevelController.prototype, "mediaWidth", {
        get: function () {
            var width;
            var media = this.media;
            if (media) {
                width = media.width || media.clientWidth || media.offsetWidth;
                width *= CapLevelController.contentScaleFactor;
            }
            return width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CapLevelController.prototype, "mediaHeight", {
        get: function () {
            var height;
            var media = this.media;
            if (media) {
                height = media.height || media.clientHeight || media.offsetHeight;
                height *= CapLevelController.contentScaleFactor;
            }
            return height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CapLevelController, "contentScaleFactor", {
        get: function () {
            var pixelRatio = 1;
            try {
                pixelRatio = window.devicePixelRatio;
            }
            catch (e) { }
            return pixelRatio;
        },
        enumerable: true,
        configurable: true
    });
    CapLevelController.isLevelAllowed = function (level, restrictedLevels) {
        if (restrictedLevels === void 0) { restrictedLevels = []; }
        return restrictedLevels.indexOf(level) === -1;
    };
    CapLevelController.getMaxLevelByMediaSize = function (levels, width, height) {
        if (!levels || (levels && !levels.length)) {
            return -1;
        }
        // Levels can have the same dimensions but differing bandwidths - since levels are ordered, we can look to the next
        // to determine whether we've chosen the greatest bandwidth for the media's dimensions
        var atGreatestBandiwdth = function (curLevel, nextLevel) {
            if (!nextLevel) {
                return true;
            }
            return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;
        };
        // If we run through the loop without breaking, the media's dimensions are greater than every level, so default to
        // the max level
        var maxLevelIndex = levels.length - 1;
        for (var i = 0; i < levels.length; i += 1) {
            var level = levels[i];
            if ((level.width >= width || level.height >= height) && atGreatestBandiwdth(level, levels[i + 1])) {
                maxLevelIndex = i;
                break;
            }
        }
        return maxLevelIndex;
    };
    return CapLevelController;
}(event_handler_1.default));
exports.default = CapLevelController;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/controller/eme-controller.js":
/*!******************************************!*\
  !*** ./src/controller/eme-controller.js ***!
  \******************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @author Stephan Hesse <disparat@gmail.com> | <tchakabam@gmail.com>
 *
 * DRM support for Hls.js
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var event_handler_1 = __webpack_require__(/*! ../event-handler */ "./src/event-handler.js");
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var XMLHttpRequest = window.XMLHttpRequest;
var MAX_LICENSE_REQUEST_FAILURES = 3;
/**
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess
 */
var KeySystems = {
    WIDEVINE: 'com.widevine.alpha',
    PLAYREADY: 'com.microsoft.playready'
};
/**
 * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemConfiguration
 * @param {Array<string>} audioCodecs List of required audio codecs to support
 * @param {Array<string>} videoCodecs List of required video codecs to support
 * @param {object} drmSystemOptions Optional parameters/requirements for the key-system
 * @returns {Array<MediaSystemConfiguration>} An array of supported configurations
 */
var createWidevineMediaKeySystemConfigurations = function (audioCodecs, videoCodecs, drmSystemOptions) {
    var baseConfig = {
        // initDataTypes: ['keyids', 'mp4'],
        // label: "",
        // persistentState: "not-allowed", // or "required" ?
        // distinctiveIdentifier: "not-allowed", // or "required" ?
        // sessionTypes: ['temporary'],
        videoCapabilities: [
        // { contentType: 'video/mp4; codecs="avc1.42E01E"' }
        ]
    };
    videoCodecs.forEach(function (codec) {
        baseConfig.videoCapabilities.push({
            contentType: "video/mp4; codecs=\"" + codec + "\""
        });
    });
    return [
        baseConfig
    ];
};
/**
 * The idea here is to handle key-system (and their respective platforms) specific configuration differences
 * in order to work with the local requestMediaKeySystemAccess method.
 *
 * We can also rule-out platform-related key-system support at this point by throwing an error or returning null.
 *
 * @param {string} keySystem Identifier for the key-system, see `KeySystems` enum
 * @param {Array<string>} audioCodecs List of required audio codecs to support
 * @param {Array<string>} videoCodecs List of required video codecs to support
 * @returns {Array<MediaSystemConfiguration> | null} A non-empty Array of MediaKeySystemConfiguration objects or `null`
 */
var getSupportedMediaKeySystemConfigurations = function (keySystem, audioCodecs, videoCodecs) {
    switch (keySystem) {
        case KeySystems.WIDEVINE:
            return createWidevineMediaKeySystemConfigurations(audioCodecs, videoCodecs);
        default:
            throw Error('Unknown key-system: ' + keySystem);
    }
};
/**
 * Controller to deal with encrypted media extensions (EME)
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API
 *
 * @class
 * @constructor
 */
var EMEController = /** @class */ (function (_super) {
    __extends(EMEController, _super);
    /**
       * @constructs
       * @param {Hls} hls Our Hls.js instance
       */
    function EMEController(hls) {
        var _this = _super.call(this, hls, events_1.default.MEDIA_ATTACHED, events_1.default.MANIFEST_PARSED) || this;
        _this._widevineLicenseUrl = hls.config.widevineLicenseUrl;
        _this._licenseXhrSetup = hls.config.licenseXhrSetup;
        _this._emeEnabled = hls.config.emeEnabled;
        _this._requestMediaKeySystemAccess = hls.config.requestMediaKeySystemAccessFunc;
        _this._mediaKeysList = [];
        _this._media = null;
        _this._hasSetMediaKeys = false;
        _this._isMediaEncrypted = false;
        _this._requestLicenseFailureCount = 0;
        return _this;
    }
    /**
       *
       * @param {string} keySystem Identifier for the key-system, see `KeySystems` enum
       * @returns {string} License server URL for key-system (if any configured, otherwise causes error)
       */
    EMEController.prototype.getLicenseServerUrl = function (keySystem) {
        var url;
        switch (keySystem) {
            case KeySystems.WIDEVINE:
                url = this._widevineLicenseUrl;
                break;
            default:
                url = null;
                break;
        }
        if (!url) {
            logger_1.logger.error("No license server URL configured for key-system \"" + keySystem + "\"");
            this.hls.trigger(events_1.default.ERROR, {
                type: errors_1.ErrorTypes.KEY_SYSTEM_ERROR,
                details: errors_1.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                fatal: true
            });
        }
        return url;
    };
    /**
       * Requests access object and adds it to our list upon success
       * @private
       * @param {string} keySystem System ID (see `KeySystems`)
       * @param {Array<string>} audioCodecs List of required audio codecs to support
       * @param {Array<string>} videoCodecs List of required video codecs to support
       */
    EMEController.prototype._attemptKeySystemAccess = function (keySystem, audioCodecs, videoCodecs) {
        // TODO: add other DRM "options"
        var _this = this;
        var mediaKeySystemConfigs = getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs);
        if (!mediaKeySystemConfigs) {
            logger_1.logger.warn('Can not create config for key-system (maybe because platform is not supported):', keySystem);
            return;
        }
        logger_1.logger.log('Requesting encrypted media key-system access');
        // expecting interface like window.navigator.requestMediaKeySystemAccess
        this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs)
            .then(function (mediaKeySystemAccess) {
            _this._onMediaKeySystemAccessObtained(keySystem, mediaKeySystemAccess);
        })
            .catch(function (err) {
            logger_1.logger.error("Failed to obtain key-system \"" + keySystem + "\" access:", err);
        });
    };
    Object.defineProperty(EMEController.prototype, "requestMediaKeySystemAccess", {
        get: function () {
            if (!this._requestMediaKeySystemAccess) {
                throw new Error('No requestMediaKeySystemAccess function configured');
            }
            return this._requestMediaKeySystemAccess;
        },
        enumerable: true,
        configurable: true
    });
    /**
       * Handles obtaining access to a key-system
       *
       * @param {string} keySystem
       * @param {MediaKeySystemAccess} mediaKeySystemAccess https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemAccess
       */
    EMEController.prototype._onMediaKeySystemAccessObtained = function (keySystem, mediaKeySystemAccess) {
        var _this = this;
        logger_1.logger.log("Access for key-system \"" + keySystem + "\" obtained");
        var mediaKeysListItem = {
            mediaKeys: null,
            mediaKeysSession: null,
            mediaKeysSessionInitialized: false,
            mediaKeySystemAccess: mediaKeySystemAccess,
            mediaKeySystemDomain: keySystem
        };
        this._mediaKeysList.push(mediaKeysListItem);
        mediaKeySystemAccess.createMediaKeys()
            .then(function (mediaKeys) {
            mediaKeysListItem.mediaKeys = mediaKeys;
            logger_1.logger.log("Media-keys created for key-system \"" + keySystem + "\"");
            _this._onMediaKeysCreated();
        })
            .catch(function (err) {
            logger_1.logger.error('Failed to create media-keys:', err);
        });
    };
    /**
       * Handles key-creation (represents access to CDM). We are going to create key-sessions upon this
       * for all existing keys where no session exists yet.
       */
    EMEController.prototype._onMediaKeysCreated = function () {
        var _this = this;
        // check for all key-list items if a session exists, otherwise, create one
        this._mediaKeysList.forEach(function (mediaKeysListItem) {
            if (!mediaKeysListItem.mediaKeysSession) {
                mediaKeysListItem.mediaKeysSession = mediaKeysListItem.mediaKeys.createSession();
                _this._onNewMediaKeySession(mediaKeysListItem.mediaKeysSession);
            }
        });
    };
    /**
       *
       * @param {*} keySession
       */
    EMEController.prototype._onNewMediaKeySession = function (keySession) {
        var _this = this;
        logger_1.logger.log("New key-system session " + keySession.sessionId);
        keySession.addEventListener('message', function (event) {
            _this._onKeySessionMessage(keySession, event.message);
        }, false);
    };
    EMEController.prototype._onKeySessionMessage = function (keySession, message) {
        logger_1.logger.log('Got EME message event, creating license request');
        this._requestLicense(message, function (data) {
            logger_1.logger.log('Received license data, updating key-session');
            keySession.update(data);
        });
    };
    EMEController.prototype._onMediaEncrypted = function (initDataType, initData) {
        logger_1.logger.log("Media is encrypted using \"" + initDataType + "\" init data type");
        this._isMediaEncrypted = true;
        this._mediaEncryptionInitDataType = initDataType;
        this._mediaEncryptionInitData = initData;
        this._attemptSetMediaKeys();
        this._generateRequestWithPreferredKeySession();
    };
    EMEController.prototype._attemptSetMediaKeys = function () {
        if (!this._hasSetMediaKeys) {
            // FIXME: see if we can/want/need-to really to deal with several potential key-sessions?
            var keysListItem = this._mediaKeysList[0];
            if (!keysListItem || !keysListItem.mediaKeys) {
                logger_1.logger.error('Fatal: Media is encrypted but no CDM access or no keys have been obtained yet');
                this.hls.trigger(events_1.default.ERROR, {
                    type: errors_1.ErrorTypes.KEY_SYSTEM_ERROR,
                    details: errors_1.ErrorDetails.KEY_SYSTEM_NO_KEYS,
                    fatal: true
                });
                return;
            }
            logger_1.logger.log('Setting keys for encrypted media');
            this._media.setMediaKeys(keysListItem.mediaKeys);
            this._hasSetMediaKeys = true;
        }
    };
    EMEController.prototype._generateRequestWithPreferredKeySession = function () {
        var _this = this;
        // FIXME: see if we can/want/need-to really to deal with several potential key-sessions?
        var keysListItem = this._mediaKeysList[0];
        if (!keysListItem) {
            logger_1.logger.error('Fatal: Media is encrypted but not any key-system access has been obtained yet');
            this.hls.trigger(events_1.default.ERROR, {
                type: errors_1.ErrorTypes.KEY_SYSTEM_ERROR,
                details: errors_1.ErrorDetails.KEY_SYSTEM_NO_ACCESS,
                fatal: true
            });
            return;
        }
        if (keysListItem.mediaKeysSessionInitialized) {
            logger_1.logger.warn('Key-Session already initialized but requested again');
            return;
        }
        var keySession = keysListItem.mediaKeysSession;
        if (!keySession) {
            logger_1.logger.error('Fatal: Media is encrypted but no key-session existing');
            this.hls.trigger(events_1.default.ERROR, {
                type: errors_1.ErrorTypes.KEY_SYSTEM_ERROR,
                details: errors_1.ErrorDetails.KEY_SYSTEM_NO_SESSION,
                fatal: true
            });
        }
        var initDataType = this._mediaEncryptionInitDataType;
        var initData = this._mediaEncryptionInitData;
        logger_1.logger.log("Generating key-session request for \"" + initDataType + "\" init data type");
        keysListItem.mediaKeysSessionInitialized = true;
        keySession.generateRequest(initDataType, initData)
            .then(function () {
            logger_1.logger.debug('Key-session generation succeeded');
        })
            .catch(function (err) {
            logger_1.logger.error('Error generating key-session request:', err);
            _this.hls.trigger(events_1.default.ERROR, {
                type: errors_1.ErrorTypes.KEY_SYSTEM_ERROR,
                details: errors_1.ErrorDetails.KEY_SYSTEM_NO_SESSION,
                fatal: false
            });
        });
    };
    /**
       * @param {string} url License server URL
       * @param {ArrayBuffer} keyMessage Message data issued by key-system
       * @param {function} callback Called when XHR has succeeded
       * @returns {XMLHttpRequest} Unsent (but opened state) XHR object
       */
    EMEController.prototype._createLicenseXhr = function (url, keyMessage, callback) {
        var xhr = new XMLHttpRequest();
        var licenseXhrSetup = this._licenseXhrSetup;
        try {
            if (licenseXhrSetup) {
                try {
                    licenseXhrSetup(xhr, url);
                }
                catch (e) {
                    // let's try to open before running setup
                    xhr.open('POST', url, true);
                    licenseXhrSetup(xhr, url);
                }
            }
            // if licenseXhrSetup did not yet call open, let's do it now
            if (!xhr.readyState) {
                xhr.open('POST', url, true);
            }
        }
        catch (e) {
            // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS
            logger_1.logger.error('Error setting up key-system license XHR', e);
            this.hls.trigger(events_1.default.ERROR, {
                type: errors_1.ErrorTypes.KEY_SYSTEM_ERROR,
                details: errors_1.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                fatal: true
            });
            return;
        }
        xhr.responseType = 'arraybuffer';
        xhr.onreadystatechange =
            this._onLicenseRequestReadyStageChange.bind(this, xhr, url, keyMessage, callback);
        return xhr;
    };
    /**
       * @param {XMLHttpRequest} xhr
       * @param {string} url License server URL
       * @param {ArrayBuffer} keyMessage Message data issued by key-system
       * @param {function} callback Called when XHR has succeeded
       *
       */
    EMEController.prototype._onLicenseRequestReadyStageChange = function (xhr, url, keyMessage, callback) {
        switch (xhr.readyState) {
            case 4:
                if (xhr.status === 200) {
                    this._requestLicenseFailureCount = 0;
                    logger_1.logger.log('License request succeeded');
                    callback(xhr.response);
                }
                else {
                    logger_1.logger.error("License Request XHR failed (" + url + "). Status: " + xhr.status + " (" + xhr.statusText + ")");
                    this._requestLicenseFailureCount++;
                    if (this._requestLicenseFailureCount <= MAX_LICENSE_REQUEST_FAILURES) {
                        var attemptsLeft = MAX_LICENSE_REQUEST_FAILURES - this._requestLicenseFailureCount + 1;
                        logger_1.logger.warn("Retrying license request, " + attemptsLeft + " attempts left");
                        this._requestLicense(keyMessage, callback);
                        return;
                    }
                    this.hls.trigger(events_1.default.ERROR, {
                        type: errors_1.ErrorTypes.KEY_SYSTEM_ERROR,
                        details: errors_1.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                        fatal: true
                    });
                }
                break;
        }
    };
    /**
       * @param {object} keysListItem
       * @param {ArrayBuffer} keyMessage
       * @returns {ArrayBuffer} Challenge data posted to license server
       */
    EMEController.prototype._generateLicenseRequestChallenge = function (keysListItem, keyMessage) {
        var challenge;
        if (keysListItem.mediaKeySystemDomain === KeySystems.PLAYREADY) {
            logger_1.logger.error('PlayReady is not supported (yet)');
            // from https://github.com/MicrosoftEdge/Demos/blob/master/eme/scripts/demo.js
            /*
              if (this.licenseType !== this.LICENSE_TYPE_WIDEVINE) {
                  // For PlayReady CDMs, we need to dig the Challenge out of the XML.
                  var keyMessageXml = new DOMParser().parseFromString(String.fromCharCode.apply(null, new Uint16Array(keyMessage)), 'application/xml');
                  if (keyMessageXml.getElementsByTagName('Challenge')[0]) {
                      challenge = atob(keyMessageXml.getElementsByTagName('Challenge')[0].childNodes[0].nodeValue);
                  } else {
                      throw 'Cannot find <Challenge> in key message';
                  }
                  var headerNames = keyMessageXml.getElementsByTagName('name');
                  var headerValues = keyMessageXml.getElementsByTagName('value');
                  if (headerNames.length !== headerValues.length) {
                      throw 'Mismatched header <name>/<value> pair in key message';
                  }
                  for (var i = 0; i < headerNames.length; i++) {
                      xhr.setRequestHeader(headerNames[i].childNodes[0].nodeValue, headerValues[i].childNodes[0].nodeValue);
                  }
              }
              */
        }
        else if (keysListItem.mediaKeySystemDomain === KeySystems.WIDEVINE) {
            // For Widevine CDMs, the challenge is the keyMessage.
            challenge = keyMessage;
        }
        else {
            logger_1.logger.error('Unsupported key-system:', keysListItem.mediaKeySystemDomain);
        }
        return challenge;
    };
    EMEController.prototype._requestLicense = function (keyMessage, callback) {
        logger_1.logger.log('Requesting content license for key-system');
        var keysListItem = this._mediaKeysList[0];
        if (!keysListItem) {
            logger_1.logger.error('Fatal error: Media is encrypted but no key-system access has been obtained yet');
            this.hls.trigger(events_1.default.ERROR, {
                type: errors_1.ErrorTypes.KEY_SYSTEM_ERROR,
                details: errors_1.ErrorDetails.KEY_SYSTEM_NO_ACCESS,
                fatal: true
            });
            return;
        }
        var url = this.getLicenseServerUrl(keysListItem.mediaKeySystemDomain);
        var xhr = this._createLicenseXhr(url, keyMessage, callback);
        logger_1.logger.log("Sending license request to URL: " + url);
        xhr.send(this._generateLicenseRequestChallenge(keysListItem, keyMessage));
    };
    EMEController.prototype.onMediaAttached = function (data) {
        var _this = this;
        if (!this._emeEnabled) {
            return;
        }
        var media = data.media;
        // keep reference of media
        this._media = media;
        // FIXME: also handle detaching media !
        media.addEventListener('encrypted', function (e) {
            _this._onMediaEncrypted(e.initDataType, e.initData);
        });
    };
    EMEController.prototype.onManifestParsed = function (data) {
        if (!this._emeEnabled) {
            return;
        }
        var audioCodecs = data.levels.map(function (level) { return level.audioCodec; });
        var videoCodecs = data.levels.map(function (level) { return level.videoCodec; });
        this._attemptKeySystemAccess(KeySystems.WIDEVINE, audioCodecs, videoCodecs);
    };
    return EMEController;
}(event_handler_1.default));
exports.default = EMEController;


/***/ }),

/***/ "./src/controller/fps-controller.js":
/*!******************************************!*\
  !*** ./src/controller/fps-controller.js ***!
  \******************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * FPS Controller
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var event_handler_1 = __webpack_require__(/*! ../event-handler */ "./src/event-handler.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var performance = window.performance;
var FPSController = /** @class */ (function (_super) {
    __extends(FPSController, _super);
    function FPSController(hls) {
        return _super.call(this, hls, events_1.default.MEDIA_ATTACHING) || this;
    }
    FPSController.prototype.destroy = function () {
        if (this.timer) {
            clearInterval(this.timer);
        }
        this.isVideoPlaybackQualityAvailable = false;
    };
    FPSController.prototype.onMediaAttaching = function (data) {
        var config = this.hls.config;
        if (config.capLevelOnFPSDrop) {
            var video_1 = this.video = data.media instanceof window.HTMLVideoElement ? data.media : null;
            if (typeof video_1.getVideoPlaybackQuality === 'function') {
                this.isVideoPlaybackQualityAvailable = true;
            }
            clearInterval(this.timer);
            this.timer = setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);
        }
    };
    FPSController.prototype.checkFPS = function (video, decodedFrames, droppedFrames) {
        var currentTime = performance.now();
        if (decodedFrames) {
            if (this.lastTime) {
                var currentPeriod = currentTime - this.lastTime, currentDropped = droppedFrames - this.lastDroppedFrames, currentDecoded = decodedFrames - this.lastDecodedFrames, droppedFPS = 1000 * currentDropped / currentPeriod, hls_1 = this.hls;
                hls_1.trigger(events_1.default.FPS_DROP, { currentDropped: currentDropped, currentDecoded: currentDecoded, totalDroppedFrames: droppedFrames });
                if (droppedFPS > 0) {
                    // logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));
                    if (currentDropped > hls_1.config.fpsDroppedMonitoringThreshold * currentDecoded) {
                        var currentLevel = hls_1.currentLevel;
                        logger_1.logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);
                        if (currentLevel > 0 && (hls_1.autoLevelCapping === -1 || hls_1.autoLevelCapping >= currentLevel)) {
                            currentLevel = currentLevel - 1;
                            hls_1.trigger(events_1.default.FPS_DROP_LEVEL_CAPPING, { level: currentLevel, droppedLevel: hls_1.currentLevel });
                            hls_1.autoLevelCapping = currentLevel;
                            hls_1.streamController.nextLevelSwitch();
                        }
                    }
                }
            }
            this.lastTime = currentTime;
            this.lastDroppedFrames = droppedFrames;
            this.lastDecodedFrames = decodedFrames;
        }
    };
    FPSController.prototype.checkFPSInterval = function () {
        var video = this.video;
        if (video) {
            if (this.isVideoPlaybackQualityAvailable) {
                var videoPlaybackQuality = video.getVideoPlaybackQuality();
                this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
            }
            else {
                this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);
            }
        }
    };
    return FPSController;
}(event_handler_1.default));
exports.default = FPSController;


/***/ }),

/***/ "./src/controller/fragment-finders.js":
/*!********************************************!*\
  !*** ./src/controller/fragment-finders.js ***!
  \********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
Object.defineProperty(exports, "__esModule", { value: true });
var binary_search_1 = __webpack_require__(/*! ../utils/binary-search */ "./src/utils/binary-search.js");
/**
 * Returns first fragment whose endPdt value exceeds the given PDT.
 * @param {Array<Fragment>} fragments - The array of candidate fragments
 * @param {number|null} [PDTValue = null] - The PDT value which must be exceeded
 * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start/end can be within in order to be considered contiguous
 * @returns {*|null} fragment - The best matching fragment
 */
function findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {
    if (!Array.isArray(fragments) || !fragments.length || !Number.isFinite(PDTValue)) {
        return null;
    }
    // if less than start
    if (PDTValue < fragments[0].programDateTime) {
        return null;
    }
    if (PDTValue >= fragments[fragments.length - 1].endProgramDateTime) {
        return null;
    }
    maxFragLookUpTolerance = maxFragLookUpTolerance || 0;
    for (var seg = 0; seg < fragments.length; ++seg) {
        var frag = fragments[seg];
        if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {
            return frag;
        }
    }
    return null;
}
exports.findFragmentByPDT = findFragmentByPDT;
/**
 * Finds a fragment based on the SN of the previous fragment; or based on the needs of the current buffer.
 * This method compensates for small buffer gaps by applying a tolerance to the start of any candidate fragment, thus
 * breaking any traps which would cause the same fragment to be continuously selected within a small range.
 * @param {*} fragPrevious - The last frag successfully appended
 * @param {Array<Fragment>} fragments - The array of candidate fragments
 * @param {number} [bufferEnd = 0] - The end of the contiguous buffered range the playhead is currently within
 * @param {number} maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous
 * @returns {*} foundFrag - The best matching fragment
 */
function findFragmentByPTS(fragPrevious, fragments, bufferEnd, maxFragLookUpTolerance) {
    if (bufferEnd === void 0) { bufferEnd = 0; }
    if (maxFragLookUpTolerance === void 0) { maxFragLookUpTolerance = 0; }
    var fragNext = fragPrevious ? fragments[fragPrevious.sn - fragments[0].sn + 1] : null;
    // Prefer the next fragment if it's within tolerance
    if (fragNext && !fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext)) {
        return fragNext;
    }
    return binary_search_1.default.search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));
}
exports.findFragmentByPTS = findFragmentByPTS;
/**
 * The test function used by the findFragmentBySn's BinarySearch to look for the best match to the current buffer conditions.
 * @param {*} candidate - The fragment to test
 * @param {number} [bufferEnd = 0] - The end of the current buffered range the playhead is currently within
 * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start can be within in order to be considered contiguous
 * @returns {number} - 0 if it matches, 1 if too low, -1 if too high
 */
function fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, candidate) {
    if (bufferEnd === void 0) { bufferEnd = 0; }
    if (maxFragLookUpTolerance === void 0) { maxFragLookUpTolerance = 0; }
    // offset should be within fragment boundary - config.maxFragLookUpTolerance
    // this is to cope with situations like
    // bufferEnd = 9.991
    // frag[Ø] : [0,10]
    // frag[1] : [10,20]
    // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
    //              frag start               frag start+duration
    //                  |-----------------------------|
    //              <--->                         <--->
    //  ...--------><-----------------------------><---------....
    // previous frag         matching fragment         next frag
    //  return -1             return 0                 return 1
    // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
    // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
    var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));
    if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
        return 1;
    }
    else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
        // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
        return -1;
    }
    return 0;
}
exports.fragmentWithinToleranceTest = fragmentWithinToleranceTest;
/**
 * The test function used by the findFragmentByPdt's BinarySearch to look for the best match to the current buffer conditions.
 * This function tests the candidate's program date time values, as represented in Unix time
 * @param {*} candidate - The fragment to test
 * @param {number} [pdtBufferEnd = 0] - The Unix time representing the end of the current buffered range
 * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start can be within in order to be considered contiguous
 * @returns {boolean} True if contiguous, false otherwise
 */
function pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {
    var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1000;
    return candidate.endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;
}
exports.pdtWithinToleranceTest = pdtWithinToleranceTest;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/controller/fragment-tracker.js":
/*!********************************************!*\
  !*** ./src/controller/fragment-tracker.js ***!
  \********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var event_handler_1 = __webpack_require__(/*! ../event-handler */ "./src/event-handler.js");
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
exports.FragmentState = {
    NOT_LOADED: 'NOT_LOADED',
    APPENDING: 'APPENDING',
    PARTIAL: 'PARTIAL',
    OK: 'OK'
};
var FragmentTracker = /** @class */ (function (_super) {
    __extends(FragmentTracker, _super);
    function FragmentTracker(hls) {
        var _this = _super.call(this, hls, events_1.default.BUFFER_APPENDED, events_1.default.FRAG_BUFFERED, events_1.default.FRAG_LOADED) || this;
        _this.bufferPadding = 0.2;
        _this.fragments = Object.create(null);
        _this.timeRanges = Object.create(null);
        _this.config = hls.config;
        return _this;
    }
    FragmentTracker.prototype.destroy = function () {
        this.fragments = null;
        this.timeRanges = null;
        this.config = null;
        event_handler_1.default.prototype.destroy.call(this);
        _super.prototype.destroy.call(this);
    };
    /**
     * Return a Fragment that match the position and levelType.
     * If not found any Fragment, return null
     * @param {number} position
     * @param {LevelType} levelType
     * @returns {Fragment|null}
     */
    FragmentTracker.prototype.getBufferedFrag = function (position, levelType) {
        var fragments = this.fragments;
        var bufferedFrags = Object.keys(fragments).filter(function (key) {
            var fragmentEntity = fragments[key];
            if (fragmentEntity.body.type !== levelType) {
                return false;
            }
            if (!fragmentEntity.buffered) {
                return false;
            }
            var frag = fragmentEntity.body;
            return frag.startPTS <= position && position <= frag.endPTS;
        });
        if (bufferedFrags.length === 0) {
            return null;
        }
        else {
            // https://github.com/video-dev/hls.js/pull/1545#discussion_r166229566
            var bufferedFragKey = bufferedFrags.pop();
            return fragments[bufferedFragKey].body;
        }
    };
    /**
     * Partial fragments effected by coded frame eviction will be removed
     * The browser will unload parts of the buffer to free up memory for new buffer data
     * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)
     * @param {String} elementaryStream The elementaryStream of media this is (eg. video/audio)
     * @param {TimeRanges} timeRange TimeRange object from a sourceBuffer
     */
    FragmentTracker.prototype.detectEvictedFragments = function (elementaryStream, timeRange) {
        var _this = this;
        var fragmentTimes, time;
        // Check if any flagged fragments have been unloaded
        Object.keys(this.fragments).forEach(function (key) {
            var fragmentEntity = _this.fragments[key];
            if (fragmentEntity.buffered === true) {
                var esData = fragmentEntity.range[elementaryStream];
                if (esData) {
                    fragmentTimes = esData.time;
                    for (var i = 0; i < fragmentTimes.length; i++) {
                        time = fragmentTimes[i];
                        if (_this.isTimeBuffered(time.startPTS, time.endPTS, timeRange) === false) {
                            // Unregister partial fragment as it needs to load again to be reused
                            _this.removeFragment(fragmentEntity.body);
                            break;
                        }
                    }
                }
            }
        });
    };
    /**
     * Checks if the fragment passed in is loaded in the buffer properly
     * Partially loaded fragments will be registered as a partial fragment
     * @param {Object} fragment Check the fragment against all sourceBuffers loaded
     */
    FragmentTracker.prototype.detectPartialFragments = function (fragment) {
        var _this = this;
        var fragKey = this.getFragmentKey(fragment);
        var fragmentEntity = this.fragments[fragKey];
        if (fragmentEntity) {
            fragmentEntity.buffered = true;
            Object.keys(this.timeRanges).forEach(function (elementaryStream) {
                if (fragment.hasElementaryStream(elementaryStream)) {
                    var timeRange = _this.timeRanges[elementaryStream];
                    // Check for malformed fragments
                    // Gaps need to be calculated for each elementaryStream
                    fragmentEntity.range[elementaryStream] = _this.getBufferedTimes(fragment.startPTS, fragment.endPTS, timeRange);
                }
            });
        }
    };
    FragmentTracker.prototype.getBufferedTimes = function (startPTS, endPTS, timeRange) {
        var fragmentTimes = [];
        var startTime, endTime;
        var fragmentPartial = false;
        for (var i = 0; i < timeRange.length; i++) {
            startTime = timeRange.start(i) - this.bufferPadding;
            endTime = timeRange.end(i) + this.bufferPadding;
            if (startPTS >= startTime && endPTS <= endTime) {
                // Fragment is entirely contained in buffer
                // No need to check the other timeRange times since it's completely playable
                fragmentTimes.push({
                    startPTS: Math.max(startPTS, timeRange.start(i)),
                    endPTS: Math.min(endPTS, timeRange.end(i))
                });
                break;
            }
            else if (startPTS < endTime && endPTS > startTime) {
                // Check for intersection with buffer
                // Get playable sections of the fragment
                fragmentTimes.push({
                    startPTS: Math.max(startPTS, timeRange.start(i)),
                    endPTS: Math.min(endPTS, timeRange.end(i))
                });
                fragmentPartial = true;
            }
            else if (endPTS <= startTime) {
                // No need to check the rest of the timeRange as it is in order
                break;
            }
        }
        return {
            time: fragmentTimes,
            partial: fragmentPartial
        };
    };
    FragmentTracker.prototype.getFragmentKey = function (fragment) {
        return fragment.type + "_" + fragment.level + "_" + fragment.urlId + "_" + fragment.sn;
    };
    /**
     * Gets the partial fragment for a certain time
     * @param {Number} time
     * @returns {Object} fragment Returns a partial fragment at a time or null if there is no partial fragment
     */
    FragmentTracker.prototype.getPartialFragment = function (time) {
        var _this = this;
        var timePadding, startTime, endTime;
        var bestFragment = null;
        var bestOverlap = 0;
        Object.keys(this.fragments).forEach(function (key) {
            var fragmentEntity = _this.fragments[key];
            if (_this.isPartial(fragmentEntity)) {
                startTime = fragmentEntity.body.startPTS - _this.bufferPadding;
                endTime = fragmentEntity.body.endPTS + _this.bufferPadding;
                if (time >= startTime && time <= endTime) {
                    // Use the fragment that has the most padding from start and end time
                    timePadding = Math.min(time - startTime, endTime - time);
                    if (bestOverlap <= timePadding) {
                        bestFragment = fragmentEntity.body;
                        bestOverlap = timePadding;
                    }
                }
            }
        });
        return bestFragment;
    };
    /**
     * @param {Object} fragment The fragment to check
     * @returns {String} Returns the fragment state when a fragment never loaded or if it partially loaded
     */
    FragmentTracker.prototype.getState = function (fragment) {
        var fragKey = this.getFragmentKey(fragment);
        var fragmentEntity = this.fragments[fragKey];
        var state = exports.FragmentState.NOT_LOADED;
        if (fragmentEntity !== undefined) {
            if (!fragmentEntity.buffered) {
                state = exports.FragmentState.APPENDING;
            }
            else if (this.isPartial(fragmentEntity) === true) {
                state = exports.FragmentState.PARTIAL;
            }
            else {
                state = exports.FragmentState.OK;
            }
        }
        return state;
    };
    FragmentTracker.prototype.isPartial = function (fragmentEntity) {
        return fragmentEntity.buffered === true &&
            ((fragmentEntity.range.video !== undefined && fragmentEntity.range.video.partial === true) ||
                (fragmentEntity.range.audio !== undefined && fragmentEntity.range.audio.partial === true));
    };
    FragmentTracker.prototype.isTimeBuffered = function (startPTS, endPTS, timeRange) {
        var startTime, endTime;
        for (var i = 0; i < timeRange.length; i++) {
            startTime = timeRange.start(i) - this.bufferPadding;
            endTime = timeRange.end(i) + this.bufferPadding;
            if (startPTS >= startTime && endPTS <= endTime) {
                return true;
            }
            if (endPTS <= startTime) {
                // No need to check the rest of the timeRange as it is in order
                return false;
            }
        }
        return false;
    };
    /**
     * Fires when a fragment loading is completed
     */
    FragmentTracker.prototype.onFragLoaded = function (e) {
        var fragment = e.frag;
        // don't track initsegment (for which sn is not a number)
        // don't track frags used for bitrateTest, they're irrelevant.
        if (Number.isFinite(fragment.sn) && !fragment.bitrateTest) {
            this.fragments[this.getFragmentKey(fragment)] = {
                body: fragment,
                range: Object.create(null),
                buffered: false
            };
        }
    };
    /**
     * Fires when the buffer is updated
     */
    FragmentTracker.prototype.onBufferAppended = function (e) {
        var _this = this;
        // Store the latest timeRanges loaded in the buffer
        this.timeRanges = e.timeRanges;
        Object.keys(this.timeRanges).forEach(function (elementaryStream) {
            var timeRange = _this.timeRanges[elementaryStream];
            _this.detectEvictedFragments(elementaryStream, timeRange);
        });
    };
    /**
     * Fires after a fragment has been loaded into the source buffer
     */
    FragmentTracker.prototype.onFragBuffered = function (e) {
        this.detectPartialFragments(e.frag);
    };
    /**
     * Return true if fragment tracker has the fragment.
     * @param {Object} fragment
     * @returns {boolean}
     */
    FragmentTracker.prototype.hasFragment = function (fragment) {
        var fragKey = this.getFragmentKey(fragment);
        return this.fragments[fragKey] !== undefined;
    };
    /**
     * Remove a fragment from fragment tracker until it is loaded again
     * @param {Object} fragment The fragment to remove
     */
    FragmentTracker.prototype.removeFragment = function (fragment) {
        var fragKey = this.getFragmentKey(fragment);
        delete this.fragments[fragKey];
    };
    /**
     * Remove all fragments from fragment tracker.
     */
    FragmentTracker.prototype.removeAllFragments = function () {
        this.fragments = Object.create(null);
    };
    return FragmentTracker;
}(event_handler_1.default));
exports.FragmentTracker = FragmentTracker;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/controller/gap-controller.js":
/*!******************************************!*\
  !*** ./src/controller/gap-controller.js ***!
  \******************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var buffer_helper_1 = __webpack_require__(/*! ../utils/buffer-helper */ "./src/utils/buffer-helper.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var stallDebounceInterval = 1000;
var jumpThreshold = 0.5; // tolerance needed as some browsers stalls playback before reaching buffered range end
var GapController = /** @class */ (function () {
    function GapController(config, media, fragmentTracker, hls) {
        this.config = config;
        this.media = media;
        this.fragmentTracker = fragmentTracker;
        this.hls = hls;
        this.stallReported = false;
    }
    /**
     * Checks if the playhead is stuck within a gap, and if so, attempts to free it.
     * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).
     * @param lastCurrentTime
     * @param buffered
     */
    GapController.prototype.poll = function (lastCurrentTime, buffered) {
        var _a = this, config = _a.config, media = _a.media;
        var currentTime = media.currentTime;
        var tnow = window.performance.now();
        if (currentTime !== lastCurrentTime) {
            // The playhead is now moving, but was previously stalled
            if (this.stallReported) {
                logger_1.logger.warn("playback not stuck anymore @" + currentTime + ", after " + Math.round(tnow - this.stalled) + "ms");
                this.stallReported = false;
            }
            this.stalled = null;
            this.nudgeRetry = 0;
            return;
        }
        if (media.ended || !media.buffered.length || media.readyState > 2) {
            return;
        }
        if (media.seeking && buffer_helper_1.BufferHelper.isBuffered(media, currentTime)) {
            return;
        }
        // The playhead isn't moving but it should be
        // Allow some slack time to for small stalls to resolve themselves
        var stalledDuration = tnow - this.stalled;
        var bufferInfo = buffer_helper_1.BufferHelper.bufferInfo(media, currentTime, config.maxBufferHole);
        if (!this.stalled) {
            this.stalled = tnow;
            return;
        }
        else if (stalledDuration >= stallDebounceInterval) {
            // Report stalling after trying to fix
            this._reportStall(bufferInfo.len);
        }
        this._tryFixBufferStall(bufferInfo, stalledDuration);
    };
    /**
     * Detects and attempts to fix known buffer stalling issues.
     * @param bufferInfo - The properties of the current buffer.
     * @param stalledDuration - The amount of time Hls.js has been stalling for.
     * @private
     */
    GapController.prototype._tryFixBufferStall = function (bufferInfo, stalledDuration) {
        var _a = this, config = _a.config, fragmentTracker = _a.fragmentTracker, media = _a.media;
        var currentTime = media.currentTime;
        var partial = fragmentTracker.getPartialFragment(currentTime);
        if (partial) {
            // Try to skip over the buffer hole caused by a partial fragment
            // This method isn't limited by the size of the gap between buffered ranges
            this._trySkipBufferHole(partial);
        }
        if (bufferInfo.len > jumpThreshold && stalledDuration > config.highBufferWatchdogPeriod * 1000) {
            // Try to nudge currentTime over a buffer hole if we've been stalling for the configured amount of seconds
            // We only try to jump the hole if it's under the configured size
            // Reset stalled so to rearm watchdog timer
            this.stalled = null;
            this._tryNudgeBuffer();
        }
    };
    /**
     * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.
     * @param bufferLen - The playhead distance from the end of the current buffer segment.
     * @private
     */
    GapController.prototype._reportStall = function (bufferLen) {
        var _a = this, hls = _a.hls, media = _a.media, stallReported = _a.stallReported;
        if (!stallReported) {
            // Report stalled error once
            this.stallReported = true;
            logger_1.logger.warn("Playback stalling at @" + media.currentTime + " due to low buffer");
            hls.trigger(events_1.default.ERROR, {
                type: errors_1.ErrorTypes.MEDIA_ERROR,
                details: errors_1.ErrorDetails.BUFFER_STALLED_ERROR,
                fatal: false,
                buffer: bufferLen
            });
        }
    };
    /**
     * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments
     * @param partial - The partial fragment found at the current time (where playback is stalling).
     * @private
     */
    GapController.prototype._trySkipBufferHole = function (partial) {
        var _a = this, hls = _a.hls, media = _a.media;
        var currentTime = media.currentTime;
        var lastEndTime = 0;
        // Check if currentTime is between unbuffered regions of partial fragments
        for (var i = 0; i < media.buffered.length; i++) {
            var startTime = media.buffered.start(i);
            if (currentTime >= lastEndTime && currentTime < startTime) {
                media.currentTime = Math.max(startTime, media.currentTime + 0.1);
                logger_1.logger.warn("skipping hole, adjusting currentTime from " + currentTime + " to " + media.currentTime);
                this.stalled = null;
                hls.trigger(events_1.default.ERROR, {
                    type: errors_1.ErrorTypes.MEDIA_ERROR,
                    details: errors_1.ErrorDetails.BUFFER_SEEK_OVER_HOLE,
                    fatal: false,
                    reason: "fragment loaded with buffer holes, seeking from " + currentTime + " to " + media.currentTime,
                    frag: partial
                });
                return;
            }
            lastEndTime = media.buffered.end(i);
        }
    };
    /**
     * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.
     * @private
     */
    GapController.prototype._tryNudgeBuffer = function () {
        var _a = this, config = _a.config, hls = _a.hls, media = _a.media;
        var currentTime = media.currentTime;
        var nudgeRetry = (this.nudgeRetry || 0) + 1;
        this.nudgeRetry = nudgeRetry;
        if (nudgeRetry < config.nudgeMaxRetry) {
            var targetTime = currentTime + nudgeRetry * config.nudgeOffset;
            logger_1.logger.log("adjust currentTime from " + currentTime + " to " + targetTime);
            // playback stalled in buffered area ... let's nudge currentTime to try to overcome this
            media.currentTime = targetTime;
            hls.trigger(events_1.default.ERROR, {
                type: errors_1.ErrorTypes.MEDIA_ERROR,
                details: errors_1.ErrorDetails.BUFFER_NUDGE_ON_STALL,
                fatal: false
            });
        }
        else {
            logger_1.logger.error("still stuck in high buffer @" + currentTime + " after " + config.nudgeMaxRetry + ", raise fatal error");
            hls.trigger(events_1.default.ERROR, {
                type: errors_1.ErrorTypes.MEDIA_ERROR,
                details: errors_1.ErrorDetails.BUFFER_STALLED_ERROR,
                fatal: true
            });
        }
    };
    return GapController;
}());
exports.default = GapController;


/***/ }),

/***/ "./src/controller/id3-track-controller.js":
/*!************************************************!*\
  !*** ./src/controller/id3-track-controller.js ***!
  \************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * id3 metadata track controller
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var event_handler_1 = __webpack_require__(/*! ../event-handler */ "./src/event-handler.js");
var id3_1 = __webpack_require__(/*! ../demux/id3 */ "./src/demux/id3.js");
var texttrack_utils_1 = __webpack_require__(/*! ../utils/texttrack-utils */ "./src/utils/texttrack-utils.js");
var ID3TrackController = /** @class */ (function (_super) {
    __extends(ID3TrackController, _super);
    function ID3TrackController(hls) {
        var _this = _super.call(this, hls, events_1.default.MEDIA_ATTACHED, events_1.default.MEDIA_DETACHING, events_1.default.FRAG_PARSING_METADATA) || this;
        _this.id3Track = undefined;
        _this.media = undefined;
        return _this;
    }
    ID3TrackController.prototype.destroy = function () {
        event_handler_1.default.prototype.destroy.call(this);
    };
    // Add ID3 metatadata text track.
    ID3TrackController.prototype.onMediaAttached = function (data) {
        this.media = data.media;
        if (!this.media) {
        }
    };
    ID3TrackController.prototype.onMediaDetaching = function () {
        texttrack_utils_1.clearCurrentCues(this.id3Track);
        this.id3Track = undefined;
        this.media = undefined;
    };
    ID3TrackController.prototype.getID3Track = function (textTracks) {
        for (var i = 0; i < textTracks.length; i++) {
            var textTrack = textTracks[i];
            if (textTrack.kind === 'metadata' && textTrack.label === 'id3') {
                // send 'addtrack' when reusing the textTrack for metadata,
                // same as what we do for captions
                texttrack_utils_1.sendAddTrackEvent(textTrack, this.media);
                return textTrack;
            }
        }
        return this.media.addTextTrack('metadata', 'id3');
    };
    ID3TrackController.prototype.onFragParsingMetadata = function (data) {
        var fragment = data.frag;
        var samples = data.samples;
        // create track dynamically
        if (!this.id3Track) {
            this.id3Track = this.getID3Track(this.media.textTracks);
            this.id3Track.mode = 'hidden';
        }
        // Attempt to recreate Safari functionality by creating
        // WebKitDataCue objects when available and store the decoded
        // ID3 data in the value property of the cue
        var Cue = window.WebKitDataCue || window.VTTCue || window.TextTrackCue;
        for (var i = 0; i < samples.length; i++) {
            var frames_1 = id3_1.default.getID3Frames(samples[i].data);
            if (frames_1) {
                var startTime = samples[i].pts;
                var endTime = i < samples.length - 1 ? samples[i + 1].pts : fragment.endPTS;
                // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE
                if (startTime === endTime) {
                    endTime += 0.0001;
                }
                for (var j = 0; j < frames_1.length; j++) {
                    var frame = frames_1[j];
                    // Safari doesn't put the timestamp frame in the TextTrack
                    if (!id3_1.default.isTimeStampFrame(frame)) {
                        var cue = new Cue(startTime, endTime, '');
                        cue.value = frame;
                        this.id3Track.addCue(cue);
                    }
                }
            }
        }
    };
    return ID3TrackController;
}(event_handler_1.default));
exports.default = ID3TrackController;


/***/ }),

/***/ "./src/controller/level-controller.js":
/*!********************************************!*\
  !*** ./src/controller/level-controller.js ***!
  \********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Level Controller
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var event_handler_1 = __webpack_require__(/*! ../event-handler */ "./src/event-handler.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var codecs_1 = __webpack_require__(/*! ../utils/codecs */ "./src/utils/codecs.js");
var level_helper_1 = __webpack_require__(/*! ./level-helper */ "./src/controller/level-helper.js");
var performance = window.performance;
var chromeOrFirefox;
var LevelController = /** @class */ (function (_super) {
    __extends(LevelController, _super);
    function LevelController(hls) {
        var _this = _super.call(this, hls, events_1.default.MANIFEST_LOADED, events_1.default.LEVEL_LOADED, events_1.default.AUDIO_TRACK_SWITCHED, events_1.default.FRAG_LOADED, events_1.default.ERROR) || this;
        _this.canload = false;
        _this.currentLevelIndex = null;
        _this.manualLevelIndex = -1;
        _this.timer = null;
        chromeOrFirefox = /chrome|firefox/.test(navigator.userAgent.toLowerCase());
        return _this;
    }
    LevelController.prototype.onHandlerDestroying = function () {
        this.clearTimer();
        this.manualLevelIndex = -1;
    };
    LevelController.prototype.clearTimer = function () {
        if (this.timer !== null) {
            clearTimeout(this.timer);
            this.timer = null;
        }
    };
    LevelController.prototype.startLoad = function () {
        var levels = this._levels;
        this.canload = true;
        this.levelRetryCount = 0;
        // clean up live level details to force reload them, and reset load errors
        if (levels) {
            levels.forEach(function (level) {
                level.loadError = 0;
                var levelDetails = level.details;
                if (levelDetails && levelDetails.live) {
                    level.details = undefined;
                }
            });
        }
        // speed up live playlist refresh if timer exists
        if (this.timer !== null) {
            this.loadLevel();
        }
    };
    LevelController.prototype.stopLoad = function () {
        this.canload = false;
    };
    LevelController.prototype.onManifestLoaded = function (data) {
        var levels = [];
        var audioTracks = [];
        var bitrateStart;
        var levelSet = {};
        var levelFromSet = null;
        var videoCodecFound = false;
        var audioCodecFound = false;
        // regroup redundant levels together
        data.levels.forEach(function (level) {
            var attributes = level.attrs;
            level.loadError = 0;
            level.fragmentError = false;
            videoCodecFound = videoCodecFound || !!level.videoCodec;
            audioCodecFound = audioCodecFound || !!level.audioCodec;
            // erase audio codec info if browser does not support mp4a.40.34.
            // demuxer will autodetect codec and fallback to mpeg/audio
            if (chromeOrFirefox && level.audioCodec && level.audioCodec.indexOf('mp4a.40.34') !== -1) {
                level.audioCodec = undefined;
            }
            levelFromSet = levelSet[level.bitrate]; // FIXME: we would also have to match the resolution here
            if (!levelFromSet) {
                level.url = [level.url];
                level.urlId = 0;
                levelSet[level.bitrate] = level;
                levels.push(level);
            }
            else {
                levelFromSet.url.push(level.url);
            }
            if (attributes) {
                if (attributes.AUDIO) {
                    audioCodecFound = true;
                    level_helper_1.addGroupId(levelFromSet || level, 'audio', attributes.AUDIO);
                }
                if (attributes.SUBTITLES) {
                    level_helper_1.addGroupId(levelFromSet || level, 'text', attributes.SUBTITLES);
                }
            }
        });
        // remove audio-only level if we also have levels with audio+video codecs signalled
        if (videoCodecFound && audioCodecFound) {
            levels = levels.filter(function (_a) {
                var videoCodec = _a.videoCodec;
                return !!videoCodec;
            });
        }
        // only keep levels with supported audio/video codecs
        levels = levels.filter(function (_a) {
            var audioCodec = _a.audioCodec, videoCodec = _a.videoCodec;
            return (!audioCodec || codecs_1.isCodecSupportedInMp4(audioCodec, 'audio')) && (!videoCodec || codecs_1.isCodecSupportedInMp4(videoCodec, 'video'));
        });
        if (data.audioTracks) {
            audioTracks = data.audioTracks.filter(function (track) { return !track.audioCodec || codecs_1.isCodecSupportedInMp4(track.audioCodec, 'audio'); });
            // Reassign id's after filtering since they're used as array indices
            audioTracks.forEach(function (track, index) {
                track.id = index;
            });
        }
        if (levels.length > 0) {
            // start bitrate is the first bitrate of the manifest
            bitrateStart = levels[0].bitrate;
            // sort level on bitrate
            levels.sort(function (a, b) { return a.bitrate - b.bitrate; });
            this._levels = levels;
            // find index of first level in sorted levels
            for (var i = 0; i < levels.length; i++) {
                if (levels[i].bitrate === bitrateStart) {
                    this._firstLevel = i;
                    logger_1.logger.log("manifest loaded," + levels.length + " level(s) found, first bitrate:" + bitrateStart);
                    break;
                }
            }
            // Audio is only alternate if manifest include a URI along with the audio group tag
            this.hls.trigger(events_1.default.MANIFEST_PARSED, {
                levels: levels,
                audioTracks: audioTracks,
                firstLevel: this._firstLevel,
                stats: data.stats,
                audio: audioCodecFound,
                video: videoCodecFound,
                altAudio: audioTracks.some(function (t) { return !!t.url; })
            });
        }
        else {
            this.hls.trigger(events_1.default.ERROR, {
                type: errors_1.ErrorTypes.MEDIA_ERROR,
                details: errors_1.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
                fatal: true,
                url: this.hls.url,
                reason: 'no level with compatible codecs found in manifest'
            });
        }
    };
    Object.defineProperty(LevelController.prototype, "levels", {
        get: function () {
            return this._levels;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LevelController.prototype, "level", {
        get: function () {
            return this.currentLevelIndex;
        },
        set: function (newLevel) {
            var levels = this._levels;
            if (levels) {
                newLevel = Math.min(newLevel, levels.length - 1);
                if (this.currentLevelIndex !== newLevel || !levels[newLevel].details) {
                    this.setLevelInternal(newLevel);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    LevelController.prototype.setLevelInternal = function (newLevel) {
        var levels = this._levels;
        var hls = this.hls;
        // check if level idx is valid
        if (newLevel >= 0 && newLevel < levels.length) {
            // stopping live reloading timer if any
            this.clearTimer();
            if (this.currentLevelIndex !== newLevel) {
                logger_1.logger.log("switching to level " + newLevel);
                this.currentLevelIndex = newLevel;
                var levelProperties = levels[newLevel];
                levelProperties.level = newLevel;
                hls.trigger(events_1.default.LEVEL_SWITCHING, levelProperties);
            }
            var level = levels[newLevel];
            var levelDetails = level.details;
            // check if we need to load playlist for this level
            if (!levelDetails || levelDetails.live) {
                // level not retrieved yet, or live playlist we need to (re)load it
                var urlId = level.urlId;
                hls.trigger(events_1.default.LEVEL_LOADING, { url: level.url[urlId], level: newLevel, id: urlId });
            }
        }
        else {
            // invalid level id given, trigger error
            hls.trigger(events_1.default.ERROR, {
                type: errors_1.ErrorTypes.OTHER_ERROR,
                details: errors_1.ErrorDetails.LEVEL_SWITCH_ERROR,
                level: newLevel,
                fatal: false,
                reason: 'invalid level idx'
            });
        }
    };
    Object.defineProperty(LevelController.prototype, "manualLevel", {
        get: function () {
            return this.manualLevelIndex;
        },
        set: function (newLevel) {
            this.manualLevelIndex = newLevel;
            if (this._startLevel === undefined) {
                this._startLevel = newLevel;
            }
            if (newLevel !== -1) {
                this.level = newLevel;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LevelController.prototype, "firstLevel", {
        get: function () {
            return this._firstLevel;
        },
        set: function (newLevel) {
            this._firstLevel = newLevel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LevelController.prototype, "startLevel", {
        get: function () {
            // hls.startLevel takes precedence over config.startLevel
            // if none of these values are defined, fallback on this._firstLevel (first quality level appearing in variant manifest)
            if (this._startLevel === undefined) {
                var configStartLevel = this.hls.config.startLevel;
                if (configStartLevel !== undefined) {
                    return configStartLevel;
                }
                else {
                    return this._firstLevel;
                }
            }
            else {
                return this._startLevel;
            }
        },
        set: function (newLevel) {
            this._startLevel = newLevel;
        },
        enumerable: true,
        configurable: true
    });
    LevelController.prototype.onError = function (data) {
        if (data.fatal) {
            if (data.type === errors_1.ErrorTypes.NETWORK_ERROR) {
                this.clearTimer();
            }
            return;
        }
        var levelError = false, fragmentError = false;
        var levelIndex;
        // try to recover not fatal errors
        switch (data.details) {
            case errors_1.ErrorDetails.FRAG_LOAD_ERROR:
            case errors_1.ErrorDetails.FRAG_LOAD_TIMEOUT:
            case errors_1.ErrorDetails.KEY_LOAD_ERROR:
            case errors_1.ErrorDetails.KEY_LOAD_TIMEOUT:
                levelIndex = data.frag.level;
                fragmentError = true;
                break;
            case errors_1.ErrorDetails.LEVEL_LOAD_ERROR:
            case errors_1.ErrorDetails.LEVEL_LOAD_TIMEOUT:
                levelIndex = data.context.level;
                levelError = true;
                break;
            case errors_1.ErrorDetails.REMUX_ALLOC_ERROR:
                levelIndex = data.level;
                levelError = true;
                break;
        }
        if (levelIndex !== undefined) {
            this.recoverLevel(data, levelIndex, levelError, fragmentError);
        }
    };
    /**
     * Switch to a redundant stream if any available.
     * If redundant stream is not available, emergency switch down if ABR mode is enabled.
     *
     * @param {Object} errorEvent
     * @param {Number} levelIndex current level index
     * @param {Boolean} levelError
     * @param {Boolean} fragmentError
     */
    // FIXME Find a better abstraction where fragment/level retry management is well decoupled
    LevelController.prototype.recoverLevel = function (errorEvent, levelIndex, levelError, fragmentError) {
        var _this = this;
        var config = this.hls.config;
        var errorDetails = errorEvent.details;
        var level = this._levels[levelIndex];
        var redundantLevels, delay, nextLevel;
        level.loadError++;
        level.fragmentError = fragmentError;
        if (levelError) {
            if ((this.levelRetryCount + 1) <= config.levelLoadingMaxRetry) {
                // exponential backoff capped to max retry timeout
                delay = Math.min(Math.pow(2, this.levelRetryCount) * config.levelLoadingRetryDelay, config.levelLoadingMaxRetryTimeout);
                // Schedule level reload
                this.timer = setTimeout(function () { return _this.loadLevel(); }, delay);
                // boolean used to inform stream controller not to switch back to IDLE on non fatal error
                errorEvent.levelRetry = true;
                this.levelRetryCount++;
                logger_1.logger.warn("level controller, " + errorDetails + ", retry in " + delay + " ms, current retry count is " + this.levelRetryCount);
            }
            else {
                logger_1.logger.error("level controller, cannot recover from " + errorDetails + " error");
                this.currentLevelIndex = null;
                // stopping live reloading timer if any
                this.clearTimer();
                // switch error to fatal
                errorEvent.fatal = true;
                return;
            }
        }
        // Try any redundant streams if available for both errors: level and fragment
        // If level.loadError reaches redundantLevels it means that we tried them all, no hope  => let's switch down
        if (levelError || fragmentError) {
            redundantLevels = level.url.length;
            if (redundantLevels > 1 && level.loadError < redundantLevels) {
                level.urlId = (level.urlId + 1) % redundantLevels;
                level.details = undefined;
                logger_1.logger.warn("level controller, " + errorDetails + " for level " + levelIndex + ": switching to redundant URL-id " + level.urlId);
                // console.log('Current audio track group ID:', this.hls.audioTracks[this.hls.audioTrack].groupId);
                // console.log('New video quality level audio group id:', level.attrs.AUDIO);
            }
            else {
                // Search for available level
                if (this.manualLevelIndex === -1) {
                    // When lowest level has been reached, let's start hunt from the top
                    nextLevel = (levelIndex === 0) ? this._levels.length - 1 : levelIndex - 1;
                    logger_1.logger.warn("level controller, " + errorDetails + ": switch to " + nextLevel);
                    this.hls.nextAutoLevel = this.currentLevelIndex = nextLevel;
                }
                else if (fragmentError) {
                    // Allow fragment retry as long as configuration allows.
                    // reset this._level so that another call to set level() will trigger again a frag load
                    logger_1.logger.warn("level controller, " + errorDetails + ": reload a fragment");
                    this.currentLevelIndex = null;
                }
            }
        }
    };
    // reset errors on the successful load of a fragment
    LevelController.prototype.onFragLoaded = function (_a) {
        var frag = _a.frag;
        if (frag !== undefined && frag.type === 'main') {
            var level = this._levels[frag.level];
            if (level !== undefined) {
                level.fragmentError = false;
                level.loadError = 0;
                this.levelRetryCount = 0;
            }
        }
    };
    LevelController.prototype.onLevelLoaded = function (data) {
        var _this = this;
        var levelId = data.level;
        // only process level loaded events matching with expected level
        if (levelId !== this.currentLevelIndex) {
            return;
        }
        var curLevel = this._levels[levelId];
        // reset level load error counter on successful level loaded only if there is no issues with fragments
        if (!curLevel.fragmentError) {
            curLevel.loadError = 0;
            this.levelRetryCount = 0;
        }
        var newDetails = data.details;
        // if current playlist is a live playlist, arm a timer to reload it
        if (newDetails.live) {
            var targetdurationMs = 1000 * (newDetails.averagetargetduration ? newDetails.averagetargetduration : newDetails.targetduration);
            var reloadInterval = targetdurationMs, curDetails = curLevel.details;
            if (curDetails && newDetails.endSN === curDetails.endSN) {
                // follow HLS Spec, If the client reloads a Playlist file and finds that it has not
                // changed then it MUST wait for a period of one-half the target
                // duration before retrying.
                reloadInterval /= 2;
                logger_1.logger.log('same live playlist, reload twice faster');
            }
            // decrement reloadInterval with level loading delay
            reloadInterval -= performance.now() - data.stats.trequest;
            // in any case, don't reload more than half of target duration
            reloadInterval = Math.max(targetdurationMs / 2, Math.round(reloadInterval));
            logger_1.logger.log("live playlist, reload in " + Math.round(reloadInterval) + " ms");
            this.timer = setTimeout(function () { return _this.loadLevel(); }, reloadInterval);
        }
        else {
            this.clearTimer();
        }
    };
    LevelController.prototype.onAudioTrackSwitched = function (data) {
        var audioGroupId = this.hls.audioTracks[data.id].groupId;
        var currentLevel = this.hls.levels[this.currentLevelIndex];
        if (!currentLevel) {
            return;
        }
        if (currentLevel.audioGroupIds) {
            var urlId = currentLevel.audioGroupIds.findIndex(function (groupId) { return groupId === audioGroupId; });
            if (urlId !== currentLevel.urlId) {
                currentLevel.urlId = urlId;
                this.startLoad();
            }
        }
    };
    LevelController.prototype.loadLevel = function () {
        logger_1.logger.debug('call to loadLevel');
        if (this.currentLevelIndex !== null && this.canload) {
            var levelObject = this._levels[this.currentLevelIndex];
            if (typeof levelObject === 'object' &&
                levelObject.url.length > 0) {
                var level = this.currentLevelIndex;
                var id = levelObject.urlId;
                var url = levelObject.url[id];
                logger_1.logger.log("Attempt loading level index " + level + " with URL-id " + id);
                // console.log('Current audio track group ID:', this.hls.audioTracks[this.hls.audioTrack].groupId);
                // console.log('New video quality level audio group id:', levelObject.attrs.AUDIO, level);
                this.hls.trigger(events_1.default.LEVEL_LOADING, { url: url, level: level, id: id });
            }
        }
    };
    Object.defineProperty(LevelController.prototype, "nextLoadLevel", {
        get: function () {
            if (this.manualLevelIndex !== -1) {
                return this.manualLevelIndex;
            }
            else {
                return this.hls.nextAutoLevel;
            }
        },
        set: function (nextLevel) {
            this.level = nextLevel;
            if (this.manualLevelIndex === -1) {
                this.hls.nextAutoLevel = nextLevel;
            }
        },
        enumerable: true,
        configurable: true
    });
    return LevelController;
}(event_handler_1.default));
exports.default = LevelController;


/***/ }),

/***/ "./src/controller/level-helper.js":
/*!****************************************!*\
  !*** ./src/controller/level-helper.js ***!
  \****************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
/**
 * @module LevelHelper
 *
 * Providing methods dealing with playlist sliding and drift
 *
 * TODO: Create an actual `Level` class/model that deals with all this logic in an object-oriented-manner.
 *
 * */
Object.defineProperty(exports, "__esModule", { value: true });
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
function addGroupId(level, type, id) {
    switch (type) {
        case 'audio':
            if (!level.audioGroupIds) {
                level.audioGroupIds = [];
            }
            level.audioGroupIds.push(id);
            break;
        case 'text':
            if (!level.textGroupIds) {
                level.textGroupIds = [];
            }
            level.textGroupIds.push(id);
            break;
    }
}
exports.addGroupId = addGroupId;
function updatePTS(fragments, fromIdx, toIdx) {
    var fragFrom = fragments[fromIdx], fragTo = fragments[toIdx], fragToPTS = fragTo.startPTS;
    // if we know startPTS[toIdx]
    if (Number.isFinite(fragToPTS)) {
        // update fragment duration.
        // it helps to fix drifts between playlist reported duration and fragment real duration
        if (toIdx > fromIdx) {
            fragFrom.duration = fragToPTS - fragFrom.start;
            if (fragFrom.duration < 0) {
                logger_1.logger.warn("negative duration computed for frag " + fragFrom.sn + ",level " + fragFrom.level + ", there should be some duration drift between playlist and fragment!");
            }
        }
        else {
            fragTo.duration = fragFrom.start - fragToPTS;
            if (fragTo.duration < 0) {
                logger_1.logger.warn("negative duration computed for frag " + fragTo.sn + ",level " + fragTo.level + ", there should be some duration drift between playlist and fragment!");
            }
        }
    }
    else {
        // we dont know startPTS[toIdx]
        if (toIdx > fromIdx) {
            fragTo.start = fragFrom.start + fragFrom.duration;
        }
        else {
            fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);
        }
    }
}
exports.updatePTS = updatePTS;
function updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {
    // update frag PTS/DTS
    var maxStartPTS = startPTS;
    if (Number.isFinite(frag.startPTS)) {
        // delta PTS between audio and video
        var deltaPTS = Math.abs(frag.startPTS - startPTS);
        if (!Number.isFinite(frag.deltaPTS)) {
            frag.deltaPTS = deltaPTS;
        }
        else {
            frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
        }
        maxStartPTS = Math.max(startPTS, frag.startPTS);
        startPTS = Math.min(startPTS, frag.startPTS);
        endPTS = Math.max(endPTS, frag.endPTS);
        startDTS = Math.min(startDTS, frag.startDTS);
        endDTS = Math.max(endDTS, frag.endDTS);
    }
    var drift = startPTS - frag.start;
    frag.start = frag.startPTS = startPTS;
    frag.maxStartPTS = maxStartPTS;
    frag.endPTS = endPTS;
    frag.startDTS = startDTS;
    frag.endDTS = endDTS;
    frag.duration = endPTS - startPTS;
    var sn = frag.sn;
    // exit if sn out of range
    if (!details || sn < details.startSN || sn > details.endSN) {
        return 0;
    }
    var fragIdx, fragments, i;
    fragIdx = sn - details.startSN;
    fragments = details.fragments;
    // update frag reference in fragments array
    // rationale is that fragments array might not contain this frag object.
    // this will happen if playlist has been refreshed between frag loading and call to updateFragPTSDTS()
    // if we don't update frag, we won't be able to propagate PTS info on the playlist
    // resulting in invalid sliding computation
    fragments[fragIdx] = frag;
    // adjust fragment PTS/duration from seqnum-1 to frag 0
    for (i = fragIdx; i > 0; i--) {
        updatePTS(fragments, i, i - 1);
    }
    // adjust fragment PTS/duration from seqnum to last frag
    for (i = fragIdx; i < fragments.length - 1; i++) {
        updatePTS(fragments, i, i + 1);
    }
    details.PTSKnown = true;
    return drift;
}
exports.updateFragPTSDTS = updateFragPTSDTS;
function mergeDetails(oldDetails, newDetails) {
    var start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN, end = Math.min(oldDetails.endSN, newDetails.endSN) - newDetails.startSN, delta = newDetails.startSN - oldDetails.startSN, oldfragments = oldDetails.fragments, newfragments = newDetails.fragments, ccOffset = 0, PTSFrag;
    // potentially retrieve cached initsegment
    if (newDetails.initSegment && oldDetails.initSegment) {
        newDetails.initSegment = oldDetails.initSegment;
    }
    // check if old/new playlists have fragments in common
    if (end < start) {
        newDetails.PTSKnown = false;
        return;
    }
    // loop through overlapping SN and update startPTS , cc, and duration if any found
    for (var i = start; i <= end; i++) {
        var oldFrag = oldfragments[delta + i], newFrag = newfragments[i];
        if (newFrag && oldFrag) {
            ccOffset = oldFrag.cc - newFrag.cc;
            if (Number.isFinite(oldFrag.startPTS)) {
                newFrag.start = newFrag.startPTS = oldFrag.startPTS;
                newFrag.endPTS = oldFrag.endPTS;
                newFrag.duration = oldFrag.duration;
                newFrag.backtracked = oldFrag.backtracked;
                newFrag.dropped = oldFrag.dropped;
                PTSFrag = newFrag;
            }
        }
    }
    if (ccOffset) {
        logger_1.logger.log('discontinuity sliding from playlist, take drift into account');
        for (i = 0; i < newfragments.length; i++) {
            newfragments[i].cc += ccOffset;
        }
    }
    // if at least one fragment contains PTS info, recompute PTS information for all fragments
    if (PTSFrag) {
        updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
    }
    else {
        // ensure that delta is within oldfragments range
        // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])
        // in that case we also need to adjust start offset of all fragments
        if (delta >= 0 && delta < oldfragments.length) {
            // adjust start by sliding offset
            var sliding = oldfragments[delta].start;
            for (i = 0; i < newfragments.length; i++) {
                newfragments[i].start += sliding;
            }
        }
    }
    // if we are here, it means we have fragments overlapping between
    // old and new level. reliable PTS info is thus relying on old level
    newDetails.PTSKnown = oldDetails.PTSKnown;
}
exports.mergeDetails = mergeDetails;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/controller/stream-controller.js":
/*!*********************************************!*\
  !*** ./src/controller/stream-controller.js ***!
  \*********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
/*
 * Stream Controller
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var binary_search_1 = __webpack_require__(/*! ../utils/binary-search */ "./src/utils/binary-search.js");
var buffer_helper_1 = __webpack_require__(/*! ../utils/buffer-helper */ "./src/utils/buffer-helper.js");
var demuxer_1 = __webpack_require__(/*! ../demux/demuxer */ "./src/demux/demuxer.js");
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var fragment_tracker_1 = __webpack_require__(/*! ./fragment-tracker */ "./src/controller/fragment-tracker.js");
var fragment_1 = __webpack_require__(/*! ../loader/fragment */ "./src/loader/fragment.js");
var playlist_loader_1 = __webpack_require__(/*! ../loader/playlist-loader */ "./src/loader/playlist-loader.js");
var LevelHelper = __webpack_require__(/*! ./level-helper */ "./src/controller/level-helper.js");
var time_ranges_1 = __webpack_require__(/*! ../utils/time-ranges */ "./src/utils/time-ranges.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var discontinuities_1 = __webpack_require__(/*! ../utils/discontinuities */ "./src/utils/discontinuities.js");
var fragment_finders_1 = __webpack_require__(/*! ./fragment-finders */ "./src/controller/fragment-finders.js");
var gap_controller_1 = __webpack_require__(/*! ./gap-controller */ "./src/controller/gap-controller.js");
var base_stream_controller_1 = __webpack_require__(/*! ./base-stream-controller */ "./src/controller/base-stream-controller.js");
var TICK_INTERVAL = 100; // how often to tick in ms
var StreamController = /** @class */ (function (_super) {
    __extends(StreamController, _super);
    function StreamController(hls, fragmentTracker) {
        var _this = _super.call(this, hls, events_1.default.MEDIA_ATTACHED, events_1.default.MEDIA_DETACHING, events_1.default.MANIFEST_LOADING, events_1.default.MANIFEST_PARSED, events_1.default.LEVEL_LOADED, events_1.default.KEY_LOADED, events_1.default.FRAG_LOADED, events_1.default.FRAG_LOAD_EMERGENCY_ABORTED, events_1.default.FRAG_PARSING_INIT_SEGMENT, events_1.default.FRAG_PARSING_DATA, events_1.default.FRAG_PARSED, events_1.default.ERROR, events_1.default.AUDIO_TRACK_SWITCHING, events_1.default.AUDIO_TRACK_SWITCHED, events_1.default.BUFFER_CREATED, events_1.default.BUFFER_APPENDED, events_1.default.BUFFER_FLUSHED) || this;
        _this.fragmentTracker = fragmentTracker;
        _this.config = hls.config;
        _this.audioCodecSwap = false;
        _this._state = base_stream_controller_1.State.STOPPED;
        _this.stallReported = false;
        _this.gapController = null;
        return _this;
    }
    StreamController.prototype.onHandlerDestroying = function () {
        this.stopLoad();
        _super.prototype.onHandlerDestroying.call(this);
    };
    StreamController.prototype.onHandlerDestroyed = function () {
        this.state = base_stream_controller_1.State.STOPPED;
        this.fragmentTracker = null;
        _super.prototype.onHandlerDestroyed.call(this);
    };
    StreamController.prototype.startLoad = function (startPosition) {
        if (this.levels) {
            var lastCurrentTime = this.lastCurrentTime, hls_1 = this.hls;
            this.stopLoad();
            this.setInterval(TICK_INTERVAL);
            this.level = -1;
            this.fragLoadError = 0;
            if (!this.startFragRequested) {
                // determine load level
                var startLevel = hls_1.startLevel;
                if (startLevel === -1) {
                    // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level
                    startLevel = 0;
                    this.bitrateTest = true;
                }
                // set new level to playlist loader : this will trigger start level load
                // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded
                this.level = hls_1.nextLoadLevel = startLevel;
                this.loadedmetadata = false;
            }
            // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime
            if (lastCurrentTime > 0 && startPosition === -1) {
                logger_1.logger.log("override startPosition with lastCurrentTime @" + lastCurrentTime.toFixed(3));
                startPosition = lastCurrentTime;
            }
            this.state = base_stream_controller_1.State.IDLE;
            this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
            this.tick();
        }
        else {
            this.forceStartLoad = true;
            this.state = base_stream_controller_1.State.STOPPED;
        }
    };
    StreamController.prototype.stopLoad = function () {
        var frag = this.fragCurrent;
        if (frag) {
            if (frag.loader) {
                frag.loader.abort();
            }
            this.fragmentTracker.removeFragment(frag);
            this.fragCurrent = null;
        }
        this.fragPrevious = null;
        if (this.demuxer) {
            this.demuxer.destroy();
            this.demuxer = null;
        }
        this.clearInterval();
        this.state = base_stream_controller_1.State.STOPPED;
        this.forceStartLoad = false;
    };
    StreamController.prototype.doTick = function () {
        switch (this.state) {
            case base_stream_controller_1.State.BUFFER_FLUSHING:
                // in buffer flushing state, reset fragLoadError counter
                this.fragLoadError = 0;
                break;
            case base_stream_controller_1.State.IDLE:
                this._doTickIdle();
                break;
            case base_stream_controller_1.State.WAITING_LEVEL:
                var level = this.levels[this.level];
                // check if playlist is already loaded
                if (level && level.details) {
                    this.state = base_stream_controller_1.State.IDLE;
                }
                break;
            case base_stream_controller_1.State.FRAG_LOADING_WAITING_RETRY:
                var now = window.performance.now();
                var retryDate = this.retryDate;
                // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
                if (!retryDate || (now >= retryDate) || (this.media && this.media.seeking)) {
                    logger_1.logger.log('mediaController: retryDate reached, switch back to IDLE state');
                    this.state = base_stream_controller_1.State.IDLE;
                }
                break;
            case base_stream_controller_1.State.ERROR:
            case base_stream_controller_1.State.STOPPED:
            case base_stream_controller_1.State.FRAG_LOADING:
            case base_stream_controller_1.State.PARSING:
            case base_stream_controller_1.State.PARSED:
            case base_stream_controller_1.State.ENDED:
                break;
            default:
                break;
        }
        // check buffer
        this._checkBuffer();
        // check/update current fragment
        this._checkFragmentChanged();
    };
    // Ironically the "idle" state is the on we do the most logic in it seems ....
    // NOTE: Maybe we could rather schedule a check for buffer length after half of the currently
    //       played segment, or on pause/play/seek instead of naively checking every 100ms?
    StreamController.prototype._doTickIdle = function () {
        var hls = this.hls, config = hls.config, media = this.media;
        // if start level not parsed yet OR
        // if video not attached AND start fragment already requested OR start frag prefetch disable
        // exit loop, as we either need more info (level not parsed) or we need media to be attached to load new fragment
        if (this.levelLastLoaded === undefined || (!media && (this.startFragRequested || !config.startFragPrefetch))) {
            return;
        }
        // if we have not yet loaded any fragment, start loading from start position
        var pos;
        if (this.loadedmetadata) {
            pos = media.currentTime;
        }
        else {
            pos = this.nextLoadPosition;
        }
        // determine next load level
        var level = hls.nextLoadLevel, levelInfo = this.levels[level];
        if (!levelInfo) {
            return;
        }
        var levelBitrate = levelInfo.bitrate, maxBufLen;
        // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s
        if (levelBitrate) {
            maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);
        }
        else {
            maxBufLen = config.maxBufferLength;
        }
        maxBufLen = Math.min(maxBufLen, config.maxMaxBufferLength);
        // determine next candidate fragment to be loaded, based on current position and end of buffer position
        // ensure up to `config.maxMaxBufferLength` of buffer upfront
        var bufferInfo = buffer_helper_1.BufferHelper.bufferInfo(this.mediaBuffer ? this.mediaBuffer : media, pos, config.maxBufferHole), bufferLen = bufferInfo.len;
        // Stay idle if we are still with buffer margins
        if (bufferLen >= maxBufLen) {
            return;
        }
        // if buffer length is less than maxBufLen try to load a new fragment ...
        logger_1.logger.trace("buffer length of " + bufferLen.toFixed(3) + " is below max of " + maxBufLen.toFixed(3) + ". checking for more payload ...");
        // set next load level : this will trigger a playlist load if needed
        this.level = hls.nextLoadLevel = level;
        var levelDetails = levelInfo.details;
        // if level info not retrieved yet, switch state and wait for level retrieval
        // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load
        // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)
        if (!levelDetails || (levelDetails.live && this.levelLastLoaded !== level)) {
            this.state = base_stream_controller_1.State.WAITING_LEVEL;
            return;
        }
        if (this._streamEnded(bufferInfo, levelDetails)) {
            var data = {};
            if (this.altAudio) {
                data.type = 'video';
            }
            this.hls.trigger(events_1.default.BUFFER_EOS, data);
            this.state = base_stream_controller_1.State.ENDED;
            return;
        }
        // if we have the levelDetails for the selected variant, lets continue enrichen our stream (load keys/fragments or trigger EOS, etc..)
        this._fetchPayloadOrEos(pos, bufferInfo, levelDetails);
    };
    StreamController.prototype._fetchPayloadOrEos = function (pos, bufferInfo, levelDetails) {
        var fragPrevious = this.fragPrevious, level = this.level, fragments = levelDetails.fragments, fragLen = fragments.length;
        // empty playlist
        if (fragLen === 0) {
            return;
        }
        // find fragment index, contiguous with end of buffer position
        var start = fragments[0].start, end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration, bufferEnd = bufferInfo.end, frag;
        if (levelDetails.initSegment && !levelDetails.initSegment.data) {
            frag = levelDetails.initSegment;
        }
        else {
            // in case of live playlist we need to ensure that requested position is not located before playlist start
            if (levelDetails.live) {
                var initialLiveManifestSize = this.config.initialLiveManifestSize;
                if (fragLen < initialLiveManifestSize) {
                    logger_1.logger.warn("Can not start playback of a level, reason: not enough fragments " + fragLen + " < " + initialLiveManifestSize);
                    return;
                }
                frag = this._ensureFragmentAtLivePoint(levelDetails, bufferEnd, start, end, fragPrevious, fragments, fragLen);
                // if it explicitely returns null don't load any fragment and exit function now
                if (frag === null) {
                    return;
                }
            }
            else {
                // VoD playlist: if bufferEnd before start of playlist, load first fragment
                if (bufferEnd < start) {
                    frag = fragments[0];
                }
            }
        }
        if (!frag) {
            frag = this._findFragment(start, fragPrevious, fragLen, fragments, bufferEnd, end, levelDetails);
        }
        if (frag) {
            if (frag.encrypted) {
                logger_1.logger.log("Loading key for " + frag.sn + " of [" + levelDetails.startSN + " ," + levelDetails.endSN + "],level " + level);
                this._loadKey(frag);
            }
            else {
                logger_1.logger.log("Loading " + frag.sn + " of [" + levelDetails.startSN + " ," + levelDetails.endSN + "],level " + level + ", currentTime:" + pos.toFixed(3) + ",bufferEnd:" + bufferEnd.toFixed(3));
                this._loadFragment(frag);
            }
        }
    };
    StreamController.prototype._ensureFragmentAtLivePoint = function (levelDetails, bufferEnd, start, end, fragPrevious, fragments, fragLen) {
        var config = this.hls.config, media = this.media;
        var frag;
        // check if requested position is within seekable boundaries :
        // logger.log(`start/pos/bufEnd/seeking:${start.toFixed(3)}/${pos.toFixed(3)}/${bufferEnd.toFixed(3)}/${this.media.seeking}`);
        var maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;
        if (bufferEnd < Math.max(start - config.maxFragLookUpTolerance, end - maxLatency)) {
            var liveSyncPosition = this.liveSyncPosition = this.computeLivePosition(start, levelDetails);
            logger_1.logger.log("buffer end: " + bufferEnd.toFixed(3) + " is located too far from the end of live sliding playlist, reset currentTime to : " + liveSyncPosition.toFixed(3));
            bufferEnd = liveSyncPosition;
            if (media && media.readyState && media.duration > liveSyncPosition) {
                media.currentTime = liveSyncPosition;
            }
            this.nextLoadPosition = liveSyncPosition;
        }
        // if end of buffer greater than live edge, don't load any fragment
        // this could happen if live playlist intermittently slides in the past.
        // level 1 loaded [182580161,182580167]
        // level 1 loaded [182580162,182580169]
        // Loading 182580168 of [182580162 ,182580169],level 1 ..
        // Loading 182580169 of [182580162 ,182580169],level 1 ..
        // level 1 loaded [182580162,182580168] <============= here we should have bufferEnd > end. in that case break to avoid reloading 182580168
        // level 1 loaded [182580164,182580171]
        //
        // don't return null in case media not loaded yet (readystate === 0)
        if (levelDetails.PTSKnown && bufferEnd > end && media && media.readyState) {
            return null;
        }
        if (this.startFragRequested && !levelDetails.PTSKnown) {
            /* we are switching level on live playlist, but we don't have any PTS info for that quality level ...
               try to load frag matching with next SN.
               even if SN are not synchronized between playlists, loading this frag will help us
               compute playlist sliding and find the right one after in case it was not the right consecutive one */
            if (fragPrevious) {
                if (levelDetails.hasProgramDateTime) {
                    // Relies on PDT in order to switch bitrates (Support EXT-X-DISCONTINUITY without EXT-X-DISCONTINUITY-SEQUENCE)
                    logger_1.logger.log("live playlist, switching playlist, load frag with same PDT: " + fragPrevious.programDateTime);
                    frag = fragment_finders_1.findFragmentByPDT(fragments, fragPrevious.endProgramDateTime, config.maxFragLookUpTolerance);
                }
                else {
                    // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)
                    var targetSN = fragPrevious.sn + 1;
                    if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {
                        var fragNext = fragments[targetSN - levelDetails.startSN];
                        if (fragPrevious.cc === fragNext.cc) {
                            frag = fragNext;
                            logger_1.logger.log("live playlist, switching playlist, load frag with next SN: " + frag.sn);
                        }
                    }
                    // next frag SN not available (or not with same continuity counter)
                    // look for a frag sharing the same CC
                    if (!frag) {
                        frag = binary_search_1.default.search(fragments, function (frag) {
                            return fragPrevious.cc - frag.cc;
                        });
                        if (frag) {
                            logger_1.logger.log("live playlist, switching playlist, load frag with same CC: " + frag.sn);
                        }
                    }
                }
            }
            if (!frag) {
                /* we have no idea about which fragment should be loaded.
                   so let's load mid fragment. it will help computing playlist sliding and find the right one
                */
                frag = fragments[Math.min(fragLen - 1, Math.round(fragLen / 2))];
                logger_1.logger.log("live playlist, switching playlist, unknown, load middle frag : " + frag.sn);
            }
        }
        return frag;
    };
    StreamController.prototype._findFragment = function (start, fragPrevious, fragLen, fragments, bufferEnd, end, levelDetails) {
        var config = this.hls.config;
        var frag;
        if (bufferEnd < end) {
            var lookupTolerance = (bufferEnd > end - config.maxFragLookUpTolerance) ? 0 : config.maxFragLookUpTolerance;
            // Remove the tolerance if it would put the bufferEnd past the actual end of stream
            // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)
            frag = fragment_finders_1.findFragmentByPTS(fragPrevious, fragments, bufferEnd, lookupTolerance);
        }
        else {
            // reach end of playlist
            frag = fragments[fragLen - 1];
        }
        if (frag) {
            var curSNIdx = frag.sn - levelDetails.startSN;
            var sameLevel = fragPrevious && frag.level === fragPrevious.level;
            var prevFrag = fragments[curSNIdx - 1];
            var nextFrag = fragments[curSNIdx + 1];
            // logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
            if (fragPrevious && frag.sn === fragPrevious.sn) {
                if (sameLevel && !frag.backtracked) {
                    if (frag.sn < levelDetails.endSN) {
                        var deltaPTS = fragPrevious.deltaPTS;
                        // if there is a significant delta between audio and video, larger than max allowed hole,
                        // and if previous remuxed fragment did not start with a keyframe. (fragPrevious.dropped)
                        // let's try to load previous fragment again to get last keyframe
                        // then we will reload again current fragment (that way we should be able to fill the buffer hole ...)
                        if (deltaPTS && deltaPTS > config.maxBufferHole && fragPrevious.dropped && curSNIdx) {
                            frag = prevFrag;
                            logger_1.logger.warn('SN just loaded, with large PTS gap between audio and video, maybe frag is not starting with a keyframe ? load previous one to try to overcome this');
                        }
                        else {
                            frag = nextFrag;
                            logger_1.logger.log("SN just loaded, load next one: " + frag.sn, frag);
                        }
                    }
                    else {
                        frag = null;
                    }
                }
                else if (frag.backtracked) {
                    // Only backtrack a max of 1 consecutive fragment to prevent sliding back too far when little or no frags start with keyframes
                    if (nextFrag && nextFrag.backtracked) {
                        logger_1.logger.warn("Already backtracked from fragment " + nextFrag.sn + ", will not backtrack to fragment " + frag.sn + ". Loading fragment " + nextFrag.sn);
                        frag = nextFrag;
                    }
                    else {
                        // If a fragment has dropped frames and it's in a same level/sequence, load the previous fragment to try and find the keyframe
                        // Reset the dropped count now since it won't be reset until we parse the fragment again, which prevents infinite backtracking on the same segment
                        logger_1.logger.warn('Loaded fragment with dropped frames, backtracking 1 segment to find a keyframe');
                        frag.dropped = 0;
                        if (prevFrag) {
                            frag = prevFrag;
                            frag.backtracked = true;
                        }
                        else if (curSNIdx) {
                            // can't backtrack on very first fragment
                            frag = null;
                        }
                    }
                }
            }
        }
        return frag;
    };
    StreamController.prototype._loadKey = function (frag) {
        this.state = base_stream_controller_1.State.KEY_LOADING;
        this.hls.trigger(events_1.default.KEY_LOADING, { frag: frag });
    };
    StreamController.prototype._loadFragment = function (frag) {
        // Check if fragment is not loaded
        var fragState = this.fragmentTracker.getState(frag);
        this.fragCurrent = frag;
        this.startFragRequested = true;
        // Don't update nextLoadPosition for fragments which are not buffered
        if (Number.isFinite(frag.sn) && !frag.bitrateTest) {
            this.nextLoadPosition = frag.start + frag.duration;
        }
        // Allow backtracked fragments to load
        if (frag.backtracked || fragState === fragment_tracker_1.FragmentState.NOT_LOADED || fragState === fragment_tracker_1.FragmentState.PARTIAL) {
            frag.autoLevel = this.hls.autoLevelEnabled;
            frag.bitrateTest = this.bitrateTest;
            this.hls.trigger(events_1.default.FRAG_LOADING, { frag: frag });
            // lazy demuxer init, as this could take some time ... do it during frag loading
            if (!this.demuxer) {
                this.demuxer = new demuxer_1.default(this.hls, 'main');
            }
            this.state = base_stream_controller_1.State.FRAG_LOADING;
        }
        else if (fragState === fragment_tracker_1.FragmentState.APPENDING) {
            // Lower the buffer size and try again
            if (this._reduceMaxBufferLength(frag.duration)) {
                this.fragmentTracker.removeFragment(frag);
            }
        }
    };
    Object.defineProperty(StreamController.prototype, "state", {
        get: function () {
            return this._state;
        },
        set: function (nextState) {
            if (this.state !== nextState) {
                var previousState = this.state;
                this._state = nextState;
                logger_1.logger.log("main stream:" + previousState + "->" + nextState);
                this.hls.trigger(events_1.default.STREAM_STATE_TRANSITION, { previousState: previousState, nextState: nextState });
            }
        },
        enumerable: true,
        configurable: true
    });
    StreamController.prototype.getBufferedFrag = function (position) {
        return this.fragmentTracker.getBufferedFrag(position, playlist_loader_1.default.LevelType.MAIN);
    };
    Object.defineProperty(StreamController.prototype, "currentLevel", {
        get: function () {
            var media = this.media;
            if (media) {
                var frag = this.getBufferedFrag(media.currentTime);
                if (frag) {
                    return frag.level;
                }
            }
            return -1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StreamController.prototype, "nextBufferedFrag", {
        get: function () {
            var media = this.media;
            if (media) {
                // first get end range of current fragment
                return this.followingBufferedFrag(this.getBufferedFrag(media.currentTime));
            }
            else {
                return null;
            }
        },
        enumerable: true,
        configurable: true
    });
    StreamController.prototype.followingBufferedFrag = function (frag) {
        if (frag) {
            // try to get range of next fragment (500ms after this range)
            return this.getBufferedFrag(frag.endPTS + 0.5);
        }
        return null;
    };
    Object.defineProperty(StreamController.prototype, "nextLevel", {
        get: function () {
            var frag = this.nextBufferedFrag;
            if (frag) {
                return frag.level;
            }
            else {
                return -1;
            }
        },
        enumerable: true,
        configurable: true
    });
    StreamController.prototype._checkFragmentChanged = function () {
        var fragPlayingCurrent, currentTime, video = this.media;
        if (video && video.readyState && video.seeking === false) {
            currentTime = video.currentTime;
            /* if video element is in seeked state, currentTime can only increase.
              (assuming that playback rate is positive ...)
              As sometimes currentTime jumps back to zero after a
              media decode error, check this, to avoid seeking back to
              wrong position after a media decode error
            */
            if (currentTime > this.lastCurrentTime) {
                this.lastCurrentTime = currentTime;
            }
            if (buffer_helper_1.BufferHelper.isBuffered(video, currentTime)) {
                fragPlayingCurrent = this.getBufferedFrag(currentTime);
            }
            else if (buffer_helper_1.BufferHelper.isBuffered(video, currentTime + 0.1)) {
                /* ensure that FRAG_CHANGED event is triggered at startup,
                  when first video frame is displayed and playback is paused.
                  add a tolerance of 100ms, in case current position is not buffered,
                  check if current pos+100ms is buffered and use that buffer range
                  for FRAG_CHANGED event reporting */
                fragPlayingCurrent = this.getBufferedFrag(currentTime + 0.1);
            }
            if (fragPlayingCurrent) {
                var fragPlaying = fragPlayingCurrent;
                if (fragPlaying !== this.fragPlaying) {
                    this.hls.trigger(events_1.default.FRAG_CHANGED, { frag: fragPlaying });
                    var fragPlayingLevel = fragPlaying.level;
                    if (!this.fragPlaying || this.fragPlaying.level !== fragPlayingLevel) {
                        this.hls.trigger(events_1.default.LEVEL_SWITCHED, { level: fragPlayingLevel });
                    }
                    this.fragPlaying = fragPlaying;
                }
            }
        }
    };
    /*
      on immediate level switch :
       - pause playback if playing
       - cancel any pending load request
       - and trigger a buffer flush
    */
    StreamController.prototype.immediateLevelSwitch = function () {
        logger_1.logger.log('immediateLevelSwitch');
        if (!this.immediateSwitch) {
            this.immediateSwitch = true;
            var media = this.media, previouslyPaused = void 0;
            if (media) {
                previouslyPaused = media.paused;
                media.pause();
            }
            else {
                // don't restart playback after instant level switch in case media not attached
                previouslyPaused = true;
            }
            this.previouslyPaused = previouslyPaused;
        }
        var fragCurrent = this.fragCurrent;
        if (fragCurrent && fragCurrent.loader) {
            fragCurrent.loader.abort();
        }
        this.fragCurrent = null;
        // flush everything
        this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
    };
    /**
     * on immediate level switch end, after new fragment has been buffered:
     * - nudge video decoder by slightly adjusting video currentTime (if currentTime buffered)
     * - resume the playback if needed
     */
    StreamController.prototype.immediateLevelSwitchEnd = function () {
        var media = this.media;
        if (media && media.buffered.length) {
            this.immediateSwitch = false;
            if (buffer_helper_1.BufferHelper.isBuffered(media, media.currentTime)) {
                // only nudge if currentTime is buffered
                media.currentTime -= 0.0001;
            }
            if (!this.previouslyPaused) {
                media.play();
            }
        }
    };
    /**
     * try to switch ASAP without breaking video playback:
     * in order to ensure smooth but quick level switching,
     * we need to find the next flushable buffer range
     * we should take into account new segment fetch time
     */
    StreamController.prototype.nextLevelSwitch = function () {
        var media = this.media;
        // ensure that media is defined and that metadata are available (to retrieve currentTime)
        if (media && media.readyState) {
            var fetchdelay = void 0, fragPlayingCurrent = void 0, nextBufferedFrag = void 0;
            fragPlayingCurrent = this.getBufferedFrag(media.currentTime);
            if (fragPlayingCurrent && fragPlayingCurrent.startPTS > 1) {
                // flush buffer preceding current fragment (flush until current fragment start offset)
                // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...
                this.flushMainBuffer(0, fragPlayingCurrent.startPTS - 1);
            }
            if (!media.paused) {
                // add a safety delay of 1s
                var nextLevelId = this.hls.nextLoadLevel, nextLevel = this.levels[nextLevelId], fragLastKbps = this.fragLastKbps;
                if (fragLastKbps && this.fragCurrent) {
                    fetchdelay = this.fragCurrent.duration * nextLevel.bitrate / (1000 * fragLastKbps) + 1;
                }
                else {
                    fetchdelay = 0;
                }
            }
            else {
                fetchdelay = 0;
            }
            // logger.log('fetchdelay:'+fetchdelay);
            // find buffer range that will be reached once new fragment will be fetched
            nextBufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);
            if (nextBufferedFrag) {
                // we can flush buffer range following this one without stalling playback
                nextBufferedFrag = this.followingBufferedFrag(nextBufferedFrag);
                if (nextBufferedFrag) {
                    // if we are here, we can also cancel any loading/demuxing in progress, as they are useless
                    var fragCurrent = this.fragCurrent;
                    if (fragCurrent && fragCurrent.loader) {
                        fragCurrent.loader.abort();
                    }
                    this.fragCurrent = null;
                    // start flush position is the start PTS of next buffered frag.
                    // we use frag.naxStartPTS which is max(audio startPTS, video startPTS).
                    // in case there is a small PTS Delta between audio and video, using maxStartPTS avoids flushing last samples from current fragment
                    this.flushMainBuffer(nextBufferedFrag.maxStartPTS, Number.POSITIVE_INFINITY);
                }
            }
        }
    };
    StreamController.prototype.flushMainBuffer = function (startOffset, endOffset) {
        this.state = base_stream_controller_1.State.BUFFER_FLUSHING;
        var flushScope = { startOffset: startOffset, endOffset: endOffset };
        // if alternate audio tracks are used, only flush video, otherwise flush everything
        if (this.altAudio) {
            flushScope.type = 'video';
        }
        this.hls.trigger(events_1.default.BUFFER_FLUSHING, flushScope);
    };
    StreamController.prototype.onMediaAttached = function (data) {
        var media = this.media = this.mediaBuffer = data.media;
        this.onvseeking = this.onMediaSeeking.bind(this);
        this.onvseeked = this.onMediaSeeked.bind(this);
        this.onvended = this.onMediaEnded.bind(this);
        media.addEventListener('seeking', this.onvseeking);
        media.addEventListener('seeked', this.onvseeked);
        media.addEventListener('ended', this.onvended);
        var config = this.config;
        if (this.levels && config.autoStartLoad) {
            this.hls.startLoad(config.startPosition);
        }
        this.gapController = new gap_controller_1.default(config, media, this.fragmentTracker, this.hls);
    };
    StreamController.prototype.onMediaDetaching = function () {
        var media = this.media;
        if (media && media.ended) {
            logger_1.logger.log('MSE detaching and video ended, reset startPosition');
            this.startPosition = this.lastCurrentTime = 0;
        }
        // reset fragment backtracked flag
        var levels = this.levels;
        if (levels) {
            levels.forEach(function (level) {
                if (level.details) {
                    level.details.fragments.forEach(function (fragment) {
                        fragment.backtracked = undefined;
                    });
                }
            });
        }
        // remove video listeners
        if (media) {
            media.removeEventListener('seeking', this.onvseeking);
            media.removeEventListener('seeked', this.onvseeked);
            media.removeEventListener('ended', this.onvended);
            this.onvseeking = this.onvseeked = this.onvended = null;
        }
        this.media = this.mediaBuffer = null;
        this.loadedmetadata = false;
        this.stopLoad();
    };
    StreamController.prototype.onMediaSeeked = function () {
        var media = this.media, currentTime = media ? media.currentTime : undefined;
        if (Number.isFinite(currentTime)) {
            logger_1.logger.log("media seeked to " + currentTime.toFixed(3));
        }
        // tick to speed up FRAGMENT_PLAYING triggering
        this.tick();
    };
    StreamController.prototype.onManifestLoading = function () {
        // reset buffer on manifest loading
        logger_1.logger.log('trigger BUFFER_RESET');
        this.hls.trigger(events_1.default.BUFFER_RESET);
        this.fragmentTracker.removeAllFragments();
        this.stalled = false;
        this.startPosition = this.lastCurrentTime = 0;
    };
    StreamController.prototype.onManifestParsed = function (data) {
        var aac = false, heaac = false, codec;
        data.levels.forEach(function (level) {
            // detect if we have different kind of audio codecs used amongst playlists
            codec = level.audioCodec;
            if (codec) {
                if (codec.indexOf('mp4a.40.2') !== -1) {
                    aac = true;
                }
                if (codec.indexOf('mp4a.40.5') !== -1) {
                    heaac = true;
                }
            }
        });
        this.audioCodecSwitch = (aac && heaac);
        if (this.audioCodecSwitch) {
            logger_1.logger.log('both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');
        }
        this.levels = data.levels;
        this.startFragRequested = false;
        var config = this.config;
        if (config.autoStartLoad || this.forceStartLoad) {
            this.hls.startLoad(config.startPosition);
        }
    };
    StreamController.prototype.onLevelLoaded = function (data) {
        var newDetails = data.details;
        var newLevelId = data.level;
        var lastLevel = this.levels[this.levelLastLoaded];
        var curLevel = this.levels[newLevelId];
        var duration = newDetails.totalduration;
        var sliding = 0;
        logger_1.logger.log("level " + newLevelId + " loaded [" + newDetails.startSN + "," + newDetails.endSN + "],duration:" + duration);
        if (newDetails.live) {
            var curDetails = curLevel.details;
            if (curDetails && newDetails.fragments.length > 0) {
                // we already have details for that level, merge them
                LevelHelper.mergeDetails(curDetails, newDetails);
                sliding = newDetails.fragments[0].start;
                this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
                if (newDetails.PTSKnown && Number.isFinite(sliding)) {
                    logger_1.logger.log("live playlist sliding:" + sliding.toFixed(3));
                }
                else {
                    logger_1.logger.log('live playlist - outdated PTS, unknown sliding');
                    discontinuities_1.alignStream(this.fragPrevious, lastLevel, newDetails);
                }
            }
            else {
                logger_1.logger.log('live playlist - first load, unknown sliding');
                newDetails.PTSKnown = false;
                discontinuities_1.alignStream(this.fragPrevious, lastLevel, newDetails);
            }
        }
        else {
            newDetails.PTSKnown = false;
        }
        // override level info
        curLevel.details = newDetails;
        this.levelLastLoaded = newLevelId;
        this.hls.trigger(events_1.default.LEVEL_UPDATED, { details: newDetails, level: newLevelId });
        if (this.startFragRequested === false) {
            // compute start position if set to -1. use it straight away if value is defined
            if (this.startPosition === -1 || this.lastCurrentTime === -1) {
                // first, check if start time offset has been set in playlist, if yes, use this value
                var startTimeOffset = newDetails.startTimeOffset;
                if (Number.isFinite(startTimeOffset)) {
                    if (startTimeOffset < 0) {
                        logger_1.logger.log("negative start time offset " + startTimeOffset + ", count from end of last fragment");
                        startTimeOffset = sliding + duration + startTimeOffset;
                    }
                    logger_1.logger.log("start time offset found in playlist, adjust startPosition to " + startTimeOffset);
                    this.startPosition = startTimeOffset;
                }
                else {
                    // if live playlist, set start position to be fragment N-this.config.liveSyncDurationCount (usually 3)
                    if (newDetails.live) {
                        this.startPosition = this.computeLivePosition(sliding, newDetails);
                        logger_1.logger.log("configure startPosition to " + this.startPosition);
                    }
                    else {
                        this.startPosition = 0;
                    }
                }
                this.lastCurrentTime = this.startPosition;
            }
            this.nextLoadPosition = this.startPosition;
        }
        // only switch batck to IDLE state if we were waiting for level to start downloading a new fragment
        if (this.state === base_stream_controller_1.State.WAITING_LEVEL) {
            this.state = base_stream_controller_1.State.IDLE;
        }
        // trigger handler right now
        this.tick();
    };
    StreamController.prototype.onKeyLoaded = function () {
        if (this.state === base_stream_controller_1.State.KEY_LOADING) {
            this.state = base_stream_controller_1.State.IDLE;
            this.tick();
        }
    };
    StreamController.prototype.onFragLoaded = function (data) {
        var _a = this, fragCurrent = _a.fragCurrent, hls = _a.hls, levels = _a.levels, media = _a.media;
        var fragLoaded = data.frag;
        if (this.state === base_stream_controller_1.State.FRAG_LOADING &&
            fragCurrent &&
            fragLoaded.type === 'main' &&
            fragLoaded.level === fragCurrent.level &&
            fragLoaded.sn === fragCurrent.sn) {
            var stats = data.stats;
            var currentLevel = levels[fragCurrent.level];
            var details = currentLevel.details;
            // reset frag bitrate test in any case after frag loaded event
            // if this frag was loaded to perform a bitrate test AND if hls.nextLoadLevel is greater than 0
            // then this means that we should be able to load a fragment at a higher quality level
            this.bitrateTest = false;
            this.stats = stats;
            logger_1.logger.log("Loaded " + fragCurrent.sn + " of [" + details.startSN + " ," + details.endSN + "],level " + fragCurrent.level);
            if (fragLoaded.bitrateTest && hls.nextLoadLevel) {
                // switch back to IDLE state ... we just loaded a fragment to determine adequate start bitrate and initialize autoswitch algo
                this.state = base_stream_controller_1.State.IDLE;
                this.startFragRequested = false;
                stats.tparsed = stats.tbuffered = window.performance.now();
                hls.trigger(events_1.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });
                this.tick();
            }
            else if (fragLoaded.sn === 'initSegment') {
                this.state = base_stream_controller_1.State.IDLE;
                stats.tparsed = stats.tbuffered = window.performance.now();
                details.initSegment.data = data.payload;
                hls.trigger(events_1.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });
                this.tick();
            }
            else {
                logger_1.logger.log("Parsing " + fragCurrent.sn + " of [" + details.startSN + " ," + details.endSN + "],level " + fragCurrent.level + ", cc " + fragCurrent.cc);
                this.state = base_stream_controller_1.State.PARSING;
                this.pendingBuffering = true;
                this.appended = false;
                // Bitrate test frags are not usually buffered so the fragment tracker ignores them. If Hls.js decides to buffer
                // it (and therefore ends up at this line), then the fragment tracker needs to be manually informed.
                if (fragLoaded.bitrateTest) {
                    fragLoaded.bitrateTest = false;
                    this.fragmentTracker.onFragLoaded({
                        frag: fragLoaded
                    });
                }
                // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live) and if media is not seeking (this is to overcome potential timestamp drifts between playlists and fragments)
                var accurateTimeOffset = !(media && media.seeking) && (details.PTSKnown || !details.live);
                var initSegmentData = details.initSegment ? details.initSegment.data : [];
                var audioCodec = this._getAudioCodec(currentLevel);
                // transmux the MPEG-TS data to ISO-BMFF segments
                var demuxer = this.demuxer = this.demuxer || new demuxer_1.default(this.hls, 'main');
                demuxer.push(data.payload, initSegmentData, audioCodec, currentLevel.videoCodec, fragCurrent, details.totalduration, accurateTimeOffset);
            }
        }
        this.fragLoadError = 0;
    };
    StreamController.prototype.onFragParsingInitSegment = function (data) {
        var fragCurrent = this.fragCurrent;
        var fragNew = data.frag;
        if (fragCurrent &&
            data.id === 'main' &&
            fragNew.sn === fragCurrent.sn &&
            fragNew.level === fragCurrent.level &&
            this.state === base_stream_controller_1.State.PARSING) {
            var tracks = data.tracks, trackName = void 0, track = void 0;
            // if audio track is expected to come from audio stream controller, discard any coming from main
            if (tracks.audio && this.altAudio) {
                delete tracks.audio;
            }
            // include levelCodec in audio and video tracks
            track = tracks.audio;
            if (track) {
                var audioCodec = this.levels[this.level].audioCodec, ua = navigator.userAgent.toLowerCase();
                if (audioCodec && this.audioCodecSwap) {
                    logger_1.logger.log('swapping playlist audio codec');
                    if (audioCodec.indexOf('mp4a.40.5') !== -1) {
                        audioCodec = 'mp4a.40.2';
                    }
                    else {
                        audioCodec = 'mp4a.40.5';
                    }
                }
                // in case AAC and HE-AAC audio codecs are signalled in manifest
                // force HE-AAC , as it seems that most browsers prefers that way,
                // except for mono streams OR on FF
                // these conditions might need to be reviewed ...
                if (this.audioCodecSwitch) {
                    // don't force HE-AAC if mono stream
                    if (track.metadata.channelCount !== 1 &&
                        // don't force HE-AAC if firefox
                        ua.indexOf('firefox') === -1) {
                        audioCodec = 'mp4a.40.5';
                    }
                }
                // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise
                if (ua.indexOf('android') !== -1 && track.container !== 'audio/mpeg') { // Exclude mpeg audio
                    audioCodec = 'mp4a.40.2';
                    logger_1.logger.log("Android: force audio codec to " + audioCodec);
                }
                track.levelCodec = audioCodec;
                track.id = data.id;
            }
            track = tracks.video;
            if (track) {
                track.levelCodec = this.levels[this.level].videoCodec;
                track.id = data.id;
            }
            this.hls.trigger(events_1.default.BUFFER_CODECS, tracks);
            // loop through tracks that are going to be provided to bufferController
            for (trackName in tracks) {
                track = tracks[trackName];
                logger_1.logger.log("main track:" + trackName + ",container:" + track.container + ",codecs[level/parsed]=[" + track.levelCodec + "/" + track.codec + "]");
                var initSegment = track.initSegment;
                if (initSegment) {
                    this.appended = true;
                    // arm pending Buffering flag before appending a segment
                    this.pendingBuffering = true;
                    this.hls.trigger(events_1.default.BUFFER_APPENDING, { type: trackName, data: initSegment, parent: 'main', content: 'initSegment' });
                }
            }
            // trigger handler right now
            this.tick();
        }
    };
    StreamController.prototype.onFragParsingData = function (data) {
        var _this = this;
        var fragCurrent = this.fragCurrent;
        var fragNew = data.frag;
        if (fragCurrent &&
            data.id === 'main' &&
            fragNew.sn === fragCurrent.sn &&
            fragNew.level === fragCurrent.level &&
            !(data.type === 'audio' && this.altAudio) && // filter out main audio if audio track is loaded through audio stream controller
            this.state === base_stream_controller_1.State.PARSING) {
            var level = this.levels[this.level], frag = fragCurrent;
            if (!Number.isFinite(data.endPTS)) {
                data.endPTS = data.startPTS + fragCurrent.duration;
                data.endDTS = data.startDTS + fragCurrent.duration;
            }
            if (data.hasAudio === true) {
                frag.addElementaryStream(fragment_1.default.ElementaryStreamTypes.AUDIO);
            }
            if (data.hasVideo === true) {
                frag.addElementaryStream(fragment_1.default.ElementaryStreamTypes.VIDEO);
            }
            logger_1.logger.log("Parsed " + data.type + ",PTS:[" + data.startPTS.toFixed(3) + "," + data.endPTS.toFixed(3) + "],DTS:[" + data.startDTS.toFixed(3) + "/" + data.endDTS.toFixed(3) + "],nb:" + data.nb + ",dropped:" + (data.dropped || 0));
            // Detect gaps in a fragment  and try to fix it by finding a keyframe in the previous fragment (see _findFragments)
            if (data.type === 'video') {
                frag.dropped = data.dropped;
                if (frag.dropped) {
                    if (!frag.backtracked) {
                        var levelDetails = level.details;
                        if (levelDetails && frag.sn === levelDetails.startSN) {
                            logger_1.logger.warn('missing video frame(s) on first frag, appending with gap', frag.sn);
                        }
                        else {
                            logger_1.logger.warn('missing video frame(s), backtracking fragment', frag.sn);
                            // Return back to the IDLE state without appending to buffer
                            // Causes findFragments to backtrack a segment and find the keyframe
                            // Audio fragments arriving before video sets the nextLoadPosition, causing _findFragments to skip the backtracked fragment
                            this.fragmentTracker.removeFragment(frag);
                            frag.backtracked = true;
                            this.nextLoadPosition = data.startPTS;
                            this.state = base_stream_controller_1.State.IDLE;
                            this.fragPrevious = frag;
                            this.tick();
                            return;
                        }
                    }
                    else {
                        logger_1.logger.warn('Already backtracked on this fragment, appending with the gap', frag.sn);
                    }
                }
                else {
                    // Only reset the backtracked flag if we've loaded the frag without any dropped frames
                    frag.backtracked = false;
                }
            }
            var drift = LevelHelper.updateFragPTSDTS(level.details, frag, data.startPTS, data.endPTS, data.startDTS, data.endDTS), hls_2 = this.hls;
            hls_2.trigger(events_1.default.LEVEL_PTS_UPDATED, { details: level.details, level: this.level, drift: drift, type: data.type, start: data.startPTS, end: data.endPTS });
            // has remuxer dropped video frames located before first keyframe ?
            [data.data1, data.data2].forEach(function (buffer) {
                // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)
                // in that case it is useless to append following segments
                if (buffer && buffer.length && _this.state === base_stream_controller_1.State.PARSING) {
                    _this.appended = true;
                    // arm pending Buffering flag before appending a segment
                    _this.pendingBuffering = true;
                    hls_2.trigger(events_1.default.BUFFER_APPENDING, { type: data.type, data: buffer, parent: 'main', content: 'data' });
                }
            });
            // trigger handler right now
            this.tick();
        }
    };
    StreamController.prototype.onFragParsed = function (data) {
        var fragCurrent = this.fragCurrent;
        var fragNew = data.frag;
        if (fragCurrent &&
            data.id === 'main' &&
            fragNew.sn === fragCurrent.sn &&
            fragNew.level === fragCurrent.level &&
            this.state === base_stream_controller_1.State.PARSING) {
            this.stats.tparsed = window.performance.now();
            this.state = base_stream_controller_1.State.PARSED;
            this._checkAppendedParsed();
        }
    };
    StreamController.prototype.onAudioTrackSwitching = function (data) {
        // if any URL found on new audio track, it is an alternate audio track
        var altAudio = !!data.url, trackId = data.id;
        // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered
        // don't do anything if we switch to alt audio: audio stream controller is handling it.
        // we will just have to change buffer scheduling on audioTrackSwitched
        if (!altAudio) {
            if (this.mediaBuffer !== this.media) {
                logger_1.logger.log('switching on main audio, use media.buffered to schedule main fragment loading');
                this.mediaBuffer = this.media;
                var fragCurrent = this.fragCurrent;
                // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch
                if (fragCurrent.loader) {
                    logger_1.logger.log('switching to main audio track, cancel main fragment load');
                    fragCurrent.loader.abort();
                }
                this.fragCurrent = null;
                this.fragPrevious = null;
                // destroy demuxer to force init segment generation (following audio switch)
                if (this.demuxer) {
                    this.demuxer.destroy();
                    this.demuxer = null;
                }
                // switch to IDLE state to load new fragment
                this.state = base_stream_controller_1.State.IDLE;
            }
            var hls_3 = this.hls;
            // switching to main audio, flush all audio and trigger track switched
            hls_3.trigger(events_1.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
            hls_3.trigger(events_1.default.AUDIO_TRACK_SWITCHED, { id: trackId });
            this.altAudio = false;
        }
    };
    StreamController.prototype.onAudioTrackSwitched = function (data) {
        var trackId = data.id, altAudio = !!this.hls.audioTracks[trackId].url;
        if (altAudio) {
            var videoBuffer = this.videoBuffer;
            // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered
            if (videoBuffer && this.mediaBuffer !== videoBuffer) {
                logger_1.logger.log('switching on alternate audio, use video.buffered to schedule main fragment loading');
                this.mediaBuffer = videoBuffer;
            }
        }
        this.altAudio = altAudio;
        this.tick();
    };
    StreamController.prototype.onBufferCreated = function (data) {
        var tracks = data.tracks, mediaTrack, name, alternate = false;
        for (var type in tracks) {
            var track = tracks[type];
            if (track.id === 'main') {
                name = type;
                mediaTrack = track;
                // keep video source buffer reference
                if (type === 'video') {
                    this.videoBuffer = tracks[type].buffer;
                }
            }
            else {
                alternate = true;
            }
        }
        if (alternate && mediaTrack) {
            logger_1.logger.log("alternate track found, use " + name + ".buffered to schedule main fragment loading");
            this.mediaBuffer = mediaTrack.buffer;
        }
        else {
            this.mediaBuffer = this.media;
        }
    };
    StreamController.prototype.onBufferAppended = function (data) {
        if (data.parent === 'main') {
            var state = this.state;
            if (state === base_stream_controller_1.State.PARSING || state === base_stream_controller_1.State.PARSED) {
                // check if all buffers have been appended
                this.pendingBuffering = (data.pending > 0);
                this._checkAppendedParsed();
            }
        }
    };
    StreamController.prototype._checkAppendedParsed = function () {
        // trigger handler right now
        if (this.state === base_stream_controller_1.State.PARSED && (!this.appended || !this.pendingBuffering)) {
            var frag = this.fragCurrent;
            if (frag) {
                var media = this.mediaBuffer ? this.mediaBuffer : this.media;
                logger_1.logger.log("main buffered : " + time_ranges_1.default.toString(media.buffered));
                this.fragPrevious = frag;
                var stats = this.stats;
                stats.tbuffered = window.performance.now();
                // we should get rid of this.fragLastKbps
                this.fragLastKbps = Math.round(8 * stats.total / (stats.tbuffered - stats.tfirst));
                this.hls.trigger(events_1.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'main' });
                this.state = base_stream_controller_1.State.IDLE;
            }
            this.tick();
        }
    };
    StreamController.prototype.onError = function (data) {
        var frag = data.frag || this.fragCurrent;
        // don't handle frag error not related to main fragment
        if (frag && frag.type !== 'main') {
            return;
        }
        // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end
        var mediaBuffered = !!this.media && buffer_helper_1.BufferHelper.isBuffered(this.media, this.media.currentTime) && buffer_helper_1.BufferHelper.isBuffered(this.media, this.media.currentTime + 0.5);
        switch (data.details) {
            case errors_1.ErrorDetails.FRAG_LOAD_ERROR:
            case errors_1.ErrorDetails.FRAG_LOAD_TIMEOUT:
            case errors_1.ErrorDetails.KEY_LOAD_ERROR:
            case errors_1.ErrorDetails.KEY_LOAD_TIMEOUT:
                if (!data.fatal) {
                    // keep retrying until the limit will be reached
                    if ((this.fragLoadError + 1) <= this.config.fragLoadingMaxRetry) {
                        // exponential backoff capped to config.fragLoadingMaxRetryTimeout
                        var delay = Math.min(Math.pow(2, this.fragLoadError) * this.config.fragLoadingRetryDelay, this.config.fragLoadingMaxRetryTimeout);
                        logger_1.logger.warn("mediaController: frag loading failed, retry in " + delay + " ms");
                        this.retryDate = window.performance.now() + delay;
                        // retry loading state
                        // if loadedmetadata is not set, it means that we are emergency switch down on first frag
                        // in that case, reset startFragRequested flag
                        if (!this.loadedmetadata) {
                            this.startFragRequested = false;
                            this.nextLoadPosition = this.startPosition;
                        }
                        this.fragLoadError++;
                        this.state = base_stream_controller_1.State.FRAG_LOADING_WAITING_RETRY;
                    }
                    else {
                        logger_1.logger.error("mediaController: " + data.details + " reaches max retry, redispatch as fatal ...");
                        // switch error to fatal
                        data.fatal = true;
                        this.state = base_stream_controller_1.State.ERROR;
                    }
                }
                break;
            case errors_1.ErrorDetails.LEVEL_LOAD_ERROR:
            case errors_1.ErrorDetails.LEVEL_LOAD_TIMEOUT:
                if (this.state !== base_stream_controller_1.State.ERROR) {
                    if (data.fatal) {
                        // if fatal error, stop processing
                        this.state = base_stream_controller_1.State.ERROR;
                        logger_1.logger.warn("streamController: " + data.details + ",switch to " + this.state + " state ...");
                    }
                    else {
                        // in case of non fatal error while loading level, if level controller is not retrying to load level , switch back to IDLE
                        if (!data.levelRetry && this.state === base_stream_controller_1.State.WAITING_LEVEL) {
                            this.state = base_stream_controller_1.State.IDLE;
                        }
                    }
                }
                break;
            case errors_1.ErrorDetails.BUFFER_FULL_ERROR:
                // if in appending state
                if (data.parent === 'main' && (this.state === base_stream_controller_1.State.PARSING || this.state === base_stream_controller_1.State.PARSED)) {
                    // reduce max buf len if current position is buffered
                    if (mediaBuffered) {
                        this._reduceMaxBufferLength(this.config.maxBufferLength);
                        this.state = base_stream_controller_1.State.IDLE;
                    }
                    else {
                        // current position is not buffered, but browser is still complaining about buffer full error
                        // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
                        // in that case flush the whole buffer to recover
                        logger_1.logger.warn('buffer full error also media.currentTime is not buffered, flush everything');
                        this.fragCurrent = null;
                        // flush everything
                        this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
                    }
                }
                break;
            default:
                break;
        }
    };
    StreamController.prototype._reduceMaxBufferLength = function (minLength) {
        var config = this.config;
        if (config.maxMaxBufferLength >= minLength) {
            // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
            config.maxMaxBufferLength /= 2;
            logger_1.logger.warn("main:reduce max buffer length to " + config.maxMaxBufferLength + "s");
            return true;
        }
        return false;
    };
    /**
     * Checks the health of the buffer and attempts to resolve playback stalls.
     * @private
     */
    StreamController.prototype._checkBuffer = function () {
        var media = this.media;
        if (!media || media.readyState === 0) {
            // Exit early if we don't have media or if the media hasn't bufferd anything yet (readyState 0)
            return;
        }
        var mediaBuffer = this.mediaBuffer ? this.mediaBuffer : media;
        var buffered = mediaBuffer.buffered;
        if (!this.loadedmetadata && buffered.length) {
            this.loadedmetadata = true;
            this._seekToStartPos();
        }
        else if (this.immediateSwitch) {
            this.immediateLevelSwitchEnd();
        }
        else {
            this.gapController.poll(this.lastCurrentTime, buffered);
        }
    };
    StreamController.prototype.onFragLoadEmergencyAborted = function () {
        this.state = base_stream_controller_1.State.IDLE;
        // if loadedmetadata is not set, it means that we are emergency switch down on first frag
        // in that case, reset startFragRequested flag
        if (!this.loadedmetadata) {
            this.startFragRequested = false;
            this.nextLoadPosition = this.startPosition;
        }
        this.tick();
    };
    StreamController.prototype.onBufferFlushed = function () {
        /* after successful buffer flushing, filter flushed fragments from bufferedFrags
          use mediaBuffered instead of media (so that we will check against video.buffered ranges in case of alt audio track)
        */
        var media = this.mediaBuffer ? this.mediaBuffer : this.media;
        if (media) {
            // filter fragments potentially evicted from buffer. this is to avoid memleak on live streams
            this.fragmentTracker.detectEvictedFragments(fragment_1.default.ElementaryStreamTypes.VIDEO, media.buffered);
        }
        // move to IDLE once flush complete. this should trigger new fragment loading
        this.state = base_stream_controller_1.State.IDLE;
        // reset reference to frag
        this.fragPrevious = null;
    };
    StreamController.prototype.swapAudioCodec = function () {
        this.audioCodecSwap = !this.audioCodecSwap;
    };
    StreamController.prototype.computeLivePosition = function (sliding, levelDetails) {
        var targetLatency = this.config.liveSyncDuration !== undefined ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * levelDetails.targetduration;
        return sliding + Math.max(0, levelDetails.totalduration - targetLatency);
    };
    /**
     * Seeks to the set startPosition if not equal to the mediaElement's current time.
     * @private
     */
    StreamController.prototype._seekToStartPos = function () {
        var media = this.media;
        var currentTime = media.currentTime;
        // only adjust currentTime if different from startPosition or if startPosition not buffered
        // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered
        var startPosition = media.seeking ? currentTime : this.startPosition;
        // if currentTime not matching with expected startPosition or startPosition not buffered but close to first buffered
        if (currentTime !== startPosition) {
            // if startPosition not buffered, let's seek to buffered.start(0)
            logger_1.logger.log("target start position not buffered, seek to buffered.start(0) " + startPosition + " from current time " + currentTime + " ");
            media.currentTime = startPosition;
        }
    };
    StreamController.prototype._getAudioCodec = function (currentLevel) {
        var audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;
        if (this.audioCodecSwap) {
            logger_1.logger.log('swapping playlist audio codec');
            if (audioCodec) {
                if (audioCodec.indexOf('mp4a.40.5') !== -1) {
                    audioCodec = 'mp4a.40.2';
                }
                else {
                    audioCodec = 'mp4a.40.5';
                }
            }
        }
        return audioCodec;
    };
    Object.defineProperty(StreamController.prototype, "liveSyncPosition", {
        get: function () {
            return this._liveSyncPosition;
        },
        set: function (value) {
            this._liveSyncPosition = value;
        },
        enumerable: true,
        configurable: true
    });
    return StreamController;
}(base_stream_controller_1.default));
exports.default = StreamController;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/controller/subtitle-stream-controller.js":
/*!******************************************************!*\
  !*** ./src/controller/subtitle-stream-controller.js ***!
  \******************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @class SubtitleStreamController
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var decrypter_1 = __webpack_require__(/*! ../crypt/decrypter */ "./src/crypt/decrypter.js");
var task_loop_1 = __webpack_require__(/*! ../task-loop */ "./src/task-loop.js");
var buffer_helper_1 = __webpack_require__(/*! ../utils/buffer-helper */ "./src/utils/buffer-helper.js");
var fragment_finders_1 = __webpack_require__(/*! ./fragment-finders */ "./src/controller/fragment-finders.js");
var fragment_tracker_1 = __webpack_require__(/*! ./fragment-tracker */ "./src/controller/fragment-tracker.js");
var performance = window.performance;
exports.SubtitleStreamControllerState = {
    STOPPED: 'STOPPED',
    IDLE: 'IDLE',
    KEY_LOADING: 'KEY_LOADING',
    FRAG_LOADING: 'FRAG_LOADING'
};
var State = exports.SubtitleStreamControllerState;
var TICK_INTERVAL = 500; // how often to tick in ms
var SubtitleStreamController = /** @class */ (function (_super) {
    __extends(SubtitleStreamController, _super);
    function SubtitleStreamController(hls, fragmentTracker) {
        var _this = _super.call(this, hls, events_1.default.MEDIA_ATTACHED, events_1.default.MEDIA_DETACHING, events_1.default.ERROR, events_1.default.KEY_LOADED, events_1.default.FRAG_LOADED, events_1.default.SUBTITLE_TRACKS_UPDATED, events_1.default.SUBTITLE_TRACK_SWITCH, events_1.default.SUBTITLE_TRACK_LOADED, events_1.default.SUBTITLE_FRAG_PROCESSED) || this;
        _this.fragmentTracker = fragmentTracker;
        _this.config = hls.config;
        _this.state = State.STOPPED;
        _this.tracks = [];
        _this.tracksBuffered = [];
        _this.currentTrackId = -1;
        _this.decrypter = new decrypter_1.default(hls, hls.config);
        return _this;
    }
    SubtitleStreamController.prototype.onHandlerDestroyed = function () {
        this.fragmentTracker = null;
        this.state = State.STOPPED;
        _super.prototype.onHandlerDestroyed.call(this);
    };
    SubtitleStreamController.prototype.onSubtitleFragProcessed = function (data) {
        this.state = State.IDLE;
        if (!data.success) {
            return;
        }
        var buffered = this.tracksBuffered[this.currentTrackId];
        var frag = data.frag;
        this.fragPrevious = frag;
        if (!buffered) {
            return;
        }
        // Create/update a buffered array matching the interface used by BufferHelper.bufferedInfo
        // so we can re-use the logic used to detect how much have been buffered
        // FIXME: put this in a utility function or proper object for time-ranges manipulation?
        var timeRange;
        for (var i = 0; i < buffered.length; i++) {
            if (frag.start >= buffered[i].start && frag.start <= buffered[i].end) {
                timeRange = buffered[i];
                break;
            }
        }
        if (timeRange) {
            timeRange.end = frag.start + frag.duration;
        }
        else {
            buffered.push({
                start: frag.start,
                end: frag.start + frag.duration
            });
        }
    };
    SubtitleStreamController.prototype.onMediaAttached = function (data) {
        this.media = data.media;
        this.state = State.IDLE;
    };
    SubtitleStreamController.prototype.onMediaDetaching = function () {
        this.media = null;
        this.state = State.STOPPED;
    };
    // If something goes wrong, procede to next frag, if we were processing one.
    SubtitleStreamController.prototype.onError = function (data) {
        var frag = data.frag;
        // don't handle error not related to subtitle fragment
        if (!frag || frag.type !== 'subtitle') {
            return;
        }
        this.state = State.IDLE;
    };
    // Got all new subtitle tracks.
    SubtitleStreamController.prototype.onSubtitleTracksUpdated = function (data) {
        var _this = this;
        logger_1.logger.log('subtitle tracks updated');
        this.tracksBuffered = [];
        this.tracks = data.subtitleTracks;
        this.tracks.forEach(function (track) {
            _this.tracksBuffered[track.id] = [];
        });
    };
    SubtitleStreamController.prototype.onSubtitleTrackSwitch = function (data) {
        this.currentTrackId = data.id;
        if (!this.tracks || this.currentTrackId === -1) {
            this.clearInterval();
            return;
        }
        // Check if track has the necessary details to load fragments
        var currentTrack = this.tracks[this.currentTrackId];
        if (currentTrack && currentTrack.details) {
            this.setInterval(TICK_INTERVAL);
        }
    };
    // Got a new set of subtitle fragments.
    SubtitleStreamController.prototype.onSubtitleTrackLoaded = function (data) {
        var id = data.id, details = data.details;
        if (!this.tracks) {
            logger_1.logger.warn('Can not update subtitle details, no tracks found');
            return;
        }
        if (this.tracks[id]) {
            logger_1.logger.log('Updating subtitle track details');
            this.tracks[id].details = details;
        }
        this.setInterval(TICK_INTERVAL);
    };
    SubtitleStreamController.prototype.onKeyLoaded = function () {
        if (this.state === State.KEY_LOADING) {
            this.state = State.IDLE;
        }
    };
    SubtitleStreamController.prototype.onFragLoaded = function (data) {
        var fragCurrent = this.fragCurrent;
        var decryptData = data.frag.decryptdata;
        var fragLoaded = data.frag;
        var hls = this.hls;
        if (this.state === State.FRAG_LOADING &&
            fragCurrent &&
            data.frag.type === 'subtitle' &&
            fragCurrent.sn === data.frag.sn) {
            // check to see if the payload needs to be decrypted
            if (data.payload.byteLength > 0 && (decryptData && decryptData.key && decryptData.method === 'AES-128')) {
                var startTime_1 = performance.now();
                // decrypt the subtitles
                this.decrypter.decrypt(data.payload, decryptData.key.buffer, decryptData.iv.buffer, function (decryptedData) {
                    var endTime = performance.now();
                    hls.trigger(events_1.default.FRAG_DECRYPTED, { frag: fragLoaded, payload: decryptedData, stats: { tstart: startTime_1, tdecrypt: endTime } });
                });
            }
        }
    };
    SubtitleStreamController.prototype.doTick = function () {
        if (!this.media) {
            this.state = State.IDLE;
            return;
        }
        switch (this.state) {
            case State.IDLE:
                var tracks = this.tracks;
                var trackId = this.currentTrackId;
                if (!tracks || !tracks[trackId] || !tracks[trackId].details) {
                    break;
                }
                var trackDetails = tracks[trackId].details;
                var config = this.config;
                var maxBufferHole = config.maxBufferHole;
                var maxConfigBuffer = Math.min(config.maxBufferLength, config.maxMaxBufferLength);
                var maxFragLookUpTolerance = config.maxFragLookUpTolerance;
                var bufferedInfo = buffer_helper_1.BufferHelper.bufferedInfo(this._getBuffered(), this.media.currentTime, maxBufferHole);
                var bufferEnd = bufferedInfo.end;
                var bufferLen = bufferedInfo.len;
                var fragments = trackDetails.fragments;
                var fragLen = fragments.length;
                var end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration;
                var foundFrag = void 0;
                if (bufferLen < maxConfigBuffer && bufferEnd < end) {
                    foundFrag = fragment_finders_1.findFragmentByPTS(this.fragPrevious, fragments, bufferEnd, maxFragLookUpTolerance);
                }
                else if (trackDetails.hasProgramDateTime && this.fragPrevious) {
                    foundFrag = fragment_finders_1.findFragmentByPDT(fragments, this.fragPrevious.endProgramDateTime, maxFragLookUpTolerance);
                }
                if (foundFrag && foundFrag.encrypted) {
                    logger_1.logger.log("Loading key for " + foundFrag.sn);
                    this.state = State.KEY_LOADING;
                    this.hls.trigger(events_1.default.KEY_LOADING, { frag: foundFrag });
                }
                else if (foundFrag && this.fragmentTracker.getState(foundFrag) === fragment_tracker_1.FragmentState.NOT_LOADED) {
                    // only load if fragment is not loaded
                    foundFrag.trackId = trackId; // Frags don't know their subtitle track ID, so let's just add that...
                    this.fragCurrent = foundFrag;
                    this.state = State.FRAG_LOADING;
                    this.hls.trigger(events_1.default.FRAG_LOADING, { frag: foundFrag });
                }
        }
    };
    SubtitleStreamController.prototype._getBuffered = function () {
        return this.tracksBuffered[this.currentTrackId] || [];
    };
    return SubtitleStreamController;
}(task_loop_1.default));
exports.SubtitleStreamController = SubtitleStreamController;


/***/ }),

/***/ "./src/controller/subtitle-track-controller.js":
/*!*****************************************************!*\
  !*** ./src/controller/subtitle-track-controller.js ***!
  \*****************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * subtitle track controller
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var event_handler_1 = __webpack_require__(/*! ../event-handler */ "./src/event-handler.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
function filterSubtitleTracks(textTrackList) {
    var tracks = [];
    for (var i = 0; i < textTrackList.length; i++) {
        if (textTrackList[i].kind === 'subtitles') {
            tracks.push(textTrackList[i]);
        }
    }
    return tracks;
}
var SubtitleTrackController = /** @class */ (function (_super) {
    __extends(SubtitleTrackController, _super);
    function SubtitleTrackController(hls) {
        var _this = _super.call(this, hls, events_1.default.MEDIA_ATTACHED, events_1.default.MEDIA_DETACHING, events_1.default.MANIFEST_LOADING, events_1.default.MANIFEST_LOADED, events_1.default.SUBTITLE_TRACK_LOADED) || this;
        _this.tracks = [];
        _this.trackId = -1;
        _this.media = null;
        /**
         * @member {boolean} subtitleDisplay Enable/disable subtitle display rendering
         */
        _this.subtitleDisplay = true;
        return _this;
    }
    SubtitleTrackController.prototype._onTextTracksChanged = function () {
        // Media is undefined when switching streams via loadSource()
        if (!this.media) {
            return;
        }
        var trackId = -1;
        var tracks = filterSubtitleTracks(this.media.textTracks);
        for (var id = 0; id < tracks.length; id++) {
            if (tracks[id].mode === 'hidden') {
                // Do not break in case there is a following track with showing.
                trackId = id;
            }
            else if (tracks[id].mode === 'showing') {
                trackId = id;
                break;
            }
        }
        // Setting current subtitleTrack will invoke code.
        this.subtitleTrack = trackId;
    };
    SubtitleTrackController.prototype.destroy = function () {
        event_handler_1.default.prototype.destroy.call(this);
    };
    // Listen for subtitle track change, then extract the current track ID.
    SubtitleTrackController.prototype.onMediaAttached = function (data) {
        var _this = this;
        this.media = data.media;
        if (!this.media) {
            return;
        }
        if (this.queuedDefaultTrack) {
            this.subtitleTrack = this.queuedDefaultTrack;
            delete this.queuedDefaultTrack;
        }
        this.trackChangeListener = this._onTextTracksChanged.bind(this);
        this.useTextTrackPolling = !(this.media.textTracks && 'onchange' in this.media.textTracks);
        if (this.useTextTrackPolling) {
            this.subtitlePollingInterval = setInterval(function () {
                _this.trackChangeListener();
            }, 500);
        }
        else {
            this.media.textTracks.addEventListener('change', this.trackChangeListener);
        }
    };
    SubtitleTrackController.prototype.onMediaDetaching = function () {
        if (!this.media) {
            return;
        }
        if (this.useTextTrackPolling) {
            clearInterval(this.subtitlePollingInterval);
        }
        else {
            this.media.textTracks.removeEventListener('change', this.trackChangeListener);
        }
        this.media = null;
    };
    // Reset subtitle tracks on manifest loading
    SubtitleTrackController.prototype.onManifestLoading = function () {
        this.tracks = [];
        this.trackId = -1;
    };
    // Fired whenever a new manifest is loaded.
    SubtitleTrackController.prototype.onManifestLoaded = function (data) {
        var _this = this;
        var tracks = data.subtitles || [];
        this.tracks = tracks;
        this.trackId = -1;
        this.hls.trigger(events_1.default.SUBTITLE_TRACKS_UPDATED, { subtitleTracks: tracks });
        // loop through available subtitle tracks and autoselect default if needed
        // TODO: improve selection logic to handle forced, etc
        tracks.forEach(function (track) {
            if (track.default) {
                // setting this.subtitleTrack will trigger internal logic
                // if media has not been attached yet, it will fail
                // we keep a reference to the default track id
                // and we'll set subtitleTrack when onMediaAttached is triggered
                if (_this.media) {
                    _this.subtitleTrack = track.id;
                }
                else {
                    _this.queuedDefaultTrack = track.id;
                }
            }
        });
    };
    // Trigger subtitle track playlist reload.
    SubtitleTrackController.prototype.onTick = function () {
        var trackId = this.trackId;
        var subtitleTrack = this.tracks[trackId];
        if (!subtitleTrack) {
            return;
        }
        var details = subtitleTrack.details;
        // check if we need to load playlist for this subtitle Track
        if (!details || details.live) {
            // track not retrieved yet, or live playlist we need to (re)load it
            logger_1.logger.log("(re)loading playlist for subtitle track " + trackId);
            this.hls.trigger(events_1.default.SUBTITLE_TRACK_LOADING, { url: subtitleTrack.url, id: trackId });
        }
    };
    SubtitleTrackController.prototype.onSubtitleTrackLoaded = function (data) {
        var _this = this;
        if (data.id < this.tracks.length) {
            logger_1.logger.log("subtitle track " + data.id + " loaded");
            this.tracks[data.id].details = data.details;
            // check if current playlist is a live playlist
            if (data.details.live && !this.timer) {
                // if live playlist we will have to reload it periodically
                // set reload period to playlist target duration
                this.timer = setInterval(function () {
                    _this.onTick();
                }, 1000 * data.details.targetduration, this);
            }
            if (!data.details.live && this.timer) {
                // playlist is not live and timer is armed : stopping it
                this._stopTimer();
            }
        }
    };
    Object.defineProperty(SubtitleTrackController.prototype, "subtitleTracks", {
        /** get alternate subtitle tracks list from playlist **/
        get: function () {
            return this.tracks;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SubtitleTrackController.prototype, "subtitleTrack", {
        /** get index of the selected subtitle track (index in subtitle track lists) **/
        get: function () {
            return this.trackId;
        },
        /** select a subtitle track, based on its index in subtitle track lists**/
        set: function (subtitleTrackId) {
            if (this.trackId !== subtitleTrackId) {
                this._toggleTrackModes(subtitleTrackId);
                this.setSubtitleTrackInternal(subtitleTrackId);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * This method is responsible for validating the subtitle index and periodically reloading if live.
     * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.
     * @param newId - The id of the subtitle track to activate.
     */
    SubtitleTrackController.prototype.setSubtitleTrackInternal = function (newId) {
        var _a = this, hls = _a.hls, tracks = _a.tracks;
        if (typeof newId !== 'number' || newId < -1 || newId >= tracks.length) {
            return;
        }
        this._stopTimer();
        this.trackId = newId;
        logger_1.logger.log("switching to subtitle track " + newId);
        hls.trigger(events_1.default.SUBTITLE_TRACK_SWITCH, { id: newId });
        if (newId === -1) {
            return;
        }
        // check if we need to load playlist for this subtitle Track
        var subtitleTrack = tracks[newId];
        var details = subtitleTrack.details;
        if (!details || details.live) {
            // track not retrieved yet, or live playlist we need to (re)load it
            logger_1.logger.log("(re)loading playlist for subtitle track " + newId);
            hls.trigger(events_1.default.SUBTITLE_TRACK_LOADING, { url: subtitleTrack.url, id: newId });
        }
    };
    SubtitleTrackController.prototype._stopTimer = function () {
        if (this.timer) {
            clearInterval(this.timer);
            this.timer = null;
        }
    };
    /**
     * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.
     * This operates on the DOM textTracks.
     * A value of -1 will disable all subtitle tracks.
     * @param newId - The id of the next track to enable
     * @private
     */
    SubtitleTrackController.prototype._toggleTrackModes = function (newId) {
        var _a = this, media = _a.media, subtitleDisplay = _a.subtitleDisplay, trackId = _a.trackId;
        if (!media) {
            return;
        }
        var textTracks = filterSubtitleTracks(media.textTracks);
        if (newId === -1) {
            [].slice.call(textTracks).forEach(function (track) {
                track.mode = 'disabled';
            });
        }
        else {
            var oldTrack = textTracks[trackId];
            if (oldTrack) {
                oldTrack.mode = 'disabled';
            }
        }
        var nextTrack = textTracks[newId];
        if (nextTrack) {
            nextTrack.mode = subtitleDisplay ? 'showing' : 'hidden';
        }
    };
    return SubtitleTrackController;
}(event_handler_1.default));
exports.default = SubtitleTrackController;


/***/ }),

/***/ "./src/controller/timeline-controller.js":
/*!***********************************************!*\
  !*** ./src/controller/timeline-controller.js ***!
  \***********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
/*
 * Timeline Controller
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var event_handler_1 = __webpack_require__(/*! ../event-handler */ "./src/event-handler.js");
var cea_608_parser_1 = __webpack_require__(/*! ../utils/cea-608-parser */ "./src/utils/cea-608-parser.js");
var output_filter_1 = __webpack_require__(/*! ../utils/output-filter */ "./src/utils/output-filter.js");
var webvtt_parser_1 = __webpack_require__(/*! ../utils/webvtt-parser */ "./src/utils/webvtt-parser.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var texttrack_utils_1 = __webpack_require__(/*! ../utils/texttrack-utils */ "./src/utils/texttrack-utils.js");
function canReuseVttTextTrack(inUseTrack, manifestTrack) {
    return inUseTrack && inUseTrack.label === manifestTrack.name && !(inUseTrack.textTrack1 || inUseTrack.textTrack2);
}
function intersection(x1, x2, y1, y2) {
    return Math.min(x2, y2) - Math.max(x1, y1);
}
var TimelineController = /** @class */ (function (_super) {
    __extends(TimelineController, _super);
    function TimelineController(hls) {
        var _this = _super.call(this, hls, events_1.default.MEDIA_ATTACHING, events_1.default.MEDIA_DETACHING, events_1.default.FRAG_PARSING_USERDATA, events_1.default.FRAG_DECRYPTED, events_1.default.MANIFEST_LOADING, events_1.default.MANIFEST_LOADED, events_1.default.FRAG_LOADED, events_1.default.LEVEL_SWITCHING, events_1.default.INIT_PTS_FOUND) || this;
        _this.hls = hls;
        _this.config = hls.config;
        _this.enabled = true;
        _this.Cues = hls.config.cueHandler;
        _this.textTracks = [];
        _this.tracks = [];
        _this.unparsedVttFrags = [];
        _this.initPTS = [];
        _this.cueRanges = [];
        _this.captionsTracks = {};
        _this.captionsProperties = {
            textTrack1: {
                label: _this.config.captionsTextTrack1Label,
                languageCode: _this.config.captionsTextTrack1LanguageCode
            },
            textTrack2: {
                label: _this.config.captionsTextTrack2Label,
                languageCode: _this.config.captionsTextTrack2LanguageCode
            }
        };
        if (_this.config.enableCEA708Captions) {
            var channel1 = new output_filter_1.default(_this, 'textTrack1');
            var channel2 = new output_filter_1.default(_this, 'textTrack2');
            _this.cea608Parser = new cea_608_parser_1.default(0, channel1, channel2);
        }
        return _this;
    }
    TimelineController.prototype.addCues = function (trackName, startTime, endTime, screen) {
        // skip cues which overlap more than 50% with previously parsed time ranges
        var ranges = this.cueRanges;
        var merged = false;
        for (var i = ranges.length; i--;) {
            var cueRange = ranges[i];
            var overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);
            if (overlap >= 0) {
                cueRange[0] = Math.min(cueRange[0], startTime);
                cueRange[1] = Math.max(cueRange[1], endTime);
                merged = true;
                if ((overlap / (endTime - startTime)) > 0.5) {
                    return;
                }
            }
        }
        if (!merged) {
            ranges.push([startTime, endTime]);
        }
        this.Cues.newCue(this.captionsTracks[trackName], startTime, endTime, screen);
    };
    // Triggered when an initial PTS is found; used for synchronisation of WebVTT.
    TimelineController.prototype.onInitPtsFound = function (data) {
        var _this = this;
        if (data.id === 'main') {
            this.initPTS[data.frag.cc] = data.initPTS;
        }
        // Due to asynchronous processing, initial PTS may arrive later than the first VTT fragments are loaded.
        // Parse any unparsed fragments upon receiving the initial PTS.
        if (this.unparsedVttFrags.length) {
            var unparsedVttFrags = this.unparsedVttFrags;
            this.unparsedVttFrags = [];
            unparsedVttFrags.forEach(function (frag) {
                _this.onFragLoaded(frag);
            });
        }
    };
    TimelineController.prototype.getExistingTrack = function (trackName) {
        var media = this.media;
        if (media) {
            for (var i = 0; i < media.textTracks.length; i++) {
                var textTrack = media.textTracks[i];
                if (textTrack[trackName]) {
                    return textTrack;
                }
            }
        }
        return null;
    };
    TimelineController.prototype.createCaptionsTrack = function (trackName) {
        var _a = this.captionsProperties[trackName], label = _a.label, languageCode = _a.languageCode;
        var captionsTracks = this.captionsTracks;
        if (!captionsTracks[trackName]) {
            // Enable reuse of existing text track.
            var existingTrack = this.getExistingTrack(trackName);
            if (!existingTrack) {
                var textTrack = this.createTextTrack('captions', label, languageCode);
                if (textTrack) {
                    // Set a special property on the track so we know it's managed by Hls.js
                    textTrack[trackName] = true;
                    captionsTracks[trackName] = textTrack;
                }
            }
            else {
                captionsTracks[trackName] = existingTrack;
                texttrack_utils_1.clearCurrentCues(captionsTracks[trackName]);
                texttrack_utils_1.sendAddTrackEvent(captionsTracks[trackName], this.media);
            }
        }
    };
    TimelineController.prototype.createTextTrack = function (kind, label, lang) {
        var media = this.media;
        if (media) {
            return media.addTextTrack(kind, label, lang);
        }
    };
    TimelineController.prototype.destroy = function () {
        event_handler_1.default.prototype.destroy.call(this);
    };
    TimelineController.prototype.onMediaAttaching = function (data) {
        this.media = data.media;
        this._cleanTracks();
    };
    TimelineController.prototype.onMediaDetaching = function () {
        var captionsTracks = this.captionsTracks;
        Object.keys(captionsTracks).forEach(function (trackName) {
            texttrack_utils_1.clearCurrentCues(captionsTracks[trackName]);
            delete captionsTracks[trackName];
        });
    };
    TimelineController.prototype.onManifestLoading = function () {
        this.lastSn = -1; // Detect discontiguity in fragment parsing
        this.prevCC = -1;
        this.vttCCs = {
            ccOffset: 0,
            presentationOffset: 0,
            0: {
                start: 0, prevCC: -1, new: false
            }
        };
        this._cleanTracks();
    };
    TimelineController.prototype._cleanTracks = function () {
        // clear outdated subtitles
        var media = this.media;
        if (media) {
            var textTracks = media.textTracks;
            if (textTracks) {
                for (var i = 0; i < textTracks.length; i++) {
                    texttrack_utils_1.clearCurrentCues(textTracks[i]);
                }
            }
        }
    };
    TimelineController.prototype.onManifestLoaded = function (data) {
        var _this = this;
        this.textTracks = [];
        this.unparsedVttFrags = this.unparsedVttFrags || [];
        this.initPTS = [];
        this.cueRanges = [];
        if (this.config.enableWebVTT) {
            this.tracks = data.subtitles || [];
            var inUseTracks_1 = this.media ? this.media.textTracks : [];
            this.tracks.forEach(function (track, index) {
                var textTrack;
                if (index < inUseTracks_1.length) {
                    var inUseTrack = [].slice.call(inUseTracks_1).find(function (inUseTrack) { return canReuseVttTextTrack(inUseTrack, track); });
                    // Reuse tracks with the same label, but do not reuse 608/708 tracks
                    if (inUseTrack) {
                        textTrack = inUseTrack;
                    }
                }
                if (!textTrack) {
                    textTrack = _this.createTextTrack('subtitles', track.name, track.lang);
                }
                if (track.default) {
                    textTrack.mode = _this.hls.subtitleDisplay ? 'showing' : 'hidden';
                }
                else {
                    textTrack.mode = 'disabled';
                }
                _this.textTracks.push(textTrack);
            });
        }
    };
    TimelineController.prototype.onLevelSwitching = function () {
        this.enabled = this.hls.currentLevel.closedCaptions !== 'NONE';
    };
    TimelineController.prototype.onFragLoaded = function (data) {
        var frag = data.frag, payload = data.payload;
        if (frag.type === 'main') {
            var sn = frag.sn;
            // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack
            if (sn !== this.lastSn + 1) {
                var cea608Parser = this.cea608Parser;
                if (cea608Parser) {
                    cea608Parser.reset();
                }
            }
            this.lastSn = sn;
        } // eslint-disable-line brace-style
        // If fragment is subtitle type, parse as WebVTT.
        else if (frag.type === 'subtitle') {
            if (payload.byteLength) {
                // We need an initial synchronisation PTS. Store fragments as long as none has arrived.
                if (!Number.isFinite(this.initPTS[frag.cc])) {
                    this.unparsedVttFrags.push(data);
                    if (this.initPTS.length) {
                        // finish unsuccessfully, otherwise the subtitle-stream-controller could be blocked from loading new frags.
                        this.hls.trigger(events_1.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
                    }
                    return;
                }
                var decryptData = frag.decryptdata;
                // If the subtitles are not encrypted, parse VTTs now. Otherwise, we need to wait.
                if ((decryptData == null) || (decryptData.key == null) || (decryptData.method !== 'AES-128')) {
                    this._parseVTTs(frag, payload);
                }
            }
            else {
                // In case there is no payload, finish unsuccessfully.
                this.hls.trigger(events_1.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
            }
        }
    };
    TimelineController.prototype._parseVTTs = function (frag, payload) {
        var vttCCs = this.vttCCs;
        if (!vttCCs[frag.cc]) {
            vttCCs[frag.cc] = { start: frag.start, prevCC: this.prevCC, new: true };
            this.prevCC = frag.cc;
        }
        var textTracks = this.textTracks, hls = this.hls;
        // Parse the WebVTT file contents.
        webvtt_parser_1.default.parse(payload, this.initPTS[frag.cc], vttCCs, frag.cc, function (cues) {
            var currentTrack = textTracks[frag.trackId];
            // WebVTTParser.parse is an async method and if the currently selected text track mode is set to "disabled"
            // before parsing is done then don't try to access currentTrack.cues.getCueById as cues will be null
            // and trying to access getCueById method of cues will throw an exception
            if (currentTrack.mode === 'disabled') {
                hls.trigger(events_1.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
                return;
            }
            // Add cues and trigger event with success true.
            cues.forEach(function (cue) {
                // Sometimes there are cue overlaps on segmented vtts so the same
                // cue can appear more than once in different vtt files.
                // This avoid showing duplicated cues with same timecode and text.
                if (!currentTrack.cues.getCueById(cue.id)) {
                    try {
                        currentTrack.addCue(cue);
                    }
                    catch (err) {
                        var textTrackCue = new window.TextTrackCue(cue.startTime, cue.endTime, cue.text);
                        textTrackCue.id = cue.id;
                        currentTrack.addCue(textTrackCue);
                    }
                }
            });
            hls.trigger(events_1.default.SUBTITLE_FRAG_PROCESSED, { success: true, frag: frag });
        }, function (e) {
            // Something went wrong while parsing. Trigger event with success false.
            logger_1.logger.log("Failed to parse VTT cue: " + e);
            hls.trigger(events_1.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
        });
    };
    TimelineController.prototype.onFragDecrypted = function (data) {
        var decryptedData = data.payload, frag = data.frag;
        if (frag.type === 'subtitle') {
            if (!Number.isFinite(this.initPTS[frag.cc])) {
                this.unparsedVttFrags.push(data);
                return;
            }
            this._parseVTTs(frag, decryptedData);
        }
    };
    TimelineController.prototype.onFragParsingUserdata = function (data) {
        // push all of the CEA-708 messages into the interpreter
        // immediately. It will create the proper timestamps based on our PTS value
        if (this.enabled && this.config.enableCEA708Captions) {
            for (var i = 0; i < data.samples.length; i++) {
                var ccdatas = this.extractCea608Data(data.samples[i].bytes);
                this.cea608Parser.addData(data.samples[i].pts, ccdatas);
            }
        }
    };
    TimelineController.prototype.extractCea608Data = function (byteArray) {
        var count = byteArray[0] & 31;
        var position = 2;
        var tmpByte, ccbyte1, ccbyte2, ccValid, ccType;
        var actualCCBytes = [];
        for (var j = 0; j < count; j++) {
            tmpByte = byteArray[position++];
            ccbyte1 = 0x7F & byteArray[position++];
            ccbyte2 = 0x7F & byteArray[position++];
            ccValid = (4 & tmpByte) !== 0;
            ccType = 3 & tmpByte;
            if (ccbyte1 === 0 && ccbyte2 === 0) {
                continue;
            }
            if (ccValid) {
                if (ccType === 0) { // || ccType === 1
                    actualCCBytes.push(ccbyte1);
                    actualCCBytes.push(ccbyte2);
                }
            }
        }
        return actualCCBytes;
    };
    return TimelineController;
}(event_handler_1.default));
exports.default = TimelineController;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/crypt/aes-crypto.js":
/*!*********************************!*\
  !*** ./src/crypt/aes-crypto.js ***!
  \*********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var AESCrypto = /** @class */ (function () {
    function AESCrypto(subtle, iv) {
        this.subtle = subtle;
        this.aesIV = iv;
    }
    AESCrypto.prototype.decrypt = function (data, key) {
        return this.subtle.decrypt({ name: 'AES-CBC', iv: this.aesIV }, key, data);
    };
    return AESCrypto;
}());
exports.default = AESCrypto;


/***/ }),

/***/ "./src/crypt/aes-decryptor.js":
/*!************************************!*\
  !*** ./src/crypt/aes-decryptor.js ***!
  \************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// PKCS7
function removePadding(buffer) {
    var outputBytes = buffer.byteLength;
    var paddingBytes = outputBytes && (new DataView(buffer)).getUint8(outputBytes - 1);
    if (paddingBytes) {
        return buffer.slice(0, outputBytes - paddingBytes);
    }
    else {
        return buffer;
    }
}
exports.removePadding = removePadding;
var AESDecryptor = /** @class */ (function () {
    function AESDecryptor() {
        // Static after running initTable
        this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
        this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
        this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
        this.sBox = new Uint32Array(256);
        this.invSBox = new Uint32Array(256);
        // Changes during runtime
        this.key = new Uint32Array(0);
        this.initTable();
    }
    // Using view.getUint32() also swaps the byte order.
    AESDecryptor.prototype.uint8ArrayToUint32Array_ = function (arrayBuffer) {
        var view = new DataView(arrayBuffer);
        var newArray = new Uint32Array(4);
        for (var i = 0; i < 4; i++) {
            newArray[i] = view.getUint32(i * 4);
        }
        return newArray;
    };
    AESDecryptor.prototype.initTable = function () {
        var sBox = this.sBox;
        var invSBox = this.invSBox;
        var subMix = this.subMix;
        var subMix0 = subMix[0];
        var subMix1 = subMix[1];
        var subMix2 = subMix[2];
        var subMix3 = subMix[3];
        var invSubMix = this.invSubMix;
        var invSubMix0 = invSubMix[0];
        var invSubMix1 = invSubMix[1];
        var invSubMix2 = invSubMix[2];
        var invSubMix3 = invSubMix[3];
        var d = new Uint32Array(256);
        var x = 0;
        var xi = 0;
        var i = 0;
        for (i = 0; i < 256; i++) {
            if (i < 128) {
                d[i] = i << 1;
            }
            else {
                d[i] = (i << 1) ^ 0x11b;
            }
        }
        for (i = 0; i < 256; i++) {
            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
            sBox[x] = sx;
            invSBox[sx] = x;
            // Compute multiplication
            var x2 = d[x];
            var x4 = d[x2];
            var x8 = d[x4];
            // Compute sub/invSub bytes, mix columns tables
            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
            subMix0[x] = (t << 24) | (t >>> 8);
            subMix1[x] = (t << 16) | (t >>> 16);
            subMix2[x] = (t << 8) | (t >>> 24);
            subMix3[x] = t;
            // Compute inv sub bytes, inv mix columns tables
            t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
            invSubMix0[sx] = (t << 24) | (t >>> 8);
            invSubMix1[sx] = (t << 16) | (t >>> 16);
            invSubMix2[sx] = (t << 8) | (t >>> 24);
            invSubMix3[sx] = t;
            // Compute next counter
            if (!x) {
                x = xi = 1;
            }
            else {
                x = x2 ^ d[d[d[x8 ^ x2]]];
                xi ^= d[d[xi]];
            }
        }
    };
    AESDecryptor.prototype.expandKey = function (keyBuffer) {
        // convert keyBuffer to Uint32Array
        var key = this.uint8ArrayToUint32Array_(keyBuffer);
        var sameKey = true;
        var offset = 0;
        while (offset < key.length && sameKey) {
            sameKey = (key[offset] === this.key[offset]);
            offset++;
        }
        if (sameKey) {
            return;
        }
        this.key = key;
        var keySize = this.keySize = key.length;
        if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
            throw new Error('Invalid aes key size=' + keySize);
        }
        var ksRows = this.ksRows = (keySize + 6 + 1) * 4;
        var ksRow;
        var invKsRow;
        var keySchedule = this.keySchedule = new Uint32Array(ksRows);
        var invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);
        var sbox = this.sBox;
        var rcon = this.rcon;
        var invSubMix = this.invSubMix;
        var invSubMix0 = invSubMix[0];
        var invSubMix1 = invSubMix[1];
        var invSubMix2 = invSubMix[2];
        var invSubMix3 = invSubMix[3];
        var prev;
        var t;
        for (ksRow = 0; ksRow < ksRows; ksRow++) {
            if (ksRow < keySize) {
                prev = keySchedule[ksRow] = key[ksRow];
                continue;
            }
            t = prev;
            if (ksRow % keySize === 0) {
                // Rot word
                t = (t << 8) | (t >>> 24);
                // Sub word
                t = (sbox[t >>> 24] << 24) | (sbox[(t >>> 16) & 0xff] << 16) | (sbox[(t >>> 8) & 0xff] << 8) | sbox[t & 0xff];
                // Mix Rcon
                t ^= rcon[(ksRow / keySize) | 0] << 24;
            }
            else if (keySize > 6 && ksRow % keySize === 4) {
                // Sub word
                t = (sbox[t >>> 24] << 24) | (sbox[(t >>> 16) & 0xff] << 16) | (sbox[(t >>> 8) & 0xff] << 8) | sbox[t & 0xff];
            }
            keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;
        }
        for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
            ksRow = ksRows - invKsRow;
            if (invKsRow & 3) {
                t = keySchedule[ksRow];
            }
            else {
                t = keySchedule[ksRow - 4];
            }
            if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t;
            }
            else {
                invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[(t >>> 16) & 0xff]] ^ invSubMix2[sbox[(t >>> 8) & 0xff]] ^ invSubMix3[sbox[t & 0xff]];
            }
            invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
        }
    };
    // Adding this as a method greatly improves performance.
    AESDecryptor.prototype.networkToHostOrderSwap = function (word) {
        return (word << 24) | ((word & 0xff00) << 8) | ((word & 0xff0000) >> 8) | (word >>> 24);
    };
    AESDecryptor.prototype.decrypt = function (inputArrayBuffer, offset, aesIV, removePKCS7Padding) {
        var nRounds = this.keySize + 6;
        var invKeySchedule = this.invKeySchedule;
        var invSBOX = this.invSBox;
        var invSubMix = this.invSubMix;
        var invSubMix0 = invSubMix[0];
        var invSubMix1 = invSubMix[1];
        var invSubMix2 = invSubMix[2];
        var invSubMix3 = invSubMix[3];
        var initVector = this.uint8ArrayToUint32Array_(aesIV);
        var initVector0 = initVector[0];
        var initVector1 = initVector[1];
        var initVector2 = initVector[2];
        var initVector3 = initVector[3];
        var inputInt32 = new Int32Array(inputArrayBuffer);
        var outputInt32 = new Int32Array(inputInt32.length);
        var t0, t1, t2, t3;
        var s0, s1, s2, s3;
        var inputWords0, inputWords1, inputWords2, inputWords3;
        var ksRow, i;
        var swapWord = this.networkToHostOrderSwap;
        while (offset < inputInt32.length) {
            inputWords0 = swapWord(inputInt32[offset]);
            inputWords1 = swapWord(inputInt32[offset + 1]);
            inputWords2 = swapWord(inputInt32[offset + 2]);
            inputWords3 = swapWord(inputInt32[offset + 3]);
            s0 = inputWords0 ^ invKeySchedule[0];
            s1 = inputWords3 ^ invKeySchedule[1];
            s2 = inputWords2 ^ invKeySchedule[2];
            s3 = inputWords1 ^ invKeySchedule[3];
            ksRow = 4;
            // Iterate through the rounds of decryption
            for (i = 1; i < nRounds; i++) {
                t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[(s1 >> 16) & 0xff] ^ invSubMix2[(s2 >> 8) & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];
                t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[(s2 >> 16) & 0xff] ^ invSubMix2[(s3 >> 8) & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
                t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[(s3 >> 16) & 0xff] ^ invSubMix2[(s0 >> 8) & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
                t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[(s0 >> 16) & 0xff] ^ invSubMix2[(s1 >> 8) & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
                // Update state
                s0 = t0;
                s1 = t1;
                s2 = t2;
                s3 = t3;
                ksRow = ksRow + 4;
            }
            // Shift rows, sub bytes, add round key
            t0 = ((invSBOX[s0 >>> 24] << 24) ^ (invSBOX[(s1 >> 16) & 0xff] << 16) ^ (invSBOX[(s2 >> 8) & 0xff] << 8) ^ invSBOX[s3 & 0xff]) ^ invKeySchedule[ksRow];
            t1 = ((invSBOX[s1 >>> 24] << 24) ^ (invSBOX[(s2 >> 16) & 0xff] << 16) ^ (invSBOX[(s3 >> 8) & 0xff] << 8) ^ invSBOX[s0 & 0xff]) ^ invKeySchedule[ksRow + 1];
            t2 = ((invSBOX[s2 >>> 24] << 24) ^ (invSBOX[(s3 >> 16) & 0xff] << 16) ^ (invSBOX[(s0 >> 8) & 0xff] << 8) ^ invSBOX[s1 & 0xff]) ^ invKeySchedule[ksRow + 2];
            t3 = ((invSBOX[s3 >>> 24] << 24) ^ (invSBOX[(s0 >> 16) & 0xff] << 16) ^ (invSBOX[(s1 >> 8) & 0xff] << 8) ^ invSBOX[s2 & 0xff]) ^ invKeySchedule[ksRow + 3];
            ksRow = ksRow + 3;
            // Write
            outputInt32[offset] = swapWord(t0 ^ initVector0);
            outputInt32[offset + 1] = swapWord(t3 ^ initVector1);
            outputInt32[offset + 2] = swapWord(t2 ^ initVector2);
            outputInt32[offset + 3] = swapWord(t1 ^ initVector3);
            // reset initVector to last 4 unsigned int
            initVector0 = inputWords0;
            initVector1 = inputWords1;
            initVector2 = inputWords2;
            initVector3 = inputWords3;
            offset = offset + 4;
        }
        return removePKCS7Padding ? removePadding(outputInt32.buffer) : outputInt32.buffer;
    };
    AESDecryptor.prototype.destroy = function () {
        this.key = undefined;
        this.keySize = undefined;
        this.ksRows = undefined;
        this.sBox = undefined;
        this.invSBox = undefined;
        this.subMix = undefined;
        this.invSubMix = undefined;
        this.keySchedule = undefined;
        this.invKeySchedule = undefined;
        this.rcon = undefined;
    };
    return AESDecryptor;
}());
exports.default = AESDecryptor;


/***/ }),

/***/ "./src/crypt/decrypter.js":
/*!********************************!*\
  !*** ./src/crypt/decrypter.js ***!
  \********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var aes_crypto_1 = __webpack_require__(/*! ./aes-crypto */ "./src/crypt/aes-crypto.js");
var fast_aes_key_1 = __webpack_require__(/*! ./fast-aes-key */ "./src/crypt/fast-aes-key.js");
var aes_decryptor_1 = __webpack_require__(/*! ./aes-decryptor */ "./src/crypt/aes-decryptor.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var get_self_scope_1 = __webpack_require__(/*! ../utils/get-self-scope */ "./src/utils/get-self-scope.js");
// see https://stackoverflow.com/a/11237259/589493
var global = get_self_scope_1.getSelfScope(); // safeguard for code that might run both on worker and main thread
var Decrypter = /** @class */ (function () {
    function Decrypter(observer, config, _a) {
        var _b = (_a === void 0 ? {} : _a).removePKCS7Padding, removePKCS7Padding = _b === void 0 ? true : _b;
        this.logEnabled = true;
        this.observer = observer;
        this.config = config;
        this.removePKCS7Padding = removePKCS7Padding;
        // built in decryptor expects PKCS7 padding
        if (removePKCS7Padding) {
            try {
                var browserCrypto = global.crypto;
                if (browserCrypto) {
                    this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
                }
            }
            catch (e) { }
        }
        this.disableWebCrypto = !this.subtle;
    }
    Decrypter.prototype.isSync = function () {
        return (this.disableWebCrypto && this.config.enableSoftwareAES);
    };
    Decrypter.prototype.decrypt = function (data, key, iv, callback) {
        var _this = this;
        if (this.disableWebCrypto && this.config.enableSoftwareAES) {
            if (this.logEnabled) {
                logger_1.logger.log('JS AES decrypt');
                this.logEnabled = false;
            }
            var decryptor = this.decryptor;
            if (!decryptor) {
                this.decryptor = decryptor = new aes_decryptor_1.default();
            }
            decryptor.expandKey(key);
            callback(decryptor.decrypt(data, 0, iv, this.removePKCS7Padding));
        }
        else {
            if (this.logEnabled) {
                logger_1.logger.log('WebCrypto AES decrypt');
                this.logEnabled = false;
            }
            var subtle_1 = this.subtle;
            if (this.key !== key) {
                this.key = key;
                this.fastAesKey = new fast_aes_key_1.default(subtle_1, key);
            }
            this.fastAesKey.expandKey()
                .then(function (aesKey) {
                // decrypt using web crypto
                var crypto = new aes_crypto_1.default(subtle_1, iv);
                crypto.decrypt(data, aesKey)
                    .catch(function (err) {
                    _this.onWebCryptoError(err, data, key, iv, callback);
                })
                    .then(function (result) {
                    callback(result);
                });
            })
                .catch(function (err) {
                _this.onWebCryptoError(err, data, key, iv, callback);
            });
        }
    };
    Decrypter.prototype.onWebCryptoError = function (err, data, key, iv, callback) {
        if (this.config.enableSoftwareAES) {
            logger_1.logger.log('WebCrypto Error, disable WebCrypto API');
            this.disableWebCrypto = true;
            this.logEnabled = true;
            this.decrypt(data, key, iv, callback);
        }
        else {
            logger_1.logger.error("decrypting error : " + err.message);
            this.observer.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.MEDIA_ERROR, details: errors_1.ErrorDetails.FRAG_DECRYPT_ERROR, fatal: true, reason: err.message });
        }
    };
    Decrypter.prototype.destroy = function () {
        var decryptor = this.decryptor;
        if (decryptor) {
            decryptor.destroy();
            this.decryptor = undefined;
        }
    };
    return Decrypter;
}());
exports.default = Decrypter;


/***/ }),

/***/ "./src/crypt/fast-aes-key.js":
/*!***********************************!*\
  !*** ./src/crypt/fast-aes-key.js ***!
  \***********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var FastAESKey = /** @class */ (function () {
    function FastAESKey(subtle, key) {
        this.subtle = subtle;
        this.key = key;
    }
    FastAESKey.prototype.expandKey = function () {
        return this.subtle.importKey('raw', this.key, { name: 'AES-CBC' }, false, ['encrypt', 'decrypt']);
    };
    return FastAESKey;
}());
exports.default = FastAESKey;


/***/ }),

/***/ "./src/demux/aacdemuxer.js":
/*!*********************************!*\
  !*** ./src/demux/aacdemuxer.js ***!
  \*********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * AAC demuxer
 */
var ADTS = __webpack_require__(/*! ./adts */ "./src/demux/adts.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var id3_1 = __webpack_require__(/*! ../demux/id3 */ "./src/demux/id3.js");
var AACDemuxer = /** @class */ (function () {
    function AACDemuxer(observer, remuxer, config) {
        this.observer = observer;
        this.config = config;
        this.remuxer = remuxer;
    }
    AACDemuxer.prototype.resetInitSegment = function (initSegment, audioCodec, videoCodec, duration) {
        this._audioTrack = { container: 'audio/adts', type: 'audio', id: 0, sequenceNumber: 0, isAAC: true, samples: [], len: 0, manifestCodec: audioCodec, duration: duration, inputTimeScale: 90000 };
    };
    AACDemuxer.prototype.resetTimeStamp = function () {
    };
    AACDemuxer.probe = function (data) {
        if (!data) {
            return false;
        }
        // Check for the ADTS sync word
        // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
        // Layer bits (position 14 and 15) in header should be always 0 for ADTS
        // More info https://wiki.multimedia.cx/index.php?title=ADTS
        var id3Data = id3_1.default.getID3Data(data, 0) || [];
        var offset = id3Data.length;
        for (var length_1 = data.length; offset < length_1; offset++) {
            if (ADTS.probe(data, offset)) {
                logger_1.logger.log('ADTS sync word found !');
                return true;
            }
        }
        return false;
    };
    // feed incoming data to the front of the parsing pipeline
    AACDemuxer.prototype.append = function (data, timeOffset, contiguous, accurateTimeOffset) {
        var track = this._audioTrack;
        var id3Data = id3_1.default.getID3Data(data, 0) || [];
        var timestamp = id3_1.default.getTimeStamp(id3Data);
        var pts = Number.isFinite(timestamp) ? timestamp * 90 : timeOffset * 90000;
        var frameIndex = 0;
        var stamp = pts;
        var length = data.length;
        var offset = id3Data.length;
        var id3Samples = [{ pts: stamp, dts: stamp, data: id3Data }];
        while (offset < length - 1) {
            if (ADTS.isHeader(data, offset) && (offset + 5) < length) {
                ADTS.initTrackConfig(track, this.observer, data, offset, track.manifestCodec);
                var frame = ADTS.appendFrame(track, data, offset, pts, frameIndex);
                if (frame) {
                    offset += frame.length;
                    stamp = frame.sample.pts;
                    frameIndex++;
                }
                else {
                    logger_1.logger.log('Unable to parse AAC frame');
                    break;
                }
            }
            else if (id3_1.default.isHeader(data, offset)) {
                id3Data = id3_1.default.getID3Data(data, offset);
                id3Samples.push({ pts: stamp, dts: stamp, data: id3Data });
                offset += id3Data.length;
            }
            else {
                // nothing found, keep looking
                offset++;
            }
        }
        this.remuxer.remux(track, { samples: [] }, { samples: id3Samples, inputTimeScale: 90000 }, { samples: [] }, timeOffset, contiguous, accurateTimeOffset);
    };
    AACDemuxer.prototype.destroy = function () {
    };
    return AACDemuxer;
}());
exports.default = AACDemuxer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/demux/adts.js":
/*!***************************!*\
  !*** ./src/demux/adts.js ***!
  \***************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 *  ADTS parser helper
 */
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
function getAudioConfig(observer, data, offset, audioCodec) {
    var adtsObjectType, // :int
    adtsSampleingIndex, // :int
    adtsExtensionSampleingIndex, // :int
    adtsChanelConfig, // :int
    config, userAgent = navigator.userAgent.toLowerCase(), manifestCodec = audioCodec, adtsSampleingRates = [
        96000, 88200,
        64000, 48000,
        44100, 32000,
        24000, 22050,
        16000, 12000,
        11025, 8000,
        7350
    ];
    // byte 2
    adtsObjectType = ((data[offset + 2] & 0xC0) >>> 6) + 1;
    adtsSampleingIndex = ((data[offset + 2] & 0x3C) >>> 2);
    if (adtsSampleingIndex > adtsSampleingRates.length - 1) {
        observer.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.MEDIA_ERROR, details: errors_1.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: "invalid ADTS sampling index:" + adtsSampleingIndex });
        return;
    }
    adtsChanelConfig = ((data[offset + 2] & 0x01) << 2);
    // byte 3
    adtsChanelConfig |= ((data[offset + 3] & 0xC0) >>> 6);
    logger_1.logger.log("manifest codec:" + audioCodec + ",ADTS data:type:" + adtsObjectType + ",sampleingIndex:" + adtsSampleingIndex + "[" + adtsSampleingRates[adtsSampleingIndex] + "Hz],channelConfig:" + adtsChanelConfig);
    // firefox: freq less than 24kHz = AAC SBR (HE-AAC)
    if (/firefox/i.test(userAgent)) {
        if (adtsSampleingIndex >= 6) {
            adtsObjectType = 5;
            config = new Array(4);
            // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
            // there is a factor 2 between frame sample rate and output sample rate
            // multiply frequency by 2 (see table below, equivalent to substract 3)
            adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
        }
        else {
            adtsObjectType = 2;
            config = new Array(2);
            adtsExtensionSampleingIndex = adtsSampleingIndex;
        }
        // Android : always use AAC
    }
    else if (userAgent.indexOf('android') !== -1) {
        adtsObjectType = 2;
        config = new Array(2);
        adtsExtensionSampleingIndex = adtsSampleingIndex;
    }
    else {
        /*  for other browsers (Chrome/Vivaldi/Opera ...)
            always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)
        */
        adtsObjectType = 5;
        config = new Array(4);
        // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)
        if ((audioCodec && ((audioCodec.indexOf('mp4a.40.29') !== -1) ||
            (audioCodec.indexOf('mp4a.40.5') !== -1))) ||
            (!audioCodec && adtsSampleingIndex >= 6)) {
            // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
            // there is a factor 2 between frame sample rate and output sample rate
            // multiply frequency by 2 (see table below, equivalent to substract 3)
            adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
        }
        else {
            // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)
            // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.
            if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && ((adtsSampleingIndex >= 6 && adtsChanelConfig === 1) ||
                /vivaldi/i.test(userAgent)) ||
                (!audioCodec && adtsChanelConfig === 1)) {
                adtsObjectType = 2;
                config = new Array(2);
            }
            adtsExtensionSampleingIndex = adtsSampleingIndex;
        }
    }
    /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config
        ISO 14496-3 (AAC).pdf - Table 1.13 — Syntax of AudioSpecificConfig()
      Audio Profile / Audio Object Type
      0: Null
      1: AAC Main
      2: AAC LC (Low Complexity)
      3: AAC SSR (Scalable Sample Rate)
      4: AAC LTP (Long Term Prediction)
      5: SBR (Spectral Band Replication)
      6: AAC Scalable
     sampling freq
      0: 96000 Hz
      1: 88200 Hz
      2: 64000 Hz
      3: 48000 Hz
      4: 44100 Hz
      5: 32000 Hz
      6: 24000 Hz
      7: 22050 Hz
      8: 16000 Hz
      9: 12000 Hz
      10: 11025 Hz
      11: 8000 Hz
      12: 7350 Hz
      13: Reserved
      14: Reserved
      15: frequency is written explictly
      Channel Configurations
      These are the channel configurations:
      0: Defined in AOT Specifc Config
      1: 1 channel: front-center
      2: 2 channels: front-left, front-right
    */
    // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1
    config[0] = adtsObjectType << 3;
    // samplingFrequencyIndex
    config[0] |= (adtsSampleingIndex & 0x0E) >> 1;
    config[1] |= (adtsSampleingIndex & 0x01) << 7;
    // channelConfiguration
    config[1] |= adtsChanelConfig << 3;
    if (adtsObjectType === 5) {
        // adtsExtensionSampleingIndex
        config[1] |= (adtsExtensionSampleingIndex & 0x0E) >> 1;
        config[2] = (adtsExtensionSampleingIndex & 0x01) << 7;
        // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???
        //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc
        config[2] |= 2 << 2;
        config[3] = 0;
    }
    return { config: config, samplerate: adtsSampleingRates[adtsSampleingIndex], channelCount: adtsChanelConfig, codec: ('mp4a.40.' + adtsObjectType), manifestCodec: manifestCodec };
}
exports.getAudioConfig = getAudioConfig;
function isHeaderPattern(data, offset) {
    return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;
}
exports.isHeaderPattern = isHeaderPattern;
function getHeaderLength(data, offset) {
    return (data[offset + 1] & 0x01 ? 7 : 9);
}
exports.getHeaderLength = getHeaderLength;
function getFullFrameLength(data, offset) {
    return ((data[offset + 3] & 0x03) << 11) |
        (data[offset + 4] << 3) |
        ((data[offset + 5] & 0xE0) >>> 5);
}
exports.getFullFrameLength = getFullFrameLength;
function isHeader(data, offset) {
    // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
    // Layer bits (position 14 and 15) in header should be always 0 for ADTS
    // More info https://wiki.multimedia.cx/index.php?title=ADTS
    if (offset + 1 < data.length && isHeaderPattern(data, offset)) {
        return true;
    }
    return false;
}
exports.isHeader = isHeader;
function probe(data, offset) {
    // same as isHeader but we also check that ADTS frame follows last ADTS frame
    // or end of data is reached
    if (offset + 1 < data.length && isHeaderPattern(data, offset)) {
        // ADTS header Length
        var headerLength = getHeaderLength(data, offset);
        // ADTS frame Length
        var frameLength = headerLength;
        if (offset + 5 < data.length) {
            frameLength = getFullFrameLength(data, offset);
        }
        var newOffset = offset + frameLength;
        if (newOffset === data.length || (newOffset + 1 < data.length && isHeaderPattern(data, newOffset))) {
            return true;
        }
    }
    return false;
}
exports.probe = probe;
function initTrackConfig(track, observer, data, offset, audioCodec) {
    if (!track.samplerate) {
        var config = getAudioConfig(observer, data, offset, audioCodec);
        track.config = config.config;
        track.samplerate = config.samplerate;
        track.channelCount = config.channelCount;
        track.codec = config.codec;
        track.manifestCodec = config.manifestCodec;
        logger_1.logger.log("parsed codec:" + track.codec + ",rate:" + config.samplerate + ",nb channel:" + config.channelCount);
    }
}
exports.initTrackConfig = initTrackConfig;
function getFrameDuration(samplerate) {
    return 1024 * 90000 / samplerate;
}
exports.getFrameDuration = getFrameDuration;
function parseFrameHeader(data, offset, pts, frameIndex, frameDuration) {
    var headerLength, frameLength, stamp;
    var length = data.length;
    // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
    headerLength = getHeaderLength(data, offset);
    // retrieve frame size
    frameLength = getFullFrameLength(data, offset);
    frameLength -= headerLength;
    if ((frameLength > 0) && ((offset + headerLength + frameLength) <= length)) {
        stamp = pts + frameIndex * frameDuration;
        // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
        return { headerLength: headerLength, frameLength: frameLength, stamp: stamp };
    }
    return undefined;
}
exports.parseFrameHeader = parseFrameHeader;
function appendFrame(track, data, offset, pts, frameIndex) {
    var frameDuration = getFrameDuration(track.samplerate);
    var header = parseFrameHeader(data, offset, pts, frameIndex, frameDuration);
    if (header) {
        var stamp = header.stamp;
        var headerLength = header.headerLength;
        var frameLength = header.frameLength;
        // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
        var aacSample = {
            unit: data.subarray(offset + headerLength, offset + headerLength + frameLength),
            pts: stamp,
            dts: stamp
        };
        track.samples.push(aacSample);
        track.len += frameLength;
        return { sample: aacSample, length: frameLength + headerLength };
    }
    return undefined;
}
exports.appendFrame = appendFrame;


/***/ }),

/***/ "./src/demux/demuxer-inline.js":
/*!*************************************!*\
  !*** ./src/demux/demuxer-inline.js ***!
  \*************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 *
 * inline demuxer: probe fragments and instantiate
 * appropriate demuxer depending on content type (TSDemuxer, AACDemuxer, ...)
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var decrypter_1 = __webpack_require__(/*! ../crypt/decrypter */ "./src/crypt/decrypter.js");
var aacdemuxer_1 = __webpack_require__(/*! ../demux/aacdemuxer */ "./src/demux/aacdemuxer.js");
var mp4demuxer_1 = __webpack_require__(/*! ../demux/mp4demuxer */ "./src/demux/mp4demuxer.js");
var tsdemuxer_1 = __webpack_require__(/*! ../demux/tsdemuxer */ "./src/demux/tsdemuxer.js");
var mp3demuxer_1 = __webpack_require__(/*! ../demux/mp3demuxer */ "./src/demux/mp3demuxer.js");
var mp4_remuxer_1 = __webpack_require__(/*! ../remux/mp4-remuxer */ "./src/remux/mp4-remuxer.js");
var passthrough_remuxer_1 = __webpack_require__(/*! ../remux/passthrough-remuxer */ "./src/remux/passthrough-remuxer.js");
var get_self_scope_1 = __webpack_require__(/*! ../utils/get-self-scope */ "./src/utils/get-self-scope.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
// see https://stackoverflow.com/a/11237259/589493
var global = get_self_scope_1.getSelfScope(); // safeguard for code that might run both on worker and main thread
var now;
// performance.now() not available on WebWorker, at least on Safari Desktop
try {
    now = global.performance.now.bind(global.performance);
}
catch (err) {
    logger_1.logger.debug('Unable to use Performance API on this environment');
    now = global.Date.now;
}
var DemuxerInline = /** @class */ (function () {
    function DemuxerInline(observer, typeSupported, config, vendor) {
        this.observer = observer;
        this.typeSupported = typeSupported;
        this.config = config;
        this.vendor = vendor;
    }
    DemuxerInline.prototype.destroy = function () {
        var demuxer = this.demuxer;
        if (demuxer) {
            demuxer.destroy();
        }
    };
    DemuxerInline.prototype.push = function (data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {
        var _this = this;
        if ((data.byteLength > 0) && (decryptdata != null) && (decryptdata.key != null) && (decryptdata.method === 'AES-128')) {
            var decrypter = this.decrypter;
            if (decrypter == null) {
                decrypter = this.decrypter = new decrypter_1.default(this.observer, this.config);
            }
            var startTime_1 = now();
            decrypter.decrypt(data, decryptdata.key.buffer, decryptdata.iv.buffer, function (decryptedData) {
                var endTime = now();
                _this.observer.trigger(events_1.default.FRAG_DECRYPTED, { stats: { tstart: startTime_1, tdecrypt: endTime } });
                _this.pushDecrypted(new Uint8Array(decryptedData), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
            });
        }
        else {
            this.pushDecrypted(new Uint8Array(data), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
        }
    };
    DemuxerInline.prototype.pushDecrypted = function (data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {
        var demuxer = this.demuxer;
        if (!demuxer ||
            // in case of continuity change, or track switch
            // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)
            // so let's check that current demuxer is still valid
            ((discontinuity || trackSwitch) && !this.probe(data))) {
            var observer = this.observer;
            var typeSupported = this.typeSupported;
            var config = this.config;
            // probing order is TS/AAC/MP3/MP4
            var muxConfig = [
                { demux: tsdemuxer_1.default, remux: mp4_remuxer_1.default },
                { demux: mp4demuxer_1.default, remux: passthrough_remuxer_1.default },
                { demux: aacdemuxer_1.default, remux: mp4_remuxer_1.default },
                { demux: mp3demuxer_1.default, remux: mp4_remuxer_1.default }
            ];
            // probe for content type
            for (var i = 0, len = muxConfig.length; i < len; i++) {
                var mux = muxConfig[i];
                var probe = mux.demux.probe;
                if (probe(data)) {
                    var remuxer_1 = this.remuxer = new mux.remux(observer, config, typeSupported, this.vendor);
                    demuxer = new mux.demux(observer, remuxer_1, config, typeSupported);
                    this.probe = probe;
                    break;
                }
            }
            if (!demuxer) {
                observer.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.MEDIA_ERROR, details: errors_1.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'no demux matching with content found' });
                return;
            }
            this.demuxer = demuxer;
        }
        var remuxer = this.remuxer;
        if (discontinuity || trackSwitch) {
            demuxer.resetInitSegment(initSegment, audioCodec, videoCodec, duration);
            remuxer.resetInitSegment();
        }
        if (discontinuity) {
            demuxer.resetTimeStamp(defaultInitPTS);
            remuxer.resetTimeStamp(defaultInitPTS);
        }
        if (typeof demuxer.setDecryptData === 'function') {
            demuxer.setDecryptData(decryptdata);
        }
        demuxer.append(data, timeOffset, contiguous, accurateTimeOffset);
    };
    return DemuxerInline;
}());
exports.default = DemuxerInline;


/***/ }),

/***/ "./src/demux/demuxer-worker.js":
/*!*************************************!*\
  !*** ./src/demux/demuxer-worker.js ***!
  \*************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* demuxer web worker.
 *  - listen to worker message, and trigger DemuxerInline upon reception of Fragments.
 *  - provides MP4 Boxes back to main thread using [transferable objects](https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast) in order to minimize message passing overhead.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var demuxer_inline_1 = __webpack_require__(/*! ../demux/demuxer-inline */ "./src/demux/demuxer-inline.js");
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var events_2 = __webpack_require__(/*! events */ "./node_modules/node-libs-browser/node_modules/events/events.js");
var DemuxerWorker = function (self) {
    // observer setup
    var observer = new events_2.EventEmitter();
    observer.trigger = function trigger(event) {
        var data = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            data[_i - 1] = arguments[_i];
        }
        observer.emit.apply(observer, [event, event].concat(data));
    };
    observer.off = function off(event) {
        var data = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            data[_i - 1] = arguments[_i];
        }
        observer.removeListener.apply(observer, [event].concat(data));
    };
    var forwardMessage = function (ev, data) {
        self.postMessage({ event: ev, data: data });
    };
    self.addEventListener('message', function (ev) {
        var data = ev.data;
        // console.log('demuxer cmd:' + data.cmd);
        switch (data.cmd) {
            case 'init':
                var config = JSON.parse(data.config);
                self.demuxer = new demuxer_inline_1.default(observer, data.typeSupported, config, data.vendor);
                logger_1.enableLogs(config.debug);
                // signal end of worker init
                forwardMessage('init', null);
                break;
            case 'demux':
                self.demuxer.push(data.data, data.decryptdata, data.initSegment, data.audioCodec, data.videoCodec, data.timeOffset, data.discontinuity, data.trackSwitch, data.contiguous, data.duration, data.accurateTimeOffset, data.defaultInitPTS);
                break;
            default:
                break;
        }
    });
    // forward events to main thread
    observer.on(events_1.default.FRAG_DECRYPTED, forwardMessage);
    observer.on(events_1.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);
    observer.on(events_1.default.FRAG_PARSED, forwardMessage);
    observer.on(events_1.default.ERROR, forwardMessage);
    observer.on(events_1.default.FRAG_PARSING_METADATA, forwardMessage);
    observer.on(events_1.default.FRAG_PARSING_USERDATA, forwardMessage);
    observer.on(events_1.default.INIT_PTS_FOUND, forwardMessage);
    // special case for FRAG_PARSING_DATA: pass data1/data2 as transferable object (no copy)
    observer.on(events_1.default.FRAG_PARSING_DATA, function (ev, data) {
        var transferable = [];
        var message = { event: ev, data: data };
        if (data.data1) {
            message.data1 = data.data1.buffer;
            transferable.push(data.data1.buffer);
            delete data.data1;
        }
        if (data.data2) {
            message.data2 = data.data2.buffer;
            transferable.push(data.data2.buffer);
            delete data.data2;
        }
        self.postMessage(message, transferable);
    });
};
exports.default = DemuxerWorker;


/***/ }),

/***/ "./src/demux/demuxer.js":
/*!******************************!*\
  !*** ./src/demux/demuxer.js ***!
  \******************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
Object.defineProperty(exports, "__esModule", { value: true });
var work = __webpack_require__(/*! webworkify-webpack */ "./node_modules/webworkify-webpack/index.js");
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var demuxer_inline_1 = __webpack_require__(/*! ../demux/demuxer-inline */ "./src/demux/demuxer-inline.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var mediasource_helper_1 = __webpack_require__(/*! ../utils/mediasource-helper */ "./src/utils/mediasource-helper.js");
var get_self_scope_1 = __webpack_require__(/*! ../utils/get-self-scope */ "./src/utils/get-self-scope.js");
var observer_1 = __webpack_require__(/*! ../observer */ "./src/observer.js");
// see https://stackoverflow.com/a/11237259/589493
var global = get_self_scope_1.getSelfScope(); // safeguard for code that might run both on worker and main thread
var MediaSource = mediasource_helper_1.getMediaSource();
var Demuxer = /** @class */ (function () {
    function Demuxer(hls, id) {
        var _this = this;
        this.hls = hls;
        this.id = id;
        var observer = this.observer = new observer_1.Observer();
        var config = hls.config;
        var forwardMessage = function (ev, data) {
            data = data || {};
            data.frag = _this.frag;
            data.id = _this.id;
            hls.trigger(ev, data);
        };
        // forward events to main thread
        observer.on(events_1.default.FRAG_DECRYPTED, forwardMessage);
        observer.on(events_1.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);
        observer.on(events_1.default.FRAG_PARSING_DATA, forwardMessage);
        observer.on(events_1.default.FRAG_PARSED, forwardMessage);
        observer.on(events_1.default.ERROR, forwardMessage);
        observer.on(events_1.default.FRAG_PARSING_METADATA, forwardMessage);
        observer.on(events_1.default.FRAG_PARSING_USERDATA, forwardMessage);
        observer.on(events_1.default.INIT_PTS_FOUND, forwardMessage);
        var typeSupported = {
            mp4: MediaSource.isTypeSupported('video/mp4'),
            mpeg: MediaSource.isTypeSupported('audio/mpeg'),
            mp3: MediaSource.isTypeSupported('audio/mp4; codecs="mp3"')
        };
        // navigator.vendor is not always available in Web Worker
        // refer to https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/navigator
        var vendor = navigator.vendor;
        if (config.enableWorker && (typeof (Worker) !== 'undefined')) {
            logger_1.logger.log('demuxing in webworker');
            var w = void 0;
            try {
                w = this.w = work(/*require.resolve*/(/*! ../demux/demuxer-worker.js */ "./src/demux/demuxer-worker.js"));
                this.onwmsg = this.onWorkerMessage.bind(this);
                w.addEventListener('message', this.onwmsg);
                w.onerror = function (event) {
                    hls.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.OTHER_ERROR, details: errors_1.ErrorDetails.INTERNAL_EXCEPTION, fatal: true, event: 'demuxerWorker', err: { message: event.message + ' (' + event.filename + ':' + event.lineno + ')' } });
                };
                w.postMessage({ cmd: 'init', typeSupported: typeSupported, vendor: vendor, id: id, config: JSON.stringify(config) });
            }
            catch (err) {
                logger_1.logger.warn('Error in worker:', err);
                logger_1.logger.error('Error while initializing DemuxerWorker, fallback on DemuxerInline');
                if (w) {
                    // revoke the Object URL that was used to create demuxer worker, so as not to leak it
                    global.URL.revokeObjectURL(w.objectURL);
                }
                this.demuxer = new demuxer_inline_1.default(observer, typeSupported, config, vendor);
                this.w = undefined;
            }
        }
        else {
            this.demuxer = new demuxer_inline_1.default(observer, typeSupported, config, vendor);
        }
    }
    Demuxer.prototype.destroy = function () {
        var w = this.w;
        if (w) {
            w.removeEventListener('message', this.onwmsg);
            w.terminate();
            this.w = null;
        }
        else {
            var demuxer = this.demuxer;
            if (demuxer) {
                demuxer.destroy();
                this.demuxer = null;
            }
        }
        var observer = this.observer;
        if (observer) {
            observer.removeAllListeners();
            this.observer = null;
        }
    };
    Demuxer.prototype.push = function (data, initSegment, audioCodec, videoCodec, frag, duration, accurateTimeOffset, defaultInitPTS) {
        var w = this.w;
        var timeOffset = Number.isFinite(frag.startPTS) ? frag.startPTS : frag.start;
        var decryptdata = frag.decryptdata;
        var lastFrag = this.frag;
        var discontinuity = !(lastFrag && (frag.cc === lastFrag.cc));
        var trackSwitch = !(lastFrag && (frag.level === lastFrag.level));
        var nextSN = lastFrag && (frag.sn === (lastFrag.sn + 1));
        var contiguous = !trackSwitch && nextSN;
        if (discontinuity) {
            logger_1.logger.log(this.id + ":discontinuity detected");
        }
        if (trackSwitch) {
            logger_1.logger.log(this.id + ":switch detected");
        }
        this.frag = frag;
        if (w) {
            // post fragment payload as transferable objects for ArrayBuffer (no copy)
            w.postMessage({ cmd: 'demux', data: data, decryptdata: decryptdata, initSegment: initSegment, audioCodec: audioCodec, videoCodec: videoCodec, timeOffset: timeOffset, discontinuity: discontinuity, trackSwitch: trackSwitch, contiguous: contiguous, duration: duration, accurateTimeOffset: accurateTimeOffset, defaultInitPTS: defaultInitPTS }, data instanceof ArrayBuffer ? [data] : []);
        }
        else {
            var demuxer = this.demuxer;
            if (demuxer) {
                demuxer.push(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
            }
        }
    };
    Demuxer.prototype.onWorkerMessage = function (ev) {
        var data = ev.data, hls = this.hls;
        switch (data.event) {
            case 'init':
                // revoke the Object URL that was used to create demuxer worker, so as not to leak it
                global.URL.revokeObjectURL(this.w.objectURL);
                break;
            // special case for FRAG_PARSING_DATA: data1 and data2 are transferable objects
            case events_1.default.FRAG_PARSING_DATA:
                data.data.data1 = new Uint8Array(data.data1);
                if (data.data2) {
                    data.data.data2 = new Uint8Array(data.data2);
                }
            /* falls through */
            default:
                data.data = data.data || {};
                data.data.frag = this.frag;
                data.data.id = this.id;
                hls.trigger(data.event, data.data);
                break;
        }
    };
    return Demuxer;
}());
exports.default = Demuxer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/demux/exp-golomb.js":
/*!*********************************!*\
  !*** ./src/demux/exp-golomb.js ***!
  \*********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.
*/
Object.defineProperty(exports, "__esModule", { value: true });
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var ExpGolomb = /** @class */ (function () {
    function ExpGolomb(data) {
        this.data = data;
        // the number of bytes left to examine in this.data
        this.bytesAvailable = data.byteLength;
        // the current word being examined
        this.word = 0; // :uint
        // the number of bits left to examine in the current word
        this.bitsAvailable = 0; // :uint
    }
    // ():void
    ExpGolomb.prototype.loadWord = function () {
        var data = this.data, bytesAvailable = this.bytesAvailable, position = data.byteLength - bytesAvailable, workingBytes = new Uint8Array(4), availableBytes = Math.min(4, bytesAvailable);
        if (availableBytes === 0) {
            throw new Error('no bytes available');
        }
        workingBytes.set(data.subarray(position, position + availableBytes));
        this.word = new DataView(workingBytes.buffer).getUint32(0);
        // track the amount of this.data that has been processed
        this.bitsAvailable = availableBytes * 8;
        this.bytesAvailable -= availableBytes;
    };
    // (count:int):void
    ExpGolomb.prototype.skipBits = function (count) {
        var skipBytes; // :int
        if (this.bitsAvailable > count) {
            this.word <<= count;
            this.bitsAvailable -= count;
        }
        else {
            count -= this.bitsAvailable;
            skipBytes = count >> 3;
            count -= (skipBytes >> 3);
            this.bytesAvailable -= skipBytes;
            this.loadWord();
            this.word <<= count;
            this.bitsAvailable -= count;
        }
    };
    // (size:int):uint
    ExpGolomb.prototype.readBits = function (size) {
        var bits = Math.min(this.bitsAvailable, size), // :uint
        valu = this.word >>> (32 - bits); // :uint
        if (size > 32) {
            logger_1.logger.error('Cannot read more than 32 bits at a time');
        }
        this.bitsAvailable -= bits;
        if (this.bitsAvailable > 0) {
            this.word <<= bits;
        }
        else if (this.bytesAvailable > 0) {
            this.loadWord();
        }
        bits = size - bits;
        if (bits > 0 && this.bitsAvailable) {
            return valu << bits | this.readBits(bits);
        }
        else {
            return valu;
        }
    };
    // ():uint
    ExpGolomb.prototype.skipLZ = function () {
        var leadingZeroCount; // :uint
        for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
            if ((this.word & (0x80000000 >>> leadingZeroCount)) !== 0) {
                // the first bit of working word is 1
                this.word <<= leadingZeroCount;
                this.bitsAvailable -= leadingZeroCount;
                return leadingZeroCount;
            }
        }
        // we exhausted word and still have not found a 1
        this.loadWord();
        return leadingZeroCount + this.skipLZ();
    };
    // ():void
    ExpGolomb.prototype.skipUEG = function () {
        this.skipBits(1 + this.skipLZ());
    };
    // ():void
    ExpGolomb.prototype.skipEG = function () {
        this.skipBits(1 + this.skipLZ());
    };
    // ():uint
    ExpGolomb.prototype.readUEG = function () {
        var clz = this.skipLZ(); // :uint
        return this.readBits(clz + 1) - 1;
    };
    // ():int
    ExpGolomb.prototype.readEG = function () {
        var valu = this.readUEG(); // :int
        if (0x01 & valu) {
            // the number is odd if the low order bit is set
            return (1 + valu) >>> 1; // add 1 to make it even, and divide by 2
        }
        else {
            return -1 * (valu >>> 1); // divide by two then make it negative
        }
    };
    // Some convenience functions
    // :Boolean
    ExpGolomb.prototype.readBoolean = function () {
        return this.readBits(1) === 1;
    };
    // ():int
    ExpGolomb.prototype.readUByte = function () {
        return this.readBits(8);
    };
    // ():int
    ExpGolomb.prototype.readUShort = function () {
        return this.readBits(16);
    };
    // ():int
    ExpGolomb.prototype.readUInt = function () {
        return this.readBits(32);
    };
    /**
     * Advance the ExpGolomb decoder past a scaling list. The scaling
     * list is optionally transmitted as part of a sequence parameter
     * set and is not relevant to transmuxing.
     * @param count {number} the number of entries in this scaling list
     * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
     */
    ExpGolomb.prototype.skipScalingList = function (count) {
        var lastScale = 8, nextScale = 8, j, deltaScale;
        for (j = 0; j < count; j++) {
            if (nextScale !== 0) {
                deltaScale = this.readEG();
                nextScale = (lastScale + deltaScale + 256) % 256;
            }
            lastScale = (nextScale === 0) ? lastScale : nextScale;
        }
    };
    /**
     * Read a sequence parameter set and return some interesting video
     * properties. A sequence parameter set is the H264 metadata that
     * describes the properties of upcoming video frames.
     * @param data {Uint8Array} the bytes of a sequence parameter set
     * @return {object} an object with configuration parsed from the
     * sequence parameter set, including the dimensions of the
     * associated video frames.
     */
    ExpGolomb.prototype.readSPS = function () {
        var frameCropLeftOffset = 0, frameCropRightOffset = 0, frameCropTopOffset = 0, frameCropBottomOffset = 0, profileIdc, profileCompat, levelIdc, numRefFramesInPicOrderCntCycle, picWidthInMbsMinus1, picHeightInMapUnitsMinus1, frameMbsOnlyFlag, scalingListCount, i, readUByte = this.readUByte.bind(this), readBits = this.readBits.bind(this), readUEG = this.readUEG.bind(this), readBoolean = this.readBoolean.bind(this), skipBits = this.skipBits.bind(this), skipEG = this.skipEG.bind(this), skipUEG = this.skipUEG.bind(this), skipScalingList = this.skipScalingList.bind(this);
        readUByte();
        profileIdc = readUByte(); // profile_idc
        profileCompat = readBits(5); // constraint_set[0-4]_flag, u(5)
        skipBits(3); // reserved_zero_3bits u(3),
        levelIdc = readUByte(); // level_idc u(8)
        skipUEG(); // seq_parameter_set_id
        // some profiles have more optional data we don't need
        if (profileIdc === 100 ||
            profileIdc === 110 ||
            profileIdc === 122 ||
            profileIdc === 244 ||
            profileIdc === 44 ||
            profileIdc === 83 ||
            profileIdc === 86 ||
            profileIdc === 118 ||
            profileIdc === 128) {
            var chromaFormatIdc = readUEG();
            if (chromaFormatIdc === 3) {
                skipBits(1);
            } // separate_colour_plane_flag
            skipUEG(); // bit_depth_luma_minus8
            skipUEG(); // bit_depth_chroma_minus8
            skipBits(1); // qpprime_y_zero_transform_bypass_flag
            if (readBoolean()) { // seq_scaling_matrix_present_flag
                scalingListCount = (chromaFormatIdc !== 3) ? 8 : 12;
                for (i = 0; i < scalingListCount; i++) {
                    if (readBoolean()) { // seq_scaling_list_present_flag[ i ]
                        if (i < 6) {
                            skipScalingList(16);
                        }
                        else {
                            skipScalingList(64);
                        }
                    }
                }
            }
        }
        skipUEG(); // log2_max_frame_num_minus4
        var picOrderCntType = readUEG();
        if (picOrderCntType === 0) {
            readUEG(); // log2_max_pic_order_cnt_lsb_minus4
        }
        else if (picOrderCntType === 1) {
            skipBits(1); // delta_pic_order_always_zero_flag
            skipEG(); // offset_for_non_ref_pic
            skipEG(); // offset_for_top_to_bottom_field
            numRefFramesInPicOrderCntCycle = readUEG();
            for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
                skipEG();
            } // offset_for_ref_frame[ i ]
        }
        skipUEG(); // max_num_ref_frames
        skipBits(1); // gaps_in_frame_num_value_allowed_flag
        picWidthInMbsMinus1 = readUEG();
        picHeightInMapUnitsMinus1 = readUEG();
        frameMbsOnlyFlag = readBits(1);
        if (frameMbsOnlyFlag === 0) {
            skipBits(1);
        } // mb_adaptive_frame_field_flag
        skipBits(1); // direct_8x8_inference_flag
        if (readBoolean()) { // frame_cropping_flag
            frameCropLeftOffset = readUEG();
            frameCropRightOffset = readUEG();
            frameCropTopOffset = readUEG();
            frameCropBottomOffset = readUEG();
        }
        var pixelRatio = [1, 1];
        if (readBoolean()) {
            // vui_parameters_present_flag
            if (readBoolean()) {
                // aspect_ratio_info_present_flag
                var aspectRatioIdc = readUByte();
                switch (aspectRatioIdc) {
                    case 1:
                        pixelRatio = [1, 1];
                        break;
                    case 2:
                        pixelRatio = [12, 11];
                        break;
                    case 3:
                        pixelRatio = [10, 11];
                        break;
                    case 4:
                        pixelRatio = [16, 11];
                        break;
                    case 5:
                        pixelRatio = [40, 33];
                        break;
                    case 6:
                        pixelRatio = [24, 11];
                        break;
                    case 7:
                        pixelRatio = [20, 11];
                        break;
                    case 8:
                        pixelRatio = [32, 11];
                        break;
                    case 9:
                        pixelRatio = [80, 33];
                        break;
                    case 10:
                        pixelRatio = [18, 11];
                        break;
                    case 11:
                        pixelRatio = [15, 11];
                        break;
                    case 12:
                        pixelRatio = [64, 33];
                        break;
                    case 13:
                        pixelRatio = [160, 99];
                        break;
                    case 14:
                        pixelRatio = [4, 3];
                        break;
                    case 15:
                        pixelRatio = [3, 2];
                        break;
                    case 16:
                        pixelRatio = [2, 1];
                        break;
                    case 255: {
                        pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];
                        break;
                    }
                }
            }
        }
        return {
            width: Math.ceil((((picWidthInMbsMinus1 + 1) * 16) - frameCropLeftOffset * 2 - frameCropRightOffset * 2)),
            height: ((2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16) - ((frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset)),
            pixelRatio: pixelRatio
        };
    };
    ExpGolomb.prototype.readSliceType = function () {
        // skip NALu type
        this.readUByte();
        // discard first_mb_in_slice
        this.readUEG();
        // return slice_type
        return this.readUEG();
    };
    return ExpGolomb;
}());
exports.default = ExpGolomb;


/***/ }),

/***/ "./src/demux/id3.js":
/*!**************************!*\
  !*** ./src/demux/id3.js ***!
  \**************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * ID3 parser
 */
var ID3 = /** @class */ (function () {
    function ID3() {
    }
    /**
     * Returns true if an ID3 header can be found at offset in data
     * @param {Uint8Array} data - The data to search in
     * @param {number} offset - The offset at which to start searching
     * @return {boolean} - True if an ID3 header is found
     */
    ID3.isHeader = function (data, offset) {
        /*
        * http://id3.org/id3v2.3.0
        * [0]     = 'I'
        * [1]     = 'D'
        * [2]     = '3'
        * [3,4]   = {Version}
        * [5]     = {Flags}
        * [6-9]   = {ID3 Size}
        *
        * An ID3v2 tag can be detected with the following pattern:
        *  $49 44 33 yy yy xx zz zz zz zz
        * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80
        */
        if (offset + 10 <= data.length) {
            // look for 'ID3' identifier
            if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {
                // check version is within range
                if (data[offset + 3] < 0xFF && data[offset + 4] < 0xFF) {
                    // check size is within range
                    if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {
                        return true;
                    }
                }
            }
        }
        return false;
    };
    /**
     * Returns true if an ID3 footer can be found at offset in data
     * @param {Uint8Array} data - The data to search in
     * @param {number} offset - The offset at which to start searching
     * @return {boolean} - True if an ID3 footer is found
     */
    ID3.isFooter = function (data, offset) {
        /*
        * The footer is a copy of the header, but with a different identifier
        */
        if (offset + 10 <= data.length) {
            // look for '3DI' identifier
            if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {
                // check version is within range
                if (data[offset + 3] < 0xFF && data[offset + 4] < 0xFF) {
                    // check size is within range
                    if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {
                        return true;
                    }
                }
            }
        }
        return false;
    };
    /**
     * Returns any adjacent ID3 tags found in data starting at offset, as one block of data
     * @param {Uint8Array} data - The data to search in
     * @param {number} offset - The offset at which to start searching
     * @return {Uint8Array} - The block of data containing any ID3 tags found
     */
    ID3.getID3Data = function (data, offset) {
        var front = offset;
        var length = 0;
        while (ID3.isHeader(data, offset)) {
            // ID3 header is 10 bytes
            length += 10;
            var size = ID3._readSize(data, offset + 6);
            length += size;
            if (ID3.isFooter(data, offset + 10)) {
                // ID3 footer is 10 bytes
                length += 10;
            }
            offset += length;
        }
        if (length > 0) {
            return data.subarray(front, front + length);
        }
        return undefined;
    };
    ID3._readSize = function (data, offset) {
        var size = 0;
        size = ((data[offset] & 0x7f) << 21);
        size |= ((data[offset + 1] & 0x7f) << 14);
        size |= ((data[offset + 2] & 0x7f) << 7);
        size |= (data[offset + 3] & 0x7f);
        return size;
    };
    /**
     * Searches for the Elementary Stream timestamp found in the ID3 data chunk
     * @param {Uint8Array} data - Block of data containing one or more ID3 tags
     * @return {number} - The timestamp
     */
    ID3.getTimeStamp = function (data) {
        var frames = ID3.getID3Frames(data);
        for (var i = 0; i < frames.length; i++) {
            var frame = frames[i];
            if (ID3.isTimeStampFrame(frame)) {
                return ID3._readTimeStamp(frame);
            }
        }
        return undefined;
    };
    /**
     * Returns true if the ID3 frame is an Elementary Stream timestamp frame
     * @param {ID3 frame} frame
     */
    ID3.isTimeStampFrame = function (frame) {
        return (frame && frame.key === 'PRIV' && frame.info === 'com.apple.streaming.transportStreamTimestamp');
    };
    ID3._getFrameData = function (data) {
        /*
        Frame ID       $xx xx xx xx (four characters)
        Size           $xx xx xx xx
        Flags          $xx xx
        */
        var type = String.fromCharCode(data[0], data[1], data[2], data[3]);
        var size = ID3._readSize(data, 4);
        // skip frame id, size, and flags
        var offset = 10;
        return { type: type, size: size, data: data.subarray(offset, offset + size) };
    };
    /**
     * Returns an array of ID3 frames found in all the ID3 tags in the id3Data
     * @param {Uint8Array} id3Data - The ID3 data containing one or more ID3 tags
     * @return {ID3 frame[]} - Array of ID3 frame objects
     */
    ID3.getID3Frames = function (id3Data) {
        var offset = 0;
        var frames = [];
        while (ID3.isHeader(id3Data, offset)) {
            var size = ID3._readSize(id3Data, offset + 6);
            // skip past ID3 header
            offset += 10;
            var end = offset + size;
            // loop through frames in the ID3 tag
            while (offset + 8 < end) {
                var frameData = ID3._getFrameData(id3Data.subarray(offset));
                var frame = ID3._decodeFrame(frameData);
                if (frame) {
                    frames.push(frame);
                }
                // skip frame header and frame data
                offset += frameData.size + 10;
            }
            if (ID3.isFooter(id3Data, offset)) {
                offset += 10;
            }
        }
        return frames;
    };
    ID3._decodeFrame = function (frame) {
        if (frame.type === 'PRIV') {
            return ID3._decodePrivFrame(frame);
        }
        else if (frame.type[0] === 'T') {
            return ID3._decodeTextFrame(frame);
        }
        else if (frame.type[0] === 'W') {
            return ID3._decodeURLFrame(frame);
        }
        return undefined;
    };
    ID3._readTimeStamp = function (timeStampFrame) {
        if (timeStampFrame.data.byteLength === 8) {
            var data = new Uint8Array(timeStampFrame.data);
            // timestamp is 33 bit expressed as a big-endian eight-octet number,
            // with the upper 31 bits set to zero.
            var pts33Bit = data[3] & 0x1;
            var timestamp = (data[4] << 23) +
                (data[5] << 15) +
                (data[6] << 7) +
                data[7];
            timestamp /= 45;
            if (pts33Bit) {
                timestamp += 47721858.84;
            } // 2^32 / 90
            return Math.round(timestamp);
        }
        return undefined;
    };
    ID3._decodePrivFrame = function (frame) {
        /*
        Format: <text string>\0<binary data>
        */
        if (frame.size < 2) {
            return undefined;
        }
        var owner = ID3._utf8ArrayToStr(frame.data, true);
        var privateData = new Uint8Array(frame.data.subarray(owner.length + 1));
        return { key: frame.type, info: owner, data: privateData.buffer };
    };
    ID3._decodeTextFrame = function (frame) {
        if (frame.size < 2) {
            return undefined;
        }
        if (frame.type === 'TXXX') {
            /*
            Format:
            [0]   = {Text Encoding}
            [1-?] = {Description}\0{Value}
            */
            var index = 1;
            var description = ID3._utf8ArrayToStr(frame.data.subarray(index));
            index += description.length + 1;
            var value = ID3._utf8ArrayToStr(frame.data.subarray(index));
            return { key: frame.type, info: description, data: value };
        }
        else {
            /*
            Format:
            [0]   = {Text Encoding}
            [1-?] = {Value}
            */
            var text = ID3._utf8ArrayToStr(frame.data.subarray(1));
            return { key: frame.type, data: text };
        }
    };
    ID3._decodeURLFrame = function (frame) {
        if (frame.type === 'WXXX') {
            /*
            Format:
            [0]   = {Text Encoding}
            [1-?] = {Description}\0{URL}
            */
            if (frame.size < 2) {
                return undefined;
            }
            var index = 1;
            var description = ID3._utf8ArrayToStr(frame.data.subarray(index));
            index += description.length + 1;
            var value = ID3._utf8ArrayToStr(frame.data.subarray(index));
            return { key: frame.type, info: description, data: value };
        }
        else {
            /*
            Format:
            [0-?] = {URL}
            */
            var url = ID3._utf8ArrayToStr(frame.data);
            return { key: frame.type, data: url };
        }
    };
    // http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197
    // http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt
    /* utf.js - UTF-8 <=> UTF-16 convertion
     *
     * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
     * Version: 1.0
     * LastModified: Dec 25 1999
     * This library is free.  You can redistribute it and/or modify it.
     */
    ID3._utf8ArrayToStr = function (array, exitOnNull) {
        if (exitOnNull === void 0) { exitOnNull = false; }
        var len = array.length;
        var c;
        var char2;
        var char3;
        var out = '';
        var i = 0;
        while (i < len) {
            c = array[i++];
            if (c === 0x00 && exitOnNull) {
                return out;
            }
            else if (c === 0x00 || c === 0x03) {
                // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it
                continue;
            }
            switch (c >> 4) {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    // 0xxxxxxx
                    out += String.fromCharCode(c);
                    break;
                case 12:
                case 13:
                    // 110x xxxx   10xx xxxx
                    char2 = array[i++];
                    out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));
                    break;
                case 14:
                    // 1110 xxxx  10xx xxxx  10xx xxxx
                    char2 = array[i++];
                    char3 = array[i++];
                    out += String.fromCharCode(((c & 0x0F) << 12) |
                        ((char2 & 0x3F) << 6) |
                        ((char3 & 0x3F) << 0));
                    break;
                default:
            }
        }
        return out;
    };
    return ID3;
}());
var utf8ArrayToStr = ID3._utf8ArrayToStr;
exports.utf8ArrayToStr = utf8ArrayToStr;
exports.default = ID3;


/***/ }),

/***/ "./src/demux/mp3demuxer.js":
/*!*********************************!*\
  !*** ./src/demux/mp3demuxer.js ***!
  \*********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * MP3 demuxer
 */
var id3_1 = __webpack_require__(/*! ../demux/id3 */ "./src/demux/id3.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var mpegaudio_1 = __webpack_require__(/*! ./mpegaudio */ "./src/demux/mpegaudio.js");
var MP3Demuxer = /** @class */ (function () {
    function MP3Demuxer(observer, remuxer, config) {
        this.observer = observer;
        this.config = config;
        this.remuxer = remuxer;
    }
    MP3Demuxer.prototype.resetInitSegment = function (initSegment, audioCodec, videoCodec, duration) {
        this._audioTrack = { container: 'audio/mpeg', type: 'audio', id: -1, sequenceNumber: 0, isAAC: false, samples: [], len: 0, manifestCodec: audioCodec, duration: duration, inputTimeScale: 90000 };
    };
    MP3Demuxer.prototype.resetTimeStamp = function () {
    };
    MP3Demuxer.probe = function (data) {
        // check if data contains ID3 timestamp and MPEG sync word
        var offset, length;
        var id3Data = id3_1.default.getID3Data(data, 0);
        if (id3Data && id3_1.default.getTimeStamp(id3Data) !== undefined) {
            // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1
            // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)
            // More info http://www.mp3-tech.org/programmer/frame_header.html
            for (offset = id3Data.length, length = Math.min(data.length - 1, offset + 100); offset < length; offset++) {
                if (mpegaudio_1.default.probe(data, offset)) {
                    logger_1.logger.log('MPEG Audio sync word found !');
                    return true;
                }
            }
        }
        return false;
    };
    // feed incoming data to the front of the parsing pipeline
    MP3Demuxer.prototype.append = function (data, timeOffset, contiguous, accurateTimeOffset) {
        var id3Data = id3_1.default.getID3Data(data, 0);
        var timestamp = id3_1.default.getTimeStamp(id3Data);
        var pts = timestamp ? 90 * timestamp : timeOffset * 90000;
        var offset = id3Data.length;
        var length = data.length;
        var frameIndex = 0, stamp = 0;
        var track = this._audioTrack;
        var id3Samples = [{ pts: pts, dts: pts, data: id3Data }];
        while (offset < length) {
            if (mpegaudio_1.default.isHeader(data, offset)) {
                var frame = mpegaudio_1.default.appendFrame(track, data, offset, pts, frameIndex);
                if (frame) {
                    offset += frame.length;
                    stamp = frame.sample.pts;
                    frameIndex++;
                }
                else {
                    // logger.log('Unable to parse Mpeg audio frame');
                    break;
                }
            }
            else if (id3_1.default.isHeader(data, offset)) {
                id3Data = id3_1.default.getID3Data(data, offset);
                id3Samples.push({ pts: stamp, dts: stamp, data: id3Data });
                offset += id3Data.length;
            }
            else {
                // nothing found, keep looking
                offset++;
            }
        }
        this.remuxer.remux(track, { samples: [] }, { samples: id3Samples, inputTimeScale: 90000 }, { samples: [] }, timeOffset, contiguous, accurateTimeOffset);
    };
    MP3Demuxer.prototype.destroy = function () {
    };
    return MP3Demuxer;
}());
exports.default = MP3Demuxer;


/***/ }),

/***/ "./src/demux/mp4demuxer.js":
/*!*********************************!*\
  !*** ./src/demux/mp4demuxer.js ***!
  \*********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * MP4 demuxer
 */
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var UINT32_MAX = Math.pow(2, 32) - 1;
var MP4Demuxer = /** @class */ (function () {
    function MP4Demuxer(observer, remuxer) {
        this.observer = observer;
        this.remuxer = remuxer;
    }
    MP4Demuxer.prototype.resetTimeStamp = function (initPTS) {
        this.initPTS = initPTS;
    };
    MP4Demuxer.prototype.resetInitSegment = function (initSegment, audioCodec, videoCodec, duration) {
        // jshint unused:false
        if (initSegment && initSegment.byteLength) {
            var initData = this.initData = MP4Demuxer.parseInitSegment(initSegment);
            // default audio codec if nothing specified
            // TODO : extract that from initsegment
            if (audioCodec == null) {
                audioCodec = 'mp4a.40.5';
            }
            if (videoCodec == null) {
                videoCodec = 'avc1.42e01e';
            }
            var tracks = {};
            if (initData.audio && initData.video) {
                tracks.audiovideo = { container: 'video/mp4', codec: audioCodec + ',' + videoCodec, initSegment: duration ? initSegment : null };
            }
            else {
                if (initData.audio) {
                    tracks.audio = { container: 'audio/mp4', codec: audioCodec, initSegment: duration ? initSegment : null };
                }
                if (initData.video) {
                    tracks.video = { container: 'video/mp4', codec: videoCodec, initSegment: duration ? initSegment : null };
                }
            }
            this.observer.trigger(events_1.default.FRAG_PARSING_INIT_SEGMENT, { tracks: tracks });
        }
        else {
            if (audioCodec) {
                this.audioCodec = audioCodec;
            }
            if (videoCodec) {
                this.videoCodec = videoCodec;
            }
        }
    };
    MP4Demuxer.probe = function (data) {
        // ensure we find a moof box in the first 16 kB
        return MP4Demuxer.findBox({ data: data, start: 0, end: Math.min(data.length, 16384) }, ['moof']).length > 0;
    };
    MP4Demuxer.bin2str = function (buffer) {
        return String.fromCharCode.apply(null, buffer);
    };
    MP4Demuxer.readUint16 = function (buffer, offset) {
        if (buffer.data) {
            offset += buffer.start;
            buffer = buffer.data;
        }
        var val = buffer[offset] << 8 |
            buffer[offset + 1];
        return val < 0 ? 65536 + val : val;
    };
    MP4Demuxer.readUint32 = function (buffer, offset) {
        if (buffer.data) {
            offset += buffer.start;
            buffer = buffer.data;
        }
        var val = buffer[offset] << 24 |
            buffer[offset + 1] << 16 |
            buffer[offset + 2] << 8 |
            buffer[offset + 3];
        return val < 0 ? 4294967296 + val : val;
    };
    MP4Demuxer.writeUint32 = function (buffer, offset, value) {
        if (buffer.data) {
            offset += buffer.start;
            buffer = buffer.data;
        }
        buffer[offset] = value >> 24;
        buffer[offset + 1] = (value >> 16) & 0xff;
        buffer[offset + 2] = (value >> 8) & 0xff;
        buffer[offset + 3] = value & 0xff;
    };
    // Find the data for a box specified by its path
    MP4Demuxer.findBox = function (data, path) {
        var results = [], i, size, type, end, subresults, start, endbox;
        if (data.data) {
            start = data.start;
            end = data.end;
            data = data.data;
        }
        else {
            start = 0;
            end = data.byteLength;
        }
        if (!path.length) {
            // short-circuit the search for empty paths
            return null;
        }
        for (i = start; i < end;) {
            size = MP4Demuxer.readUint32(data, i);
            type = MP4Demuxer.bin2str(data.subarray(i + 4, i + 8));
            endbox = size > 1 ? i + size : end;
            if (type === path[0]) {
                if (path.length === 1) {
                    // this is the end of the path and we've found the box we were
                    // looking for
                    results.push({ data: data, start: i + 8, end: endbox });
                }
                else {
                    // recursively search for the next box along the path
                    subresults = MP4Demuxer.findBox({ data: data, start: i + 8, end: endbox }, path.slice(1));
                    if (subresults.length) {
                        results = results.concat(subresults);
                    }
                }
            }
            i = endbox;
        }
        // we've finished searching all of data
        return results;
    };
    MP4Demuxer.parseSegmentIndex = function (initSegment) {
        var moov = MP4Demuxer.findBox(initSegment, ['moov'])[0];
        var moovEndOffset = moov ? moov.end : null; // we need this in case we need to chop of garbage of the end of current data
        var index = 0;
        var sidx = MP4Demuxer.findBox(initSegment, ['sidx']);
        var references;
        if (!sidx || !sidx[0]) {
            return null;
        }
        references = [];
        sidx = sidx[0];
        var version = sidx.data[0];
        // set initial offset, we skip the reference ID (not needed)
        index = version === 0 ? 8 : 16;
        var timescale = MP4Demuxer.readUint32(sidx, index);
        index += 4;
        // TODO: parse earliestPresentationTime and firstOffset
        // usually zero in our case
        var earliestPresentationTime = 0;
        var firstOffset = 0;
        if (version === 0) {
            index += 8;
        }
        else {
            index += 16;
        }
        // skip reserved
        index += 2;
        var startByte = sidx.end + firstOffset;
        var referencesCount = MP4Demuxer.readUint16(sidx, index);
        index += 2;
        for (var i = 0; i < referencesCount; i++) {
            var referenceIndex = index;
            var referenceInfo = MP4Demuxer.readUint32(sidx, referenceIndex);
            referenceIndex += 4;
            var referenceSize = referenceInfo & 0x7FFFFFFF;
            var referenceType = (referenceInfo & 0x80000000) >>> 31;
            if (referenceType === 1) {
                console.warn('SIDX has hierarchical references (not supported)');
                return;
            }
            var subsegmentDuration = MP4Demuxer.readUint32(sidx, referenceIndex);
            referenceIndex += 4;
            references.push({
                referenceSize: referenceSize,
                subsegmentDuration: subsegmentDuration,
                info: {
                    duration: subsegmentDuration / timescale,
                    start: startByte,
                    end: startByte + referenceSize - 1
                }
            });
            startByte += referenceSize;
            // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits
            // for |sapDelta|.
            referenceIndex += 4;
            // skip to next ref
            index = referenceIndex;
        }
        return {
            earliestPresentationTime: earliestPresentationTime,
            timescale: timescale,
            version: version,
            referencesCount: referencesCount,
            references: references,
            moovEndOffset: moovEndOffset
        };
    };
    /**
     * Parses an MP4 initialization segment and extracts stream type and
     * timescale values for any declared tracks. Timescale values indicate the
     * number of clock ticks per second to assume for time-based values
     * elsewhere in the MP4.
     *
     * To determine the start time of an MP4, you need two pieces of
     * information: the timescale unit and the earliest base media decode
     * time. Multiple timescales can be specified within an MP4 but the
     * base media decode time is always expressed in the timescale from
     * the media header box for the track:
     * ```
     * moov > trak > mdia > mdhd.timescale
     * moov > trak > mdia > hdlr
     * ```
     * @param init {Uint8Array} the bytes of the init segment
     * @return {object} a hash of track type to timescale values or null if
     * the init segment is malformed.
     */
    MP4Demuxer.parseInitSegment = function (initSegment) {
        var result = [];
        var traks = MP4Demuxer.findBox(initSegment, ['moov', 'trak']);
        traks.forEach(function (trak) {
            var tkhd = MP4Demuxer.findBox(trak, ['tkhd'])[0];
            if (tkhd) {
                var version = tkhd.data[tkhd.start];
                var index = version === 0 ? 12 : 20;
                var trackId = MP4Demuxer.readUint32(tkhd, index);
                var mdhd = MP4Demuxer.findBox(trak, ['mdia', 'mdhd'])[0];
                if (mdhd) {
                    version = mdhd.data[mdhd.start];
                    index = version === 0 ? 12 : 20;
                    var timescale = MP4Demuxer.readUint32(mdhd, index);
                    var hdlr = MP4Demuxer.findBox(trak, ['mdia', 'hdlr'])[0];
                    if (hdlr) {
                        var hdlrType = MP4Demuxer.bin2str(hdlr.data.subarray(hdlr.start + 8, hdlr.start + 12));
                        var type = { 'soun': 'audio', 'vide': 'video' }[hdlrType];
                        if (type) {
                            // extract codec info. TODO : parse codec details to be able to build MIME type
                            var codecBox = MP4Demuxer.findBox(trak, ['mdia', 'minf', 'stbl', 'stsd']);
                            if (codecBox.length) {
                                codecBox = codecBox[0];
                                var codecType = MP4Demuxer.bin2str(codecBox.data.subarray(codecBox.start + 12, codecBox.start + 16));
                                logger_1.logger.log("MP4Demuxer:" + type + ":" + codecType + " found");
                            }
                            result[trackId] = { timescale: timescale, type: type };
                            result[type] = { timescale: timescale, id: trackId };
                        }
                    }
                }
            }
        });
        return result;
    };
    /**
   * Determine the base media decode start time, in seconds, for an MP4
   * fragment. If multiple fragments are specified, the earliest time is
   * returned.
   *
   * The base media decode time can be parsed from track fragment
   * metadata:
   * ```
   * moof > traf > tfdt.baseMediaDecodeTime
   * ```
   * It requires the timescale value from the mdhd to interpret.
   *
   * @param timescale {object} a hash of track ids to timescale values.
   * @return {number} the earliest base media decode start time for the
   * fragment, in seconds
   */
    MP4Demuxer.getStartDTS = function (initData, fragment) {
        var trafs, baseTimes, result;
        // we need info from two childrend of each track fragment box
        trafs = MP4Demuxer.findBox(fragment, ['moof', 'traf']);
        // determine the start times for each track
        baseTimes = [].concat.apply([], trafs.map(function (traf) {
            return MP4Demuxer.findBox(traf, ['tfhd']).map(function (tfhd) {
                var id, scale, baseTime;
                // get the track id from the tfhd
                id = MP4Demuxer.readUint32(tfhd, 4);
                // assume a 90kHz clock if no timescale was specified
                scale = initData[id].timescale || 90e3;
                // get the base media decode time from the tfdt
                baseTime = MP4Demuxer.findBox(traf, ['tfdt']).map(function (tfdt) {
                    var version, result;
                    version = tfdt.data[tfdt.start];
                    result = MP4Demuxer.readUint32(tfdt, 4);
                    if (version === 1) {
                        result *= Math.pow(2, 32);
                        result += MP4Demuxer.readUint32(tfdt, 8);
                    }
                    return result;
                })[0];
                // convert base time to seconds
                return baseTime / scale;
            });
        }));
        // return the minimum
        result = Math.min.apply(null, baseTimes);
        return isFinite(result) ? result : 0;
    };
    MP4Demuxer.offsetStartDTS = function (initData, fragment, timeOffset) {
        MP4Demuxer.findBox(fragment, ['moof', 'traf']).map(function (traf) {
            return MP4Demuxer.findBox(traf, ['tfhd']).map(function (tfhd) {
                // get the track id from the tfhd
                var id = MP4Demuxer.readUint32(tfhd, 4);
                // assume a 90kHz clock if no timescale was specified
                var timescale = initData[id].timescale || 90e3;
                // get the base media decode time from the tfdt
                MP4Demuxer.findBox(traf, ['tfdt']).map(function (tfdt) {
                    var version = tfdt.data[tfdt.start];
                    var baseMediaDecodeTime = MP4Demuxer.readUint32(tfdt, 4);
                    if (version === 0) {
                        MP4Demuxer.writeUint32(tfdt, 4, baseMediaDecodeTime - timeOffset * timescale);
                    }
                    else {
                        baseMediaDecodeTime *= Math.pow(2, 32);
                        baseMediaDecodeTime += MP4Demuxer.readUint32(tfdt, 8);
                        baseMediaDecodeTime -= timeOffset * timescale;
                        baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
                        var upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));
                        var lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
                        MP4Demuxer.writeUint32(tfdt, 4, upper);
                        MP4Demuxer.writeUint32(tfdt, 8, lower);
                    }
                });
            });
        });
    };
    // feed incoming data to the front of the parsing pipeline
    MP4Demuxer.prototype.append = function (data, timeOffset, contiguous, accurateTimeOffset) {
        var initData = this.initData;
        if (!initData) {
            this.resetInitSegment(data, this.audioCodec, this.videoCodec, false);
            initData = this.initData;
        }
        var startDTS, initPTS = this.initPTS;
        if (initPTS === undefined) {
            var startDTS_1 = MP4Demuxer.getStartDTS(initData, data);
            this.initPTS = initPTS = startDTS_1 - timeOffset;
            this.observer.trigger(events_1.default.INIT_PTS_FOUND, { initPTS: initPTS });
        }
        MP4Demuxer.offsetStartDTS(initData, data, initPTS);
        startDTS = MP4Demuxer.getStartDTS(initData, data);
        this.remuxer.remux(initData.audio, initData.video, null, null, startDTS, contiguous, accurateTimeOffset, data);
    };
    MP4Demuxer.prototype.destroy = function () { };
    return MP4Demuxer;
}());
exports.default = MP4Demuxer;


/***/ }),

/***/ "./src/demux/mpegaudio.js":
/*!********************************!*\
  !*** ./src/demux/mpegaudio.js ***!
  \********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 *  MPEG parser helper
 */
Object.defineProperty(exports, "__esModule", { value: true });
var MpegAudio = {
    BitratesMap: [
        32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448,
        32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384,
        32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320,
        32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256,
        8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160
    ],
    SamplingRateMap: [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000],
    SamplesCoefficients: [
        // MPEG 2.5
        [
            0,
            72,
            144,
            12 // Layer1
        ],
        // Reserved
        [
            0,
            0,
            0,
            0 // Layer1
        ],
        // MPEG 2
        [
            0,
            72,
            144,
            12 // Layer1
        ],
        // MPEG 1
        [
            0,
            144,
            144,
            12 // Layer1
        ]
    ],
    BytesInSlot: [
        0,
        1,
        1,
        4 // Layer1
    ],
    appendFrame: function (track, data, offset, pts, frameIndex) {
        // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference
        if (offset + 24 > data.length) {
            return undefined;
        }
        var header = this.parseHeader(data, offset);
        if (header && offset + header.frameLength <= data.length) {
            var frameDuration = header.samplesPerFrame * 90000 / header.sampleRate;
            var stamp = pts + frameIndex * frameDuration;
            var sample = { unit: data.subarray(offset, offset + header.frameLength), pts: stamp, dts: stamp };
            track.config = [];
            track.channelCount = header.channelCount;
            track.samplerate = header.sampleRate;
            track.samples.push(sample);
            track.len += header.frameLength;
            return { sample: sample, length: header.frameLength };
        }
        return undefined;
    },
    parseHeader: function (data, offset) {
        var headerB = (data[offset + 1] >> 3) & 3;
        var headerC = (data[offset + 1] >> 1) & 3;
        var headerE = (data[offset + 2] >> 4) & 15;
        var headerF = (data[offset + 2] >> 2) & 3;
        var headerG = (data[offset + 2] >> 1) & 1;
        if (headerB !== 1 && headerE !== 0 && headerE !== 15 && headerF !== 3) {
            var columnInBitrates = headerB === 3 ? (3 - headerC) : (headerC === 3 ? 3 : 4);
            var bitRate = MpegAudio.BitratesMap[columnInBitrates * 14 + headerE - 1] * 1000;
            var columnInSampleRates = headerB === 3 ? 0 : headerB === 2 ? 1 : 2;
            var sampleRate = MpegAudio.SamplingRateMap[columnInSampleRates * 3 + headerF];
            var channelCount = data[offset + 3] >> 6 === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)
            var sampleCoefficient = MpegAudio.SamplesCoefficients[headerB][headerC];
            var bytesInSlot = MpegAudio.BytesInSlot[headerC];
            var samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;
            var frameLength = parseInt(sampleCoefficient * bitRate / sampleRate + headerG, 10) * bytesInSlot;
            return { sampleRate: sampleRate, channelCount: channelCount, frameLength: frameLength, samplesPerFrame: samplesPerFrame };
        }
        return undefined;
    },
    isHeaderPattern: function (data, offset) {
        return data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00;
    },
    isHeader: function (data, offset) {
        // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1
        // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)
        // More info http://www.mp3-tech.org/programmer/frame_header.html
        if (offset + 1 < data.length && this.isHeaderPattern(data, offset)) {
            return true;
        }
        return false;
    },
    probe: function (data, offset) {
        // same as isHeader but we also check that MPEG frame follows last MPEG frame
        // or end of data is reached
        if (offset + 1 < data.length && this.isHeaderPattern(data, offset)) {
            // MPEG header Length
            var headerLength = 4;
            // MPEG frame Length
            var header = this.parseHeader(data, offset);
            var frameLength = headerLength;
            if (header && header.frameLength) {
                frameLength = header.frameLength;
            }
            var newOffset = offset + frameLength;
            if (newOffset === data.length || (newOffset + 1 < data.length && this.isHeaderPattern(data, newOffset))) {
                return true;
            }
        }
        return false;
    }
};
exports.default = MpegAudio;


/***/ }),

/***/ "./src/demux/sample-aes.js":
/*!*********************************!*\
  !*** ./src/demux/sample-aes.js ***!
  \*********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * SAMPLE-AES decrypter
*/
Object.defineProperty(exports, "__esModule", { value: true });
var decrypter_1 = __webpack_require__(/*! ../crypt/decrypter */ "./src/crypt/decrypter.js");
var SampleAesDecrypter = /** @class */ (function () {
    function SampleAesDecrypter(observer, config, decryptdata, discardEPB) {
        this.decryptdata = decryptdata;
        this.discardEPB = discardEPB;
        this.decrypter = new decrypter_1.default(observer, config, { removePKCS7Padding: false });
    }
    SampleAesDecrypter.prototype.decryptBuffer = function (encryptedData, callback) {
        this.decrypter.decrypt(encryptedData, this.decryptdata.key.buffer, this.decryptdata.iv.buffer, callback);
    };
    // AAC - encrypt all full 16 bytes blocks starting from offset 16
    SampleAesDecrypter.prototype.decryptAacSample = function (samples, sampleIndex, callback, sync) {
        var curUnit = samples[sampleIndex].unit;
        var encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);
        var encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);
        var localthis = this;
        this.decryptBuffer(encryptedBuffer, function (decryptedData) {
            decryptedData = new Uint8Array(decryptedData);
            curUnit.set(decryptedData, 16);
            if (!sync) {
                localthis.decryptAacSamples(samples, sampleIndex + 1, callback);
            }
        });
    };
    SampleAesDecrypter.prototype.decryptAacSamples = function (samples, sampleIndex, callback) {
        for (;; sampleIndex++) {
            if (sampleIndex >= samples.length) {
                callback();
                return;
            }
            if (samples[sampleIndex].unit.length < 32) {
                continue;
            }
            var sync = this.decrypter.isSync();
            this.decryptAacSample(samples, sampleIndex, callback, sync);
            if (!sync) {
                return;
            }
        }
    };
    // AVC - encrypt one 16 bytes block out of ten, starting from offset 32
    SampleAesDecrypter.prototype.getAvcEncryptedData = function (decodedData) {
        var encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;
        var encryptedData = new Int8Array(encryptedDataLen);
        var outputPos = 0;
        for (var inputPos = 32; inputPos <= decodedData.length - 16; inputPos += 160, outputPos += 16) {
            encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);
        }
        return encryptedData;
    };
    SampleAesDecrypter.prototype.getAvcDecryptedUnit = function (decodedData, decryptedData) {
        decryptedData = new Uint8Array(decryptedData);
        var inputPos = 0;
        for (var outputPos = 32; outputPos <= decodedData.length - 16; outputPos += 160, inputPos += 16) {
            decodedData.set(decryptedData.subarray(inputPos, inputPos + 16), outputPos);
        }
        return decodedData;
    };
    SampleAesDecrypter.prototype.decryptAvcSample = function (samples, sampleIndex, unitIndex, callback, curUnit, sync) {
        var decodedData = this.discardEPB(curUnit.data);
        var encryptedData = this.getAvcEncryptedData(decodedData);
        var localthis = this;
        this.decryptBuffer(encryptedData.buffer, function (decryptedData) {
            curUnit.data = localthis.getAvcDecryptedUnit(decodedData, decryptedData);
            if (!sync) {
                localthis.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);
            }
        });
    };
    SampleAesDecrypter.prototype.decryptAvcSamples = function (samples, sampleIndex, unitIndex, callback) {
        for (;; sampleIndex++, unitIndex = 0) {
            if (sampleIndex >= samples.length) {
                callback();
                return;
            }
            var curUnits = samples[sampleIndex].units;
            for (;; unitIndex++) {
                if (unitIndex >= curUnits.length) {
                    break;
                }
                var curUnit = curUnits[unitIndex];
                if (curUnit.length <= 48 || (curUnit.type !== 1 && curUnit.type !== 5)) {
                    continue;
                }
                var sync = this.decrypter.isSync();
                this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync);
                if (!sync) {
                    return;
                }
            }
        }
    };
    return SampleAesDecrypter;
}());
exports.default = SampleAesDecrypter;


/***/ }),

/***/ "./src/demux/tsdemuxer.js":
/*!********************************!*\
  !*** ./src/demux/tsdemuxer.js ***!
  \********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * highly optimized TS demuxer:
 * parse PAT, PMT
 * extract PES packet from audio and video PIDs
 * extract AVC/H264 NAL units and AAC/ADTS samples from PES packet
 * trigger the remuxer upon parsing completion
 * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.
 * it also controls the remuxing process :
 * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.
*/
Object.defineProperty(exports, "__esModule", { value: true });
var ADTS = __webpack_require__(/*! ./adts */ "./src/demux/adts.js");
var mpegaudio_1 = __webpack_require__(/*! ./mpegaudio */ "./src/demux/mpegaudio.js");
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var exp_golomb_1 = __webpack_require__(/*! ./exp-golomb */ "./src/demux/exp-golomb.js");
var sample_aes_1 = __webpack_require__(/*! ./sample-aes */ "./src/demux/sample-aes.js");
// import Hex from '../utils/hex';
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
// We are using fixed track IDs for driving the MP4 remuxer
// instead of following the TS PIDs.
// There is no reason not to do this and some browsers/SourceBuffer-demuxers
// may not like if there are TrackID "switches"
// See https://github.com/video-dev/hls.js/issues/1331
// Here we are mapping our internal track types to constant MP4 track IDs
// With MSE currently one can only have one track of each, and we are muxing
// whatever video/audio rendition in them.
var RemuxerTrackIdConfig = {
    video: 1,
    audio: 2,
    id3: 3,
    text: 4
};
var TSDemuxer = /** @class */ (function () {
    function TSDemuxer(observer, remuxer, config, typeSupported) {
        this.observer = observer;
        this.config = config;
        this.typeSupported = typeSupported;
        this.remuxer = remuxer;
        this.sampleAes = null;
    }
    TSDemuxer.prototype.setDecryptData = function (decryptdata) {
        if ((decryptdata != null) && (decryptdata.key != null) && (decryptdata.method === 'SAMPLE-AES')) {
            this.sampleAes = new sample_aes_1.default(this.observer, this.config, decryptdata, this.discardEPB);
        }
        else {
            this.sampleAes = null;
        }
    };
    TSDemuxer.probe = function (data) {
        var syncOffset = TSDemuxer._syncOffset(data);
        if (syncOffset < 0) {
            return false;
        }
        else {
            if (syncOffset) {
                logger_1.logger.warn("MPEG2-TS detected but first sync word found @ offset " + syncOffset + ", junk ahead ?");
            }
            return true;
        }
    };
    TSDemuxer._syncOffset = function (data) {
        // scan 1000 first bytes
        var scanwindow = Math.min(1000, data.length - 3 * 188);
        var i = 0;
        while (i < scanwindow) {
            // a TS fragment should contain at least 3 TS packets, a PAT, a PMT, and one PID, each starting with 0x47
            if (data[i] === 0x47 && data[i + 188] === 0x47 && data[i + 2 * 188] === 0x47) {
                return i;
            }
            else {
                i++;
            }
        }
        return -1;
    };
    /**
     * Creates a track model internal to demuxer used to drive remuxing input
     *
     * @param {string} type 'audio' | 'video' | 'id3' | 'text'
     * @param {number} duration
     * @return {object} TSDemuxer's internal track model
     */
    TSDemuxer.createTrack = function (type, duration) {
        return {
            container: type === 'video' || type === 'audio' ? 'video/mp2t' : undefined,
            type: type,
            id: RemuxerTrackIdConfig[type],
            pid: -1,
            inputTimeScale: 90000,
            sequenceNumber: 0,
            samples: [],
            len: 0,
            dropped: type === 'video' ? 0 : undefined,
            isAAC: type === 'audio' ? true : undefined,
            duration: type === 'audio' ? duration : undefined
        };
    };
    /**
     * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)
     * Resets all internal track instances of the demuxer.
     *
     * @override Implements generic demuxing/remuxing interface (see DemuxerInline)
     * @param {object} initSegment
     * @param {string} audioCodec
     * @param {string} videoCodec
     * @param {number} duration (in TS timescale = 90kHz)
     */
    TSDemuxer.prototype.resetInitSegment = function (initSegment, audioCodec, videoCodec, duration) {
        this.pmtParsed = false;
        this._pmtId = -1;
        this._avcTrack = TSDemuxer.createTrack('video', duration);
        this._audioTrack = TSDemuxer.createTrack('audio', duration);
        this._id3Track = TSDemuxer.createTrack('id3', duration);
        this._txtTrack = TSDemuxer.createTrack('text', duration);
        // flush any partial content
        this.aacOverFlow = null;
        this.aacLastPTS = null;
        this.avcSample = null;
        this.audioCodec = audioCodec;
        this.videoCodec = videoCodec;
        this._duration = duration;
    };
    /**
     *
     * @override
     */
    TSDemuxer.prototype.resetTimeStamp = function () { };
    // feed incoming data to the front of the parsing pipeline
    TSDemuxer.prototype.append = function (data, timeOffset, contiguous, accurateTimeOffset) {
        var start, len = data.length, stt, pid, atf, offset, pes, unknownPIDs = false;
        this.contiguous = contiguous;
        var pmtParsed = this.pmtParsed, avcTrack = this._avcTrack, audioTrack = this._audioTrack, id3Track = this._id3Track, avcId = avcTrack.pid, audioId = audioTrack.pid, id3Id = id3Track.pid, pmtId = this._pmtId, avcData = avcTrack.pesData, audioData = audioTrack.pesData, id3Data = id3Track.pesData, parsePAT = this._parsePAT, parsePMT = this._parsePMT, parsePES = this._parsePES, parseAVCPES = this._parseAVCPES.bind(this), parseAACPES = this._parseAACPES.bind(this), parseMPEGPES = this._parseMPEGPES.bind(this), parseID3PES = this._parseID3PES.bind(this);
        var syncOffset = TSDemuxer._syncOffset(data);
        // don't parse last TS packet if incomplete
        len -= (len + syncOffset) % 188;
        // loop through TS packets
        for (start = syncOffset; start < len; start += 188) {
            if (data[start] === 0x47) {
                stt = !!(data[start + 1] & 0x40);
                // pid is a 13-bit field starting at the last bit of TS[1]
                pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2];
                atf = (data[start + 3] & 0x30) >> 4;
                // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.
                if (atf > 1) {
                    offset = start + 5 + data[start + 4];
                    // continue if there is only adaptation field
                    if (offset === (start + 188)) {
                        continue;
                    }
                }
                else {
                    offset = start + 4;
                }
                switch (pid) {
                    case avcId:
                        if (stt) {
                            if (avcData && (pes = parsePES(avcData)) && pes.pts !== undefined) {
                                parseAVCPES(pes, false);
                            }
                            avcData = { data: [], size: 0 };
                        }
                        if (avcData) {
                            avcData.data.push(data.subarray(offset, start + 188));
                            avcData.size += start + 188 - offset;
                        }
                        break;
                    case audioId:
                        if (stt) {
                            if (audioData && (pes = parsePES(audioData)) && pes.pts !== undefined) {
                                if (audioTrack.isAAC) {
                                    parseAACPES(pes);
                                }
                                else {
                                    parseMPEGPES(pes);
                                }
                            }
                            audioData = { data: [], size: 0 };
                        }
                        if (audioData) {
                            audioData.data.push(data.subarray(offset, start + 188));
                            audioData.size += start + 188 - offset;
                        }
                        break;
                    case id3Id:
                        if (stt) {
                            if (id3Data && (pes = parsePES(id3Data)) && pes.pts !== undefined) {
                                parseID3PES(pes);
                            }
                            id3Data = { data: [], size: 0 };
                        }
                        if (id3Data) {
                            id3Data.data.push(data.subarray(offset, start + 188));
                            id3Data.size += start + 188 - offset;
                        }
                        break;
                    case 0:
                        if (stt) {
                            offset += data[offset] + 1;
                        }
                        pmtId = this._pmtId = parsePAT(data, offset);
                        break;
                    case pmtId:
                        if (stt) {
                            offset += data[offset] + 1;
                        }
                        var parsedPIDs = parsePMT(data, offset, this.typeSupported.mpeg === true || this.typeSupported.mp3 === true, this.sampleAes != null);
                        // only update track id if track PID found while parsing PMT
                        // this is to avoid resetting the PID to -1 in case
                        // track PID transiently disappears from the stream
                        // this could happen in case of transient missing audio samples for example
                        // NOTE this is only the PID of the track as found in TS,
                        // but we are not using this for MP4 track IDs.
                        avcId = parsedPIDs.avc;
                        if (avcId > 0) {
                            avcTrack.pid = avcId;
                        }
                        audioId = parsedPIDs.audio;
                        if (audioId > 0) {
                            audioTrack.pid = audioId;
                            audioTrack.isAAC = parsedPIDs.isAAC;
                        }
                        id3Id = parsedPIDs.id3;
                        if (id3Id > 0) {
                            id3Track.pid = id3Id;
                        }
                        if (unknownPIDs && !pmtParsed) {
                            logger_1.logger.log('reparse from beginning');
                            unknownPIDs = false;
                            // we set it to -188, the += 188 in the for loop will reset start to 0
                            start = syncOffset - 188;
                        }
                        pmtParsed = this.pmtParsed = true;
                        break;
                    case 17:
                    case 0x1fff:
                        break;
                    default:
                        unknownPIDs = true;
                        break;
                }
            }
            else {
                this.observer.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.MEDIA_ERROR, details: errors_1.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'TS packet did not start with 0x47' });
            }
        }
        // try to parse last PES packets
        if (avcData && (pes = parsePES(avcData)) && pes.pts !== undefined) {
            parseAVCPES(pes, true);
            avcTrack.pesData = null;
        }
        else {
            // either avcData null or PES truncated, keep it for next frag parsing
            avcTrack.pesData = avcData;
        }
        if (audioData && (pes = parsePES(audioData)) && pes.pts !== undefined) {
            if (audioTrack.isAAC) {
                parseAACPES(pes);
            }
            else {
                parseMPEGPES(pes);
            }
            audioTrack.pesData = null;
        }
        else {
            if (audioData && audioData.size) {
                logger_1.logger.log('last AAC PES packet truncated,might overlap between fragments');
            }
            // either audioData null or PES truncated, keep it for next frag parsing
            audioTrack.pesData = audioData;
        }
        if (id3Data && (pes = parsePES(id3Data)) && pes.pts !== undefined) {
            parseID3PES(pes);
            id3Track.pesData = null;
        }
        else {
            // either id3Data null or PES truncated, keep it for next frag parsing
            id3Track.pesData = id3Data;
        }
        if (this.sampleAes == null) {
            this.remuxer.remux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);
        }
        else {
            this.decryptAndRemux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);
        }
    };
    TSDemuxer.prototype.decryptAndRemux = function (audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
        if (audioTrack.samples && audioTrack.isAAC) {
            var localthis_1 = this;
            this.sampleAes.decryptAacSamples(audioTrack.samples, 0, function () {
                localthis_1.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
            });
        }
        else {
            this.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
        }
    };
    TSDemuxer.prototype.decryptAndRemuxAvc = function (audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
        if (videoTrack.samples) {
            var localthis_2 = this;
            this.sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {
                localthis_2.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
            });
        }
        else {
            this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
        }
    };
    TSDemuxer.prototype.destroy = function () {
        this._initPTS = this._initDTS = undefined;
        this._duration = 0;
    };
    TSDemuxer.prototype._parsePAT = function (data, offset) {
        // skip the PSI header and parse the first PMT entry
        return (data[offset + 10] & 0x1F) << 8 | data[offset + 11];
        // logger.log('PMT PID:'  + this._pmtId);
    };
    TSDemuxer.prototype._parsePMT = function (data, offset, mpegSupported, isSampleAes) {
        var sectionLength, tableEnd, programInfoLength, pid, result = { audio: -1, avc: -1, id3: -1, isAAC: true };
        sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];
        tableEnd = offset + 3 + sectionLength - 4;
        // to determine where the table is, we have to figure out how
        // long the program info descriptors are
        programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];
        // advance the offset to the first entry in the mapping table
        offset += 12 + programInfoLength;
        while (offset < tableEnd) {
            pid = (data[offset + 1] & 0x1F) << 8 | data[offset + 2];
            switch (data[offset]) {
                case 0xcf: // SAMPLE-AES AAC
                    if (!isSampleAes) {
                        logger_1.logger.log('unkown stream type:' + data[offset]);
                        break;
                    }
                /* falls through */
                // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)
                case 0x0f:
                    // logger.log('AAC PID:'  + pid);
                    if (result.audio === -1) {
                        result.audio = pid;
                    }
                    break;
                // Packetized metadata (ID3)
                case 0x15:
                    // logger.log('ID3 PID:'  + pid);
                    if (result.id3 === -1) {
                        result.id3 = pid;
                    }
                    break;
                case 0xdb: // SAMPLE-AES AVC
                    if (!isSampleAes) {
                        logger_1.logger.log('unkown stream type:' + data[offset]);
                        break;
                    }
                /* falls through */
                // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)
                case 0x1b:
                    // logger.log('AVC PID:'  + pid);
                    if (result.avc === -1) {
                        result.avc = pid;
                    }
                    break;
                // ISO/IEC 11172-3 (MPEG-1 audio)
                // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)
                case 0x03:
                case 0x04:
                    // logger.log('MPEG PID:'  + pid);
                    if (!mpegSupported) {
                        logger_1.logger.log('MPEG audio found, not supported in this browser for now');
                    }
                    else if (result.audio === -1) {
                        result.audio = pid;
                        result.isAAC = false;
                    }
                    break;
                case 0x24:
                    logger_1.logger.warn('HEVC stream type found, not supported for now');
                    break;
                default:
                    logger_1.logger.log('unkown stream type:' + data[offset]);
                    break;
            }
            // move to the next table entry
            // skip past the elementary stream descriptors, if present
            offset += ((data[offset + 3] & 0x0F) << 8 | data[offset + 4]) + 5;
        }
        return result;
    };
    TSDemuxer.prototype._parsePES = function (stream) {
        var i = 0, frag, pesFlags, pesPrefix, pesLen, pesHdrLen, pesData, pesPts, pesDts, payloadStartOffset, data = stream.data;
        // safety check
        if (!stream || stream.size === 0) {
            return null;
        }
        // we might need up to 19 bytes to read PES header
        // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes
        // usually only one merge is needed (and this is rare ...)
        while (data[0].length < 19 && data.length > 1) {
            var newData = new Uint8Array(data[0].length + data[1].length);
            newData.set(data[0]);
            newData.set(data[1], data[0].length);
            data[0] = newData;
            data.splice(1, 1);
        }
        // retrieve PTS/DTS from first fragment
        frag = data[0];
        pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
        if (pesPrefix === 1) {
            pesLen = (frag[4] << 8) + frag[5];
            // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated
            // minus 6 : PES header size
            if (pesLen && pesLen > stream.size - 6) {
                return null;
            }
            pesFlags = frag[7];
            if (pesFlags & 0xC0) {
                /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html
                    as PTS / DTS is 33 bit we cannot use bitwise operator in JS,
                    as Bitwise operators treat their operands as a sequence of 32 bits */
                pesPts = (frag[9] & 0x0E) * 536870912 + // 1 << 29
                    (frag[10] & 0xFF) * 4194304 + // 1 << 22
                    (frag[11] & 0xFE) * 16384 + // 1 << 14
                    (frag[12] & 0xFF) * 128 + // 1 << 7
                    (frag[13] & 0xFE) / 2;
                // check if greater than 2^32 -1
                if (pesPts > 4294967295) {
                    // decrement 2^33
                    pesPts -= 8589934592;
                }
                if (pesFlags & 0x40) {
                    pesDts = (frag[14] & 0x0E) * 536870912 + // 1 << 29
                        (frag[15] & 0xFF) * 4194304 + // 1 << 22
                        (frag[16] & 0xFE) * 16384 + // 1 << 14
                        (frag[17] & 0xFF) * 128 + // 1 << 7
                        (frag[18] & 0xFE) / 2;
                    // check if greater than 2^32 -1
                    if (pesDts > 4294967295) {
                        // decrement 2^33
                        pesDts -= 8589934592;
                    }
                    if (pesPts - pesDts > 60 * 90000) {
                        logger_1.logger.warn(Math.round((pesPts - pesDts) / 90000) + "s delta between PTS and DTS, align them");
                        pesPts = pesDts;
                    }
                }
                else {
                    pesDts = pesPts;
                }
            }
            pesHdrLen = frag[8];
            // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension
            payloadStartOffset = pesHdrLen + 9;
            stream.size -= payloadStartOffset;
            // reassemble PES packet
            pesData = new Uint8Array(stream.size);
            for (var j = 0, dataLen = data.length; j < dataLen; j++) {
                frag = data[j];
                var len = frag.byteLength;
                if (payloadStartOffset) {
                    if (payloadStartOffset > len) {
                        // trim full frag if PES header bigger than frag
                        payloadStartOffset -= len;
                        continue;
                    }
                    else {
                        // trim partial frag if PES header smaller than frag
                        frag = frag.subarray(payloadStartOffset);
                        len -= payloadStartOffset;
                        payloadStartOffset = 0;
                    }
                }
                pesData.set(frag, i);
                i += len;
            }
            if (pesLen) {
                // payload size : remove PES header + PES extension
                pesLen -= pesHdrLen + 3;
            }
            return { data: pesData, pts: pesPts, dts: pesDts, len: pesLen };
        }
        else {
            return null;
        }
    };
    TSDemuxer.prototype.pushAccesUnit = function (avcSample, avcTrack) {
        if (avcSample.units.length && avcSample.frame) {
            var samples = avcTrack.samples;
            var nbSamples = samples.length;
            // only push AVC sample if starting with a keyframe is not mandatory OR
            //    if keyframe already found in this fragment OR
            //       keyframe found in last fragment (track.sps) AND
            //          samples already appended (we already found a keyframe in this fragment) OR fragment is contiguous
            if (!this.config.forceKeyFrameOnDiscontinuity ||
                avcSample.key === true ||
                (avcTrack.sps && (nbSamples || this.contiguous))) {
                avcSample.id = nbSamples;
                samples.push(avcSample);
            }
            else {
                // dropped samples, track it
                avcTrack.dropped++;
            }
        }
        if (avcSample.debug.length) {
            logger_1.logger.log(avcSample.pts + '/' + avcSample.dts + ':' + avcSample.debug);
        }
    };
    TSDemuxer.prototype._parseAVCPES = function (pes, last) {
        var _this = this;
        // logger.log('parse new PES');
        var track = this._avcTrack, units = this._parseAVCNALu(pes.data), debug = false, expGolombDecoder, avcSample = this.avcSample, push, spsfound = false, i, pushAccesUnit = this.pushAccesUnit.bind(this), createAVCSample = function (key, pts, dts, debug) {
            return { key: key, pts: pts, dts: dts, units: [], debug: debug };
        };
        // free pes.data to save up some memory
        pes.data = null;
        // if new NAL units found and last sample still there, let's push ...
        // this helps parsing streams with missing AUD (only do this if AUD never found)
        if (avcSample && units.length && !track.audFound) {
            pushAccesUnit(avcSample, track);
            avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, '');
        }
        units.forEach(function (unit) {
            switch (unit.type) {
                // NDR
                case 1:
                    push = true;
                    if (!avcSample) {
                        avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');
                    }
                    if (debug) {
                        avcSample.debug += 'NDR ';
                    }
                    avcSample.frame = true;
                    var data = unit.data;
                    // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)
                    if (spsfound && data.length > 4) {
                        // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR
                        var sliceType = new exp_golomb_1.default(data).readSliceType();
                        // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice
                        // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.
                        // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.
                        // I slice: A slice that is not an SI slice that is decoded using intra prediction only.
                        // if (sliceType === 2 || sliceType === 7) {
                        if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {
                            avcSample.key = true;
                        }
                    }
                    break;
                // IDR
                case 5:
                    push = true;
                    // handle PES not starting with AUD
                    if (!avcSample) {
                        avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');
                    }
                    if (debug) {
                        avcSample.debug += 'IDR ';
                    }
                    avcSample.key = true;
                    avcSample.frame = true;
                    break;
                // SEI
                case 6:
                    push = true;
                    if (debug && avcSample) {
                        avcSample.debug += 'SEI ';
                    }
                    expGolombDecoder = new exp_golomb_1.default(_this.discardEPB(unit.data));
                    // skip frameType
                    expGolombDecoder.readUByte();
                    var payloadType = 0;
                    var payloadSize = 0;
                    var endOfCaptions = false;
                    var b = 0;
                    while (!endOfCaptions && expGolombDecoder.bytesAvailable > 1) {
                        payloadType = 0;
                        do {
                            b = expGolombDecoder.readUByte();
                            payloadType += b;
                        } while (b === 0xFF);
                        // Parse payload size.
                        payloadSize = 0;
                        do {
                            b = expGolombDecoder.readUByte();
                            payloadSize += b;
                        } while (b === 0xFF);
                        // TODO: there can be more than one payload in an SEI packet...
                        // TODO: need to read type and size in a while loop to get them all
                        if (payloadType === 4 && expGolombDecoder.bytesAvailable !== 0) {
                            endOfCaptions = true;
                            var countryCode = expGolombDecoder.readUByte();
                            if (countryCode === 181) {
                                var providerCode = expGolombDecoder.readUShort();
                                if (providerCode === 49) {
                                    var userStructure = expGolombDecoder.readUInt();
                                    if (userStructure === 0x47413934) {
                                        var userDataType = expGolombDecoder.readUByte();
                                        // Raw CEA-608 bytes wrapped in CEA-708 packet
                                        if (userDataType === 3) {
                                            var firstByte = expGolombDecoder.readUByte();
                                            var secondByte = expGolombDecoder.readUByte();
                                            var totalCCs = 31 & firstByte;
                                            var byteArray = [firstByte, secondByte];
                                            for (i = 0; i < totalCCs; i++) {
                                                // 3 bytes per CC
                                                byteArray.push(expGolombDecoder.readUByte());
                                                byteArray.push(expGolombDecoder.readUByte());
                                                byteArray.push(expGolombDecoder.readUByte());
                                            }
                                            _this._insertSampleInOrder(_this._txtTrack.samples, { type: 3, pts: pes.pts, bytes: byteArray });
                                        }
                                    }
                                }
                            }
                        }
                        else if (payloadSize < expGolombDecoder.bytesAvailable) {
                            for (i = 0; i < payloadSize; i++) {
                                expGolombDecoder.readUByte();
                            }
                        }
                    }
                    break;
                // SPS
                case 7:
                    push = true;
                    spsfound = true;
                    if (debug && avcSample) {
                        avcSample.debug += 'SPS ';
                    }
                    if (!track.sps) {
                        expGolombDecoder = new exp_golomb_1.default(unit.data);
                        var config = expGolombDecoder.readSPS();
                        track.width = config.width;
                        track.height = config.height;
                        track.pixelRatio = config.pixelRatio;
                        track.sps = [unit.data];
                        track.duration = _this._duration;
                        var codecarray = unit.data.subarray(1, 4);
                        var codecstring = 'avc1.';
                        for (i = 0; i < 3; i++) {
                            var h = codecarray[i].toString(16);
                            if (h.length < 2) {
                                h = '0' + h;
                            }
                            codecstring += h;
                        }
                        track.codec = codecstring;
                    }
                    break;
                // PPS
                case 8:
                    push = true;
                    if (debug && avcSample) {
                        avcSample.debug += 'PPS ';
                    }
                    if (!track.pps) {
                        track.pps = [unit.data];
                    }
                    break;
                // AUD
                case 9:
                    push = false;
                    track.audFound = true;
                    if (avcSample) {
                        pushAccesUnit(avcSample, track);
                    }
                    avcSample = _this.avcSample = createAVCSample(false, pes.pts, pes.dts, debug ? 'AUD ' : '');
                    break;
                // Filler Data
                case 12:
                    push = false;
                    break;
                default:
                    push = false;
                    if (avcSample) {
                        avcSample.debug += 'unknown NAL ' + unit.type + ' ';
                    }
                    break;
            }
            if (avcSample && push) {
                var units_1 = avcSample.units;
                units_1.push(unit);
            }
        });
        // if last PES packet, push samples
        if (last && avcSample) {
            pushAccesUnit(avcSample, track);
            this.avcSample = null;
        }
    };
    TSDemuxer.prototype._insertSampleInOrder = function (arr, data) {
        var len = arr.length;
        if (len > 0) {
            if (data.pts >= arr[len - 1].pts) {
                arr.push(data);
            }
            else {
                for (var pos = len - 1; pos >= 0; pos--) {
                    if (data.pts < arr[pos].pts) {
                        arr.splice(pos, 0, data);
                        break;
                    }
                }
            }
        }
        else {
            arr.push(data);
        }
    };
    TSDemuxer.prototype._getLastNalUnit = function () {
        var avcSample = this.avcSample, lastUnit;
        // try to fallback to previous sample if current one is empty
        if (!avcSample || avcSample.units.length === 0) {
            var track = this._avcTrack, samples = track.samples;
            avcSample = samples[samples.length - 1];
        }
        if (avcSample) {
            var units = avcSample.units;
            lastUnit = units[units.length - 1];
        }
        return lastUnit;
    };
    TSDemuxer.prototype._parseAVCNALu = function (array) {
        var i = 0, len = array.byteLength, value, overflow, track = this._avcTrack, state = track.naluState || 0, lastState = state;
        var units = [], unit, unitType, lastUnitStart = -1, lastUnitType;
        // logger.log('PES:' + Hex.hexDump(array));
        if (state === -1) {
            // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet
            lastUnitStart = 0;
            // NALu type is value read from offset 0
            lastUnitType = array[0] & 0x1f;
            state = 0;
            i = 1;
        }
        while (i < len) {
            value = array[i++];
            // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case
            if (!state) {
                state = value ? 0 : 1;
                continue;
            }
            if (state === 1) {
                state = value ? 0 : 2;
                continue;
            }
            // here we have state either equal to 2 or 3
            if (!value) {
                state = 3;
            }
            else if (value === 1) {
                if (lastUnitStart >= 0) {
                    unit = { data: array.subarray(lastUnitStart, i - state - 1), type: lastUnitType };
                    // logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);
                    units.push(unit);
                }
                else {
                    // lastUnitStart is undefined => this is the first start code found in this PES packet
                    // first check if start code delimiter is overlapping between 2 PES packets,
                    // ie it started in last packet (lastState not zero)
                    // and ended at the beginning of this PES packet (i <= 4 - lastState)
                    var lastUnit = this._getLastNalUnit();
                    if (lastUnit) {
                        if (lastState && (i <= 4 - lastState)) {
                            // start delimiter overlapping between PES packets
                            // strip start delimiter bytes from the end of last NAL unit
                            // check if lastUnit had a state different from zero
                            if (lastUnit.state) {
                                // strip last bytes
                                lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
                            }
                        }
                        // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.
                        overflow = i - state - 1;
                        if (overflow > 0) {
                            // logger.log('first NALU found with overflow:' + overflow);
                            var tmp = new Uint8Array(lastUnit.data.byteLength + overflow);
                            tmp.set(lastUnit.data, 0);
                            tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);
                            lastUnit.data = tmp;
                        }
                    }
                }
                // check if we can read unit type
                if (i < len) {
                    unitType = array[i] & 0x1f;
                    // logger.log('find NALU @ offset:' + i + ',type:' + unitType);
                    lastUnitStart = i;
                    lastUnitType = unitType;
                    state = 0;
                }
                else {
                    // not enough byte to read unit type. let's read it on next PES parsing
                    state = -1;
                }
            }
            else {
                state = 0;
            }
        }
        if (lastUnitStart >= 0 && state >= 0) {
            unit = { data: array.subarray(lastUnitStart, len), type: lastUnitType, state: state };
            units.push(unit);
            // logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);
        }
        // no NALu found
        if (units.length === 0) {
            // append pes.data to previous NAL unit
            var lastUnit = this._getLastNalUnit();
            if (lastUnit) {
                var tmp = new Uint8Array(lastUnit.data.byteLength + array.byteLength);
                tmp.set(lastUnit.data, 0);
                tmp.set(array, lastUnit.data.byteLength);
                lastUnit.data = tmp;
            }
        }
        track.naluState = state;
        return units;
    };
    /**
     * remove Emulation Prevention bytes from a RBSP
     */
    TSDemuxer.prototype.discardEPB = function (data) {
        var length = data.byteLength, EPBPositions = [], i = 1, newLength, newData;
        // Find all `Emulation Prevention Bytes`
        while (i < length - 2) {
            if (data[i] === 0 &&
                data[i + 1] === 0 &&
                data[i + 2] === 0x03) {
                EPBPositions.push(i + 2);
                i += 2;
            }
            else {
                i++;
            }
        }
        // If no Emulation Prevention Bytes were found just return the original
        // array
        if (EPBPositions.length === 0) {
            return data;
        }
        // Create a new array to hold the NAL unit data
        newLength = length - EPBPositions.length;
        newData = new Uint8Array(newLength);
        var sourceIndex = 0;
        for (i = 0; i < newLength; sourceIndex++, i++) {
            if (sourceIndex === EPBPositions[0]) {
                // Skip this byte
                sourceIndex++;
                // Remove this position index
                EPBPositions.shift();
            }
            newData[i] = data[sourceIndex];
        }
        return newData;
    };
    TSDemuxer.prototype._parseAACPES = function (pes) {
        var track = this._audioTrack, data = pes.data, pts = pes.pts, startOffset = 0, aacOverFlow = this.aacOverFlow, aacLastPTS = this.aacLastPTS, frameDuration, frameIndex, offset, stamp, len;
        if (aacOverFlow) {
            var tmp = new Uint8Array(aacOverFlow.byteLength + data.byteLength);
            tmp.set(aacOverFlow, 0);
            tmp.set(data, aacOverFlow.byteLength);
            // logger.log(`AAC: append overflowing ${aacOverFlow.byteLength} bytes to beginning of new PES`);
            data = tmp;
        }
        // look for ADTS header (0xFFFx)
        for (offset = startOffset, len = data.length; offset < len - 1; offset++) {
            if (ADTS.isHeader(data, offset)) {
                break;
            }
        }
        // if ADTS header does not start straight from the beginning of the PES payload, raise an error
        if (offset) {
            var reason = void 0, fatal = void 0;
            if (offset < len - 1) {
                reason = "AAC PES did not start with ADTS header,offset:" + offset;
                fatal = false;
            }
            else {
                reason = 'no ADTS header found in AAC PES';
                fatal = true;
            }
            logger_1.logger.warn("parsing error:" + reason);
            this.observer.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.MEDIA_ERROR, details: errors_1.ErrorDetails.FRAG_PARSING_ERROR, fatal: fatal, reason: reason });
            if (fatal) {
                return;
            }
        }
        ADTS.initTrackConfig(track, this.observer, data, offset, this.audioCodec);
        frameIndex = 0;
        frameDuration = ADTS.getFrameDuration(track.samplerate);
        // if last AAC frame is overflowing, we should ensure timestamps are contiguous:
        // first sample PTS should be equal to last sample PTS + frameDuration
        if (aacOverFlow && aacLastPTS) {
            var newPTS = aacLastPTS + frameDuration;
            if (Math.abs(newPTS - pts) > 1) {
                logger_1.logger.log("AAC: align PTS for overlapping frames by " + Math.round((newPTS - pts) / 90));
                pts = newPTS;
            }
        }
        // scan for aac samples
        while (offset < len) {
            if (ADTS.isHeader(data, offset) && (offset + 5) < len) {
                var frame = ADTS.appendFrame(track, data, offset, pts, frameIndex);
                if (frame) {
                    // logger.log(`${Math.round(frame.sample.pts)} : AAC`);
                    offset += frame.length;
                    stamp = frame.sample.pts;
                    frameIndex++;
                }
                else {
                    // logger.log('Unable to parse AAC frame');
                    break;
                }
            }
            else {
                // nothing found, keep looking
                offset++;
            }
        }
        if (offset < len) {
            aacOverFlow = data.subarray(offset, len);
            // logger.log(`AAC: overflow detected:${len-offset}`);
        }
        else {
            aacOverFlow = null;
        }
        this.aacOverFlow = aacOverFlow;
        this.aacLastPTS = stamp;
    };
    TSDemuxer.prototype._parseMPEGPES = function (pes) {
        var data = pes.data;
        var length = data.length;
        var frameIndex = 0;
        var offset = 0;
        var pts = pes.pts;
        while (offset < length) {
            if (mpegaudio_1.default.isHeader(data, offset)) {
                var frame = mpegaudio_1.default.appendFrame(this._audioTrack, data, offset, pts, frameIndex);
                if (frame) {
                    offset += frame.length;
                    frameIndex++;
                }
                else {
                    // logger.log('Unable to parse Mpeg audio frame');
                    break;
                }
            }
            else {
                // nothing found, keep looking
                offset++;
            }
        }
    };
    TSDemuxer.prototype._parseID3PES = function (pes) {
        this._id3Track.samples.push(pes);
    };
    return TSDemuxer;
}());
exports.default = TSDemuxer;


/***/ }),

/***/ "./src/errors.js":
/*!***********************!*\
  !*** ./src/errors.js ***!
  \***********************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ErrorTypes = {
    // Identifier for a network error (loading error / timeout ...)
    NETWORK_ERROR: 'networkError',
    // Identifier for a media Error (video/parsing/mediasource error)
    MEDIA_ERROR: 'mediaError',
    // EME (encrypted media extensions) errors
    KEY_SYSTEM_ERROR: 'keySystemError',
    // Identifier for a mux Error (demuxing/remuxing)
    MUX_ERROR: 'muxError',
    // Identifier for all other errors
    OTHER_ERROR: 'otherError'
};
/**
 * @enum {ErrorDetails}
 * @typedef {string} ErrorDetail
 */
exports.ErrorDetails = {
    KEY_SYSTEM_NO_KEYS: 'keySystemNoKeys',
    KEY_SYSTEM_NO_ACCESS: 'keySystemNoAccess',
    KEY_SYSTEM_NO_SESSION: 'keySystemNoSession',
    KEY_SYSTEM_LICENSE_REQUEST_FAILED: 'keySystemLicenseRequestFailed',
    // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}
    MANIFEST_LOAD_ERROR: 'manifestLoadError',
    // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
    MANIFEST_LOAD_TIMEOUT: 'manifestLoadTimeOut',
    // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}
    MANIFEST_PARSING_ERROR: 'manifestParsingError',
    // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}
    MANIFEST_INCOMPATIBLE_CODECS_ERROR: 'manifestIncompatibleCodecsError',
    // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}
    LEVEL_LOAD_ERROR: 'levelLoadError',
    // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
    LEVEL_LOAD_TIMEOUT: 'levelLoadTimeOut',
    // Identifier for a level switch error - data: { level : faulty level Id, event : error description}
    LEVEL_SWITCH_ERROR: 'levelSwitchError',
    // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}
    AUDIO_TRACK_LOAD_ERROR: 'audioTrackLoadError',
    // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
    AUDIO_TRACK_LOAD_TIMEOUT: 'audioTrackLoadTimeOut',
    // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}
    FRAG_LOAD_ERROR: 'fragLoadError',
    // Identifier for fragment load timeout error - data: { frag : fragment object}
    FRAG_LOAD_TIMEOUT: 'fragLoadTimeOut',
    // Identifier for a fragment decryption error event - data: {id : demuxer Id,frag: fragment object, reason : parsing error description }
    FRAG_DECRYPT_ERROR: 'fragDecryptError',
    // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }
    // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release
    FRAG_PARSING_ERROR: 'fragParsingError',
    // Identifier for a remux alloc error event - data: { id : demuxer Id, frag : fragment object, bytes : nb of bytes on which allocation failed , reason : error text }
    REMUX_ALLOC_ERROR: 'remuxAllocError',
    // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}
    KEY_LOAD_ERROR: 'keyLoadError',
    // Identifier for decrypt key load timeout error - data: { frag : fragment object}
    KEY_LOAD_TIMEOUT: 'keyLoadTimeOut',
    // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : {  err : exception , mimeType : mimeType }
    BUFFER_ADD_CODEC_ERROR: 'bufferAddCodecError',
    // Identifier for a buffer append error - data: append error description
    BUFFER_APPEND_ERROR: 'bufferAppendError',
    // Identifier for a buffer appending error event - data: appending error description
    BUFFER_APPENDING_ERROR: 'bufferAppendingError',
    // Identifier for a buffer stalled error event
    BUFFER_STALLED_ERROR: 'bufferStalledError',
    // Identifier for a buffer full event
    BUFFER_FULL_ERROR: 'bufferFullError',
    // Identifier for a buffer seek over hole event
    BUFFER_SEEK_OVER_HOLE: 'bufferSeekOverHole',
    // Identifier for a buffer nudge on stall (playback is stuck although currentTime is in a buffered area)
    BUFFER_NUDGE_ON_STALL: 'bufferNudgeOnStall',
    // Identifier for an internal exception happening inside hls.js while handling an event
    INTERNAL_EXCEPTION: 'internalException'
};


/***/ }),

/***/ "./src/event-handler.js":
/*!******************************!*\
  !*** ./src/event-handler.js ***!
  \******************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
*
* All objects in the event handling chain should inherit from this class
*
*/
Object.defineProperty(exports, "__esModule", { value: true });
var logger_1 = __webpack_require__(/*! ./utils/logger */ "./src/utils/logger.js");
var errors_1 = __webpack_require__(/*! ./errors */ "./src/errors.js");
var events_1 = __webpack_require__(/*! ./events */ "./src/events.js");
var FORBIDDEN_EVENT_NAMES = {
    'hlsEventGeneric': true,
    'hlsHandlerDestroying': true,
    'hlsHandlerDestroyed': true
};
var EventHandler = /** @class */ (function () {
    function EventHandler(hls) {
        var events = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            events[_i - 1] = arguments[_i];
        }
        this.hls = hls;
        this.onEvent = this.onEvent.bind(this);
        this.handledEvents = events;
        this.useGenericHandler = true;
        this.registerListeners();
    }
    EventHandler.prototype.destroy = function () {
        this.onHandlerDestroying();
        this.unregisterListeners();
        this.onHandlerDestroyed();
    };
    EventHandler.prototype.onHandlerDestroying = function () { };
    EventHandler.prototype.onHandlerDestroyed = function () { };
    EventHandler.prototype.isEventHandler = function () {
        return typeof this.handledEvents === 'object' && this.handledEvents.length && typeof this.onEvent === 'function';
    };
    EventHandler.prototype.registerListeners = function () {
        if (this.isEventHandler()) {
            this.handledEvents.forEach(function (event) {
                if (FORBIDDEN_EVENT_NAMES[event]) {
                    throw new Error('Forbidden event-name: ' + event);
                }
                this.hls.on(event, this.onEvent);
            }, this);
        }
    };
    EventHandler.prototype.unregisterListeners = function () {
        if (this.isEventHandler()) {
            this.handledEvents.forEach(function (event) {
                this.hls.off(event, this.onEvent);
            }, this);
        }
    };
    /**
     * arguments: event (string), data (any)
     */
    EventHandler.prototype.onEvent = function (event, data) {
        this.onEventGeneric(event, data);
    };
    EventHandler.prototype.onEventGeneric = function (event, data) {
        var eventToFunction = function (event, data) {
            var funcName = 'on' + event.replace('hls', '');
            if (typeof this[funcName] !== 'function') {
                throw new Error("Event " + event + " has no generic handler in this " + this.constructor.name + " class (tried " + funcName + ")");
            }
            return this[funcName].bind(this, data);
        };
        try {
            eventToFunction.call(this, event, data).call();
        }
        catch (err) {
            logger_1.logger.error("An internal error happened while handling event " + event + ". Error message: \"" + err.message + "\". Here is a stacktrace:", err);
            this.hls.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.OTHER_ERROR, details: errors_1.ErrorDetails.INTERNAL_EXCEPTION, fatal: false, event: event, err: err });
        }
    };
    return EventHandler;
}());
exports.default = EventHandler;


/***/ }),

/***/ "./src/events.js":
/*!***********************!*\
  !*** ./src/events.js ***!
  \***********************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @readonly
 * @enum {string}
 */
var HlsEvents = {
    // fired before MediaSource is attaching to media element - data: { media }
    MEDIA_ATTACHING: 'hlsMediaAttaching',
    // fired when MediaSource has been succesfully attached to media element - data: { }
    MEDIA_ATTACHED: 'hlsMediaAttached',
    // fired before detaching MediaSource from media element - data: { }
    MEDIA_DETACHING: 'hlsMediaDetaching',
    // fired when MediaSource has been detached from media element - data: { }
    MEDIA_DETACHED: 'hlsMediaDetached',
    // fired when we buffer is going to be reset - data: { }
    BUFFER_RESET: 'hlsBufferReset',
    // fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}
    BUFFER_CODECS: 'hlsBufferCodecs',
    // fired when sourcebuffers have been created - data: { tracks : tracks }
    BUFFER_CREATED: 'hlsBufferCreated',
    // fired when we append a segment to the buffer - data: { segment: segment object }
    BUFFER_APPENDING: 'hlsBufferAppending',
    // fired when we are done with appending a media segment to the buffer - data : { parent : segment parent that triggered BUFFER_APPENDING, pending : nb of segments waiting for appending for this segment parent}
    BUFFER_APPENDED: 'hlsBufferAppended',
    // fired when the stream is finished and we want to notify the media buffer that there will be no more data - data: { }
    BUFFER_EOS: 'hlsBufferEos',
    // fired when the media buffer should be flushed - data { startOffset, endOffset }
    BUFFER_FLUSHING: 'hlsBufferFlushing',
    // fired when the media buffer has been flushed - data: { }
    BUFFER_FLUSHED: 'hlsBufferFlushed',
    // fired to signal that a manifest loading starts - data: { url : manifestURL}
    MANIFEST_LOADING: 'hlsManifestLoading',
    // fired after manifest has been loaded - data: { levels : [available quality levels], audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}
    MANIFEST_LOADED: 'hlsManifestLoaded',
    // fired after manifest has been parsed - data: { levels : [available quality levels], firstLevel : index of first quality level appearing in Manifest}
    MANIFEST_PARSED: 'hlsManifestParsed',
    // fired when a level switch is requested - data: { level : id of new level }
    LEVEL_SWITCHING: 'hlsLevelSwitching',
    // fired when a level switch is effective - data: { level : id of new level }
    LEVEL_SWITCHED: 'hlsLevelSwitched',
    // fired when a level playlist loading starts - data: { url : level URL, level : id of level being loaded}
    LEVEL_LOADING: 'hlsLevelLoading',
    // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }
    LEVEL_LOADED: 'hlsLevelLoaded',
    // fired when a level's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, level : id of updated level }
    LEVEL_UPDATED: 'hlsLevelUpdated',
    // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }
    LEVEL_PTS_UPDATED: 'hlsLevelPtsUpdated',
    // fired to notify that audio track lists has been updated - data: { audioTracks : audioTracks }
    AUDIO_TRACKS_UPDATED: 'hlsAudioTracksUpdated',
    // fired when an audio track switching is requested - data: { id : audio track id }
    AUDIO_TRACK_SWITCHING: 'hlsAudioTrackSwitching',
    // fired when an audio track switch actually occurs - data: { id : audio track id }
    AUDIO_TRACK_SWITCHED: 'hlsAudioTrackSwitched',
    // fired when an audio track loading starts - data: { url : audio track URL, id : audio track id }
    AUDIO_TRACK_LOADING: 'hlsAudioTrackLoading',
    // fired when an audio track loading finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime } }
    AUDIO_TRACK_LOADED: 'hlsAudioTrackLoaded',
    // fired to notify that subtitle track lists has been updated - data: { subtitleTracks : subtitleTracks }
    SUBTITLE_TRACKS_UPDATED: 'hlsSubtitleTracksUpdated',
    // fired when an subtitle track switch occurs - data: { id : subtitle track id }
    SUBTITLE_TRACK_SWITCH: 'hlsSubtitleTrackSwitch',
    // fired when a subtitle track loading starts - data: { url : subtitle track URL, id : subtitle track id }
    SUBTITLE_TRACK_LOADING: 'hlsSubtitleTrackLoading',
    // fired when a subtitle track loading finishes - data: { details : levelDetails object, id : subtitle track id, stats : { trequest, tfirst, tload, mtime } }
    SUBTITLE_TRACK_LOADED: 'hlsSubtitleTrackLoaded',
    // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag }
    SUBTITLE_FRAG_PROCESSED: 'hlsSubtitleFragProcessed',
    // fired when the first timestamp is found - data: { id : demuxer id, initPTS: initPTS, frag : fragment object }
    INIT_PTS_FOUND: 'hlsInitPtsFound',
    // fired when a fragment loading starts - data: { frag : fragment object }
    FRAG_LOADING: 'hlsFragLoading',
    // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded } }
    FRAG_LOAD_PROGRESS: 'hlsFragLoadProgress',
    // Identifier for fragment load aborting for emergency switch down - data: { frag : fragment object }
    FRAG_LOAD_EMERGENCY_ABORTED: 'hlsFragLoadEmergencyAborted',
    // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length } }
    FRAG_LOADED: 'hlsFragLoaded',
    // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, payload : fragment payload, stats : { tstart, tdecrypt } }
    FRAG_DECRYPTED: 'hlsFragDecrypted',
    // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment }
    FRAG_PARSING_INIT_SEGMENT: 'hlsFragParsingInitSegment',
    // fired when parsing sei text is completed - data: { id : demuxer id, frag: fragment object, samples : [ sei samples pes ] }
    FRAG_PARSING_USERDATA: 'hlsFragParsingUserdata',
    // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }
    FRAG_PARSING_METADATA: 'hlsFragParsingMetadata',
    // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}
    FRAG_PARSING_DATA: 'hlsFragParsingData',
    // fired when fragment parsing is completed - data: { id : demuxer id, frag: fragment object }
    FRAG_PARSED: 'hlsFragParsed',
    // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id, frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length, bwEstimate } }
    FRAG_BUFFERED: 'hlsFragBuffered',
    // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }
    FRAG_CHANGED: 'hlsFragChanged',
    // Identifier for a FPS drop event - data: { curentDropped, currentDecoded, totalDroppedFrames }
    FPS_DROP: 'hlsFpsDrop',
    // triggered when FPS drop triggers auto level capping - data: { level, droppedlevel }
    FPS_DROP_LEVEL_CAPPING: 'hlsFpsDropLevelCapping',
    // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data }
    ERROR: 'hlsError',
    // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example - data: { }
    DESTROYING: 'hlsDestroying',
    // fired when a decrypt key loading starts - data: { frag : fragment object }
    KEY_LOADING: 'hlsKeyLoading',
    // fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length } }
    KEY_LOADED: 'hlsKeyLoaded',
    // fired upon stream controller state transitions - data: { previousState, nextState }
    STREAM_STATE_TRANSITION: 'hlsStreamStateTransition'
};
exports.default = HlsEvents;


/***/ }),

/***/ "./src/hls.js":
/*!********************!*\
  !*** ./src/hls.js ***!
  \********************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var URLToolkit = __webpack_require__(/*! url-toolkit */ "./node_modules/url-toolkit/src/url-toolkit.js");
var errors_1 = __webpack_require__(/*! ./errors */ "./src/errors.js");
var playlist_loader_1 = __webpack_require__(/*! ./loader/playlist-loader */ "./src/loader/playlist-loader.js");
var fragment_loader_1 = __webpack_require__(/*! ./loader/fragment-loader */ "./src/loader/fragment-loader.js");
var key_loader_1 = __webpack_require__(/*! ./loader/key-loader */ "./src/loader/key-loader.js");
var fragment_tracker_1 = __webpack_require__(/*! ./controller/fragment-tracker */ "./src/controller/fragment-tracker.js");
var stream_controller_1 = __webpack_require__(/*! ./controller/stream-controller */ "./src/controller/stream-controller.js");
var level_controller_1 = __webpack_require__(/*! ./controller/level-controller */ "./src/controller/level-controller.js");
var id3_track_controller_1 = __webpack_require__(/*! ./controller/id3-track-controller */ "./src/controller/id3-track-controller.js");
var is_supported_1 = __webpack_require__(/*! ./is-supported */ "./src/is-supported.js");
var logger_1 = __webpack_require__(/*! ./utils/logger */ "./src/utils/logger.js");
var config_1 = __webpack_require__(/*! ./config */ "./src/config.js");
var events_1 = __webpack_require__(/*! ./events */ "./src/events.js");
var observer_1 = __webpack_require__(/*! ./observer */ "./src/observer.js");
/**
 * @module Hls
 * @class
 * @constructor
 */
var Hls = /** @class */ (function (_super) {
    __extends(Hls, _super);
    /**
     * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.
     *
     * @constructs Hls
     * @param {HlsConfig} config
     */
    function Hls(config) {
        if (config === void 0) { config = {}; }
        var _this = _super.call(this) || this;
        var defaultConfig = Hls.DefaultConfig;
        if ((config.liveSyncDurationCount || config.liveMaxLatencyDurationCount) && (config.liveSyncDuration || config.liveMaxLatencyDuration)) {
            throw new Error('Illegal hls.js config: don\'t mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration');
        }
        for (var prop in defaultConfig) {
            if (prop in config)
                continue;
            config[prop] = defaultConfig[prop];
        }
        if (config.liveMaxLatencyDurationCount !== undefined && config.liveMaxLatencyDurationCount <= config.liveSyncDurationCount) {
            throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"');
        }
        if (config.liveMaxLatencyDuration !== undefined && (config.liveMaxLatencyDuration <= config.liveSyncDuration || config.liveSyncDuration === undefined)) {
            throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"');
        }
        logger_1.enableLogs(config.debug);
        _this.config = config;
        _this._autoLevelCapping = -1;
        // core controllers and network loaders
        /**
         * @member {AbrController} abrController
         */
        var abrController = _this.abrController = new config.abrController(_this);
        var bufferController = new config.bufferController(_this);
        var capLevelController = new config.capLevelController(_this);
        var fpsController = new config.fpsController(_this);
        var playListLoader = new playlist_loader_1.default(_this);
        var fragmentLoader = new fragment_loader_1.default(_this);
        var keyLoader = new key_loader_1.default(_this);
        var id3TrackController = new id3_track_controller_1.default(_this);
        // network controllers
        /**
         * @member {LevelController} levelController
         */
        var levelController = _this.levelController = new level_controller_1.default(_this);
        // FIXME: FragmentTracker must be defined before StreamController because the order of event handling is important
        var fragmentTracker = new fragment_tracker_1.FragmentTracker(_this);
        /**
         * @member {StreamController} streamController
         */
        var streamController = _this.streamController = new stream_controller_1.default(_this, fragmentTracker);
        var networkControllers = [levelController, streamController];
        // optional audio stream controller
        /**
         * @var {ICoreComponent | Controller}
         */
        var Controller = config.audioStreamController;
        if (Controller) {
            networkControllers.push(new Controller(_this, fragmentTracker));
        }
        /**
         * @member {INetworkController[]} networkControllers
         */
        _this.networkControllers = networkControllers;
        /**
         * @var {ICoreComponent[]}
         */
        var coreComponents = [
            playListLoader,
            fragmentLoader,
            keyLoader,
            abrController,
            bufferController,
            capLevelController,
            fpsController,
            id3TrackController,
            fragmentTracker
        ];
        // optional audio track and subtitle controller
        Controller = config.audioTrackController;
        if (Controller) {
            var audioTrackController = new Controller(_this);
            /**
             * @member {AudioTrackController} audioTrackController
             */
            _this.audioTrackController = audioTrackController;
            coreComponents.push(audioTrackController);
        }
        Controller = config.subtitleTrackController;
        if (Controller) {
            var subtitleTrackController = new Controller(_this);
            /**
             * @member {SubtitleTrackController} subtitleTrackController
             */
            _this.subtitleTrackController = subtitleTrackController;
            coreComponents.push(subtitleTrackController);
        }
        Controller = config.emeController;
        if (Controller) {
            var emeController = new Controller(_this);
            /**
             * @member {EMEController} emeController
             */
            _this.emeController = emeController;
            coreComponents.push(emeController);
        }
        // optional subtitle controllers
        Controller = config.subtitleStreamController;
        if (Controller) {
            coreComponents.push(new Controller(_this, fragmentTracker));
        }
        Controller = config.timelineController;
        if (Controller) {
            coreComponents.push(new Controller(_this));
        }
        /**
         * @member {ICoreComponent[]}
         */
        _this.coreComponents = coreComponents;
        return _this;
    }
    Object.defineProperty(Hls, "version", {
        /**
         * @type {string}
         */
        get: function () {
            return "0.12.2";
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @type {boolean}
     */
    Hls.isSupported = function () {
        return is_supported_1.isSupported();
    };
    Object.defineProperty(Hls, "Events", {
        /**
         * @type {HlsEvents}
         */
        get: function () {
            return events_1.default;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls, "ErrorTypes", {
        /**
         * @type {HlsErrorTypes}
         */
        get: function () {
            return errors_1.ErrorTypes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls, "ErrorDetails", {
        /**
         * @type {HlsErrorDetails}
         */
        get: function () {
            return errors_1.ErrorDetails;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls, "DefaultConfig", {
        /**
         * @type {HlsConfig}
         */
        get: function () {
            if (!Hls.defaultConfig) {
                return config_1.hlsDefaultConfig;
            }
            return Hls.defaultConfig;
        },
        /**
         * @type {HlsConfig}
         */
        set: function (defaultConfig) {
            Hls.defaultConfig = defaultConfig;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the instance
     */
    Hls.prototype.destroy = function () {
        logger_1.logger.log('destroy');
        this.trigger(events_1.default.DESTROYING);
        this.detachMedia();
        this.coreComponents.concat(this.networkControllers).forEach(function (component) {
            component.destroy();
        });
        this.url = null;
        this.removeAllListeners();
        this._autoLevelCapping = -1;
    };
    /**
     * Attach a media element
     * @param {HTMLMediaElement} media
     */
    Hls.prototype.attachMedia = function (media) {
        logger_1.logger.log('attachMedia');
        this.media = media;
        this.trigger(events_1.default.MEDIA_ATTACHING, { media: media });
    };
    /**
     * Detach from the media
     */
    Hls.prototype.detachMedia = function () {
        logger_1.logger.log('detachMedia');
        this.trigger(events_1.default.MEDIA_DETACHING);
        this.media = null;
    };
    /**
     * Set the source URL. Can be relative or absolute.
     * @param {string} url
     */
    Hls.prototype.loadSource = function (url) {
        url = URLToolkit.buildAbsoluteURL(window.location.href, url, { alwaysNormalize: true });
        logger_1.logger.log("loadSource:" + url);
        this.url = url;
        // when attaching to a source URL, trigger a playlist load
        this.trigger(events_1.default.MANIFEST_LOADING, { url: url });
    };
    /**
     * Start loading data from the stream source.
     * Depending on default config, client starts loading automatically when a source is set.
     *
     * @param {number} startPosition Set the start position to stream from
     * @default -1 None (from earliest point)
     */
    Hls.prototype.startLoad = function (startPosition) {
        if (startPosition === void 0) { startPosition = -1; }
        logger_1.logger.log("startLoad(" + startPosition + ")");
        this.networkControllers.forEach(function (controller) {
            controller.startLoad(startPosition);
        });
    };
    /**
     * Stop loading of any stream data.
     */
    Hls.prototype.stopLoad = function () {
        logger_1.logger.log('stopLoad');
        this.networkControllers.forEach(function (controller) {
            controller.stopLoad();
        });
    };
    /**
     * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)
     */
    Hls.prototype.swapAudioCodec = function () {
        logger_1.logger.log('swapAudioCodec');
        this.streamController.swapAudioCodec();
    };
    /**
     * When the media-element fails, this allows to detach and then re-attach it
     * as one call (convenience method).
     *
     * Automatic recovery of media-errors by this process is configurable.
     */
    Hls.prototype.recoverMediaError = function () {
        logger_1.logger.log('recoverMediaError');
        var media = this.media;
        this.detachMedia();
        this.attachMedia(media);
    };
    Object.defineProperty(Hls.prototype, "levels", {
        /**
         * @type {QualityLevel[]}
         */
        get: function () {
            return this.levelController.levels;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "currentLevel", {
        /**
         * Index of quality level currently played
         * @type {number}
         */
        get: function () {
            return this.streamController.currentLevel;
        },
        /**
         * Set quality level index immediately .
         * This will flush the current buffer to replace the quality asap.
         * That means playback will interrupt at least shortly to re-buffer and re-sync eventually.
         * @type {number} -1 for automatic level selection
         */
        set: function (newLevel) {
            logger_1.logger.log("set currentLevel:" + newLevel);
            this.loadLevel = newLevel;
            this.streamController.immediateLevelSwitch();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "nextLevel", {
        /**
         * Index of next quality level loaded as scheduled by stream controller.
         * @type {number}
         */
        get: function () {
            return this.streamController.nextLevel;
        },
        /**
         * Set quality level index for next loaded data.
         * This will switch the video quality asap, without interrupting playback.
         * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).
         * @type {number} -1 for automatic level selection
         */
        set: function (newLevel) {
            logger_1.logger.log("set nextLevel:" + newLevel);
            this.levelController.manualLevel = newLevel;
            this.streamController.nextLevelSwitch();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "loadLevel", {
        /**
         * Return the quality level of the currently or last (of none is loaded currently) segment
         * @type {number}
         */
        get: function () {
            return this.levelController.level;
        },
        /**
         * Set quality level index for next loaded data in a conservative way.
         * This will switch the quality without flushing, but interrupt current loading.
         * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.
         * @type {number} newLevel -1 for automatic level selection
         */
        set: function (newLevel) {
            logger_1.logger.log("set loadLevel:" + newLevel);
            this.levelController.manualLevel = newLevel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "nextLoadLevel", {
        /**
         * get next quality level loaded
         * @type {number}
         */
        get: function () {
            return this.levelController.nextLoadLevel;
        },
        /**
         * Set quality level of next loaded segment in a fully "non-destructive" way.
         * Same as `loadLevel` but will wait for next switch (until current loading is done).
         * @type {number} level
         */
        set: function (level) {
            this.levelController.nextLoadLevel = level;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "firstLevel", {
        /**
         * Return "first level": like a default level, if not set,
         * falls back to index of first level referenced in manifest
         * @type {number}
         */
        get: function () {
            return Math.max(this.levelController.firstLevel, this.minAutoLevel);
        },
        /**
         * Sets "first-level", see getter.
         * @type {number}
         */
        set: function (newLevel) {
            logger_1.logger.log("set firstLevel:" + newLevel);
            this.levelController.firstLevel = newLevel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "startLevel", {
        /**
         * Return start level (level of first fragment that will be played back)
         * if not overrided by user, first level appearing in manifest will be used as start level
         * if -1 : automatic start level selection, playback will start from level matching download bandwidth
         * (determined from download of first segment)
         * @type {number}
         */
        get: function () {
            return this.levelController.startLevel;
        },
        /**
         * set  start level (level of first fragment that will be played back)
         * if not overrided by user, first level appearing in manifest will be used as start level
         * if -1 : automatic start level selection, playback will start from level matching download bandwidth
         * (determined from download of first segment)
         * @type {number} newLevel
         */
        set: function (newLevel) {
            logger_1.logger.log("set startLevel:" + newLevel);
            var hls = this;
            // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel
            if (newLevel !== -1) {
                newLevel = Math.max(newLevel, hls.minAutoLevel);
            }
            hls.levelController.startLevel = newLevel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "autoLevelCapping", {
        /**
         * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
         * @type {number}
         */
        get: function () {
            return this._autoLevelCapping;
        },
        /**
         * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
         * @type {number}
         */
        set: function (newLevel) {
            logger_1.logger.log("set autoLevelCapping:" + newLevel);
            this._autoLevelCapping = newLevel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "autoLevelEnabled", {
        /**
         * True when automatic level selection enabled
         * @type {boolean}
         */
        get: function () {
            return (this.levelController.manualLevel === -1);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "manualLevel", {
        /**
         * Level set manually (if any)
         * @type {number}
         */
        get: function () {
            return this.levelController.manualLevel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "minAutoLevel", {
        /**
         * min level selectable in auto mode according to config.minAutoBitrate
         * @type {number}
         */
        get: function () {
            var hls = this, levels = hls.levels, minAutoBitrate = hls.config.minAutoBitrate, len = levels ? levels.length : 0;
            for (var i = 0; i < len; i++) {
                var levelNextBitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate;
                if (levelNextBitrate > minAutoBitrate) {
                    return i;
                }
            }
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "maxAutoLevel", {
        /**
         * max level selectable in auto mode according to autoLevelCapping
         * @type {number}
         */
        get: function () {
            var hls = this;
            var levels = hls.levels;
            var autoLevelCapping = hls.autoLevelCapping;
            var maxAutoLevel;
            if (autoLevelCapping === -1 && levels && levels.length) {
                maxAutoLevel = levels.length - 1;
            }
            else {
                maxAutoLevel = autoLevelCapping;
            }
            return maxAutoLevel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "nextAutoLevel", {
        /**
         * next automatically selected quality level
         * @type {number}
         */
        get: function () {
            var hls = this;
            // ensure next auto level is between  min and max auto level
            return Math.min(Math.max(hls.abrController.nextAutoLevel, hls.minAutoLevel), hls.maxAutoLevel);
        },
        /**
         * this setter is used to force next auto level.
         * this is useful to force a switch down in auto mode:
         * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)
         * forced value is valid for one fragment. upon succesful frag loading at forced level,
         * this value will be resetted to -1 by ABR controller.
         * @type {number}
         */
        set: function (nextLevel) {
            var hls = this;
            hls.abrController.nextAutoLevel = Math.max(hls.minAutoLevel, nextLevel);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "audioTracks", {
        /**
         * @type {AudioTrack[]}
         */
        get: function () {
            var audioTrackController = this.audioTrackController;
            return audioTrackController ? audioTrackController.audioTracks : [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "audioTrack", {
        /**
         * index of the selected audio track (index in audio track lists)
         * @type {number}
         */
        get: function () {
            var audioTrackController = this.audioTrackController;
            return audioTrackController ? audioTrackController.audioTrack : -1;
        },
        /**
         * selects an audio track, based on its index in audio track lists
         * @type {number}
         */
        set: function (audioTrackId) {
            var audioTrackController = this.audioTrackController;
            if (audioTrackController) {
                audioTrackController.audioTrack = audioTrackId;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "liveSyncPosition", {
        /**
         * @type {Seconds}
         */
        get: function () {
            return this.streamController.liveSyncPosition;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "subtitleTracks", {
        /**
         * get alternate subtitle tracks list from playlist
         * @type {SubtitleTrack[]}
         */
        get: function () {
            var subtitleTrackController = this.subtitleTrackController;
            return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "subtitleTrack", {
        /**
         * index of the selected subtitle track (index in subtitle track lists)
         * @type {number}
         */
        get: function () {
            var subtitleTrackController = this.subtitleTrackController;
            return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;
        },
        /**
         * select an subtitle track, based on its index in subtitle track lists
         * @type{number}
         */
        set: function (subtitleTrackId) {
            var subtitleTrackController = this.subtitleTrackController;
            if (subtitleTrackController) {
                subtitleTrackController.subtitleTrack = subtitleTrackId;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hls.prototype, "subtitleDisplay", {
        /**
         * @type {boolean}
         */
        get: function () {
            var subtitleTrackController = this.subtitleTrackController;
            return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;
        },
        /**
         * Enable/disable subtitle display rendering
         * @type {boolean}
         */
        set: function (value) {
            var subtitleTrackController = this.subtitleTrackController;
            if (subtitleTrackController) {
                subtitleTrackController.subtitleDisplay = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    return Hls;
}(observer_1.Observer));
exports.default = Hls;


/***/ }),

/***/ "./src/is-supported.js":
/*!*****************************!*\
  !*** ./src/is-supported.js ***!
  \*****************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var mediasource_helper_1 = __webpack_require__(/*! ./utils/mediasource-helper */ "./src/utils/mediasource-helper.js");
function isSupported() {
    var mediaSource = mediasource_helper_1.getMediaSource();
    var sourceBuffer = window.SourceBuffer || window.WebKitSourceBuffer;
    var isTypeSupported = mediaSource &&
        typeof mediaSource.isTypeSupported === 'function' &&
        mediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
    // if SourceBuffer is exposed ensure its API is valid
    // safari and old version of Chrome doe not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible
    var sourceBufferValidAPI = !sourceBuffer ||
        (sourceBuffer.prototype &&
            typeof sourceBuffer.prototype.appendBuffer === 'function' &&
            typeof sourceBuffer.prototype.remove === 'function');
    return !!isTypeSupported && !!sourceBufferValidAPI;
}
exports.isSupported = isSupported;


/***/ }),

/***/ "./src/loader/fragment-loader.js":
/*!***************************************!*\
  !*** ./src/loader/fragment-loader.js ***!
  \***************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
/*
 * Fragment Loader
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var event_handler_1 = __webpack_require__(/*! ../event-handler */ "./src/event-handler.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var FragmentLoader = /** @class */ (function (_super) {
    __extends(FragmentLoader, _super);
    function FragmentLoader(hls) {
        var _this = _super.call(this, hls, events_1.default.FRAG_LOADING) || this;
        _this.loaders = {};
        return _this;
    }
    FragmentLoader.prototype.destroy = function () {
        var loaders = this.loaders;
        for (var loaderName in loaders) {
            var loader = loaders[loaderName];
            if (loader) {
                loader.destroy();
            }
        }
        this.loaders = {};
        _super.prototype.destroy.call(this);
    };
    FragmentLoader.prototype.onFragLoading = function (data) {
        var frag = data.frag, type = frag.type, loaders = this.loaders, config = this.hls.config, FragmentILoader = config.fLoader, DefaultILoader = config.loader;
        // reset fragment state
        frag.loaded = 0;
        var loader = loaders[type];
        if (loader) {
            logger_1.logger.warn("abort previous fragment loader for type: " + type);
            loader.abort();
        }
        loader = loaders[type] = frag.loader =
            config.fLoader ? new FragmentILoader(config) : new DefaultILoader(config);
        var loaderContext, loaderConfig, loaderCallbacks;
        loaderContext = { url: frag.url, frag: frag, responseType: 'arraybuffer', progressData: false };
        var start = frag.byteRangeStartOffset, end = frag.byteRangeEndOffset;
        if (Number.isFinite(start) && Number.isFinite(end)) {
            loaderContext.rangeStart = start;
            loaderContext.rangeEnd = end;
        }
        loaderConfig = {
            timeout: config.fragLoadingTimeOut,
            maxRetry: 0,
            retryDelay: 0,
            maxRetryDelay: config.fragLoadingMaxRetryTimeout
        };
        loaderCallbacks = {
            onSuccess: this.loadsuccess.bind(this),
            onError: this.loaderror.bind(this),
            onTimeout: this.loadtimeout.bind(this),
            onProgress: this.loadprogress.bind(this)
        };
        loader.load(loaderContext, loaderConfig, loaderCallbacks);
    };
    FragmentLoader.prototype.loadsuccess = function (response, stats, context, networkDetails) {
        if (networkDetails === void 0) { networkDetails = null; }
        var payload = response.data, frag = context.frag;
        // detach fragment loader on load success
        frag.loader = undefined;
        this.loaders[frag.type] = undefined;
        this.hls.trigger(events_1.default.FRAG_LOADED, { payload: payload, frag: frag, stats: stats, networkDetails: networkDetails });
    };
    FragmentLoader.prototype.loaderror = function (response, context, networkDetails) {
        if (networkDetails === void 0) { networkDetails = null; }
        var frag = context.frag;
        var loader = frag.loader;
        if (loader) {
            loader.abort();
        }
        this.loaders[frag.type] = undefined;
        this.hls.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.NETWORK_ERROR, details: errors_1.ErrorDetails.FRAG_LOAD_ERROR, fatal: false, frag: context.frag, response: response, networkDetails: networkDetails });
    };
    FragmentLoader.prototype.loadtimeout = function (stats, context, networkDetails) {
        if (networkDetails === void 0) { networkDetails = null; }
        var frag = context.frag;
        var loader = frag.loader;
        if (loader) {
            loader.abort();
        }
        this.loaders[frag.type] = undefined;
        this.hls.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.NETWORK_ERROR, details: errors_1.ErrorDetails.FRAG_LOAD_TIMEOUT, fatal: false, frag: context.frag, networkDetails: networkDetails });
    };
    // data will be used for progressive parsing
    FragmentLoader.prototype.loadprogress = function (stats, context, data, networkDetails) {
        if (networkDetails === void 0) { networkDetails = null; }
        var frag = context.frag;
        frag.loaded = stats.loaded;
        this.hls.trigger(events_1.default.FRAG_LOAD_PROGRESS, { frag: frag, stats: stats, networkDetails: networkDetails });
    };
    return FragmentLoader;
}(event_handler_1.default));
exports.default = FragmentLoader;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/loader/fragment.js":
/*!********************************!*\
  !*** ./src/loader/fragment.js ***!
  \********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
Object.defineProperty(exports, "__esModule", { value: true });
var URLToolkit = __webpack_require__(/*! url-toolkit */ "./node_modules/url-toolkit/src/url-toolkit.js");
var level_key_1 = __webpack_require__(/*! ./level-key */ "./src/loader/level-key.js");
var Fragment = /** @class */ (function () {
    function Fragment() {
        var _a;
        this._url = null;
        this._byteRange = null;
        this._decryptdata = null;
        this.tagList = [];
        this.programDateTime = null;
        this.rawProgramDateTime = null;
        // Holds the types of data this fragment supports
        this._elementaryStreams = (_a = {},
            _a[Fragment.ElementaryStreamTypes.AUDIO] = false,
            _a[Fragment.ElementaryStreamTypes.VIDEO] = false,
            _a);
    }
    Object.defineProperty(Fragment, "ElementaryStreamTypes", {
        /**
         * `type` property for this._elementaryStreams
         *
         * @enum
         */
        get: function () {
            return {
                AUDIO: 'audio',
                VIDEO: 'video'
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Fragment.prototype, "url", {
        get: function () {
            if (!this._url && this.relurl) {
                this._url = URLToolkit.buildAbsoluteURL(this.baseurl, this.relurl, { alwaysNormalize: true });
            }
            return this._url;
        },
        set: function (value) {
            this._url = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Fragment.prototype, "byteRange", {
        get: function () {
            if (!this._byteRange && !this.rawByteRange) {
                return [];
            }
            if (this._byteRange) {
                return this._byteRange;
            }
            var byteRange = [];
            if (this.rawByteRange) {
                var params = this.rawByteRange.split('@', 2);
                if (params.length === 1) {
                    var lastByteRangeEndOffset = this.lastByteRangeEndOffset;
                    byteRange[0] = lastByteRangeEndOffset || 0;
                }
                else {
                    byteRange[0] = parseInt(params[1]);
                }
                byteRange[1] = parseInt(params[0]) + byteRange[0];
                this._byteRange = byteRange;
            }
            return byteRange;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Fragment.prototype, "byteRangeStartOffset", {
        /**
         * @type {number}
         */
        get: function () {
            return this.byteRange[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Fragment.prototype, "byteRangeEndOffset", {
        get: function () {
            return this.byteRange[1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Fragment.prototype, "decryptdata", {
        get: function () {
            if (!this._decryptdata) {
                this._decryptdata = this.fragmentDecryptdataFromLevelkey(this.levelkey, this.sn);
            }
            return this._decryptdata;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Fragment.prototype, "endProgramDateTime", {
        get: function () {
            if (!Number.isFinite(this.programDateTime)) {
                return null;
            }
            var duration = !Number.isFinite(this.duration) ? 0 : this.duration;
            return this.programDateTime + (duration * 1000);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Fragment.prototype, "encrypted", {
        get: function () {
            return !!((this.decryptdata && this.decryptdata.uri !== null) && (this.decryptdata.key === null));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {ElementaryStreamType} type
     */
    Fragment.prototype.addElementaryStream = function (type) {
        this._elementaryStreams[type] = true;
    };
    /**
     * @param {ElementaryStreamType} type
     */
    Fragment.prototype.hasElementaryStream = function (type) {
        return this._elementaryStreams[type] === true;
    };
    /**
     * Utility method for parseLevelPlaylist to create an initialization vector for a given segment
     * @returns {Uint8Array}
     */
    Fragment.prototype.createInitializationVector = function (segmentNumber) {
        var uint8View = new Uint8Array(16);
        for (var i = 12; i < 16; i++) {
            uint8View[i] = (segmentNumber >> 8 * (15 - i)) & 0xff;
        }
        return uint8View;
    };
    /**
     * Utility method for parseLevelPlaylist to get a fragment's decryption data from the currently parsed encryption key data
     * @param levelkey - a playlist's encryption info
     * @param segmentNumber - the fragment's segment number
     * @returns {*} - an object to be applied as a fragment's decryptdata
     */
    Fragment.prototype.fragmentDecryptdataFromLevelkey = function (levelkey, segmentNumber) {
        var decryptdata = levelkey;
        if (levelkey && levelkey.method && levelkey.uri && !levelkey.iv) {
            decryptdata = new level_key_1.default();
            decryptdata.method = levelkey.method;
            decryptdata.baseuri = levelkey.baseuri;
            decryptdata.reluri = levelkey.reluri;
            decryptdata.iv = this.createInitializationVector(segmentNumber);
        }
        return decryptdata;
    };
    return Fragment;
}());
exports.default = Fragment;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/loader/key-loader.js":
/*!**********************************!*\
  !*** ./src/loader/key-loader.js ***!
  \**********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Decrypt key Loader
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var event_handler_1 = __webpack_require__(/*! ../event-handler */ "./src/event-handler.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var KeyLoader = /** @class */ (function (_super) {
    __extends(KeyLoader, _super);
    function KeyLoader(hls) {
        var _this = _super.call(this, hls, events_1.default.KEY_LOADING) || this;
        _this.loaders = {};
        _this.decryptkey = null;
        _this.decrypturl = null;
        return _this;
    }
    KeyLoader.prototype.destroy = function () {
        for (var loaderName in this.loaders) {
            var loader = this.loaders[loaderName];
            if (loader) {
                loader.destroy();
            }
        }
        this.loaders = {};
        event_handler_1.default.prototype.destroy.call(this);
    };
    KeyLoader.prototype.onKeyLoading = function (data) {
        var frag = data.frag, type = frag.type, loader = this.loaders[type], decryptdata = frag.decryptdata, uri = decryptdata.uri;
        // if uri is different from previous one or if decrypt key not retrieved yet
        if (uri !== this.decrypturl || this.decryptkey === null) {
            var config = this.hls.config;
            if (loader) {
                logger_1.logger.warn("abort previous key loader for type:" + type);
                loader.abort();
            }
            frag.loader = this.loaders[type] = new config.loader(config);
            this.decrypturl = uri;
            this.decryptkey = null;
            var loaderContext = void 0, loaderConfig = void 0, loaderCallbacks = void 0;
            loaderContext = { url: uri, frag: frag, responseType: 'arraybuffer' };
            // maxRetry is 0 so that instead of retrying the same key on the same variant multiple times,
            // key-loader will trigger an error and rely on stream-controller to handle retry logic.
            // this will also align retry logic with fragment-loader
            loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: 0, retryDelay: config.fragLoadingRetryDelay, maxRetryDelay: config.fragLoadingMaxRetryTimeout };
            loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
            frag.loader.load(loaderContext, loaderConfig, loaderCallbacks);
        }
        else if (this.decryptkey) {
            // we already loaded this key, return it
            decryptdata.key = this.decryptkey;
            this.hls.trigger(events_1.default.KEY_LOADED, { frag: frag });
        }
    };
    KeyLoader.prototype.loadsuccess = function (response, stats, context) {
        var frag = context.frag;
        this.decryptkey = frag.decryptdata.key = new Uint8Array(response.data);
        // detach fragment loader on load success
        frag.loader = undefined;
        this.loaders[frag.type] = undefined;
        this.hls.trigger(events_1.default.KEY_LOADED, { frag: frag });
    };
    KeyLoader.prototype.loaderror = function (response, context) {
        var frag = context.frag, loader = frag.loader;
        if (loader) {
            loader.abort();
        }
        this.loaders[context.type] = undefined;
        this.hls.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.NETWORK_ERROR, details: errors_1.ErrorDetails.KEY_LOAD_ERROR, fatal: false, frag: frag, response: response });
    };
    KeyLoader.prototype.loadtimeout = function (stats, context) {
        var frag = context.frag, loader = frag.loader;
        if (loader) {
            loader.abort();
        }
        this.loaders[context.type] = undefined;
        this.hls.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.NETWORK_ERROR, details: errors_1.ErrorDetails.KEY_LOAD_TIMEOUT, fatal: false, frag: frag });
    };
    return KeyLoader;
}(event_handler_1.default));
exports.default = KeyLoader;


/***/ }),

/***/ "./src/loader/level-key.js":
/*!*********************************!*\
  !*** ./src/loader/level-key.js ***!
  \*********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var URLToolkit = __webpack_require__(/*! url-toolkit */ "./node_modules/url-toolkit/src/url-toolkit.js");
var LevelKey = /** @class */ (function () {
    function LevelKey() {
        this.method = null;
        this.key = null;
        this.iv = null;
        this._uri = null;
    }
    Object.defineProperty(LevelKey.prototype, "uri", {
        get: function () {
            if (!this._uri && this.reluri) {
                this._uri = URLToolkit.buildAbsoluteURL(this.baseuri, this.reluri, { alwaysNormalize: true });
            }
            return this._uri;
        },
        enumerable: true,
        configurable: true
    });
    return LevelKey;
}());
exports.default = LevelKey;


/***/ }),

/***/ "./src/loader/level.js":
/*!*****************************!*\
  !*** ./src/loader/level.js ***!
  \*****************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
Object.defineProperty(exports, "__esModule", { value: true });
var Level = /** @class */ (function () {
    function Level(baseUrl) {
        // Please keep properties in alphabetical order
        this.endCC = 0;
        this.endSN = 0;
        this.fragments = [];
        this.initSegment = null;
        this.live = true;
        this.needSidxRanges = false;
        this.startCC = 0;
        this.startSN = 0;
        this.startTimeOffset = null;
        this.targetduration = 0;
        this.totalduration = 0;
        this.type = null;
        this.url = baseUrl;
        this.version = null;
    }
    Object.defineProperty(Level.prototype, "hasProgramDateTime", {
        get: function () {
            return !!(this.fragments[0] && Number.isFinite(this.fragments[0].programDateTime));
        },
        enumerable: true,
        configurable: true
    });
    return Level;
}());
exports.default = Level;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/loader/m3u8-parser.js":
/*!***********************************!*\
  !*** ./src/loader/m3u8-parser.js ***!
  \***********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
Object.defineProperty(exports, "__esModule", { value: true });
var URLToolkit = __webpack_require__(/*! url-toolkit */ "./node_modules/url-toolkit/src/url-toolkit.js");
var fragment_1 = __webpack_require__(/*! ./fragment */ "./src/loader/fragment.js");
var level_1 = __webpack_require__(/*! ./level */ "./src/loader/level.js");
var level_key_1 = __webpack_require__(/*! ./level-key */ "./src/loader/level-key.js");
var attr_list_1 = __webpack_require__(/*! ../utils/attr-list */ "./src/utils/attr-list.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var codecs_1 = __webpack_require__(/*! ../utils/codecs */ "./src/utils/codecs.js");
/**
 * M3U8 parser
 * @module
 */
// https://regex101.com is your friend
var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g;
var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;
var LEVEL_PLAYLIST_REGEX_FAST = new RegExp([
    /#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,
    /|(?!#)([\S+ ?]+)/.source,
    /|#EXT-X-BYTERANGE:*(.+)/.source,
    /|#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,
    /|#.*/.source // All other non-segment oriented tags will match with all groups empty
].join(''), 'g');
var LEVEL_PLAYLIST_REGEX_SLOW = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)([^:]*):(.*))|(?:(#)(.*))(?:.*)\r?\n?/;
var MP4_REGEX_SUFFIX = /\.(mp4|m4s|m4v|m4a)$/i;
var M3U8Parser = /** @class */ (function () {
    function M3U8Parser() {
    }
    M3U8Parser.findGroup = function (groups, mediaGroupId) {
        if (!groups) {
            return null;
        }
        var matchingGroup = null;
        for (var i = 0; i < groups.length; i++) {
            var group = groups[i];
            if (group.id === mediaGroupId) {
                matchingGroup = group;
            }
        }
        return matchingGroup;
    };
    M3U8Parser.convertAVC1ToAVCOTI = function (codec) {
        var result, avcdata = codec.split('.');
        if (avcdata.length > 2) {
            result = avcdata.shift() + '.';
            result += parseInt(avcdata.shift()).toString(16);
            result += ('000' + parseInt(avcdata.shift()).toString(16)).substr(-4);
        }
        else {
            result = codec;
        }
        return result;
    };
    M3U8Parser.resolve = function (url, baseUrl) {
        return URLToolkit.buildAbsoluteURL(baseUrl, url, { alwaysNormalize: true });
    };
    M3U8Parser.parseMasterPlaylist = function (string, baseurl) {
        var levels = [], result;
        MASTER_PLAYLIST_REGEX.lastIndex = 0;
        function setCodecs(codecs, level) {
            ['video', 'audio'].forEach(function (type) {
                var filtered = codecs.filter(function (codec) { return codecs_1.isCodecType(codec, type); });
                if (filtered.length) {
                    var preferred = filtered.filter(function (codec) {
                        return codec.lastIndexOf('avc1', 0) === 0 || codec.lastIndexOf('mp4a', 0) === 0;
                    });
                    level[type + "Codec"] = preferred.length > 0 ? preferred[0] : filtered[0];
                    // remove from list
                    codecs = codecs.filter(function (codec) { return filtered.indexOf(codec) === -1; });
                }
            });
            level.unknownCodecs = codecs;
        }
        while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {
            var level = {};
            var attrs = level.attrs = new attr_list_1.default(result[1]);
            level.url = M3U8Parser.resolve(result[2], baseurl);
            var resolution = attrs.decimalResolution('RESOLUTION');
            if (resolution) {
                level.width = resolution.width;
                level.height = resolution.height;
            }
            level.bitrate = attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH');
            level.name = attrs.NAME;
            setCodecs([].concat((attrs.CODECS || '').split(/[ ,]+/)), level);
            if (level.videoCodec && level.videoCodec.indexOf('avc1') !== -1) {
                level.videoCodec = M3U8Parser.convertAVC1ToAVCOTI(level.videoCodec);
            }
            levels.push(level);
        }
        return levels;
    };
    M3U8Parser.parseMasterPlaylistMedia = function (string, baseurl, type, audioGroups) {
        if (audioGroups === void 0) { audioGroups = []; }
        var result;
        var medias = [];
        var id = 0;
        MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;
        while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {
            var media = {};
            var attrs = new attr_list_1.default(result[1]);
            if (attrs.TYPE === type) {
                media.groupId = attrs['GROUP-ID'];
                media.name = attrs.NAME;
                media.type = type;
                media.default = (attrs.DEFAULT === 'YES');
                media.autoselect = (attrs.AUTOSELECT === 'YES');
                media.forced = (attrs.FORCED === 'YES');
                if (attrs.URI) {
                    media.url = M3U8Parser.resolve(attrs.URI, baseurl);
                }
                media.lang = attrs.LANGUAGE;
                if (!media.name) {
                    media.name = media.lang;
                }
                if (audioGroups.length) {
                    var groupCodec = M3U8Parser.findGroup(audioGroups, media.groupId);
                    media.audioCodec = groupCodec ? groupCodec.codec : audioGroups[0].codec;
                }
                media.id = id++;
                medias.push(media);
            }
        }
        return medias;
    };
    M3U8Parser.parseLevelPlaylist = function (string, baseurl, id, type, levelUrlId) {
        var currentSN = 0;
        var totalduration = 0;
        var level = new level_1.default(baseurl);
        var levelkey = new level_key_1.default();
        var cc = 0;
        var prevFrag = null;
        var frag = new fragment_1.default();
        var result;
        var i;
        var firstPdtIndex = null;
        LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;
        while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {
            var duration = result[1];
            if (duration) { // INF
                frag.duration = parseFloat(duration);
                // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
                var title = (' ' + result[2]).slice(1);
                frag.title = title || null;
                frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);
            }
            else if (result[3]) { // url
                if (Number.isFinite(frag.duration)) {
                    var sn = currentSN++;
                    frag.type = type;
                    frag.start = totalduration;
                    frag.levelkey = levelkey;
                    frag.sn = sn;
                    frag.level = id;
                    frag.cc = cc;
                    frag.urlId = levelUrlId;
                    frag.baseurl = baseurl;
                    // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
                    frag.relurl = (' ' + result[3]).slice(1);
                    assignProgramDateTime(frag, prevFrag);
                    level.fragments.push(frag);
                    prevFrag = frag;
                    totalduration += frag.duration;
                    frag = new fragment_1.default();
                }
            }
            else if (result[4]) { // X-BYTERANGE
                frag.rawByteRange = (' ' + result[4]).slice(1);
                if (prevFrag) {
                    var lastByteRangeEndOffset = prevFrag.byteRangeEndOffset;
                    if (lastByteRangeEndOffset) {
                        frag.lastByteRangeEndOffset = lastByteRangeEndOffset;
                    }
                }
            }
            else if (result[5]) { // PROGRAM-DATE-TIME
                // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
                frag.rawProgramDateTime = (' ' + result[5]).slice(1);
                frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);
                if (firstPdtIndex === null) {
                    firstPdtIndex = level.fragments.length;
                }
            }
            else {
                result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);
                for (i = 1; i < result.length; i++) {
                    if (result[i] !== undefined) {
                        break;
                    }
                }
                // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
                var value1 = (' ' + result[i + 1]).slice(1);
                var value2 = (' ' + result[i + 2]).slice(1);
                switch (result[i]) {
                    case '#':
                        frag.tagList.push(value2 ? [value1, value2] : [value1]);
                        break;
                    case 'PLAYLIST-TYPE':
                        level.type = value1.toUpperCase();
                        break;
                    case 'MEDIA-SEQUENCE':
                        currentSN = level.startSN = parseInt(value1);
                        break;
                    case 'TARGETDURATION':
                        level.targetduration = parseFloat(value1);
                        break;
                    case 'VERSION':
                        level.version = parseInt(value1);
                        break;
                    case 'EXTM3U':
                        break;
                    case 'ENDLIST':
                        level.live = false;
                        break;
                    case 'DIS':
                        cc++;
                        frag.tagList.push(['DIS']);
                        break;
                    case 'DISCONTINUITY-SEQ':
                        cc = parseInt(value1);
                        break;
                    case 'KEY':
                        // https://tools.ietf.org/html/draft-pantos-http-live-streaming-08#section-3.4.4
                        var decryptparams = value1;
                        var keyAttrs = new attr_list_1.default(decryptparams);
                        var decryptmethod = keyAttrs.enumeratedString('METHOD'), decrypturi = keyAttrs.URI, decryptiv = keyAttrs.hexadecimalInteger('IV');
                        if (decryptmethod) {
                            levelkey = new level_key_1.default();
                            if ((decrypturi) && (['AES-128', 'SAMPLE-AES', 'SAMPLE-AES-CENC'].indexOf(decryptmethod) >= 0)) {
                                levelkey.method = decryptmethod;
                                // URI to get the key
                                levelkey.baseuri = baseurl;
                                levelkey.reluri = decrypturi;
                                levelkey.key = null;
                                // Initialization Vector (IV)
                                levelkey.iv = decryptiv;
                            }
                        }
                        break;
                    case 'START':
                        var startParams = value1;
                        var startAttrs = new attr_list_1.default(startParams);
                        var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');
                        // TIME-OFFSET can be 0
                        if (Number.isFinite(startTimeOffset)) {
                            level.startTimeOffset = startTimeOffset;
                        }
                        break;
                    case 'MAP':
                        var mapAttrs = new attr_list_1.default(value1);
                        frag.relurl = mapAttrs.URI;
                        frag.rawByteRange = mapAttrs.BYTERANGE;
                        frag.baseurl = baseurl;
                        frag.level = id;
                        frag.type = type;
                        frag.sn = 'initSegment';
                        level.initSegment = frag;
                        frag = new fragment_1.default();
                        frag.rawProgramDateTime = level.initSegment.rawProgramDateTime;
                        break;
                    default:
                        logger_1.logger.warn("line parsed but not handled: " + result);
                        break;
                }
            }
        }
        frag = prevFrag;
        // logger.log('found ' + level.fragments.length + ' fragments');
        if (frag && !frag.relurl) {
            level.fragments.pop();
            totalduration -= frag.duration;
        }
        level.totalduration = totalduration;
        level.averagetargetduration = totalduration / level.fragments.length;
        level.endSN = currentSN - 1;
        level.startCC = level.fragments[0] ? level.fragments[0].cc : 0;
        level.endCC = cc;
        if (!level.initSegment && level.fragments.length) {
            // this is a bit lurky but HLS really has no other way to tell us
            // if the fragments are TS or MP4, except if we download them :/
            // but this is to be able to handle SIDX.
            if (level.fragments.every(function (frag) { return MP4_REGEX_SUFFIX.test(frag.relurl); })) {
                logger_1.logger.warn('MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX');
                frag = new fragment_1.default();
                frag.relurl = level.fragments[0].relurl;
                frag.baseurl = baseurl;
                frag.level = id;
                frag.type = type;
                frag.sn = 'initSegment';
                level.initSegment = frag;
                level.needSidxRanges = true;
            }
        }
        /**
         * Backfill any missing PDT values
           "If the first EXT-X-PROGRAM-DATE-TIME tag in a Playlist appears after
           one or more Media Segment URIs, the client SHOULD extrapolate
           backward from that tag (using EXTINF durations and/or media
           timestamps) to associate dates with those segments."
         * We have already extrapolated forward, but all fragments up to the first instance of PDT do not have their PDTs
         * computed.
         */
        if (firstPdtIndex) {
            backfillProgramDateTimes(level.fragments, firstPdtIndex);
        }
        return level;
    };
    return M3U8Parser;
}());
exports.default = M3U8Parser;
function backfillProgramDateTimes(fragments, startIndex) {
    var fragPrev = fragments[startIndex];
    for (var i = startIndex - 1; i >= 0; i--) {
        var frag = fragments[i];
        frag.programDateTime = fragPrev.programDateTime - (frag.duration * 1000);
        fragPrev = frag;
    }
}
function assignProgramDateTime(frag, prevFrag) {
    if (frag.rawProgramDateTime) {
        frag.programDateTime = Date.parse(frag.rawProgramDateTime);
    }
    else if (prevFrag && prevFrag.programDateTime) {
        frag.programDateTime = prevFrag.endProgramDateTime;
    }
    if (!Number.isFinite(frag.programDateTime)) {
        frag.programDateTime = null;
        frag.rawProgramDateTime = null;
    }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/loader/playlist-loader.js":
/*!***************************************!*\
  !*** ./src/loader/playlist-loader.js ***!
  \***************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
/**
 * PlaylistLoader - delegate for media manifest/playlist loading tasks. Takes care of parsing media to internal data-models.
 *
 * Once loaded, dispatches events with parsed data-models of manifest/levels/audio/subtitle tracks.
 *
 * Uses loader(s) set in config to do actual internal loading of resource tasks.
 *
 * @module
 *
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var event_handler_1 = __webpack_require__(/*! ../event-handler */ "./src/event-handler.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var mp4demuxer_1 = __webpack_require__(/*! ../demux/mp4demuxer */ "./src/demux/mp4demuxer.js");
var m3u8_parser_1 = __webpack_require__(/*! ./m3u8-parser */ "./src/loader/m3u8-parser.js");
var performance = window.performance;
/**
 * `type` property values for this loaders' context object
 * @enum
 *
 */
var ContextType = {
    MANIFEST: 'manifest',
    LEVEL: 'level',
    AUDIO_TRACK: 'audioTrack',
    SUBTITLE_TRACK: 'subtitleTrack'
};
/**
 * @enum {string}
 */
var LevelType = {
    MAIN: 'main',
    AUDIO: 'audio',
    SUBTITLE: 'subtitle'
};
/**
 * @constructor
 */
var PlaylistLoader = /** @class */ (function (_super) {
    __extends(PlaylistLoader, _super);
    /**
     * @constructs
     * @param {Hls} hls
     */
    function PlaylistLoader(hls) {
        var _this = _super.call(this, hls, events_1.default.MANIFEST_LOADING, events_1.default.LEVEL_LOADING, events_1.default.AUDIO_TRACK_LOADING, events_1.default.SUBTITLE_TRACK_LOADING) || this;
        _this.loaders = {};
        return _this;
    }
    Object.defineProperty(PlaylistLoader, "ContextType", {
        get: function () {
            return ContextType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PlaylistLoader, "LevelType", {
        get: function () {
            return LevelType;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {ContextType} type
     * @returns {boolean}
     */
    PlaylistLoader.canHaveQualityLevels = function (type) {
        return (type !== ContextType.AUDIO_TRACK &&
            type !== ContextType.SUBTITLE_TRACK);
    };
    /**
     * Map context.type to LevelType
     * @param {{type: ContextType}} context
     * @returns {LevelType}
     */
    PlaylistLoader.mapContextToLevelType = function (context) {
        var type = context.type;
        switch (type) {
            case ContextType.AUDIO_TRACK:
                return LevelType.AUDIO;
            case ContextType.SUBTITLE_TRACK:
                return LevelType.SUBTITLE;
            default:
                return LevelType.MAIN;
        }
    };
    PlaylistLoader.getResponseUrl = function (response, context) {
        var url = response.url;
        // responseURL not supported on some browsers (it is used to detect URL redirection)
        // data-uri mode also not supported (but no need to detect redirection)
        if (url === undefined || url.indexOf('data:') === 0) {
            // fallback to initial URL
            url = context.url;
        }
        return url;
    };
    /**
     * Returns defaults or configured loader-type overloads (pLoader and loader config params)
     * Default loader is XHRLoader (see utils)
     * @param {object} context
     * @returns {XHRLoader} or other compatible configured overload
     */
    PlaylistLoader.prototype.createInternalLoader = function (context) {
        var config = this.hls.config;
        var PLoader = config.pLoader;
        var Loader = config.loader;
        var InternalLoader = PLoader || Loader;
        var loader = new InternalLoader(config);
        context.loader = loader;
        this.loaders[context.type] = loader;
        return loader;
    };
    PlaylistLoader.prototype.getInternalLoader = function (context) {
        return this.loaders[context.type];
    };
    PlaylistLoader.prototype.resetInternalLoader = function (contextType) {
        if (this.loaders[contextType]) {
            delete this.loaders[contextType];
        }
    };
    /**
     * Call `destroy` on all internal loader instances mapped (one per context type)
     */
    PlaylistLoader.prototype.destroyInternalLoaders = function () {
        for (var contextType in this.loaders) {
            var loader = this.loaders[contextType];
            if (loader) {
                loader.destroy();
            }
            this.resetInternalLoader(contextType);
        }
    };
    PlaylistLoader.prototype.destroy = function () {
        this.destroyInternalLoaders();
        _super.prototype.destroy.call(this);
    };
    PlaylistLoader.prototype.onManifestLoading = function (data) {
        this.load(data.url, { type: ContextType.MANIFEST, level: 0, id: null });
    };
    PlaylistLoader.prototype.onLevelLoading = function (data) {
        this.load(data.url, { type: ContextType.LEVEL, level: data.level, id: data.id });
    };
    PlaylistLoader.prototype.onAudioTrackLoading = function (data) {
        this.load(data.url, { type: ContextType.AUDIO_TRACK, level: null, id: data.id });
    };
    PlaylistLoader.prototype.onSubtitleTrackLoading = function (data) {
        this.load(data.url, { type: ContextType.SUBTITLE_TRACK, level: null, id: data.id });
    };
    PlaylistLoader.prototype.load = function (url, context) {
        var config = this.hls.config;
        logger_1.logger.debug("Loading playlist of type " + context.type + ", level: " + context.level + ", id: " + context.id);
        // Check if a loader for this context already exists
        var loader = this.getInternalLoader(context);
        if (loader) {
            var loaderContext = loader.context;
            if (loaderContext && loaderContext.url === url) { // same URL can't overlap
                logger_1.logger.trace('playlist request ongoing');
                return false;
            }
            else {
                logger_1.logger.warn("aborting previous loader for type: " + context.type);
                loader.abort();
            }
        }
        var maxRetry, timeout, retryDelay, maxRetryDelay;
        // apply different configs for retries depending on
        // context (manifest, level, audio/subs playlist)
        switch (context.type) {
            case ContextType.MANIFEST:
                maxRetry = config.manifestLoadingMaxRetry;
                timeout = config.manifestLoadingTimeOut;
                retryDelay = config.manifestLoadingRetryDelay;
                maxRetryDelay = config.manifestLoadingMaxRetryTimeout;
                break;
            case ContextType.LEVEL:
                // Disable internal loader retry logic, since we are managing retries in Level Controller
                maxRetry = 0;
                timeout = config.levelLoadingTimeOut;
                // TODO Introduce retry settings for audio-track and subtitle-track, it should not use level retry config
                break;
            default:
                maxRetry = config.levelLoadingMaxRetry;
                timeout = config.levelLoadingTimeOut;
                retryDelay = config.levelLoadingRetryDelay;
                maxRetryDelay = config.levelLoadingMaxRetryTimeout;
                break;
        }
        loader = this.createInternalLoader(context);
        context.url = url;
        context.responseType = context.responseType || ''; // FIXME: (should not be necessary to do this)
        var loaderConfig = {
            timeout: timeout,
            maxRetry: maxRetry,
            retryDelay: retryDelay,
            maxRetryDelay: maxRetryDelay
        };
        var loaderCallbacks = {
            onSuccess: this.loadsuccess.bind(this),
            onError: this.loaderror.bind(this),
            onTimeout: this.loadtimeout.bind(this)
        };
        logger_1.logger.debug("Calling internal loader delegate for URL: " + url);
        loader.load(context, loaderConfig, loaderCallbacks);
        return true;
    };
    PlaylistLoader.prototype.loadsuccess = function (response, stats, context, networkDetails) {
        if (networkDetails === void 0) { networkDetails = null; }
        if (context.isSidxRequest) {
            this._handleSidxRequest(response, context);
            this._handlePlaylistLoaded(response, stats, context, networkDetails);
            return;
        }
        this.resetInternalLoader(context.type);
        var string = response.data;
        stats.tload = performance.now();
        // stats.mtime = new Date(target.getResponseHeader('Last-Modified'));
        // Validate if it is an M3U8 at all
        if (string.indexOf('#EXTM3U') !== 0) {
            this._handleManifestParsingError(response, context, 'no EXTM3U delimiter', networkDetails);
            return;
        }
        // Check if chunk-list or master. handle empty chunk list case (first EXTINF not signaled, but TARGETDURATION present)
        if (string.indexOf('#EXTINF:') > 0 || string.indexOf('#EXT-X-TARGETDURATION:') > 0) {
            this._handleTrackOrLevelPlaylist(response, stats, context, networkDetails);
        }
        else {
            this._handleMasterPlaylist(response, stats, context, networkDetails);
        }
    };
    PlaylistLoader.prototype.loaderror = function (response, context, networkDetails) {
        if (networkDetails === void 0) { networkDetails = null; }
        this._handleNetworkError(context, networkDetails, false, response);
    };
    PlaylistLoader.prototype.loadtimeout = function (stats, context, networkDetails) {
        if (networkDetails === void 0) { networkDetails = null; }
        this._handleNetworkError(context, networkDetails, true);
    };
    PlaylistLoader.prototype._handleMasterPlaylist = function (response, stats, context, networkDetails) {
        var hls = this.hls;
        var string = response.data;
        var url = PlaylistLoader.getResponseUrl(response, context);
        var levels = m3u8_parser_1.default.parseMasterPlaylist(string, url);
        if (!levels.length) {
            this._handleManifestParsingError(response, context, 'no level found in manifest', networkDetails);
            return;
        }
        // multi level playlist, parse level info
        var audioGroups = levels.map(function (level) { return ({
            id: level.attrs.AUDIO,
            codec: level.audioCodec
        }); });
        var audioTracks = m3u8_parser_1.default.parseMasterPlaylistMedia(string, url, 'AUDIO', audioGroups);
        var subtitles = m3u8_parser_1.default.parseMasterPlaylistMedia(string, url, 'SUBTITLES');
        if (audioTracks.length) {
            // check if we have found an audio track embedded in main playlist (audio track without URI attribute)
            var embeddedAudioFound_1 = false;
            audioTracks.forEach(function (audioTrack) {
                if (!audioTrack.url) {
                    embeddedAudioFound_1 = true;
                }
            });
            // if no embedded audio track defined, but audio codec signaled in quality level,
            // we need to signal this main audio track this could happen with playlists with
            // alt audio rendition in which quality levels (main)
            // contains both audio+video. but with mixed audio track not signaled
            if (embeddedAudioFound_1 === false && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
                logger_1.logger.log('audio codec signaled in quality level, but no embedded audio track signaled, create one');
                audioTracks.unshift({
                    type: 'main',
                    name: 'main'
                });
            }
        }
        hls.trigger(events_1.default.MANIFEST_LOADED, {
            levels: levels,
            audioTracks: audioTracks,
            subtitles: subtitles,
            url: url,
            stats: stats,
            networkDetails: networkDetails
        });
    };
    PlaylistLoader.prototype._handleTrackOrLevelPlaylist = function (response, stats, context, networkDetails) {
        var hls = this.hls;
        var id = context.id, level = context.level, type = context.type;
        var url = PlaylistLoader.getResponseUrl(response, context);
        var levelUrlId = Number.isFinite(id) ? id : 0;
        var levelId = Number.isFinite(level) ? level : levelUrlId;
        var levelType = PlaylistLoader.mapContextToLevelType(context);
        var levelDetails = m3u8_parser_1.default.parseLevelPlaylist(response.data, url, levelId, levelType, levelUrlId);
        // set stats on level structure
        levelDetails.tload = stats.tload;
        // We have done our first request (Manifest-type) and receive
        // not a master playlist but a chunk-list (track/level)
        // We fire the manifest-loaded event anyway with the parsed level-details
        // by creating a single-level structure for it.
        if (type === ContextType.MANIFEST) {
            var singleLevel = {
                url: url,
                details: levelDetails
            };
            hls.trigger(events_1.default.MANIFEST_LOADED, {
                levels: [singleLevel],
                audioTracks: [],
                url: url,
                stats: stats,
                networkDetails: networkDetails
            });
        }
        // save parsing time
        stats.tparsed = performance.now();
        // in case we need SIDX ranges
        // return early after calling load for
        // the SIDX box.
        if (levelDetails.needSidxRanges) {
            var sidxUrl = levelDetails.initSegment.url;
            this.load(sidxUrl, {
                isSidxRequest: true,
                type: type,
                level: level,
                levelDetails: levelDetails,
                id: id,
                rangeStart: 0,
                rangeEnd: 2048,
                responseType: 'arraybuffer'
            });
            return;
        }
        // extend the context with the new levelDetails property
        context.levelDetails = levelDetails;
        this._handlePlaylistLoaded(response, stats, context, networkDetails);
    };
    PlaylistLoader.prototype._handleSidxRequest = function (response, context) {
        var sidxInfo = mp4demuxer_1.default.parseSegmentIndex(new Uint8Array(response.data));
        // if provided fragment does not contain sidx, early return
        if (!sidxInfo) {
            return;
        }
        var sidxReferences = sidxInfo.references;
        var levelDetails = context.levelDetails;
        sidxReferences.forEach(function (segmentRef, index) {
            var segRefInfo = segmentRef.info;
            var frag = levelDetails.fragments[index];
            if (frag.byteRange.length === 0) {
                frag.rawByteRange = String(1 + segRefInfo.end - segRefInfo.start) + '@' + String(segRefInfo.start);
            }
        });
        levelDetails.initSegment.rawByteRange = String(sidxInfo.moovEndOffset) + '@0';
    };
    PlaylistLoader.prototype._handleManifestParsingError = function (response, context, reason, networkDetails) {
        this.hls.trigger(events_1.default.ERROR, {
            type: errors_1.ErrorTypes.NETWORK_ERROR,
            details: errors_1.ErrorDetails.MANIFEST_PARSING_ERROR,
            fatal: true,
            url: response.url,
            reason: reason,
            networkDetails: networkDetails
        });
    };
    PlaylistLoader.prototype._handleNetworkError = function (context, networkDetails, timeout, response) {
        if (timeout === void 0) { timeout = false; }
        if (response === void 0) { response = null; }
        logger_1.logger.info("A network error occured while loading a " + context.type + "-type playlist");
        var details;
        var fatal;
        var loader = this.getInternalLoader(context);
        switch (context.type) {
            case ContextType.MANIFEST:
                details = (timeout ? errors_1.ErrorDetails.MANIFEST_LOAD_TIMEOUT : errors_1.ErrorDetails.MANIFEST_LOAD_ERROR);
                fatal = true;
                break;
            case ContextType.LEVEL:
                details = (timeout ? errors_1.ErrorDetails.LEVEL_LOAD_TIMEOUT : errors_1.ErrorDetails.LEVEL_LOAD_ERROR);
                fatal = false;
                break;
            case ContextType.AUDIO_TRACK:
                details = (timeout ? errors_1.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : errors_1.ErrorDetails.AUDIO_TRACK_LOAD_ERROR);
                fatal = false;
                break;
            default:
                // details = ...?
                fatal = false;
        }
        if (loader) {
            loader.abort();
            this.resetInternalLoader(context.type);
        }
        var errorData = {
            type: errors_1.ErrorTypes.NETWORK_ERROR,
            details: details,
            fatal: fatal,
            url: loader.url,
            loader: loader,
            context: context,
            networkDetails: networkDetails
        };
        if (response) {
            errorData.response = response;
        }
        this.hls.trigger(events_1.default.ERROR, errorData);
    };
    PlaylistLoader.prototype._handlePlaylistLoaded = function (response, stats, context, networkDetails) {
        var type = context.type, level = context.level, id = context.id, levelDetails = context.levelDetails;
        if (!levelDetails.targetduration) {
            this._handleManifestParsingError(response, context, 'invalid target duration', networkDetails);
            return;
        }
        var canHaveLevels = PlaylistLoader.canHaveQualityLevels(context.type);
        if (canHaveLevels) {
            this.hls.trigger(events_1.default.LEVEL_LOADED, {
                details: levelDetails,
                level: level || 0,
                id: id || 0,
                stats: stats,
                networkDetails: networkDetails
            });
        }
        else {
            switch (type) {
                case ContextType.AUDIO_TRACK:
                    this.hls.trigger(events_1.default.AUDIO_TRACK_LOADED, {
                        details: levelDetails,
                        id: id,
                        stats: stats,
                        networkDetails: networkDetails
                    });
                    break;
                case ContextType.SUBTITLE_TRACK:
                    this.hls.trigger(events_1.default.SUBTITLE_TRACK_LOADED, {
                        details: levelDetails,
                        id: id,
                        stats: stats,
                        networkDetails: networkDetails
                    });
                    break;
            }
        }
    };
    return PlaylistLoader;
}(event_handler_1.default));
exports.default = PlaylistLoader;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/observer.js":
/*!*************************!*\
  !*** ./src/observer.js ***!
  \*************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var eventemitter3_1 = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
/**
 * @class
 *
 * Simple adapter sub-class of Nodejs-like EventEmitter.
 *
 * We simply want to pass along the event-name itself
 * in every call to a handler, which is the purpose of our `trigger` method
 * extending the standard API.
 *
 */
var Observer = /** @class */ (function (_super) {
    __extends(Observer, _super);
    function Observer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @param {string} event
     * @param {any} data
     */
    Observer.prototype.trigger = function (event) {
        var data = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            data[_i - 1] = arguments[_i];
        }
        this.emit.apply(this, [event, event].concat(data));
    };
    return Observer;
}(eventemitter3_1.EventEmitter));
exports.Observer = Observer;


/***/ }),

/***/ "./src/polyfills/number.js":
/*!*********************************!*\
  !*** ./src/polyfills/number.js ***!
  \*********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var get_self_scope_1 = __webpack_require__(/*! ../utils/get-self-scope */ "./src/utils/get-self-scope.js");
var self = get_self_scope_1.getSelfScope();
var Number = self.Number;
exports.Number = Number;
// TODO: get rid of global polyfills and replace them with wrappers ("ponyfills")
Number.isFinite = Number.isFinite || function (value) {
    return typeof value === 'number' && isFinite(value);
};


/***/ }),

/***/ "./src/remux/aac-helper.js":
/*!*********************************!*\
  !*** ./src/remux/aac-helper.js ***!
  \*********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 *  AAC helper
 */
Object.defineProperty(exports, "__esModule", { value: true });
var AAC = /** @class */ (function () {
    function AAC() {
    }
    AAC.getSilentFrame = function (codec, channelCount) {
        switch (codec) {
            case 'mp4a.40.2':
                if (channelCount === 1) {
                    return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);
                }
                else if (channelCount === 2) {
                    return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);
                }
                else if (channelCount === 3) {
                    return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);
                }
                else if (channelCount === 4) {
                    return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);
                }
                else if (channelCount === 5) {
                    return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);
                }
                else if (channelCount === 6) {
                    return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);
                }
                break;
            // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)
            default:
                if (channelCount === 1) {
                    // ffmpeg -y -f lavfi -i "aevalsrc=0:d=0.05" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
                    return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
                }
                else if (channelCount === 2) {
                    // ffmpeg -y -f lavfi -i "aevalsrc=0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
                    return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
                }
                else if (channelCount === 3) {
                    // ffmpeg -y -f lavfi -i "aevalsrc=0|0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
                    return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
                }
                break;
        }
        return null;
    };
    return AAC;
}());
exports.default = AAC;


/***/ }),

/***/ "./src/remux/mp4-generator.js":
/*!************************************!*\
  !*** ./src/remux/mp4-generator.js ***!
  \************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Generate MP4 Box
*/
Object.defineProperty(exports, "__esModule", { value: true });
var UINT32_MAX = Math.pow(2, 32) - 1;
var MP4 = /** @class */ (function () {
    function MP4() {
    }
    MP4.init = function () {
        MP4.types = {
            avc1: [],
            avcC: [],
            btrt: [],
            dinf: [],
            dref: [],
            esds: [],
            ftyp: [],
            hdlr: [],
            mdat: [],
            mdhd: [],
            mdia: [],
            mfhd: [],
            minf: [],
            moof: [],
            moov: [],
            mp4a: [],
            '.mp3': [],
            mvex: [],
            mvhd: [],
            pasp: [],
            sdtp: [],
            stbl: [],
            stco: [],
            stsc: [],
            stsd: [],
            stsz: [],
            stts: [],
            tfdt: [],
            tfhd: [],
            traf: [],
            trak: [],
            trun: [],
            trex: [],
            tkhd: [],
            vmhd: [],
            smhd: []
        };
        var i;
        for (i in MP4.types) {
            if (MP4.types.hasOwnProperty(i)) {
                MP4.types[i] = [
                    i.charCodeAt(0),
                    i.charCodeAt(1),
                    i.charCodeAt(2),
                    i.charCodeAt(3)
                ];
            }
        }
        var videoHdlr = new Uint8Array([
            0x00,
            0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x76, 0x69, 0x64, 0x65,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x56, 0x69, 0x64, 0x65,
            0x6f, 0x48, 0x61, 0x6e,
            0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'
        ]);
        var audioHdlr = new Uint8Array([
            0x00,
            0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x73, 0x6f, 0x75, 0x6e,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x53, 0x6f, 0x75, 0x6e,
            0x64, 0x48, 0x61, 0x6e,
            0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'
        ]);
        MP4.HDLR_TYPES = {
            'video': videoHdlr,
            'audio': audioHdlr
        };
        var dref = new Uint8Array([
            0x00,
            0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x01,
            0x00, 0x00, 0x00, 0x0c,
            0x75, 0x72, 0x6c, 0x20,
            0x00,
            0x00, 0x00, 0x01 // entry_flags
        ]);
        var stco = new Uint8Array([
            0x00,
            0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00 // entry_count
        ]);
        MP4.STTS = MP4.STSC = MP4.STCO = stco;
        MP4.STSZ = new Uint8Array([
            0x00,
            0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00 // sample_count
        ]);
        MP4.VMHD = new Uint8Array([
            0x00,
            0x00, 0x00, 0x01,
            0x00, 0x00,
            0x00, 0x00,
            0x00, 0x00,
            0x00, 0x00 // opcolor
        ]);
        MP4.SMHD = new Uint8Array([
            0x00,
            0x00, 0x00, 0x00,
            0x00, 0x00,
            0x00, 0x00 // reserved
        ]);
        MP4.STSD = new Uint8Array([
            0x00,
            0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x01
        ]); // entry_count
        var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom
        var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1
        var minorVersion = new Uint8Array([0, 0, 0, 1]);
        MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
        MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));
    };
    MP4.box = function (type) {
        var payload = Array.prototype.slice.call(arguments, 1), size = 8, i = payload.length, len = i, result;
        // calculate the total size we need to allocate
        while (i--) {
            size += payload[i].byteLength;
        }
        result = new Uint8Array(size);
        result[0] = (size >> 24) & 0xff;
        result[1] = (size >> 16) & 0xff;
        result[2] = (size >> 8) & 0xff;
        result[3] = size & 0xff;
        result.set(type, 4);
        // copy the payload into the result
        for (i = 0, size = 8; i < len; i++) {
            // copy payload[i] array @ offset size
            result.set(payload[i], size);
            size += payload[i].byteLength;
        }
        return result;
    };
    MP4.hdlr = function (type) {
        return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);
    };
    MP4.mdat = function (data) {
        return MP4.box(MP4.types.mdat, data);
    };
    MP4.mdhd = function (timescale, duration) {
        duration *= timescale;
        var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
        var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
        return MP4.box(MP4.types.mdhd, new Uint8Array([
            0x01,
            0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
            (timescale >> 24) & 0xFF,
            (timescale >> 16) & 0xFF,
            (timescale >> 8) & 0xFF,
            timescale & 0xFF,
            (upperWordDuration >> 24),
            (upperWordDuration >> 16) & 0xFF,
            (upperWordDuration >> 8) & 0xFF,
            upperWordDuration & 0xFF,
            (lowerWordDuration >> 24),
            (lowerWordDuration >> 16) & 0xFF,
            (lowerWordDuration >> 8) & 0xFF,
            lowerWordDuration & 0xFF,
            0x55, 0xc4,
            0x00, 0x00
        ]));
    };
    MP4.mdia = function (track) {
        return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));
    };
    MP4.mfhd = function (sequenceNumber) {
        return MP4.box(MP4.types.mfhd, new Uint8Array([
            0x00,
            0x00, 0x00, 0x00,
            (sequenceNumber >> 24),
            (sequenceNumber >> 16) & 0xFF,
            (sequenceNumber >> 8) & 0xFF,
            sequenceNumber & 0xFF // sequence_number
        ]));
    };
    MP4.minf = function (track) {
        if (track.type === 'audio') {
            return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));
        }
        else {
            return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));
        }
    };
    MP4.moof = function (sn, baseMediaDecodeTime, track) {
        return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));
    };
    /**
   * @param tracks... (optional) {array} the tracks associated with this movie
   */
    MP4.moov = function (tracks) {
        var i = tracks.length, boxes = [];
        while (i--) {
            boxes[i] = MP4.trak(tracks[i]);
        }
        return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));
    };
    MP4.mvex = function (tracks) {
        var i = tracks.length, boxes = [];
        while (i--) {
            boxes[i] = MP4.trex(tracks[i]);
        }
        return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));
    };
    MP4.mvhd = function (timescale, duration) {
        duration *= timescale;
        var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
        var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
        var bytes = new Uint8Array([
            0x01,
            0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
            (timescale >> 24) & 0xFF,
            (timescale >> 16) & 0xFF,
            (timescale >> 8) & 0xFF,
            timescale & 0xFF,
            (upperWordDuration >> 24),
            (upperWordDuration >> 16) & 0xFF,
            (upperWordDuration >> 8) & 0xFF,
            upperWordDuration & 0xFF,
            (lowerWordDuration >> 24),
            (lowerWordDuration >> 16) & 0xFF,
            (lowerWordDuration >> 8) & 0xFF,
            lowerWordDuration & 0xFF,
            0x00, 0x01, 0x00, 0x00,
            0x01, 0x00,
            0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x01, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x01, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x40, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff // next_track_ID
        ]);
        return MP4.box(MP4.types.mvhd, bytes);
    };
    MP4.sdtp = function (track) {
        var samples = track.samples || [], bytes = new Uint8Array(4 + samples.length), flags, i;
        // leave the full box header (4 bytes) all zero
        // write the sample table
        for (i = 0; i < samples.length; i++) {
            flags = samples[i].flags;
            bytes[i + 4] = (flags.dependsOn << 4) |
                (flags.isDependedOn << 2) |
                (flags.hasRedundancy);
        }
        return MP4.box(MP4.types.sdtp, bytes);
    };
    MP4.stbl = function (track) {
        return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));
    };
    MP4.avc1 = function (track) {
        var sps = [], pps = [], i, data, len;
        // assemble the SPSs
        for (i = 0; i < track.sps.length; i++) {
            data = track.sps[i];
            len = data.byteLength;
            sps.push((len >>> 8) & 0xFF);
            sps.push((len & 0xFF));
            // SPS
            sps = sps.concat(Array.prototype.slice.call(data));
        }
        // assemble the PPSs
        for (i = 0; i < track.pps.length; i++) {
            data = track.pps[i];
            len = data.byteLength;
            pps.push((len >>> 8) & 0xFF);
            pps.push((len & 0xFF));
            pps = pps.concat(Array.prototype.slice.call(data));
        }
        var avcc = MP4.box(MP4.types.avcC, new Uint8Array([
            0x01,
            sps[3],
            sps[4],
            sps[5],
            0xfc | 3,
            0xE0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets
        ].concat(sps).concat([
            track.pps.length // numOfPictureParameterSets
        ]).concat(pps))), // "PPS"
        width = track.width, height = track.height, hSpacing = track.pixelRatio[0], vSpacing = track.pixelRatio[1];
        return MP4.box(MP4.types.avc1, new Uint8Array([
            0x00, 0x00, 0x00,
            0x00, 0x00, 0x00,
            0x00, 0x01,
            0x00, 0x00,
            0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            (width >> 8) & 0xFF,
            width & 0xff,
            (height >> 8) & 0xFF,
            height & 0xff,
            0x00, 0x48, 0x00, 0x00,
            0x00, 0x48, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x01,
            0x12,
            0x64, 0x61, 0x69, 0x6C,
            0x79, 0x6D, 0x6F, 0x74,
            0x69, 0x6F, 0x6E, 0x2F,
            0x68, 0x6C, 0x73, 0x2E,
            0x6A, 0x73, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00,
            0x00, 0x18,
            0x11, 0x11
        ]), // pre_defined = -1
        avcc, MP4.box(MP4.types.btrt, new Uint8Array([
            0x00, 0x1c, 0x9c, 0x80,
            0x00, 0x2d, 0xc6, 0xc0,
            0x00, 0x2d, 0xc6, 0xc0
        ])), // avgBitrate
        MP4.box(MP4.types.pasp, new Uint8Array([
            (hSpacing >> 24),
            (hSpacing >> 16) & 0xFF,
            (hSpacing >> 8) & 0xFF,
            hSpacing & 0xFF,
            (vSpacing >> 24),
            (vSpacing >> 16) & 0xFF,
            (vSpacing >> 8) & 0xFF,
            vSpacing & 0xFF
        ])));
    };
    MP4.esds = function (track) {
        var configlen = track.config.length;
        return new Uint8Array([
            0x00,
            0x00, 0x00, 0x00,
            0x03,
            0x17 + configlen,
            0x00, 0x01,
            0x00,
            0x04,
            0x0f + configlen,
            0x40,
            0x15,
            0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x05 // descriptor_type
        ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor
    };
    MP4.mp4a = function (track) {
        var samplerate = track.samplerate;
        return MP4.box(MP4.types.mp4a, new Uint8Array([
            0x00, 0x00, 0x00,
            0x00, 0x00, 0x00,
            0x00, 0x01,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, track.channelCount,
            0x00, 0x10,
            0x00, 0x00, 0x00, 0x00,
            (samplerate >> 8) & 0xFF,
            samplerate & 0xff,
            0x00, 0x00
        ]), MP4.box(MP4.types.esds, MP4.esds(track)));
    };
    MP4.mp3 = function (track) {
        var samplerate = track.samplerate;
        return MP4.box(MP4.types['.mp3'], new Uint8Array([
            0x00, 0x00, 0x00,
            0x00, 0x00, 0x00,
            0x00, 0x01,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, track.channelCount,
            0x00, 0x10,
            0x00, 0x00, 0x00, 0x00,
            (samplerate >> 8) & 0xFF,
            samplerate & 0xff,
            0x00, 0x00
        ]));
    };
    MP4.stsd = function (track) {
        if (track.type === 'audio') {
            if (!track.isAAC && track.codec === 'mp3') {
                return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));
            }
            return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));
        }
        else {
            return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));
        }
    };
    MP4.tkhd = function (track) {
        var id = track.id, duration = track.duration * track.timescale, width = track.width, height = track.height, upperWordDuration = Math.floor(duration / (UINT32_MAX + 1)), lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
        return MP4.box(MP4.types.tkhd, new Uint8Array([
            0x01,
            0x00, 0x00, 0x07,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
            (id >> 24) & 0xFF,
            (id >> 16) & 0xFF,
            (id >> 8) & 0xFF,
            id & 0xFF,
            0x00, 0x00, 0x00, 0x00,
            (upperWordDuration >> 24),
            (upperWordDuration >> 16) & 0xFF,
            (upperWordDuration >> 8) & 0xFF,
            upperWordDuration & 0xFF,
            (lowerWordDuration >> 24),
            (lowerWordDuration >> 16) & 0xFF,
            (lowerWordDuration >> 8) & 0xFF,
            lowerWordDuration & 0xFF,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
            0x00, 0x00,
            0x00, 0x00,
            0x00, 0x00,
            0x00, 0x01, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x01, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x40, 0x00, 0x00, 0x00,
            (width >> 8) & 0xFF,
            width & 0xFF,
            0x00, 0x00,
            (height >> 8) & 0xFF,
            height & 0xFF,
            0x00, 0x00 // height
        ]));
    };
    MP4.traf = function (track, baseMediaDecodeTime) {
        var sampleDependencyTable = MP4.sdtp(track), id = track.id, upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1)), lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
        return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([
            0x00,
            0x00, 0x00, 0x00,
            (id >> 24),
            (id >> 16) & 0XFF,
            (id >> 8) & 0XFF,
            (id & 0xFF) // track_ID
        ])), MP4.box(MP4.types.tfdt, new Uint8Array([
            0x01,
            0x00, 0x00, 0x00,
            (upperWordBaseMediaDecodeTime >> 24),
            (upperWordBaseMediaDecodeTime >> 16) & 0XFF,
            (upperWordBaseMediaDecodeTime >> 8) & 0XFF,
            (upperWordBaseMediaDecodeTime & 0xFF),
            (lowerWordBaseMediaDecodeTime >> 24),
            (lowerWordBaseMediaDecodeTime >> 16) & 0XFF,
            (lowerWordBaseMediaDecodeTime >> 8) & 0XFF,
            (lowerWordBaseMediaDecodeTime & 0xFF)
        ])), MP4.trun(track, sampleDependencyTable.length +
            16 + // tfhd
            20 + // tfdt
            8 + // traf header
            16 + // mfhd
            8 + // moof header
            8), // mdat header
        sampleDependencyTable);
    };
    /**
     * Generate a track box.
     * @param track {object} a track definition
     * @return {Uint8Array} the track box
     */
    MP4.trak = function (track) {
        track.duration = track.duration || 0xffffffff;
        return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));
    };
    MP4.trex = function (track) {
        var id = track.id;
        return MP4.box(MP4.types.trex, new Uint8Array([
            0x00,
            0x00, 0x00, 0x00,
            (id >> 24),
            (id >> 16) & 0XFF,
            (id >> 8) & 0XFF,
            (id & 0xFF),
            0x00, 0x00, 0x00, 0x01,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x01, 0x00, 0x01 // default_sample_flags
        ]));
    };
    MP4.trun = function (track, offset) {
        var samples = track.samples || [], len = samples.length, arraylen = 12 + (16 * len), array = new Uint8Array(arraylen), i, sample, duration, size, flags, cts;
        offset += 8 + arraylen;
        array.set([
            0x00,
            0x00, 0x0f, 0x01,
            (len >>> 24) & 0xFF,
            (len >>> 16) & 0xFF,
            (len >>> 8) & 0xFF,
            len & 0xFF,
            (offset >>> 24) & 0xFF,
            (offset >>> 16) & 0xFF,
            (offset >>> 8) & 0xFF,
            offset & 0xFF // data_offset
        ], 0);
        for (i = 0; i < len; i++) {
            sample = samples[i];
            duration = sample.duration;
            size = sample.size;
            flags = sample.flags;
            cts = sample.cts;
            array.set([
                (duration >>> 24) & 0xFF,
                (duration >>> 16) & 0xFF,
                (duration >>> 8) & 0xFF,
                duration & 0xFF,
                (size >>> 24) & 0xFF,
                (size >>> 16) & 0xFF,
                (size >>> 8) & 0xFF,
                size & 0xFF,
                (flags.isLeading << 2) | flags.dependsOn,
                (flags.isDependedOn << 6) |
                    (flags.hasRedundancy << 4) |
                    (flags.paddingValue << 1) |
                    flags.isNonSync,
                flags.degradPrio & 0xF0 << 8,
                flags.degradPrio & 0x0F,
                (cts >>> 24) & 0xFF,
                (cts >>> 16) & 0xFF,
                (cts >>> 8) & 0xFF,
                cts & 0xFF // sample_composition_time_offset
            ], 12 + 16 * i);
        }
        return MP4.box(MP4.types.trun, array);
    };
    MP4.initSegment = function (tracks) {
        if (!MP4.types) {
            MP4.init();
        }
        var movie = MP4.moov(tracks), result;
        result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);
        result.set(MP4.FTYP);
        result.set(movie, MP4.FTYP.byteLength);
        return result;
    };
    return MP4;
}());
exports.default = MP4;


/***/ }),

/***/ "./src/remux/mp4-remuxer.js":
/*!**********************************!*\
  !*** ./src/remux/mp4-remuxer.js ***!
  \**********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * fMP4 remuxer
*/
Object.defineProperty(exports, "__esModule", { value: true });
var aac_helper_1 = __webpack_require__(/*! ./aac-helper */ "./src/remux/aac-helper.js");
var mp4_generator_1 = __webpack_require__(/*! ./mp4-generator */ "./src/remux/mp4-generator.js");
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./src/errors.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
// 10 seconds
var MAX_SILENT_FRAME_DURATION = 10 * 1000;
var MP4Remuxer = /** @class */ (function () {
    function MP4Remuxer(observer, config, typeSupported, vendor) {
        this.observer = observer;
        this.config = config;
        this.typeSupported = typeSupported;
        var userAgent = navigator.userAgent;
        this.isSafari = vendor && vendor.indexOf('Apple') > -1 && userAgent && !userAgent.match('CriOS');
        this.ISGenerated = false;
    }
    MP4Remuxer.prototype.destroy = function () {
    };
    MP4Remuxer.prototype.resetTimeStamp = function (defaultTimeStamp) {
        this._initPTS = this._initDTS = defaultTimeStamp;
    };
    MP4Remuxer.prototype.resetInitSegment = function () {
        this.ISGenerated = false;
    };
    MP4Remuxer.prototype.remux = function (audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
        // generate Init Segment if needed
        if (!this.ISGenerated) {
            this.generateIS(audioTrack, videoTrack, timeOffset);
        }
        if (this.ISGenerated) {
            var nbAudioSamples = audioTrack.samples.length;
            var nbVideoSamples = videoTrack.samples.length;
            var audioTimeOffset = timeOffset;
            var videoTimeOffset = timeOffset;
            if (nbAudioSamples && nbVideoSamples) {
                // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)
                // if first audio DTS is not aligned with first video DTS then we need to take that into account
                // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small
                // drift between audio and video streams
                var audiovideoDeltaDts = (audioTrack.samples[0].pts - videoTrack.samples[0].pts) / videoTrack.inputTimeScale;
                audioTimeOffset += Math.max(0, audiovideoDeltaDts);
                videoTimeOffset += Math.max(0, -audiovideoDeltaDts);
            }
            // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is
            // calculated in remuxAudio.
            // logger.log('nb AAC samples:' + audioTrack.samples.length);
            if (nbAudioSamples) {
                // if initSegment was generated without video samples, regenerate it again
                if (!audioTrack.timescale) {
                    logger_1.logger.warn('regenerate InitSegment as audio detected');
                    this.generateIS(audioTrack, videoTrack, timeOffset);
                }
                var audioData = this.remuxAudio(audioTrack, audioTimeOffset, contiguous, accurateTimeOffset);
                // logger.log('nb AVC samples:' + videoTrack.samples.length);
                if (nbVideoSamples) {
                    var audioTrackLength = void 0;
                    if (audioData) {
                        audioTrackLength = audioData.endPTS - audioData.startPTS;
                    }
                    // if initSegment was generated without video samples, regenerate it again
                    if (!videoTrack.timescale) {
                        logger_1.logger.warn('regenerate InitSegment as video detected');
                        this.generateIS(audioTrack, videoTrack, timeOffset);
                    }
                    this.remuxVideo(videoTrack, videoTimeOffset, contiguous, audioTrackLength, accurateTimeOffset);
                }
            }
            else {
                // logger.log('nb AVC samples:' + videoTrack.samples.length);
                if (nbVideoSamples) {
                    var videoData = this.remuxVideo(videoTrack, videoTimeOffset, contiguous, 0, accurateTimeOffset);
                    if (videoData && audioTrack.codec) {
                        this.remuxEmptyAudio(audioTrack, audioTimeOffset, contiguous, videoData);
                    }
                }
            }
        }
        // logger.log('nb ID3 samples:' + audioTrack.samples.length);
        if (id3Track.samples.length) {
            this.remuxID3(id3Track, timeOffset);
        }
        // logger.log('nb ID3 samples:' + audioTrack.samples.length);
        if (textTrack.samples.length) {
            this.remuxText(textTrack, timeOffset);
        }
        // notify end of parsing
        this.observer.trigger(events_1.default.FRAG_PARSED);
    };
    MP4Remuxer.prototype.generateIS = function (audioTrack, videoTrack, timeOffset) {
        var observer = this.observer, audioSamples = audioTrack.samples, videoSamples = videoTrack.samples, typeSupported = this.typeSupported, container = 'audio/mp4', tracks = {}, data = { tracks: tracks }, computePTSDTS = (this._initPTS === undefined), initPTS, initDTS;
        if (computePTSDTS) {
            initPTS = initDTS = Infinity;
        }
        if (audioTrack.config && audioSamples.length) {
            // let's use audio sampling rate as MP4 time scale.
            // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)
            // using audio sampling rate here helps having an integer MP4 frame duration
            // this avoids potential rounding issue and AV sync issue
            audioTrack.timescale = audioTrack.samplerate;
            logger_1.logger.log("audio sampling rate : " + audioTrack.samplerate);
            if (!audioTrack.isAAC) {
                if (typeSupported.mpeg) { // Chrome and Safari
                    container = 'audio/mpeg';
                    audioTrack.codec = '';
                }
                else if (typeSupported.mp3) { // Firefox
                    audioTrack.codec = 'mp3';
                }
            }
            tracks.audio = {
                container: container,
                codec: audioTrack.codec,
                initSegment: !audioTrack.isAAC && typeSupported.mpeg ? new Uint8Array() : mp4_generator_1.default.initSegment([audioTrack]),
                metadata: {
                    channelCount: audioTrack.channelCount
                }
            };
            if (computePTSDTS) {
                // remember first PTS of this demuxing context. for audio, PTS = DTS
                initPTS = initDTS = audioSamples[0].pts - audioTrack.inputTimeScale * timeOffset;
            }
        }
        if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
            // let's use input time scale as MP4 video timescale
            // we use input time scale straight away to avoid rounding issues on frame duration / cts computation
            var inputTimeScale = videoTrack.inputTimeScale;
            videoTrack.timescale = inputTimeScale;
            tracks.video = {
                container: 'video/mp4',
                codec: videoTrack.codec,
                initSegment: mp4_generator_1.default.initSegment([videoTrack]),
                metadata: {
                    width: videoTrack.width,
                    height: videoTrack.height
                }
            };
            if (computePTSDTS) {
                initPTS = Math.min(initPTS, videoSamples[0].pts - inputTimeScale * timeOffset);
                initDTS = Math.min(initDTS, videoSamples[0].dts - inputTimeScale * timeOffset);
                this.observer.trigger(events_1.default.INIT_PTS_FOUND, { initPTS: initPTS });
            }
        }
        if (Object.keys(tracks).length) {
            observer.trigger(events_1.default.FRAG_PARSING_INIT_SEGMENT, data);
            this.ISGenerated = true;
            if (computePTSDTS) {
                this._initPTS = initPTS;
                this._initDTS = initDTS;
            }
        }
        else {
            observer.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.MEDIA_ERROR, details: errors_1.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'no audio/video samples found' });
        }
    };
    MP4Remuxer.prototype.remuxVideo = function (track, timeOffset, contiguous, audioTrackLength, accurateTimeOffset) {
        var offset = 8;
        var mp4SampleDuration;
        var mdat;
        var moof;
        var firstPTS;
        var firstDTS;
        var lastPTS;
        var lastDTS;
        var timeScale = track.timescale;
        var inputSamples = track.samples;
        var outputSamples = [];
        var nbSamples = inputSamples.length;
        var ptsNormalize = this._PTSNormalize;
        var initPTS = this._initPTS;
        // if parsed fragment is contiguous with last one, let's use last DTS value as reference
        var nextAvcDts = this.nextAvcDts;
        var isSafari = this.isSafari;
        if (nbSamples === 0) {
            return;
        }
        // Safari does not like overlapping DTS on consecutive fragments. let's use nextAvcDts to overcome this if fragments are consecutive
        if (isSafari) {
            // also consider consecutive fragments as being contiguous (even if a level switch occurs),
            // for sake of clarity:
            // consecutive fragments are frags with
            //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR
            //  - less than 200 ms PTS gaps (timeScale/5)
            contiguous |= (inputSamples.length && nextAvcDts &&
                ((accurateTimeOffset && Math.abs(timeOffset - nextAvcDts / timeScale) < 0.1) ||
                    Math.abs((inputSamples[0].pts - nextAvcDts - initPTS)) < timeScale / 5));
        }
        if (!contiguous) {
            // if not contiguous, let's use target timeOffset
            nextAvcDts = timeOffset * timeScale;
        }
        // PTS is coded on 33bits, and can loop from -2^32 to 2^32
        // ptsNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value
        inputSamples.forEach(function (sample) {
            sample.pts = ptsNormalize(sample.pts - initPTS, nextAvcDts);
            sample.dts = ptsNormalize(sample.dts - initPTS, nextAvcDts);
        });
        // sort video samples by DTS then PTS then demux id order
        inputSamples.sort(function (a, b) {
            var deltadts = a.dts - b.dts;
            var deltapts = a.pts - b.pts;
            return deltadts || (deltapts || (a.id - b.id));
        });
        // handle broken streams with PTS < DTS, tolerance up 200ms (18000 in 90kHz timescale)
        var PTSDTSshift = inputSamples.reduce(function (prev, curr) { return Math.max(Math.min(prev, curr.pts - curr.dts), -18000); }, 0);
        if (PTSDTSshift < 0) {
            logger_1.logger.warn("PTS < DTS detected in video samples, shifting DTS by " + Math.round(PTSDTSshift / 90) + " ms to overcome this issue");
            for (var i = 0; i < inputSamples.length; i++) {
                inputSamples[i].dts += PTSDTSshift;
            }
        }
        // compute first DTS and last DTS, normalize them against reference value
        var sample = inputSamples[0];
        firstDTS = Math.max(sample.dts, 0);
        firstPTS = Math.max(sample.pts, 0);
        // check timestamp continuity accross consecutive fragments (this is to remove inter-fragment gap/hole)
        var delta = Math.round((firstDTS - nextAvcDts) / 90);
        // if fragment are contiguous, detect hole/overlapping between fragments
        if (contiguous) {
            if (delta) {
                if (delta > 1) {
                    logger_1.logger.log("AVC:" + delta + " ms hole between fragments detected,filling it");
                }
                else if (delta < -1) {
                    logger_1.logger.log("AVC:" + (-delta) + " ms overlapping between fragments detected");
                }
                // remove hole/gap : set DTS to next expected DTS
                firstDTS = nextAvcDts;
                inputSamples[0].dts = firstDTS;
                // offset PTS as well, ensure that PTS is smaller or equal than new DTS
                firstPTS = Math.max(firstPTS - delta, nextAvcDts);
                inputSamples[0].pts = firstPTS;
                logger_1.logger.log("Video/PTS/DTS adjusted: " + Math.round(firstPTS / 90) + "/" + Math.round(firstDTS / 90) + ",delta:" + delta + " ms");
            }
        }
        // compute lastPTS/lastDTS
        sample = inputSamples[inputSamples.length - 1];
        lastDTS = Math.max(sample.dts, 0);
        lastPTS = Math.max(sample.pts, 0, lastDTS);
        // on Safari let's signal the same sample duration for all samples
        // sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS
        // set this constant duration as being the avg delta between consecutive DTS.
        if (isSafari) {
            mp4SampleDuration = Math.round((lastDTS - firstDTS) / (inputSamples.length - 1));
        }
        var nbNalu = 0, naluLen = 0;
        for (var i = 0; i < nbSamples; i++) {
            // compute total/avc sample length and nb of NAL units
            var sample_1 = inputSamples[i], units = sample_1.units, nbUnits = units.length, sampleLen = 0;
            for (var j = 0; j < nbUnits; j++) {
                sampleLen += units[j].data.length;
            }
            naluLen += sampleLen;
            nbNalu += nbUnits;
            sample_1.length = sampleLen;
            // normalize PTS/DTS
            if (isSafari) {
                // sample DTS is computed using a constant decoding offset (mp4SampleDuration) between samples
                sample_1.dts = firstDTS + i * mp4SampleDuration;
            }
            else {
                // ensure sample monotonic DTS
                sample_1.dts = Math.max(sample_1.dts, firstDTS);
            }
            // ensure that computed value is greater or equal than sample DTS
            sample_1.pts = Math.max(sample_1.pts, sample_1.dts);
        }
        /* concatenate the video data and construct the mdat in place
          (need 8 more bytes to fill length and mpdat type) */
        var mdatSize = naluLen + (4 * nbNalu) + 8;
        try {
            mdat = new Uint8Array(mdatSize);
        }
        catch (err) {
            this.observer.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.MUX_ERROR, details: errors_1.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: "fail allocating video mdat " + mdatSize });
            return;
        }
        var view = new DataView(mdat.buffer);
        view.setUint32(0, mdatSize);
        mdat.set(mp4_generator_1.default.types.mdat, 4);
        for (var i = 0; i < nbSamples; i++) {
            var avcSample = inputSamples[i], avcSampleUnits = avcSample.units, mp4SampleLength = 0, compositionTimeOffset = void 0;
            // convert NALU bitstream to MP4 format (prepend NALU with size field)
            for (var j = 0, nbUnits = avcSampleUnits.length; j < nbUnits; j++) {
                var unit = avcSampleUnits[j], unitData = unit.data, unitDataLen = unit.data.byteLength;
                view.setUint32(offset, unitDataLen);
                offset += 4;
                mdat.set(unitData, offset);
                offset += unitDataLen;
                mp4SampleLength += 4 + unitDataLen;
            }
            if (!isSafari) {
                // expected sample duration is the Decoding Timestamp diff of consecutive samples
                if (i < nbSamples - 1) {
                    mp4SampleDuration = inputSamples[i + 1].dts - avcSample.dts;
                }
                else {
                    var config = this.config, lastFrameDuration = avcSample.dts - inputSamples[i > 0 ? i - 1 : i].dts;
                    if (config.stretchShortVideoTrack) {
                        // In some cases, a segment's audio track duration may exceed the video track duration.
                        // Since we've already remuxed audio, and we know how long the audio track is, we look to
                        // see if the delta to the next segment is longer than maxBufferHole.
                        // If so, playback would potentially get stuck, so we artificially inflate
                        // the duration of the last frame to minimize any potential gap between segments.
                        var maxBufferHole = config.maxBufferHole, gapTolerance = Math.floor(maxBufferHole * timeScale), deltaToFrameEnd = (audioTrackLength ? firstPTS + audioTrackLength * timeScale : this.nextAudioPts) - avcSample.pts;
                        if (deltaToFrameEnd > gapTolerance) {
                            // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video
                            // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.
                            mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;
                            if (mp4SampleDuration < 0) {
                                mp4SampleDuration = lastFrameDuration;
                            }
                            logger_1.logger.log("It is approximately " + deltaToFrameEnd / 90 + " ms to the next segment; using duration " + mp4SampleDuration / 90 + " ms for the last video frame.");
                        }
                        else {
                            mp4SampleDuration = lastFrameDuration;
                        }
                    }
                    else {
                        mp4SampleDuration = lastFrameDuration;
                    }
                }
                compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);
            }
            else {
                compositionTimeOffset = Math.max(0, mp4SampleDuration * Math.round((avcSample.pts - avcSample.dts) / mp4SampleDuration));
            }
            // console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${avcSample.pts}/${avcSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(avcSample.pts/4294967296).toFixed(3)}');
            outputSamples.push({
                size: mp4SampleLength,
                // constant duration
                duration: mp4SampleDuration,
                cts: compositionTimeOffset,
                flags: {
                    isLeading: 0,
                    isDependedOn: 0,
                    hasRedundancy: 0,
                    degradPrio: 0,
                    dependsOn: avcSample.key ? 2 : 1,
                    isNonSync: avcSample.key ? 0 : 1
                }
            });
        }
        // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)
        this.nextAvcDts = lastDTS + mp4SampleDuration;
        var dropped = track.dropped;
        track.len = 0;
        track.nbNalu = 0;
        track.dropped = 0;
        if (outputSamples.length && navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
            var flags = outputSamples[0].flags;
            // chrome workaround, mark first sample as being a Random Access Point to avoid sourcebuffer append issue
            // https://code.google.com/p/chromium/issues/detail?id=229412
            flags.dependsOn = 2;
            flags.isNonSync = 0;
        }
        track.samples = outputSamples;
        moof = mp4_generator_1.default.moof(track.sequenceNumber++, firstDTS, track);
        track.samples = [];
        var data = {
            data1: moof,
            data2: mdat,
            startPTS: firstPTS / timeScale,
            endPTS: (lastPTS + mp4SampleDuration) / timeScale,
            startDTS: firstDTS / timeScale,
            endDTS: this.nextAvcDts / timeScale,
            type: 'video',
            hasAudio: false,
            hasVideo: true,
            nb: outputSamples.length,
            dropped: dropped
        };
        this.observer.trigger(events_1.default.FRAG_PARSING_DATA, data);
        return data;
    };
    MP4Remuxer.prototype.remuxAudio = function (track, timeOffset, contiguous, accurateTimeOffset) {
        var inputTimeScale = track.inputTimeScale;
        var mp4timeScale = track.timescale;
        var scaleFactor = inputTimeScale / mp4timeScale;
        var mp4SampleDuration = track.isAAC ? 1024 : 1152;
        var inputSampleDuration = mp4SampleDuration * scaleFactor;
        var ptsNormalize = this._PTSNormalize;
        var initPTS = this._initPTS;
        var rawMPEG = !track.isAAC && this.typeSupported.mpeg;
        var offset, mp4Sample, fillFrame, mdat, moof, firstPTS, lastPTS, inputSamples = track.samples, outputSamples = [], nextAudioPts = this.nextAudioPts;
        // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),
        // for sake of clarity:
        // consecutive fragments are frags with
        //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR
        //  - less than 20 audio frames distance
        // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
        // this helps ensuring audio continuity
        // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame
        contiguous |= (inputSamples.length && nextAudioPts &&
            ((accurateTimeOffset && Math.abs(timeOffset - nextAudioPts / inputTimeScale) < 0.1) ||
                Math.abs((inputSamples[0].pts - nextAudioPts - initPTS)) < 20 * inputSampleDuration));
        // compute normalized PTS
        inputSamples.forEach(function (sample) {
            sample.pts = sample.dts = ptsNormalize(sample.pts - initPTS, timeOffset * inputTimeScale);
        });
        // filter out sample with negative PTS that are not playable anyway
        // if we don't remove these negative samples, they will shift all audio samples forward.
        // leading to audio overlap between current / next fragment
        inputSamples = inputSamples.filter(function (sample) {
            return sample.pts >= 0;
        });
        // in case all samples have negative PTS, and have been filtered out, return now
        if (inputSamples.length === 0) {
            return;
        }
        if (!contiguous) {
            if (!accurateTimeOffset) {
                // if frag are mot contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS
                nextAudioPts = inputSamples[0].pts;
            }
            else {
                // if timeOffset is accurate, let's use it as predicted next audio PTS
                nextAudioPts = timeOffset * inputTimeScale;
            }
        }
        // If the audio track is missing samples, the frames seem to get "left-shifted" within the
        // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.
        // In an effort to prevent this from happening, we inject frames here where there are gaps.
        // When possible, we inject a silent frame; when that's not possible, we duplicate the last
        // frame.
        if (track.isAAC) {
            var maxAudioFramesDrift = this.config.maxAudioFramesDrift;
            for (var i = 0, nextPts = nextAudioPts; i < inputSamples.length;) {
                // First, let's see how far off this frame is from where we expect it to be
                var sample = inputSamples[i], delta;
                var pts = sample.pts;
                delta = pts - nextPts;
                var duration = Math.abs(1000 * delta / inputTimeScale);
                // If we're overlapping by more than a duration, drop this sample
                if (delta <= -maxAudioFramesDrift * inputSampleDuration) {
                    logger_1.logger.warn("Dropping 1 audio frame @ " + (nextPts / inputTimeScale).toFixed(3) + "s due to " + Math.round(duration) + " ms overlap.");
                    inputSamples.splice(i, 1);
                    track.len -= sample.unit.length;
                    // Don't touch nextPtsNorm or i
                } // eslint-disable-line brace-style
                // Insert missing frames if:
                // 1: We're more than maxAudioFramesDrift frame away
                // 2: Not more than MAX_SILENT_FRAME_DURATION away
                // 3: currentTime (aka nextPtsNorm) is not 0
                else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && nextPts) {
                    var missing = Math.round(delta / inputSampleDuration);
                    logger_1.logger.warn("Injecting " + missing + " audio frame @ " + (nextPts / inputTimeScale).toFixed(3) + "s due to " + Math.round(1000 * delta / inputTimeScale) + " ms gap.");
                    for (var j = 0; j < missing; j++) {
                        var newStamp = Math.max(nextPts, 0);
                        fillFrame = aac_helper_1.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                        if (!fillFrame) {
                            logger_1.logger.log('Unable to get silent frame for given audio codec; duplicating last frame instead.');
                            fillFrame = sample.unit.subarray();
                        }
                        inputSamples.splice(i, 0, { unit: fillFrame, pts: newStamp, dts: newStamp });
                        track.len += fillFrame.length;
                        nextPts += inputSampleDuration;
                        i++;
                    }
                    // Adjust sample to next expected pts
                    sample.pts = sample.dts = nextPts;
                    nextPts += inputSampleDuration;
                    i++;
                }
                else {
                    // Otherwise, just adjust pts
                    if (Math.abs(delta) > (0.1 * inputSampleDuration)) {
                        // logger.log(`Invalid frame delta ${Math.round(delta + inputSampleDuration)} at PTS ${Math.round(pts / 90)} (should be ${Math.round(inputSampleDuration)}).`);
                    }
                    sample.pts = sample.dts = nextPts;
                    nextPts += inputSampleDuration;
                    i++;
                }
            }
        }
        for (var j = 0, nbSamples_1 = inputSamples.length; j < nbSamples_1; j++) {
            var audioSample = inputSamples[j];
            var unit = audioSample.unit;
            var pts = audioSample.pts;
            // logger.log(`Audio/PTS:${Math.round(pts/90)}`);
            // if not first sample
            if (lastPTS !== undefined) {
                mp4Sample.duration = Math.round((pts - lastPTS) / scaleFactor);
            }
            else {
                var delta_1 = Math.round(1000 * (pts - nextAudioPts) / inputTimeScale), numMissingFrames = 0;
                // if fragment are contiguous, detect hole/overlapping between fragments
                // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
                if (contiguous && track.isAAC) {
                    // log delta
                    if (delta_1) {
                        if (delta_1 > 0 && delta_1 < MAX_SILENT_FRAME_DURATION) {
                            numMissingFrames = Math.round((pts - nextAudioPts) / inputSampleDuration);
                            logger_1.logger.log(delta_1 + " ms hole between AAC samples detected,filling it");
                            if (numMissingFrames > 0) {
                                fillFrame = aac_helper_1.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                                if (!fillFrame) {
                                    fillFrame = unit.subarray();
                                }
                                track.len += numMissingFrames * fillFrame.length;
                            }
                            // if we have frame overlap, overlapping for more than half a frame duraion
                        }
                        else if (delta_1 < -12) {
                            // drop overlapping audio frames... browser will deal with it
                            logger_1.logger.log("drop overlapping AAC sample, expected/parsed/delta:" + (nextAudioPts / inputTimeScale).toFixed(3) + "s/" + (pts / inputTimeScale).toFixed(3) + "s/" + (-delta_1) + "ms");
                            track.len -= unit.byteLength;
                            continue;
                        }
                        // set PTS/DTS to expected PTS/DTS
                        pts = nextAudioPts;
                    }
                }
                // remember first PTS of our audioSamples
                firstPTS = pts;
                if (track.len > 0) {
                    /* concatenate the audio data and construct the mdat in place
                      (need 8 more bytes to fill length and mdat type) */
                    var mdatSize = rawMPEG ? track.len : track.len + 8;
                    offset = rawMPEG ? 0 : 8;
                    try {
                        mdat = new Uint8Array(mdatSize);
                    }
                    catch (err) {
                        this.observer.trigger(events_1.default.ERROR, { type: errors_1.ErrorTypes.MUX_ERROR, details: errors_1.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: "fail allocating audio mdat " + mdatSize });
                        return;
                    }
                    if (!rawMPEG) {
                        var view = new DataView(mdat.buffer);
                        view.setUint32(0, mdatSize);
                        mdat.set(mp4_generator_1.default.types.mdat, 4);
                    }
                }
                else {
                    // no audio samples
                    return;
                }
                for (var i = 0; i < numMissingFrames; i++) {
                    fillFrame = aac_helper_1.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                    if (!fillFrame) {
                        logger_1.logger.log('Unable to get silent frame for given audio codec; duplicating this frame instead.');
                        fillFrame = unit.subarray();
                    }
                    mdat.set(fillFrame, offset);
                    offset += fillFrame.byteLength;
                    mp4Sample = {
                        size: fillFrame.byteLength,
                        cts: 0,
                        duration: 1024,
                        flags: {
                            isLeading: 0,
                            isDependedOn: 0,
                            hasRedundancy: 0,
                            degradPrio: 0,
                            dependsOn: 1
                        }
                    };
                    outputSamples.push(mp4Sample);
                }
            }
            mdat.set(unit, offset);
            var unitLen = unit.byteLength;
            offset += unitLen;
            // console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${audioSample.pts}/${audioSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(audioSample.pts/4294967296).toFixed(3)}');
            mp4Sample = {
                size: unitLen,
                cts: 0,
                duration: 0,
                flags: {
                    isLeading: 0,
                    isDependedOn: 0,
                    hasRedundancy: 0,
                    degradPrio: 0,
                    dependsOn: 1
                }
            };
            outputSamples.push(mp4Sample);
            lastPTS = pts;
        }
        var lastSampleDuration = 0;
        var nbSamples = outputSamples.length;
        // set last sample duration as being identical to previous sample
        if (nbSamples >= 2) {
            lastSampleDuration = outputSamples[nbSamples - 2].duration;
            mp4Sample.duration = lastSampleDuration;
        }
        if (nbSamples) {
            // next audio sample PTS should be equal to last sample PTS + duration
            this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSampleDuration;
            // logger.log('Audio/PTS/PTSend:' + audioSample.pts.toFixed(0) + '/' + this.nextAacDts.toFixed(0));
            track.len = 0;
            track.samples = outputSamples;
            if (rawMPEG) {
                moof = new Uint8Array();
            }
            else {
                moof = mp4_generator_1.default.moof(track.sequenceNumber++, firstPTS / scaleFactor, track);
            }
            track.samples = [];
            var start = firstPTS / inputTimeScale;
            var end = nextAudioPts / inputTimeScale;
            var audioData = {
                data1: moof,
                data2: mdat,
                startPTS: start,
                endPTS: end,
                startDTS: start,
                endDTS: end,
                type: 'audio',
                hasAudio: true,
                hasVideo: false,
                nb: nbSamples
            };
            this.observer.trigger(events_1.default.FRAG_PARSING_DATA, audioData);
            return audioData;
        }
        return null;
    };
    MP4Remuxer.prototype.remuxEmptyAudio = function (track, timeOffset, contiguous, videoData) {
        var inputTimeScale = track.inputTimeScale, mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale, scaleFactor = inputTimeScale / mp4timeScale, nextAudioPts = this.nextAudioPts, 
        // sync with video's timestamp
        startDTS = (nextAudioPts !== undefined ? nextAudioPts : videoData.startDTS * inputTimeScale) + this._initDTS, endDTS = videoData.endDTS * inputTimeScale + this._initDTS, 
        // one sample's duration value
        sampleDuration = 1024, frameDuration = scaleFactor * sampleDuration, 
        // samples count of this segment's duration
        nbSamples = Math.ceil((endDTS - startDTS) / frameDuration), 
        // silent frame
        silentFrame = aac_helper_1.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
        logger_1.logger.warn('remux empty Audio');
        // Can't remux if we can't generate a silent frame...
        if (!silentFrame) {
            logger_1.logger.trace('Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!');
            return;
        }
        var samples = [];
        for (var i = 0; i < nbSamples; i++) {
            var stamp = startDTS + i * frameDuration;
            samples.push({ unit: silentFrame, pts: stamp, dts: stamp });
            track.len += silentFrame.length;
        }
        track.samples = samples;
        this.remuxAudio(track, timeOffset, contiguous);
    };
    MP4Remuxer.prototype.remuxID3 = function (track) {
        var length = track.samples.length, sample;
        var inputTimeScale = track.inputTimeScale;
        var initPTS = this._initPTS;
        var initDTS = this._initDTS;
        // consume samples
        if (length) {
            for (var index = 0; index < length; index++) {
                sample = track.samples[index];
                // setting id3 pts, dts to relative time
                // using this._initPTS and this._initDTS to calculate relative time
                sample.pts = ((sample.pts - initPTS) / inputTimeScale);
                sample.dts = ((sample.dts - initDTS) / inputTimeScale);
            }
            this.observer.trigger(events_1.default.FRAG_PARSING_METADATA, {
                samples: track.samples
            });
        }
        track.samples = [];
    };
    MP4Remuxer.prototype.remuxText = function (track) {
        track.samples.sort(function (a, b) {
            return (a.pts - b.pts);
        });
        var length = track.samples.length, sample;
        var inputTimeScale = track.inputTimeScale;
        var initPTS = this._initPTS;
        // consume samples
        if (length) {
            for (var index = 0; index < length; index++) {
                sample = track.samples[index];
                // setting text pts, dts to relative time
                // using this._initPTS and this._initDTS to calculate relative time
                sample.pts = ((sample.pts - initPTS) / inputTimeScale);
            }
            this.observer.trigger(events_1.default.FRAG_PARSING_USERDATA, {
                samples: track.samples
            });
        }
        track.samples = [];
    };
    MP4Remuxer.prototype._PTSNormalize = function (value, reference) {
        var offset;
        if (reference === undefined) {
            return value;
        }
        if (reference < value) {
            // - 2^33
            offset = -8589934592;
        }
        else {
            // + 2^33
            offset = 8589934592;
        }
        /* PTS is 33bit (from 0 to 2^33 -1)
          if diff between value and reference is bigger than half of the amplitude (2^32) then it means that
          PTS looping occured. fill the gap */
        while (Math.abs(value - reference) > 4294967296) {
            value += offset;
        }
        return value;
    };
    return MP4Remuxer;
}());
exports.default = MP4Remuxer;


/***/ }),

/***/ "./src/remux/passthrough-remuxer.js":
/*!******************************************!*\
  !*** ./src/remux/passthrough-remuxer.js ***!
  \******************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * passthrough remuxer
*/
var events_1 = __webpack_require__(/*! ../events */ "./src/events.js");
var PassThroughRemuxer = /** @class */ (function () {
    function PassThroughRemuxer(observer) {
        this.observer = observer;
    }
    PassThroughRemuxer.prototype.destroy = function () {
    };
    PassThroughRemuxer.prototype.resetTimeStamp = function () {
    };
    PassThroughRemuxer.prototype.resetInitSegment = function () {
    };
    PassThroughRemuxer.prototype.remux = function (audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset, rawData) {
        var observer = this.observer;
        var streamType = '';
        if (audioTrack) {
            streamType += 'audio';
        }
        if (videoTrack) {
            streamType += 'video';
        }
        observer.trigger(events_1.default.FRAG_PARSING_DATA, {
            data1: rawData,
            startPTS: timeOffset,
            startDTS: timeOffset,
            type: streamType,
            hasAudio: !!audioTrack,
            hasVideo: !!videoTrack,
            nb: 1,
            dropped: 0
        });
        // notify end of parsing
        observer.trigger(events_1.default.FRAG_PARSED);
    };
    return PassThroughRemuxer;
}());
exports.default = PassThroughRemuxer;


/***/ }),

/***/ "./src/task-loop.js":
/*!**************************!*\
  !*** ./src/task-loop.js ***!
  \**************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var event_handler_1 = __webpack_require__(/*! ./event-handler */ "./src/event-handler.js");
/**
 * Sub-class specialization of EventHandler base class.
 *
 * TaskLoop allows to schedule a task function being called (optionnaly repeatedly) on the main loop,
 * scheduled asynchroneously, avoiding recursive calls in the same tick.
 *
 * The task itself is implemented in `doTick`. It can be requested and called for single execution
 * using the `tick` method.
 *
 * It will be assured that the task execution method (`tick`) only gets called once per main loop "tick",
 * no matter how often it gets requested for execution. Execution in further ticks will be scheduled accordingly.
 *
 * If further execution requests have already been scheduled on the next tick, it can be checked with `hasNextTick`,
 * and cancelled with `clearNextTick`.
 *
 * The task can be scheduled as an interval repeatedly with a period as parameter (see `setInterval`, `clearInterval`).
 *
 * Sub-classes need to implement the `doTick` method which will effectively have the task execution routine.
 *
 * Further explanations:
 *
 * The baseclass has a `tick` method that will schedule the doTick call. It may be called synchroneously
 * only for a stack-depth of one. On re-entrant calls, sub-sequent calls are scheduled for next main loop ticks.
 *
 * When the task execution (`tick` method) is called in re-entrant way this is detected and
 * we are limiting the task execution per call stack to exactly one, but scheduling/post-poning further
 * task processing on the next main loop iteration (also known as "next tick" in the Node/JS runtime lingo).
 */
var TaskLoop = /** @class */ (function (_super) {
    __extends(TaskLoop, _super);
    function TaskLoop(hls) {
        var events = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            events[_i - 1] = arguments[_i];
        }
        var _this = _super.apply(this, [hls].concat(events)) || this;
        _this._tickInterval = null;
        _this._tickTimer = null;
        _this._tickCallCount = 0;
        _this._boundTick = _this.tick.bind(_this);
        return _this;
    }
    /**
     * @override
     */
    TaskLoop.prototype.onHandlerDestroying = function () {
        // clear all timers before unregistering from event bus
        this.clearNextTick();
        this.clearInterval();
    };
    /**
     * @returns {boolean}
     */
    TaskLoop.prototype.hasInterval = function () {
        return !!this._tickInterval;
    };
    /**
     * @returns {boolean}
     */
    TaskLoop.prototype.hasNextTick = function () {
        return !!this._tickTimer;
    };
    /**
     * @param {number} millis Interval time (ms)
     * @returns {boolean} True when interval has been scheduled, false when already scheduled (no effect)
     */
    TaskLoop.prototype.setInterval = function (millis) {
        if (!this._tickInterval) {
            this._tickInterval = setInterval(this._boundTick, millis);
            return true;
        }
        return false;
    };
    /**
     * @returns {boolean} True when interval was cleared, false when none was set (no effect)
     */
    TaskLoop.prototype.clearInterval = function () {
        if (this._tickInterval) {
            clearInterval(this._tickInterval);
            this._tickInterval = null;
            return true;
        }
        return false;
    };
    /**
     * @returns {boolean} True when timeout was cleared, false when none was set (no effect)
     */
    TaskLoop.prototype.clearNextTick = function () {
        if (this._tickTimer) {
            clearTimeout(this._tickTimer);
            this._tickTimer = null;
            return true;
        }
        return false;
    };
    /**
     * Will call the subclass doTick implementation in this main loop tick
     * or in the next one (via setTimeout(,0)) in case it has already been called
     * in this tick (in case this is a re-entrant call).
     */
    TaskLoop.prototype.tick = function () {
        this._tickCallCount++;
        if (this._tickCallCount === 1) {
            this.doTick();
            // re-entrant call to tick from previous doTick call stack
            // -> schedule a call on the next main loop iteration to process this task processing request
            if (this._tickCallCount > 1) {
                // make sure only one timer exists at any time at max
                this.clearNextTick();
                this._tickTimer = setTimeout(this._boundTick, 0);
            }
            this._tickCallCount = 0;
        }
    };
    /**
     * For subclass to implement task logic
     * @abstract
     */
    TaskLoop.prototype.doTick = function () { };
    return TaskLoop;
}(event_handler_1.default));
exports.default = TaskLoop;


/***/ }),

/***/ "./src/utils/attr-list.js":
/*!********************************!*\
  !*** ./src/utils/attr-list.js ***!
  \********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
Object.defineProperty(exports, "__esModule", { value: true });
var DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/; // eslint-disable-line no-useless-escape
var ATTR_LIST_REGEX = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g; // eslint-disable-line no-useless-escape
// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js
var AttrList = /** @class */ (function () {
    function AttrList(attrs) {
        if (typeof attrs === 'string') {
            attrs = AttrList.parseAttrList(attrs);
        }
        for (var attr in attrs) {
            if (attrs.hasOwnProperty(attr)) {
                this[attr] = attrs[attr];
            }
        }
    }
    AttrList.prototype.decimalInteger = function (attrName) {
        var intValue = parseInt(this[attrName], 10);
        if (intValue > Number.MAX_SAFE_INTEGER) {
            return Infinity;
        }
        return intValue;
    };
    AttrList.prototype.hexadecimalInteger = function (attrName) {
        if (this[attrName]) {
            var stringValue = (this[attrName] || '0x').slice(2);
            stringValue = ((stringValue.length & 1) ? '0' : '') + stringValue;
            var value = new Uint8Array(stringValue.length / 2);
            for (var i = 0; i < stringValue.length / 2; i++) {
                value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
            }
            return value;
        }
        else {
            return null;
        }
    };
    AttrList.prototype.hexadecimalIntegerAsNumber = function (attrName) {
        var intValue = parseInt(this[attrName], 16);
        if (intValue > Number.MAX_SAFE_INTEGER) {
            return Infinity;
        }
        return intValue;
    };
    AttrList.prototype.decimalFloatingPoint = function (attrName) {
        return parseFloat(this[attrName]);
    };
    AttrList.prototype.enumeratedString = function (attrName) {
        return this[attrName];
    };
    AttrList.prototype.decimalResolution = function (attrName) {
        var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);
        if (res === null) {
            return undefined;
        }
        return {
            width: parseInt(res[1], 10),
            height: parseInt(res[2], 10)
        };
    };
    AttrList.parseAttrList = function (input) {
        var match, attrs = {};
        ATTR_LIST_REGEX.lastIndex = 0;
        while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
            var value = match[2], quote = '"';
            if (value.indexOf(quote) === 0 &&
                value.lastIndexOf(quote) === (value.length - 1)) {
                value = value.slice(1, -1);
            }
            attrs[match[1]] = value;
        }
        return attrs;
    };
    return AttrList;
}());
exports.default = AttrList;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/utils/binary-search.js":
/*!************************************!*\
  !*** ./src/utils/binary-search.js ***!
  \************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var BinarySearch = {
    /**
       * Searches for an item in an array which matches a certain condition.
       * This requires the condition to only match one item in the array,
       * and for the array to be ordered.
       *
       * @param {Array} list The array to search.
       * @param {Function} comparisonFunction
       *      Called and provided a candidate item as the first argument.
       *      Should return:
       *          > -1 if the item should be located at a lower index than the provided item.
       *          > 1 if the item should be located at a higher index than the provided item.
       *          > 0 if the item is the item you're looking for.
       *
       * @return {*} The object if it is found or null otherwise.
       */
    search: function (list, comparisonFunction) {
        var minIndex = 0;
        var maxIndex = list.length - 1;
        var currentIndex = null;
        var currentElement = null;
        while (minIndex <= maxIndex) {
            currentIndex = (minIndex + maxIndex) / 2 | 0;
            currentElement = list[currentIndex];
            var comparisonResult = comparisonFunction(currentElement);
            if (comparisonResult > 0) {
                minIndex = currentIndex + 1;
            }
            else if (comparisonResult < 0) {
                maxIndex = currentIndex - 1;
            }
            else {
                return currentElement;
            }
        }
        return null;
    }
};
exports.default = BinarySearch;


/***/ }),

/***/ "./src/utils/buffer-helper.js":
/*!************************************!*\
  !*** ./src/utils/buffer-helper.js ***!
  \************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @module BufferHelper
 *
 * Providing methods dealing with buffer length retrieval for example.
 *
 * In general, a helper around HTML5 MediaElement TimeRanges gathered from `buffered` property.
 *
 * Also @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/buffered
*/
Object.defineProperty(exports, "__esModule", { value: true });
var BufferHelper = /** @class */ (function () {
    function BufferHelper() {
    }
    /**
     * Return true if `media`'s buffered include `position`
     * @param {HTMLMediaElement|SourceBuffer} media
     * @param {number} position
     * @returns {boolean}
     */
    BufferHelper.isBuffered = function (media, position) {
        try {
            if (media) {
                var buffered = media.buffered;
                for (var i = 0; i < buffered.length; i++) {
                    if (position >= buffered.start(i) && position <= buffered.end(i)) {
                        return true;
                    }
                }
            }
        }
        catch (error) {
            // this is to catch
            // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':
            // This SourceBuffer has been removed from the parent media source
        }
        return false;
    };
    BufferHelper.bufferInfo = function (media, pos, maxHoleDuration) {
        try {
            if (media) {
                var vbuffered = media.buffered, buffered = [], i = void 0;
                for (i = 0; i < vbuffered.length; i++) {
                    buffered.push({ start: vbuffered.start(i), end: vbuffered.end(i) });
                }
                return this.bufferedInfo(buffered, pos, maxHoleDuration);
            }
        }
        catch (error) {
            // this is to catch
            // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':
            // This SourceBuffer has been removed from the parent media source
        }
        return { len: 0, start: pos, end: pos, nextStart: undefined };
    };
    BufferHelper.bufferedInfo = function (buffered, pos, maxHoleDuration) {
        var buffered2 = [], 
        // bufferStart and bufferEnd are buffer boundaries around current video position
        bufferLen, bufferStart, bufferEnd, bufferStartNext, i;
        // sort on buffer.start/smaller end (IE does not always return sorted buffered range)
        buffered.sort(function (a, b) {
            var diff = a.start - b.start;
            if (diff) {
                return diff;
            }
            else {
                return b.end - a.end;
            }
        });
        // there might be some small holes between buffer time range
        // consider that holes smaller than maxHoleDuration are irrelevant and build another
        // buffer time range representations that discards those holes
        for (i = 0; i < buffered.length; i++) {
            var buf2len = buffered2.length;
            if (buf2len) {
                var buf2end = buffered2[buf2len - 1].end;
                // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)
                if ((buffered[i].start - buf2end) < maxHoleDuration) {
                    // merge overlapping time ranges
                    // update lastRange.end only if smaller than item.end
                    // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)
                    // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])
                    if (buffered[i].end > buf2end) {
                        buffered2[buf2len - 1].end = buffered[i].end;
                    }
                }
                else {
                    // big hole
                    buffered2.push(buffered[i]);
                }
            }
            else {
                // first value
                buffered2.push(buffered[i]);
            }
        }
        for (i = 0, bufferLen = 0, bufferStart = bufferEnd = pos; i < buffered2.length; i++) {
            var start = buffered2[i].start, end = buffered2[i].end;
            // logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));
            if ((pos + maxHoleDuration) >= start && pos < end) {
                // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length
                bufferStart = start;
                bufferEnd = end;
                bufferLen = bufferEnd - pos;
            }
            else if ((pos + maxHoleDuration) < start) {
                bufferStartNext = start;
                break;
            }
        }
        return { len: bufferLen, start: bufferStart, end: bufferEnd, nextStart: bufferStartNext };
    };
    return BufferHelper;
}());
exports.BufferHelper = BufferHelper;


/***/ }),

/***/ "./src/utils/cea-608-parser.js":
/*!*************************************!*\
  !*** ./src/utils/cea-608-parser.js ***!
  \*************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 *
 * This code was ported from the dash.js project at:
 *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js
 *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2
 *
 * The original copyright appears below:
 *
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2015-2016, DASH Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  1. Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  2. Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
/**
     *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes
     */
Object.defineProperty(exports, "__esModule", { value: true });
var specialCea608CharsCodes = {
    0x2a: 0xe1,
    0x5c: 0xe9,
    0x5e: 0xed,
    0x5f: 0xf3,
    0x60: 0xfa,
    0x7b: 0xe7,
    0x7c: 0xf7,
    0x7d: 0xd1,
    0x7e: 0xf1,
    0x7f: 0x2588,
    // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
    // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
    0x80: 0xae,
    0x81: 0xb0,
    0x82: 0xbd,
    0x83: 0xbf,
    0x84: 0x2122,
    0x85: 0xa2,
    0x86: 0xa3,
    0x87: 0x266a,
    0x88: 0xe0,
    0x89: 0x20,
    0x8a: 0xe8,
    0x8b: 0xe2,
    0x8c: 0xea,
    0x8d: 0xee,
    0x8e: 0xf4,
    0x8f: 0xfb,
    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
    0x90: 0xc1,
    0x91: 0xc9,
    0x92: 0xd3,
    0x93: 0xda,
    0x94: 0xdc,
    0x95: 0xfc,
    0x96: 0x2018,
    0x97: 0xa1,
    0x98: 0x2a,
    0x99: 0x2019,
    0x9a: 0x2501,
    0x9b: 0xa9,
    0x9c: 0x2120,
    0x9d: 0x2022,
    0x9e: 0x201c,
    0x9f: 0x201d,
    0xa0: 0xc0,
    0xa1: 0xc2,
    0xa2: 0xc7,
    0xa3: 0xc8,
    0xa4: 0xca,
    0xa5: 0xcb,
    0xa6: 0xeb,
    0xa7: 0xce,
    0xa8: 0xcf,
    0xa9: 0xef,
    0xaa: 0xd4,
    0xab: 0xd9,
    0xac: 0xf9,
    0xad: 0xdb,
    0xae: 0xab,
    0xaf: 0xbb,
    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
    0xb0: 0xc3,
    0xb1: 0xe3,
    0xb2: 0xcd,
    0xb3: 0xcc,
    0xb4: 0xec,
    0xb5: 0xd2,
    0xb6: 0xf2,
    0xb7: 0xd5,
    0xb8: 0xf5,
    0xb9: 0x7b,
    0xba: 0x7d,
    0xbb: 0x5c,
    0xbc: 0x5e,
    0xbd: 0x5f,
    0xbe: 0x7c,
    0xbf: 0x223c,
    0xc0: 0xc4,
    0xc1: 0xe4,
    0xc2: 0xd6,
    0xc3: 0xf6,
    0xc4: 0xdf,
    0xc5: 0xa5,
    0xc6: 0xa4,
    0xc7: 0x2503,
    0xc8: 0xc5,
    0xc9: 0xe5,
    0xca: 0xd8,
    0xcb: 0xf8,
    0xcc: 0x250f,
    0xcd: 0x2513,
    0xce: 0x2517,
    0xcf: 0x251b // Box drawings heavy up and left
};
/**
 * Utils
 */
var getCharForByte = function (byte) {
    var charCode = byte;
    if (specialCea608CharsCodes.hasOwnProperty(byte)) {
        charCode = specialCea608CharsCodes[byte];
    }
    return String.fromCharCode(charCode);
};
var NR_ROWS = 15, NR_COLS = 100;
// Tables to look up row from PAC data
var rowsLowCh1 = { 0x11: 1, 0x12: 3, 0x15: 5, 0x16: 7, 0x17: 9, 0x10: 11, 0x13: 12, 0x14: 14 };
var rowsHighCh1 = { 0x11: 2, 0x12: 4, 0x15: 6, 0x16: 8, 0x17: 10, 0x13: 13, 0x14: 15 };
var rowsLowCh2 = { 0x19: 1, 0x1A: 3, 0x1D: 5, 0x1E: 7, 0x1F: 9, 0x18: 11, 0x1B: 12, 0x1C: 14 };
var rowsHighCh2 = { 0x19: 2, 0x1A: 4, 0x1D: 6, 0x1E: 8, 0x1F: 10, 0x1B: 13, 0x1C: 15 };
var backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];
/**
 * Simple logger class to be able to write with time-stamps and filter on level.
 */
var logger = {
    verboseFilter: { 'DATA': 3, 'DEBUG': 3, 'INFO': 2, 'WARNING': 2, 'TEXT': 1, 'ERROR': 0 },
    time: null,
    verboseLevel: 0,
    setTime: function (newTime) {
        this.time = newTime;
    },
    log: function (severity, msg) {
        var minLevel = this.verboseFilter[severity];
        if (this.verboseLevel >= minLevel) {
            // console.log(this.time + ' [' + severity + '] ' + msg);
        }
    }
};
var numArrayToHexArray = function (numArray) {
    var hexArray = [];
    for (var j = 0; j < numArray.length; j++) {
        hexArray.push(numArray[j].toString(16));
    }
    return hexArray;
};
var PenState = /** @class */ (function () {
    function PenState(foreground, underline, italics, background, flash) {
        this.foreground = foreground || 'white';
        this.underline = underline || false;
        this.italics = italics || false;
        this.background = background || 'black';
        this.flash = flash || false;
    }
    PenState.prototype.reset = function () {
        this.foreground = 'white';
        this.underline = false;
        this.italics = false;
        this.background = 'black';
        this.flash = false;
    };
    PenState.prototype.setStyles = function (styles) {
        var attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];
        for (var i = 0; i < attribs.length; i++) {
            var style = attribs[i];
            if (styles.hasOwnProperty(style)) {
                this[style] = styles[style];
            }
        }
    };
    PenState.prototype.isDefault = function () {
        return (this.foreground === 'white' && !this.underline && !this.italics &&
            this.background === 'black' && !this.flash);
    };
    PenState.prototype.equals = function (other) {
        return ((this.foreground === other.foreground) &&
            (this.underline === other.underline) &&
            (this.italics === other.italics) &&
            (this.background === other.background) &&
            (this.flash === other.flash));
    };
    PenState.prototype.copy = function (newPenState) {
        this.foreground = newPenState.foreground;
        this.underline = newPenState.underline;
        this.italics = newPenState.italics;
        this.background = newPenState.background;
        this.flash = newPenState.flash;
    };
    PenState.prototype.toString = function () {
        return ('color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics +
            ', background=' + this.background + ', flash=' + this.flash);
    };
    return PenState;
}());
/**
 * Unicode character with styling and background.
 * @constructor
 */
var StyledUnicodeChar = /** @class */ (function () {
    function StyledUnicodeChar(uchar, foreground, underline, italics, background, flash) {
        this.uchar = uchar || ' '; // unicode character
        this.penState = new PenState(foreground, underline, italics, background, flash);
    }
    StyledUnicodeChar.prototype.reset = function () {
        this.uchar = ' ';
        this.penState.reset();
    };
    StyledUnicodeChar.prototype.setChar = function (uchar, newPenState) {
        this.uchar = uchar;
        this.penState.copy(newPenState);
    };
    StyledUnicodeChar.prototype.setPenState = function (newPenState) {
        this.penState.copy(newPenState);
    };
    StyledUnicodeChar.prototype.equals = function (other) {
        return this.uchar === other.uchar && this.penState.equals(other.penState);
    };
    StyledUnicodeChar.prototype.copy = function (newChar) {
        this.uchar = newChar.uchar;
        this.penState.copy(newChar.penState);
    };
    StyledUnicodeChar.prototype.isEmpty = function () {
        return this.uchar === ' ' && this.penState.isDefault();
    };
    return StyledUnicodeChar;
}());
/**
 * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.
 * @constructor
 */
var Row = /** @class */ (function () {
    function Row() {
        this.chars = [];
        for (var i = 0; i < NR_COLS; i++) {
            this.chars.push(new StyledUnicodeChar());
        }
        this.pos = 0;
        this.currPenState = new PenState();
    }
    Row.prototype.equals = function (other) {
        var equal = true;
        for (var i = 0; i < NR_COLS; i++) {
            if (!this.chars[i].equals(other.chars[i])) {
                equal = false;
                break;
            }
        }
        return equal;
    };
    Row.prototype.copy = function (other) {
        for (var i = 0; i < NR_COLS; i++) {
            this.chars[i].copy(other.chars[i]);
        }
    };
    Row.prototype.isEmpty = function () {
        var empty = true;
        for (var i = 0; i < NR_COLS; i++) {
            if (!this.chars[i].isEmpty()) {
                empty = false;
                break;
            }
        }
        return empty;
    };
    /**
       *  Set the cursor to a valid column.
       */
    Row.prototype.setCursor = function (absPos) {
        if (this.pos !== absPos) {
            this.pos = absPos;
        }
        if (this.pos < 0) {
            logger.log('ERROR', 'Negative cursor position ' + this.pos);
            this.pos = 0;
        }
        else if (this.pos > NR_COLS) {
            logger.log('ERROR', 'Too large cursor position ' + this.pos);
            this.pos = NR_COLS;
        }
    };
    /**
       * Move the cursor relative to current position.
       */
    Row.prototype.moveCursor = function (relPos) {
        var newPos = this.pos + relPos;
        if (relPos > 1) {
            for (var i = this.pos + 1; i < newPos + 1; i++) {
                this.chars[i].setPenState(this.currPenState);
            }
        }
        this.setCursor(newPos);
    };
    /**
       * Backspace, move one step back and clear character.
       */
    Row.prototype.backSpace = function () {
        this.moveCursor(-1);
        this.chars[this.pos].setChar(' ', this.currPenState);
    };
    Row.prototype.insertChar = function (byte) {
        if (byte >= 0x90) { // Extended char
            this.backSpace();
        }
        var char = getCharForByte(byte);
        if (this.pos >= NR_COLS) {
            logger.log('ERROR', 'Cannot insert ' + byte.toString(16) +
                ' (' + char + ') at position ' + this.pos + '. Skipping it!');
            return;
        }
        this.chars[this.pos].setChar(char, this.currPenState);
        this.moveCursor(1);
    };
    Row.prototype.clearFromPos = function (startPos) {
        var i;
        for (i = startPos; i < NR_COLS; i++) {
            this.chars[i].reset();
        }
    };
    Row.prototype.clear = function () {
        this.clearFromPos(0);
        this.pos = 0;
        this.currPenState.reset();
    };
    Row.prototype.clearToEndOfRow = function () {
        this.clearFromPos(this.pos);
    };
    Row.prototype.getTextString = function () {
        var chars = [];
        var empty = true;
        for (var i = 0; i < NR_COLS; i++) {
            var char = this.chars[i].uchar;
            if (char !== ' ') {
                empty = false;
            }
            chars.push(char);
        }
        if (empty) {
            return '';
        }
        else {
            return chars.join('');
        }
    };
    Row.prototype.setPenStyles = function (styles) {
        this.currPenState.setStyles(styles);
        var currChar = this.chars[this.pos];
        currChar.setPenState(this.currPenState);
    };
    return Row;
}());
/**
 * Keep a CEA-608 screen of 32x15 styled characters
 * @constructor
*/
var CaptionScreen = /** @class */ (function () {
    function CaptionScreen() {
        this.rows = [];
        for (var i = 0; i < NR_ROWS; i++) {
            this.rows.push(new Row());
        } // Note that we use zero-based numbering (0-14)
        this.currRow = NR_ROWS - 1;
        this.nrRollUpRows = null;
        this.reset();
    }
    CaptionScreen.prototype.reset = function () {
        for (var i = 0; i < NR_ROWS; i++) {
            this.rows[i].clear();
        }
        this.currRow = NR_ROWS - 1;
    };
    CaptionScreen.prototype.equals = function (other) {
        var equal = true;
        for (var i = 0; i < NR_ROWS; i++) {
            if (!this.rows[i].equals(other.rows[i])) {
                equal = false;
                break;
            }
        }
        return equal;
    };
    CaptionScreen.prototype.copy = function (other) {
        for (var i = 0; i < NR_ROWS; i++) {
            this.rows[i].copy(other.rows[i]);
        }
    };
    CaptionScreen.prototype.isEmpty = function () {
        var empty = true;
        for (var i = 0; i < NR_ROWS; i++) {
            if (!this.rows[i].isEmpty()) {
                empty = false;
                break;
            }
        }
        return empty;
    };
    CaptionScreen.prototype.backSpace = function () {
        var row = this.rows[this.currRow];
        row.backSpace();
    };
    CaptionScreen.prototype.clearToEndOfRow = function () {
        var row = this.rows[this.currRow];
        row.clearToEndOfRow();
    };
    /**
       * Insert a character (without styling) in the current row.
       */
    CaptionScreen.prototype.insertChar = function (char) {
        var row = this.rows[this.currRow];
        row.insertChar(char);
    };
    CaptionScreen.prototype.setPen = function (styles) {
        var row = this.rows[this.currRow];
        row.setPenStyles(styles);
    };
    CaptionScreen.prototype.moveCursor = function (relPos) {
        var row = this.rows[this.currRow];
        row.moveCursor(relPos);
    };
    CaptionScreen.prototype.setCursor = function (absPos) {
        logger.log('INFO', 'setCursor: ' + absPos);
        var row = this.rows[this.currRow];
        row.setCursor(absPos);
    };
    CaptionScreen.prototype.setPAC = function (pacData) {
        logger.log('INFO', 'pacData = ' + JSON.stringify(pacData));
        var newRow = pacData.row - 1;
        if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
            newRow = this.nrRollUpRows - 1;
        }
        // Make sure this only affects Roll-up Captions by checking this.nrRollUpRows
        if (this.nrRollUpRows && this.currRow !== newRow) {
            // clear all rows first
            for (var i = 0; i < NR_ROWS; i++) {
                this.rows[i].clear();
            }
            // Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location
            // topRowIndex - the start of rows to copy (inclusive index)
            var topRowIndex = this.currRow + 1 - (this.nrRollUpRows);
            // We only copy if the last position was already shown.
            // We use the cueStartTime value to check this.
            var lastOutputScreen = this.lastOutputScreen;
            if (lastOutputScreen) {
                var prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;
                if (prevLineTime && prevLineTime < logger.time) {
                    for (var i = 0; i < this.nrRollUpRows; i++) {
                        this.rows[newRow - this.nrRollUpRows + i + 1].copy(lastOutputScreen.rows[topRowIndex + i]);
                    }
                }
            }
        }
        this.currRow = newRow;
        var row = this.rows[this.currRow];
        if (pacData.indent !== null) {
            var indent = pacData.indent;
            var prevPos = Math.max(indent - 1, 0);
            row.setCursor(pacData.indent);
            pacData.color = row.chars[prevPos].penState.foreground;
        }
        var styles = { foreground: pacData.color, underline: pacData.underline, italics: pacData.italics, background: 'black', flash: false };
        this.setPen(styles);
    };
    /**
       * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
       */
    CaptionScreen.prototype.setBkgData = function (bkgData) {
        logger.log('INFO', 'bkgData = ' + JSON.stringify(bkgData));
        this.backSpace();
        this.setPen(bkgData);
        this.insertChar(0x20); // Space
    };
    CaptionScreen.prototype.setRollUpRows = function (nrRows) {
        this.nrRollUpRows = nrRows;
    };
    CaptionScreen.prototype.rollUp = function () {
        if (this.nrRollUpRows === null) {
            logger.log('DEBUG', 'roll_up but nrRollUpRows not set yet');
            return; // Not properly setup
        }
        logger.log('TEXT', this.getDisplayText());
        var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
        var topRow = this.rows.splice(topRowIndex, 1)[0];
        topRow.clear();
        this.rows.splice(this.currRow, 0, topRow);
        logger.log('INFO', 'Rolling up');
        // logger.log('TEXT', this.get_display_text())
    };
    /**
      * Get all non-empty rows with as unicode text.
      */
    CaptionScreen.prototype.getDisplayText = function (asOneRow) {
        asOneRow = asOneRow || false;
        var displayText = [];
        var text = '';
        var rowNr = -1;
        for (var i = 0; i < NR_ROWS; i++) {
            var rowText = this.rows[i].getTextString();
            if (rowText) {
                rowNr = i + 1;
                if (asOneRow) {
                    displayText.push('Row ' + rowNr + ': \'' + rowText + '\'');
                }
                else {
                    displayText.push(rowText.trim());
                }
            }
        }
        if (displayText.length > 0) {
            if (asOneRow) {
                text = '[' + displayText.join(' | ') + ']';
            }
            else {
                text = displayText.join('\n');
            }
        }
        return text;
    };
    CaptionScreen.prototype.getTextAndFormat = function () {
        return this.rows;
    };
    return CaptionScreen;
}());
// var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];
var Cea608Channel = /** @class */ (function () {
    function Cea608Channel(channelNumber, outputFilter) {
        this.chNr = channelNumber;
        this.outputFilter = outputFilter;
        this.mode = null;
        this.verbose = 0;
        this.displayedMemory = new CaptionScreen();
        this.nonDisplayedMemory = new CaptionScreen();
        this.lastOutputScreen = new CaptionScreen();
        this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
        this.writeScreen = this.displayedMemory;
        this.mode = null;
        this.cueStartTime = null; // Keeps track of where a cue started.
    }
    Cea608Channel.prototype.reset = function () {
        this.mode = null;
        this.displayedMemory.reset();
        this.nonDisplayedMemory.reset();
        this.lastOutputScreen.reset();
        this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
        this.writeScreen = this.displayedMemory;
        this.mode = null;
        this.cueStartTime = null;
        this.lastCueEndTime = null;
    };
    Cea608Channel.prototype.getHandler = function () {
        return this.outputFilter;
    };
    Cea608Channel.prototype.setHandler = function (newHandler) {
        this.outputFilter = newHandler;
    };
    Cea608Channel.prototype.setPAC = function (pacData) {
        this.writeScreen.setPAC(pacData);
    };
    Cea608Channel.prototype.setBkgData = function (bkgData) {
        this.writeScreen.setBkgData(bkgData);
    };
    Cea608Channel.prototype.setMode = function (newMode) {
        if (newMode === this.mode) {
            return;
        }
        this.mode = newMode;
        logger.log('INFO', 'MODE=' + newMode);
        if (this.mode === 'MODE_POP-ON') {
            this.writeScreen = this.nonDisplayedMemory;
        }
        else {
            this.writeScreen = this.displayedMemory;
            this.writeScreen.reset();
        }
        if (this.mode !== 'MODE_ROLL-UP') {
            this.displayedMemory.nrRollUpRows = null;
            this.nonDisplayedMemory.nrRollUpRows = null;
        }
        this.mode = newMode;
    };
    Cea608Channel.prototype.insertChars = function (chars) {
        for (var i = 0; i < chars.length; i++) {
            this.writeScreen.insertChar(chars[i]);
        }
        var screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';
        logger.log('INFO', screen + ': ' + this.writeScreen.getDisplayText(true));
        if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {
            logger.log('TEXT', 'DISPLAYED: ' + this.displayedMemory.getDisplayText(true));
            this.outputDataUpdate();
        }
    };
    Cea608Channel.prototype.ccRCL = function () {
        logger.log('INFO', 'RCL - Resume Caption Loading');
        this.setMode('MODE_POP-ON');
    };
    Cea608Channel.prototype.ccBS = function () {
        logger.log('INFO', 'BS - BackSpace');
        if (this.mode === 'MODE_TEXT') {
            return;
        }
        this.writeScreen.backSpace();
        if (this.writeScreen === this.displayedMemory) {
            this.outputDataUpdate();
        }
    };
    Cea608Channel.prototype.ccAOF = function () {
    };
    Cea608Channel.prototype.ccAON = function () {
    };
    Cea608Channel.prototype.ccDER = function () {
        logger.log('INFO', 'DER- Delete to End of Row');
        this.writeScreen.clearToEndOfRow();
        this.outputDataUpdate();
    };
    Cea608Channel.prototype.ccRU = function (nrRows) {
        logger.log('INFO', 'RU(' + nrRows + ') - Roll Up');
        this.writeScreen = this.displayedMemory;
        this.setMode('MODE_ROLL-UP');
        this.writeScreen.setRollUpRows(nrRows);
    };
    Cea608Channel.prototype.ccFON = function () {
        logger.log('INFO', 'FON - Flash On');
        this.writeScreen.setPen({ flash: true });
    };
    Cea608Channel.prototype.ccRDC = function () {
        logger.log('INFO', 'RDC - Resume Direct Captioning');
        this.setMode('MODE_PAINT-ON');
    };
    Cea608Channel.prototype.ccTR = function () {
        logger.log('INFO', 'TR');
        this.setMode('MODE_TEXT');
    };
    Cea608Channel.prototype.ccRTD = function () {
        logger.log('INFO', 'RTD');
        this.setMode('MODE_TEXT');
    };
    Cea608Channel.prototype.ccEDM = function () {
        logger.log('INFO', 'EDM - Erase Displayed Memory');
        this.displayedMemory.reset();
        this.outputDataUpdate(true);
    };
    Cea608Channel.prototype.ccCR = function () {
        logger.log('CR - Carriage Return');
        this.writeScreen.rollUp();
        this.outputDataUpdate(true);
    };
    Cea608Channel.prototype.ccENM = function () {
        logger.log('INFO', 'ENM - Erase Non-displayed Memory');
        this.nonDisplayedMemory.reset();
    };
    Cea608Channel.prototype.ccEOC = function () {
        logger.log('INFO', 'EOC - End Of Caption');
        if (this.mode === 'MODE_POP-ON') {
            var tmp = this.displayedMemory;
            this.displayedMemory = this.nonDisplayedMemory;
            this.nonDisplayedMemory = tmp;
            this.writeScreen = this.nonDisplayedMemory;
            logger.log('TEXT', 'DISP: ' + this.displayedMemory.getDisplayText());
        }
        this.outputDataUpdate(true);
    };
    Cea608Channel.prototype.ccTO = function (nrCols) {
        logger.log('INFO', 'TO(' + nrCols + ') - Tab Offset');
        this.writeScreen.moveCursor(nrCols);
    };
    Cea608Channel.prototype.ccMIDROW = function (secondByte) {
        var styles = { flash: false };
        styles.underline = secondByte % 2 === 1;
        styles.italics = secondByte >= 0x2e;
        if (!styles.italics) {
            var colorIndex = Math.floor(secondByte / 2) - 0x10;
            var colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];
            styles.foreground = colors[colorIndex];
        }
        else {
            styles.foreground = 'white';
        }
        logger.log('INFO', 'MIDROW: ' + JSON.stringify(styles));
        this.writeScreen.setPen(styles);
    };
    Cea608Channel.prototype.outputDataUpdate = function (dispatch) {
        if (dispatch === void 0) { dispatch = false; }
        var t = logger.time;
        if (t === null) {
            return;
        }
        if (this.outputFilter) {
            if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) { // Start of a new cue
                this.cueStartTime = t;
            }
            else {
                if (!this.displayedMemory.equals(this.lastOutputScreen)) {
                    if (this.outputFilter.newCue) {
                        this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen);
                        if (dispatch === true && this.outputFilter.dispatchCue) {
                            this.outputFilter.dispatchCue();
                        }
                    }
                    this.cueStartTime = this.displayedMemory.isEmpty() ? null : t;
                }
            }
            this.lastOutputScreen.copy(this.displayedMemory);
        }
    };
    Cea608Channel.prototype.cueSplitAtTime = function (t) {
        if (this.outputFilter) {
            if (!this.displayedMemory.isEmpty()) {
                if (this.outputFilter.newCue) {
                    this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);
                }
                this.cueStartTime = t;
            }
        }
    };
    return Cea608Channel;
}());
var Cea608Parser = /** @class */ (function () {
    function Cea608Parser(field, out1, out2) {
        this.field = field || 1;
        this.outputs = [out1, out2];
        this.channels = [new Cea608Channel(1, out1), new Cea608Channel(2, out2)];
        this.currChNr = -1; // Will be 1 or 2
        this.lastCmdA = null; // First byte of last command
        this.lastCmdB = null; // Second byte of last command
        this.bufferedData = [];
        this.startTime = null;
        this.lastTime = null;
        this.dataCounters = { 'padding': 0, 'char': 0, 'cmd': 0, 'other': 0 };
    }
    Cea608Parser.prototype.getHandler = function (index) {
        return this.channels[index].getHandler();
    };
    Cea608Parser.prototype.setHandler = function (index, newHandler) {
        this.channels[index].setHandler(newHandler);
    };
    /**
       * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
       */
    Cea608Parser.prototype.addData = function (t, byteList) {
        var cmdFound, a, b, charsFound = false;
        this.lastTime = t;
        logger.setTime(t);
        for (var i = 0; i < byteList.length; i += 2) {
            a = byteList[i] & 0x7f;
            b = byteList[i + 1] & 0x7f;
            if (a === 0 && b === 0) {
                this.dataCounters.padding += 2;
                continue;
            }
            else {
                logger.log('DATA', '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');
            }
            cmdFound = this.parseCmd(a, b);
            if (!cmdFound) {
                cmdFound = this.parseMidrow(a, b);
            }
            if (!cmdFound) {
                cmdFound = this.parsePAC(a, b);
            }
            if (!cmdFound) {
                cmdFound = this.parseBackgroundAttributes(a, b);
            }
            if (!cmdFound) {
                charsFound = this.parseChars(a, b);
                if (charsFound) {
                    if (this.currChNr && this.currChNr >= 0) {
                        var channel = this.channels[this.currChNr - 1];
                        channel.insertChars(charsFound);
                    }
                    else {
                        logger.log('WARNING', 'No channel found yet. TEXT-MODE?');
                    }
                }
            }
            if (cmdFound) {
                this.dataCounters.cmd += 2;
            }
            else if (charsFound) {
                this.dataCounters.char += 2;
            }
            else {
                this.dataCounters.other += 2;
                logger.log('WARNING', 'Couldn\'t parse cleaned data ' + numArrayToHexArray([a, b]) +
                    ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));
            }
        }
    };
    /**
       * Parse Command.
       * @returns {Boolean} Tells if a command was found
       */
    Cea608Parser.prototype.parseCmd = function (a, b) {
        var chNr = null;
        var cond1 = (a === 0x14 || a === 0x1C) && (b >= 0x20 && b <= 0x2F);
        var cond2 = (a === 0x17 || a === 0x1F) && (b >= 0x21 && b <= 0x23);
        if (!(cond1 || cond2)) {
            return false;
        }
        if (a === this.lastCmdA && b === this.lastCmdB) {
            this.lastCmdA = null;
            this.lastCmdB = null; // Repeated commands are dropped (once)
            logger.log('DEBUG', 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');
            return true;
        }
        if (a === 0x14 || a === 0x17) {
            chNr = 1;
        }
        else {
            chNr = 2;
        } // (a === 0x1C || a=== 0x1f)
        var channel = this.channels[chNr - 1];
        if (a === 0x14 || a === 0x1C) {
            if (b === 0x20) {
                channel.ccRCL();
            }
            else if (b === 0x21) {
                channel.ccBS();
            }
            else if (b === 0x22) {
                channel.ccAOF();
            }
            else if (b === 0x23) {
                channel.ccAON();
            }
            else if (b === 0x24) {
                channel.ccDER();
            }
            else if (b === 0x25) {
                channel.ccRU(2);
            }
            else if (b === 0x26) {
                channel.ccRU(3);
            }
            else if (b === 0x27) {
                channel.ccRU(4);
            }
            else if (b === 0x28) {
                channel.ccFON();
            }
            else if (b === 0x29) {
                channel.ccRDC();
            }
            else if (b === 0x2A) {
                channel.ccTR();
            }
            else if (b === 0x2B) {
                channel.ccRTD();
            }
            else if (b === 0x2C) {
                channel.ccEDM();
            }
            else if (b === 0x2D) {
                channel.ccCR();
            }
            else if (b === 0x2E) {
                channel.ccENM();
            }
            else if (b === 0x2F) {
                channel.ccEOC();
            }
        }
        else { // a == 0x17 || a == 0x1F
            channel.ccTO(b - 0x20);
        }
        this.lastCmdA = a;
        this.lastCmdB = b;
        this.currChNr = chNr;
        return true;
    };
    /**
       * Parse midrow styling command
       * @returns {Boolean}
       */
    Cea608Parser.prototype.parseMidrow = function (a, b) {
        var chNr = null;
        if (((a === 0x11) || (a === 0x19)) && b >= 0x20 && b <= 0x2f) {
            if (a === 0x11) {
                chNr = 1;
            }
            else {
                chNr = 2;
            }
            if (chNr !== this.currChNr) {
                logger.log('ERROR', 'Mismatch channel in midrow parsing');
                return false;
            }
            var channel = this.channels[chNr - 1];
            channel.ccMIDROW(b);
            logger.log('DEBUG', 'MIDROW (' + numArrayToHexArray([a, b]) + ')');
            return true;
        }
        return false;
    };
    /**
       * Parse Preable Access Codes (Table 53).
       * @returns {Boolean} Tells if PAC found
       */
    Cea608Parser.prototype.parsePAC = function (a, b) {
        var chNr = null;
        var row = null;
        var case1 = ((a >= 0x11 && a <= 0x17) || (a >= 0x19 && a <= 0x1F)) && (b >= 0x40 && b <= 0x7F);
        var case2 = (a === 0x10 || a === 0x18) && (b >= 0x40 && b <= 0x5F);
        if (!(case1 || case2)) {
            return false;
        }
        if (a === this.lastCmdA && b === this.lastCmdB) {
            this.lastCmdA = null;
            this.lastCmdB = null;
            return true; // Repeated commands are dropped (once)
        }
        chNr = (a <= 0x17) ? 1 : 2;
        if (b >= 0x40 && b <= 0x5F) {
            row = (chNr === 1) ? rowsLowCh1[a] : rowsLowCh2[a];
        }
        else { // 0x60 <= b <= 0x7F
            row = (chNr === 1) ? rowsHighCh1[a] : rowsHighCh2[a];
        }
        var pacData = this.interpretPAC(row, b);
        var channel = this.channels[chNr - 1];
        channel.setPAC(pacData);
        this.lastCmdA = a;
        this.lastCmdB = b;
        this.currChNr = chNr;
        return true;
    };
    /**
       * Interpret the second byte of the pac, and return the information.
       * @returns {Object} pacData with style parameters.
       */
    Cea608Parser.prototype.interpretPAC = function (row, byte) {
        var pacIndex = byte;
        var pacData = { color: null, italics: false, indent: null, underline: false, row: row };
        if (byte > 0x5F) {
            pacIndex = byte - 0x60;
        }
        else {
            pacIndex = byte - 0x40;
        }
        pacData.underline = (pacIndex & 1) === 1;
        if (pacIndex <= 0xd) {
            pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];
        }
        else if (pacIndex <= 0xf) {
            pacData.italics = true;
            pacData.color = 'white';
        }
        else {
            pacData.indent = (Math.floor((pacIndex - 0x10) / 2)) * 4;
        }
        return pacData; // Note that row has zero offset. The spec uses 1.
    };
    /**
       * Parse characters.
       * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
       */
    Cea608Parser.prototype.parseChars = function (a, b) {
        var channelNr = null, charCodes = null, charCode1 = null;
        if (a >= 0x19) {
            channelNr = 2;
            charCode1 = a - 8;
        }
        else {
            channelNr = 1;
            charCode1 = a;
        }
        if (charCode1 >= 0x11 && charCode1 <= 0x13) {
            // Special character
            var oneCode = b;
            if (charCode1 === 0x11) {
                oneCode = b + 0x50;
            }
            else if (charCode1 === 0x12) {
                oneCode = b + 0x70;
            }
            else {
                oneCode = b + 0x90;
            }
            logger.log('INFO', 'Special char \'' + getCharForByte(oneCode) + '\' in channel ' + channelNr);
            charCodes = [oneCode];
        }
        else if (a >= 0x20 && a <= 0x7f) {
            charCodes = (b === 0) ? [a] : [a, b];
        }
        if (charCodes) {
            var hexCodes = numArrayToHexArray(charCodes);
            logger.log('DEBUG', 'Char codes =  ' + hexCodes.join(','));
            this.lastCmdA = null;
            this.lastCmdB = null;
        }
        return charCodes;
    };
    /**
      * Parse extended background attributes as well as new foreground color black.
      * @returns{Boolean} Tells if background attributes are found
      */
    Cea608Parser.prototype.parseBackgroundAttributes = function (a, b) {
        var bkgData, index, chNr, channel;
        var case1 = (a === 0x10 || a === 0x18) && (b >= 0x20 && b <= 0x2f);
        var case2 = (a === 0x17 || a === 0x1f) && (b >= 0x2d && b <= 0x2f);
        if (!(case1 || case2)) {
            return false;
        }
        bkgData = {};
        if (a === 0x10 || a === 0x18) {
            index = Math.floor((b - 0x20) / 2);
            bkgData.background = backgroundColors[index];
            if (b % 2 === 1) {
                bkgData.background = bkgData.background + '_semi';
            }
        }
        else if (b === 0x2d) {
            bkgData.background = 'transparent';
        }
        else {
            bkgData.foreground = 'black';
            if (b === 0x2f) {
                bkgData.underline = true;
            }
        }
        chNr = (a < 0x18) ? 1 : 2;
        channel = this.channels[chNr - 1];
        channel.setBkgData(bkgData);
        this.lastCmdA = null;
        this.lastCmdB = null;
        return true;
    };
    /**
       * Reset state of parser and its channels.
       */
    Cea608Parser.prototype.reset = function () {
        for (var i = 0; i < this.channels.length; i++) {
            if (this.channels[i]) {
                this.channels[i].reset();
            }
        }
        this.lastCmdA = null;
        this.lastCmdB = null;
    };
    /**
       * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
       */
    Cea608Parser.prototype.cueSplitAtTime = function (t) {
        for (var i = 0; i < this.channels.length; i++) {
            if (this.channels[i]) {
                this.channels[i].cueSplitAtTime(t);
            }
        }
    };
    return Cea608Parser;
}());
exports.default = Cea608Parser;


/***/ }),

/***/ "./src/utils/codecs.js":
/*!*****************************!*\
  !*** ./src/utils/codecs.js ***!
  \*****************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// from http://mp4ra.org/codecs.html
var sampleEntryCodesISO = {
    audio: {
        'a3ds': true,
        'ac-3': true,
        'ac-4': true,
        'alac': true,
        'alaw': true,
        'dra1': true,
        'dts+': true,
        'dts-': true,
        'dtsc': true,
        'dtse': true,
        'dtsh': true,
        'ec-3': true,
        'enca': true,
        'g719': true,
        'g726': true,
        'm4ae': true,
        'mha1': true,
        'mha2': true,
        'mhm1': true,
        'mhm2': true,
        'mlpa': true,
        'mp4a': true,
        'raw ': true,
        'Opus': true,
        'samr': true,
        'sawb': true,
        'sawp': true,
        'sevc': true,
        'sqcp': true,
        'ssmv': true,
        'twos': true,
        'ulaw': true
    },
    video: {
        'avc1': true,
        'avc2': true,
        'avc3': true,
        'avc4': true,
        'avcp': true,
        'drac': true,
        'dvav': true,
        'dvhe': true,
        'encv': true,
        'hev1': true,
        'hvc1': true,
        'mjp2': true,
        'mp4v': true,
        'mvc1': true,
        'mvc2': true,
        'mvc3': true,
        'mvc4': true,
        'resv': true,
        'rv60': true,
        's263': true,
        'svc1': true,
        'svc2': true,
        'vc-1': true,
        'vp08': true,
        'vp09': true
    }
};
function isCodecType(codec, type) {
    var typeCodes = sampleEntryCodesISO[type];
    return !!typeCodes && typeCodes[codec.slice(0, 4)] === true;
}
exports.isCodecType = isCodecType;
function isCodecSupportedInMp4(codec, type) {
    return window.MediaSource.isTypeSupported((type || 'video') + "/mp4;codecs=\"" + codec + "\"");
}
exports.isCodecSupportedInMp4 = isCodecSupportedInMp4;


/***/ }),

/***/ "./src/utils/cues.js":
/*!***************************!*\
  !*** ./src/utils/cues.js ***!
  \***************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var vttparser_1 = __webpack_require__(/*! ./vttparser */ "./src/utils/vttparser.js");
function newCue(track, startTime, endTime, captionScreen) {
    var row;
    var cue;
    var indenting;
    var indent;
    var text;
    var VTTCue = window.VTTCue || window.TextTrackCue;
    for (var r = 0; r < captionScreen.rows.length; r++) {
        row = captionScreen.rows[r];
        indenting = true;
        indent = 0;
        text = '';
        if (!row.isEmpty()) {
            for (var c = 0; c < row.chars.length; c++) {
                if (row.chars[c].uchar.match(/\s/) && indenting) {
                    indent++;
                }
                else {
                    text += row.chars[c].uchar;
                    indenting = false;
                }
            }
            // To be used for cleaning-up orphaned roll-up captions
            row.cueStartTime = startTime;
            // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE
            if (startTime === endTime) {
                endTime += 0.0001;
            }
            cue = new VTTCue(startTime, endTime, vttparser_1.fixLineBreaks(text.trim()));
            if (indent >= 16) {
                indent--;
            }
            else {
                indent++;
            }
            // VTTCue.line get's flakey when using controls, so let's now include line 13&14
            // also, drop line 1 since it's to close to the top
            if (navigator.userAgent.match(/Firefox\//)) {
                cue.line = r + 1;
            }
            else {
                cue.line = (r > 7 ? r - 2 : r + 1);
            }
            cue.align = 'left';
            // Clamp the position between 0 and 100 - if out of these bounds, Firefox throws an exception and captions break
            cue.position = Math.max(0, Math.min(100, 100 * (indent / 32) + (navigator.userAgent.match(/Firefox\//) ? 50 : 0)));
            track.addCue(cue);
        }
    }
}
exports.newCue = newCue;


/***/ }),

/***/ "./src/utils/discontinuities.js":
/*!**************************************!*\
  !*** ./src/utils/discontinuities.js ***!
  \**************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
Object.defineProperty(exports, "__esModule", { value: true });
var binary_search_1 = __webpack_require__(/*! ./binary-search */ "./src/utils/binary-search.js");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
function findFirstFragWithCC(fragments, cc) {
    var firstFrag = null;
    for (var i = 0; i < fragments.length; i += 1) {
        var currentFrag = fragments[i];
        if (currentFrag && currentFrag.cc === cc) {
            firstFrag = currentFrag;
            break;
        }
    }
    return firstFrag;
}
exports.findFirstFragWithCC = findFirstFragWithCC;
function findFragWithCC(fragments, CC) {
    return binary_search_1.default.search(fragments, function (candidate) {
        if (candidate.cc < CC) {
            return 1;
        }
        else if (candidate.cc > CC) {
            return -1;
        }
        else {
            return 0;
        }
    });
}
exports.findFragWithCC = findFragWithCC;
function shouldAlignOnDiscontinuities(lastFrag, lastLevel, details) {
    var shouldAlign = false;
    if (lastLevel && lastLevel.details && details) {
        if (details.endCC > details.startCC || (lastFrag && lastFrag.cc < details.startCC)) {
            shouldAlign = true;
        }
    }
    return shouldAlign;
}
exports.shouldAlignOnDiscontinuities = shouldAlignOnDiscontinuities;
// Find the first frag in the previous level which matches the CC of the first frag of the new level
function findDiscontinuousReferenceFrag(prevDetails, curDetails) {
    var prevFrags = prevDetails.fragments;
    var curFrags = curDetails.fragments;
    if (!curFrags.length || !prevFrags.length) {
        logger_1.logger.log('No fragments to align');
        return;
    }
    var prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);
    if (!prevStartFrag || (prevStartFrag && !prevStartFrag.startPTS)) {
        logger_1.logger.log('No frag in previous level to align on');
        return;
    }
    return prevStartFrag;
}
exports.findDiscontinuousReferenceFrag = findDiscontinuousReferenceFrag;
function adjustPts(sliding, details) {
    details.fragments.forEach(function (frag) {
        if (frag) {
            var start = frag.start + sliding;
            frag.start = frag.startPTS = start;
            frag.endPTS = start + frag.duration;
        }
    });
    details.PTSKnown = true;
}
exports.adjustPts = adjustPts;
/**
 * Using the parameters of the last level, this function computes PTS' of the new fragments so that they form a
 * contiguous stream with the last fragments.
 * The PTS of a fragment lets Hls.js know where it fits into a stream - by knowing every PTS, we know which fragment to
 * download at any given time. PTS is normally computed when the fragment is demuxed, so taking this step saves us time
 * and an extra download.
 * @param lastFrag
 * @param lastLevel
 * @param details
 */
function alignStream(lastFrag, lastLevel, details) {
    alignDiscontinuities(lastFrag, details, lastLevel);
    if (!details.PTSKnown && lastLevel) {
        // If the PTS wasn't figured out via discontinuity sequence that means there was no CC increase within the level.
        // Aligning via Program Date Time should therefore be reliable, since PDT should be the same within the same
        // discontinuity sequence.
        alignPDT(details, lastLevel.details);
    }
}
exports.alignStream = alignStream;
/**
 * Computes the PTS if a new level's fragments using the PTS of a fragment in the last level which shares the same
 * discontinuity sequence.
 * @param lastLevel - The details of the last loaded level
 * @param details - The details of the new level
 */
function alignDiscontinuities(lastFrag, details, lastLevel) {
    if (shouldAlignOnDiscontinuities(lastFrag, lastLevel, details)) {
        var referenceFrag = findDiscontinuousReferenceFrag(lastLevel.details, details);
        if (referenceFrag) {
            logger_1.logger.log('Adjusting PTS using last level due to CC increase within current level');
            adjustPts(referenceFrag.start, details);
        }
    }
}
exports.alignDiscontinuities = alignDiscontinuities;
/**
 * Computes the PTS of a new level's fragments using the difference in Program Date Time from the last level.
 * @param details - The details of the new level
 * @param lastDetails - The details of the last loaded level
 */
function alignPDT(details, lastDetails) {
    if (lastDetails && lastDetails.fragments.length) {
        if (!details.hasProgramDateTime || !lastDetails.hasProgramDateTime) {
            return;
        }
        // if last level sliding is 1000 and its first frag PROGRAM-DATE-TIME is 2017-08-20 1:10:00 AM
        // and if new details first frag PROGRAM DATE-TIME is 2017-08-20 1:10:08 AM
        // then we can deduce that playlist B sliding is 1000+8 = 1008s
        var lastPDT = lastDetails.fragments[0].programDateTime;
        var newPDT = details.fragments[0].programDateTime;
        // date diff is in ms. frag.start is in seconds
        var sliding = (newPDT - lastPDT) / 1000 + lastDetails.fragments[0].start;
        if (Number.isFinite(sliding)) {
            logger_1.logger.log("adjusting PTS using programDateTime delta, sliding:" + sliding.toFixed(3));
            adjustPts(sliding, details);
        }
    }
}
exports.alignPDT = alignPDT;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/utils/ewma-bandwidth-estimator.js":
/*!***********************************************!*\
  !*** ./src/utils/ewma-bandwidth-estimator.js ***!
  \***********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * EWMA Bandwidth Estimator
 *  - heavily inspired from shaka-player
 * Tracks bandwidth samples and estimates available bandwidth.
 * Based on the minimum of two exponentially-weighted moving averages with
 * different half-lives.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ewma_1 = __webpack_require__(/*! ../utils/ewma */ "./src/utils/ewma.js");
var EwmaBandWidthEstimator = /** @class */ (function () {
    function EwmaBandWidthEstimator(hls, slow, fast, defaultEstimate) {
        this.hls = hls;
        this.defaultEstimate_ = defaultEstimate;
        this.minWeight_ = 0.001;
        this.minDelayMs_ = 50;
        this.slow_ = new ewma_1.default(slow);
        this.fast_ = new ewma_1.default(fast);
    }
    EwmaBandWidthEstimator.prototype.sample = function (durationMs, numBytes) {
        durationMs = Math.max(durationMs, this.minDelayMs_);
        var bandwidth = 8000 * numBytes / durationMs, 
        // console.log('instant bw:'+ Math.round(bandwidth));
        // we weight sample using loading duration....
        weight = durationMs / 1000;
        this.fast_.sample(weight, bandwidth);
        this.slow_.sample(weight, bandwidth);
    };
    EwmaBandWidthEstimator.prototype.canEstimate = function () {
        var fast = this.fast_;
        return (fast && fast.getTotalWeight() >= this.minWeight_);
    };
    EwmaBandWidthEstimator.prototype.getEstimate = function () {
        if (this.canEstimate()) {
            // console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));
            // console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));
            // Take the minimum of these two estimates.  This should have the effect of
            // adapting down quickly, but up more slowly.
            return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
        }
        else {
            return this.defaultEstimate_;
        }
    };
    EwmaBandWidthEstimator.prototype.destroy = function () {
    };
    return EwmaBandWidthEstimator;
}());
exports.default = EwmaBandWidthEstimator;


/***/ }),

/***/ "./src/utils/ewma.js":
/*!***************************!*\
  !*** ./src/utils/ewma.js ***!
  \***************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * compute an Exponential Weighted moving average
 * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
 *  - heavily inspired from shaka-player
 */
Object.defineProperty(exports, "__esModule", { value: true });
var EWMA = /** @class */ (function () {
    //  About half of the estimated value will be from the last |halfLife| samples by weight.
    function EWMA(halfLife) {
        // Larger values of alpha expire historical data more slowly.
        this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
        this.estimate_ = 0;
        this.totalWeight_ = 0;
    }
    EWMA.prototype.sample = function (weight, value) {
        var adjAlpha = Math.pow(this.alpha_, weight);
        this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
        this.totalWeight_ += weight;
    };
    EWMA.prototype.getTotalWeight = function () {
        return this.totalWeight_;
    };
    EWMA.prototype.getEstimate = function () {
        if (this.alpha_) {
            var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
            return this.estimate_ / zeroFactor;
        }
        else {
            return this.estimate_;
        }
    };
    return EWMA;
}());
exports.default = EWMA;


/***/ }),

/***/ "./src/utils/get-self-scope.js":
/*!*************************************!*\
  !*** ./src/utils/get-self-scope.js ***!
  \*************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function getSelfScope() {
    // see https://stackoverflow.com/a/11237259/589493
    if (typeof window === 'undefined') {
        /* eslint-disable-next-line no-undef */
        return self;
    }
    else {
        return window;
    }
}
exports.getSelfScope = getSelfScope;


/***/ }),

/***/ "./src/utils/logger.js":
/*!*****************************!*\
  !*** ./src/utils/logger.js ***!
  \*****************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var get_self_scope_1 = __webpack_require__(/*! ./get-self-scope */ "./src/utils/get-self-scope.js");
function noop() { }
var fakeLogger = {
    trace: noop,
    debug: noop,
    log: noop,
    warn: noop,
    info: noop,
    error: noop
};
var exportedLogger = fakeLogger;
// let lastCallTime;
// function formatMsgWithTimeInfo(type, msg) {
//   const now = Date.now();
//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';
//   lastCallTime = now;
//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';
//   return msg;
// }
function formatMsg(type, msg) {
    msg = '[' + type + '] > ' + msg;
    return msg;
}
var global = get_self_scope_1.getSelfScope();
function consolePrintFn(type) {
    var func = global.console[type];
    if (func) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (args[0]) {
                args[0] = formatMsg(type, args[0]);
            }
            func.apply(global.console, args);
        };
    }
    return noop;
}
function exportLoggerFunctions(debugConfig) {
    var functions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        functions[_i - 1] = arguments[_i];
    }
    functions.forEach(function (type) {
        exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);
    });
}
exports.enableLogs = function (debugConfig) {
    if (debugConfig === true || typeof debugConfig === 'object') {
        exportLoggerFunctions(debugConfig, 
        // Remove out from list here to hard-disable a log-level
        // 'trace',
        'debug', 'log', 'info', 'warn', 'error');
        // Some browsers don't allow to use bind on console object anyway
        // fallback to default if needed
        try {
            exportedLogger.log();
        }
        catch (e) {
            exportedLogger = fakeLogger;
        }
    }
    else {
        exportedLogger = fakeLogger;
    }
};
exports.logger = exportedLogger;


/***/ }),

/***/ "./src/utils/mediakeys-helper.js":
/*!***************************************!*\
  !*** ./src/utils/mediakeys-helper.js ***!
  \***************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var requestMediaKeySystemAccess = (function () {
    if (typeof window !== 'undefined' && window.navigator && window.navigator.requestMediaKeySystemAccess) {
        return window.navigator.requestMediaKeySystemAccess.bind(window.navigator);
    }
    else {
        return null;
    }
})();
exports.requestMediaKeySystemAccess = requestMediaKeySystemAccess;


/***/ }),

/***/ "./src/utils/mediasource-helper.js":
/*!*****************************************!*\
  !*** ./src/utils/mediasource-helper.js ***!
  \*****************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * MediaSource helper
 */
Object.defineProperty(exports, "__esModule", { value: true });
function getMediaSource() {
    if (typeof window !== 'undefined') {
        return window.MediaSource || window.WebKitMediaSource;
    }
}
exports.getMediaSource = getMediaSource;


/***/ }),

/***/ "./src/utils/output-filter.js":
/*!************************************!*\
  !*** ./src/utils/output-filter.js ***!
  \************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var OutputFilter = /** @class */ (function () {
    function OutputFilter(timelineController, trackName) {
        this.timelineController = timelineController;
        this.trackName = trackName;
        this.startTime = null;
        this.endTime = null;
        this.screen = null;
    }
    OutputFilter.prototype.dispatchCue = function () {
        if (this.startTime === null) {
            return;
        }
        this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen);
        this.startTime = null;
    };
    OutputFilter.prototype.newCue = function (startTime, endTime, screen) {
        if (this.startTime === null || this.startTime > startTime) {
            this.startTime = startTime;
        }
        this.endTime = endTime;
        this.screen = screen;
        this.timelineController.createCaptionsTrack(this.trackName);
    };
    return OutputFilter;
}());
exports.default = OutputFilter;


/***/ }),

/***/ "./src/utils/texttrack-utils.js":
/*!**************************************!*\
  !*** ./src/utils/texttrack-utils.js ***!
  \**************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function sendAddTrackEvent(track, videoEl) {
    var event = null;
    try {
        event = new window.Event('addtrack');
    }
    catch (err) {
        // for IE11
        event = document.createEvent('Event');
        event.initEvent('addtrack', false, false);
    }
    event.track = track;
    videoEl.dispatchEvent(event);
}
exports.sendAddTrackEvent = sendAddTrackEvent;
function clearCurrentCues(track) {
    if (track && track.cues) {
        while (track.cues.length > 0) {
            track.removeCue(track.cues[0]);
        }
    }
}
exports.clearCurrentCues = clearCurrentCues;


/***/ }),

/***/ "./src/utils/time-ranges.js":
/*!**********************************!*\
  !*** ./src/utils/time-ranges.js ***!
  \**********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 *  TimeRanges to string helper
 */
Object.defineProperty(exports, "__esModule", { value: true });
var TimeRanges = {
    toString: function (r) {
        var log = '', len = r.length;
        for (var i = 0; i < len; i++) {
            log += '[' + r.start(i).toFixed(3) + ',' + r.end(i).toFixed(3) + ']';
        }
        return log;
    }
};
exports.default = TimeRanges;


/***/ }),

/***/ "./src/utils/vttcue.js":
/*!*****************************!*\
  !*** ./src/utils/vttcue.js ***!
  \*****************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = (function () {
    if (typeof window !== 'undefined' && window.VTTCue) {
        return window.VTTCue;
    }
    var autoKeyword = 'auto';
    var directionSetting = {
        '': true,
        lr: true,
        rl: true
    };
    var alignSetting = {
        start: true,
        middle: true,
        end: true,
        left: true,
        right: true
    };
    function findDirectionSetting(value) {
        if (typeof value !== 'string') {
            return false;
        }
        var dir = directionSetting[value.toLowerCase()];
        return dir ? value.toLowerCase() : false;
    }
    function findAlignSetting(value) {
        if (typeof value !== 'string') {
            return false;
        }
        var align = alignSetting[value.toLowerCase()];
        return align ? value.toLowerCase() : false;
    }
    function extend(obj) {
        var i = 1;
        for (; i < arguments.length; i++) {
            var cobj = arguments[i];
            for (var p in cobj) {
                obj[p] = cobj[p];
            }
        }
        return obj;
    }
    function VTTCue(startTime, endTime, text) {
        var cue = this;
        var isIE8 = (function () {
            if (typeof navigator === 'undefined') {
                return;
            }
            return (/MSIE\s8\.0/).test(navigator.userAgent);
        })();
        var baseObj = {};
        if (isIE8) {
            cue = document.createElement('custom');
        }
        else {
            baseObj.enumerable = true;
        }
        /**
         * Shim implementation specific properties. These properties are not in
         * the spec.
         */
        // Lets us know when the VTTCue's data has changed in such a way that we need
        // to recompute its display state. This lets us compute its display state
        // lazily.
        cue.hasBeenReset = false;
        /**
         * VTTCue and TextTrackCue properties
         * http://dev.w3.org/html5/webvtt/#vttcue-interface
         */
        var _id = '';
        var _pauseOnExit = false;
        var _startTime = startTime;
        var _endTime = endTime;
        var _text = text;
        var _region = null;
        var _vertical = '';
        var _snapToLines = true;
        var _line = 'auto';
        var _lineAlign = 'start';
        var _position = 50;
        var _positionAlign = 'middle';
        var _size = 50;
        var _align = 'middle';
        Object.defineProperty(cue, 'id', extend({}, baseObj, {
            get: function () {
                return _id;
            },
            set: function (value) {
                _id = '' + value;
            }
        }));
        Object.defineProperty(cue, 'pauseOnExit', extend({}, baseObj, {
            get: function () {
                return _pauseOnExit;
            },
            set: function (value) {
                _pauseOnExit = !!value;
            }
        }));
        Object.defineProperty(cue, 'startTime', extend({}, baseObj, {
            get: function () {
                return _startTime;
            },
            set: function (value) {
                if (typeof value !== 'number') {
                    throw new TypeError('Start time must be set to a number.');
                }
                _startTime = value;
                this.hasBeenReset = true;
            }
        }));
        Object.defineProperty(cue, 'endTime', extend({}, baseObj, {
            get: function () {
                return _endTime;
            },
            set: function (value) {
                if (typeof value !== 'number') {
                    throw new TypeError('End time must be set to a number.');
                }
                _endTime = value;
                this.hasBeenReset = true;
            }
        }));
        Object.defineProperty(cue, 'text', extend({}, baseObj, {
            get: function () {
                return _text;
            },
            set: function (value) {
                _text = '' + value;
                this.hasBeenReset = true;
            }
        }));
        Object.defineProperty(cue, 'region', extend({}, baseObj, {
            get: function () {
                return _region;
            },
            set: function (value) {
                _region = value;
                this.hasBeenReset = true;
            }
        }));
        Object.defineProperty(cue, 'vertical', extend({}, baseObj, {
            get: function () {
                return _vertical;
            },
            set: function (value) {
                var setting = findDirectionSetting(value);
                // Have to check for false because the setting an be an empty string.
                if (setting === false) {
                    throw new SyntaxError('An invalid or illegal string was specified.');
                }
                _vertical = setting;
                this.hasBeenReset = true;
            }
        }));
        Object.defineProperty(cue, 'snapToLines', extend({}, baseObj, {
            get: function () {
                return _snapToLines;
            },
            set: function (value) {
                _snapToLines = !!value;
                this.hasBeenReset = true;
            }
        }));
        Object.defineProperty(cue, 'line', extend({}, baseObj, {
            get: function () {
                return _line;
            },
            set: function (value) {
                if (typeof value !== 'number' && value !== autoKeyword) {
                    throw new SyntaxError('An invalid number or illegal string was specified.');
                }
                _line = value;
                this.hasBeenReset = true;
            }
        }));
        Object.defineProperty(cue, 'lineAlign', extend({}, baseObj, {
            get: function () {
                return _lineAlign;
            },
            set: function (value) {
                var setting = findAlignSetting(value);
                if (!setting) {
                    throw new SyntaxError('An invalid or illegal string was specified.');
                }
                _lineAlign = setting;
                this.hasBeenReset = true;
            }
        }));
        Object.defineProperty(cue, 'position', extend({}, baseObj, {
            get: function () {
                return _position;
            },
            set: function (value) {
                if (value < 0 || value > 100) {
                    throw new Error('Position must be between 0 and 100.');
                }
                _position = value;
                this.hasBeenReset = true;
            }
        }));
        Object.defineProperty(cue, 'positionAlign', extend({}, baseObj, {
            get: function () {
                return _positionAlign;
            },
            set: function (value) {
                var setting = findAlignSetting(value);
                if (!setting) {
                    throw new SyntaxError('An invalid or illegal string was specified.');
                }
                _positionAlign = setting;
                this.hasBeenReset = true;
            }
        }));
        Object.defineProperty(cue, 'size', extend({}, baseObj, {
            get: function () {
                return _size;
            },
            set: function (value) {
                if (value < 0 || value > 100) {
                    throw new Error('Size must be between 0 and 100.');
                }
                _size = value;
                this.hasBeenReset = true;
            }
        }));
        Object.defineProperty(cue, 'align', extend({}, baseObj, {
            get: function () {
                return _align;
            },
            set: function (value) {
                var setting = findAlignSetting(value);
                if (!setting) {
                    throw new SyntaxError('An invalid or illegal string was specified.');
                }
                _align = setting;
                this.hasBeenReset = true;
            }
        }));
        /**
         * Other <track> spec defined properties
         */
        // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state
        cue.displayState = undefined;
        if (isIE8) {
            return cue;
        }
    }
    /**
     * VTTCue methods
     */
    VTTCue.prototype.getCueAsHTML = function () {
        // Assume WebVTT.convertCueToDOMTree is on the global.
        var WebVTT = window.WebVTT;
        return WebVTT.convertCueToDOMTree(window, this.text);
    };
    return VTTCue;
})();


/***/ }),

/***/ "./src/utils/vttparser.js":
/*!********************************!*\
  !*** ./src/utils/vttparser.js ***!
  \********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js#L1716
 */
Object.defineProperty(exports, "__esModule", { value: true });
var vttcue_1 = __webpack_require__(/*! ./vttcue */ "./src/utils/vttcue.js");
var StringDecoder = function StringDecoder() {
    return {
        decode: function (data) {
            if (!data) {
                return '';
            }
            if (typeof data !== 'string') {
                throw new Error('Error - expected string data.');
            }
            return decodeURIComponent(encodeURIComponent(data));
        }
    };
};
function VTTParser() {
    this.window = window;
    this.state = 'INITIAL';
    this.buffer = '';
    this.decoder = new StringDecoder();
    this.regionList = [];
}
// Try to parse input as a time stamp.
function parseTimeStamp(input) {
    function computeSeconds(h, m, s, f) {
        return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;
    }
    var m = input.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);
    if (!m) {
        return null;
    }
    if (m[3]) {
        // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]
        return computeSeconds(m[1], m[2], m[3].replace(':', ''), m[4]);
    }
    else if (m[1] > 59) {
        // Timestamp takes the form of [hours]:[minutes].[milliseconds]
        // First position is hours as it's over 59.
        return computeSeconds(m[1], m[2], 0, m[4]);
    }
    else {
        // Timestamp takes the form of [minutes]:[seconds].[milliseconds]
        return computeSeconds(0, m[1], m[2], m[4]);
    }
}
// A settings object holds key/value pairs and will ignore anything but the first
// assignment to a specific key.
function Settings() {
    this.values = Object.create(null);
}
Settings.prototype = {
    // Only accept the first assignment to any key.
    set: function (k, v) {
        if (!this.get(k) && v !== '') {
            this.values[k] = v;
        }
    },
    // Return the value for a key, or a default value.
    // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
    // a number of possible default values as properties where 'defaultKey' is
    // the key of the property that will be chosen; otherwise it's assumed to be
    // a single value.
    get: function (k, dflt, defaultKey) {
        if (defaultKey) {
            return this.has(k) ? this.values[k] : dflt[defaultKey];
        }
        return this.has(k) ? this.values[k] : dflt;
    },
    // Check whether we have a value for a key.
    has: function (k) {
        return k in this.values;
    },
    // Accept a setting if its one of the given alternatives.
    alt: function (k, v, a) {
        for (var n = 0; n < a.length; ++n) {
            if (v === a[n]) {
                this.set(k, v);
                break;
            }
        }
    },
    // Accept a setting if its a valid (signed) integer.
    integer: function (k, v) {
        if (/^-?\d+$/.test(v)) { // integer
            this.set(k, parseInt(v, 10));
        }
    },
    // Accept a setting if its a valid percentage.
    percent: function (k, v) {
        var m;
        if ((m = v.match(/^([\d]{1,3})(\.[\d]*)?%$/))) {
            v = parseFloat(v);
            if (v >= 0 && v <= 100) {
                this.set(k, v);
                return true;
            }
        }
        return false;
    }
};
// Helper function to parse input into groups separated by 'groupDelim', and
// interprete each group as a key/value pair separated by 'keyValueDelim'.
function parseOptions(input, callback, keyValueDelim, groupDelim) {
    var groups = groupDelim ? input.split(groupDelim) : [input];
    for (var i in groups) {
        if (typeof groups[i] !== 'string') {
            continue;
        }
        var kv = groups[i].split(keyValueDelim);
        if (kv.length !== 2) {
            continue;
        }
        var k = kv[0];
        var v = kv[1];
        callback(k, v);
    }
}
var defaults = new vttcue_1.default(0, 0, 0);
// 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244
//  Safari doesn't yet support this change, but FF and Chrome do.
var center = defaults.align === 'middle' ? 'middle' : 'center';
function parseCue(input, cue, regionList) {
    // Remember the original input if we need to throw an error.
    var oInput = input;
    // 4.1 WebVTT timestamp
    function consumeTimeStamp() {
        var ts = parseTimeStamp(input);
        if (ts === null) {
            throw new Error('Malformed timestamp: ' + oInput);
        }
        // Remove time stamp from input.
        input = input.replace(/^[^\sa-zA-Z-]+/, '');
        return ts;
    }
    // 4.4.2 WebVTT cue settings
    function consumeCueSettings(input, cue) {
        var settings = new Settings();
        parseOptions(input, function (k, v) {
            switch (k) {
                case 'region':
                    // Find the last region we parsed with the same region id.
                    for (var i = regionList.length - 1; i >= 0; i--) {
                        if (regionList[i].id === v) {
                            settings.set(k, regionList[i].region);
                            break;
                        }
                    }
                    break;
                case 'vertical':
                    settings.alt(k, v, ['rl', 'lr']);
                    break;
                case 'line':
                    var vals = v.split(','), vals0 = vals[0];
                    settings.integer(k, vals0);
                    if (settings.percent(k, vals0)) {
                        settings.set('snapToLines', false);
                    }
                    settings.alt(k, vals0, ['auto']);
                    if (vals.length === 2) {
                        settings.alt('lineAlign', vals[1], ['start', center, 'end']);
                    }
                    break;
                case 'position':
                    vals = v.split(',');
                    settings.percent(k, vals[0]);
                    if (vals.length === 2) {
                        settings.alt('positionAlign', vals[1], ['start', center, 'end', 'line-left', 'line-right', 'auto']);
                    }
                    break;
                case 'size':
                    settings.percent(k, v);
                    break;
                case 'align':
                    settings.alt(k, v, ['start', center, 'end', 'left', 'right']);
                    break;
            }
        }, /:/, /\s/);
        // Apply default values for any missing fields.
        cue.region = settings.get('region', null);
        cue.vertical = settings.get('vertical', '');
        var line = settings.get('line', 'auto');
        if (line === 'auto' && defaults.line === -1) {
            // set numeric line number for Safari
            line = -1;
        }
        cue.line = line;
        cue.lineAlign = settings.get('lineAlign', 'start');
        cue.snapToLines = settings.get('snapToLines', true);
        cue.size = settings.get('size', 100);
        cue.align = settings.get('align', center);
        var position = settings.get('position', 'auto');
        if (position === 'auto' && defaults.position === 50) {
            // set numeric position for Safari
            position = cue.align === 'start' || cue.align === 'left' ? 0 : cue.align === 'end' || cue.align === 'right' ? 100 : 50;
        }
        cue.position = position;
    }
    function skipWhitespace() {
        input = input.replace(/^\s+/, '');
    }
    // 4.1 WebVTT cue timings.
    skipWhitespace();
    cue.startTime = consumeTimeStamp(); // (1) collect cue start time
    skipWhitespace();
    if (input.substr(0, 3) !== '-->') { // (3) next characters must match '-->'
        throw new Error('Malformed time stamp (time stamps must be separated by \'-->\'): ' +
            oInput);
    }
    input = input.substr(3);
    skipWhitespace();
    cue.endTime = consumeTimeStamp(); // (5) collect cue end time
    // 4.1 WebVTT cue settings list.
    skipWhitespace();
    consumeCueSettings(input, cue);
}
function fixLineBreaks(input) {
    return input.replace(/<br(?: \/)?>/gi, '\n');
}
exports.fixLineBreaks = fixLineBreaks;
VTTParser.prototype = {
    parse: function (data) {
        var self = this;
        // If there is no data then we won't decode it, but will just try to parse
        // whatever is in buffer already. This may occur in circumstances, for
        // example when flush() is called.
        if (data) {
            // Try to decode the data that we received.
            self.buffer += self.decoder.decode(data, { stream: true });
        }
        function collectNextLine() {
            var buffer = self.buffer;
            var pos = 0;
            buffer = fixLineBreaks(buffer);
            while (pos < buffer.length && buffer[pos] !== '\r' && buffer[pos] !== '\n') {
                ++pos;
            }
            var line = buffer.substr(0, pos);
            // Advance the buffer early in case we fail below.
            if (buffer[pos] === '\r') {
                ++pos;
            }
            if (buffer[pos] === '\n') {
                ++pos;
            }
            self.buffer = buffer.substr(pos);
            return line;
        }
        // 3.2 WebVTT metadata header syntax
        function parseHeader(input) {
            parseOptions(input, function (k, v) {
                switch (k) {
                    case 'Region':
                        // 3.3 WebVTT region metadata header syntax
                        // console.log('parse region', v);
                        // parseRegion(v);
                        break;
                }
            }, /:/);
        }
        // 5.1 WebVTT file parsing.
        try {
            var line = void 0;
            if (self.state === 'INITIAL') {
                // We can't start parsing until we have the first line.
                if (!/\r\n|\n/.test(self.buffer)) {
                    return this;
                }
                line = collectNextLine();
                // strip of UTF-8 BOM if any
                // https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8
                var m = line.match(/^(ï»¿)?WEBVTT([ \t].*)?$/);
                if (!m || !m[0]) {
                    throw new Error('Malformed WebVTT signature.');
                }
                self.state = 'HEADER';
            }
            var alreadyCollectedLine = false;
            while (self.buffer) {
                // We can't parse a line until we have the full line.
                if (!/\r\n|\n/.test(self.buffer)) {
                    return this;
                }
                if (!alreadyCollectedLine) {
                    line = collectNextLine();
                }
                else {
                    alreadyCollectedLine = false;
                }
                switch (self.state) {
                    case 'HEADER':
                        // 13-18 - Allow a header (metadata) under the WEBVTT line.
                        if (/:/.test(line)) {
                            parseHeader(line);
                        }
                        else if (!line) {
                            // An empty line terminates the header and starts the body (cues).
                            self.state = 'ID';
                        }
                        continue;
                    case 'NOTE':
                        // Ignore NOTE blocks.
                        if (!line) {
                            self.state = 'ID';
                        }
                        continue;
                    case 'ID':
                        // Check for the start of NOTE blocks.
                        if (/^NOTE($|[ \t])/.test(line)) {
                            self.state = 'NOTE';
                            break;
                        }
                        // 19-29 - Allow any number of line terminators, then initialize new cue values.
                        if (!line) {
                            continue;
                        }
                        self.cue = new vttcue_1.default(0, 0, '');
                        self.state = 'CUE';
                        // 30-39 - Check if self line contains an optional identifier or timing data.
                        if (line.indexOf('-->') === -1) {
                            self.cue.id = line;
                            continue;
                        }
                    // Process line as start of a cue.
                    /* falls through */
                    case 'CUE':
                        // 40 - Collect cue timings and settings.
                        try {
                            parseCue(line, self.cue, self.regionList);
                        }
                        catch (e) {
                            // In case of an error ignore rest of the cue.
                            self.cue = null;
                            self.state = 'BADCUE';
                            continue;
                        }
                        self.state = 'CUETEXT';
                        continue;
                    case 'CUETEXT':
                        var hasSubstring = line.indexOf('-->') !== -1;
                        // 34 - If we have an empty line then report the cue.
                        // 35 - If we have the special substring '-->' then report the cue,
                        // but do not collect the line as we need to process the current
                        // one as a new cue.
                        if (!line || hasSubstring && (alreadyCollectedLine = true)) {
                            // We are done parsing self cue.
                            if (self.oncue) {
                                self.oncue(self.cue);
                            }
                            self.cue = null;
                            self.state = 'ID';
                            continue;
                        }
                        if (self.cue.text) {
                            self.cue.text += '\n';
                        }
                        self.cue.text += line;
                        continue;
                    case 'BADCUE': // BADCUE
                        // 54-62 - Collect and discard the remaining cue.
                        if (!line) {
                            self.state = 'ID';
                        }
                        continue;
                }
            }
        }
        catch (e) {
            // If we are currently parsing a cue, report what we have.
            if (self.state === 'CUETEXT' && self.cue && self.oncue) {
                self.oncue(self.cue);
            }
            self.cue = null;
            // Enter BADWEBVTT state if header was not parsed correctly otherwise
            // another exception occurred so enter BADCUE state.
            self.state = self.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE';
        }
        return this;
    },
    flush: function () {
        var self = this;
        try {
            // Finish decoding the stream.
            self.buffer += self.decoder.decode();
            // Synthesize the end of the current cue or region.
            if (self.cue || self.state === 'HEADER') {
                self.buffer += '\n\n';
                self.parse();
            }
            // If we've flushed, parsed, and we're still on the INITIAL state then
            // that means we don't have enough of the stream to parse the first
            // line.
            if (self.state === 'INITIAL') {
                throw new Error('Malformed WebVTT signature.');
            }
        }
        catch (e) {
            throw e;
        }
        if (self.onflush) {
            self.onflush();
        }
        return this;
    }
};
exports.default = VTTParser;


/***/ }),

/***/ "./src/utils/webvtt-parser.js":
/*!************************************!*\
  !*** ./src/utils/webvtt-parser.js ***!
  \************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Number) {
Object.defineProperty(exports, "__esModule", { value: true });
var vttparser_1 = __webpack_require__(/*! ./vttparser */ "./src/utils/vttparser.js");
var id3_1 = __webpack_require__(/*! ../demux/id3 */ "./src/demux/id3.js");
// String.prototype.startsWith is not supported in IE11
var startsWith = function (inputString, searchString, position) {
    return inputString.substr(position || 0, searchString.length) === searchString;
};
var cueString2millis = function (timeString) {
    var ts = parseInt(timeString.substr(-3));
    var secs = parseInt(timeString.substr(-6, 2));
    var mins = parseInt(timeString.substr(-9, 2));
    var hours = timeString.length > 9 ? parseInt(timeString.substr(0, timeString.indexOf(':'))) : 0;
    if (!Number.isFinite(ts) || !Number.isFinite(secs) || !Number.isFinite(mins) || !Number.isFinite(hours)) {
        return -1;
    }
    ts += 1000 * secs;
    ts += 60 * 1000 * mins;
    ts += 60 * 60 * 1000 * hours;
    return ts;
};
// From https://github.com/darkskyapp/string-hash
var hash = function (text) {
    var hash = 5381;
    var i = text.length;
    while (i) {
        hash = (hash * 33) ^ text.charCodeAt(--i);
    }
    return (hash >>> 0).toString();
};
var calculateOffset = function (vttCCs, cc, presentationTime) {
    var currCC = vttCCs[cc];
    var prevCC = vttCCs[currCC.prevCC];
    // This is the first discontinuity or cues have been processed since the last discontinuity
    // Offset = current discontinuity time
    if (!prevCC || (!prevCC.new && currCC.new)) {
        vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;
        currCC.new = false;
        return;
    }
    // There have been discontinuities since cues were last parsed.
    // Offset = time elapsed
    while (prevCC && prevCC.new) {
        vttCCs.ccOffset += currCC.start - prevCC.start;
        currCC.new = false;
        currCC = prevCC;
        prevCC = vttCCs[currCC.prevCC];
    }
    vttCCs.presentationOffset = presentationTime;
};
var WebVTTParser = {
    parse: function (vttByteArray, syncPTS, vttCCs, cc, callBack, errorCallBack) {
        // Convert byteArray into string, replacing any somewhat exotic linefeeds with "\n", then split on that character.
        var re = /\r\n|\n\r|\n|\r/g;
        // Uint8Array.prototype.reduce is not implemented in IE11
        var vttLines = id3_1.utf8ArrayToStr(new Uint8Array(vttByteArray)).trim().replace(re, '\n').split('\n');
        var cueTime = '00:00.000';
        var mpegTs = 0;
        var localTime = 0;
        var presentationTime = 0;
        var cues = [];
        var parsingError;
        var inHeader = true;
        // let VTTCue = VTTCue || window.TextTrackCue;
        // Create parser object using VTTCue with TextTrackCue fallback on certain browsers.
        var parser = new vttparser_1.default();
        parser.oncue = function (cue) {
            // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.
            var currCC = vttCCs[cc];
            var cueOffset = vttCCs.ccOffset;
            // Update offsets for new discontinuities
            if (currCC && currCC.new) {
                if (localTime !== undefined) {
                    // When local time is provided, offset = discontinuity start time - local time
                    cueOffset = vttCCs.ccOffset = currCC.start;
                }
                else {
                    calculateOffset(vttCCs, cc, presentationTime);
                }
            }
            if (presentationTime) {
                // If we have MPEGTS, offset = presentation time + discontinuity offset
                cueOffset = presentationTime - vttCCs.presentationOffset;
            }
            cue.startTime += cueOffset - localTime;
            cue.endTime += cueOffset - localTime;
            // Create a unique hash id for a cue based on start/end times and text.
            // This helps timeline-controller to avoid showing repeated captions.
            cue.id = hash(cue.startTime.toString()) + hash(cue.endTime.toString()) + hash(cue.text);
            // Fix encoding of special characters. TODO: Test with all sorts of weird characters.
            cue.text = decodeURIComponent(encodeURIComponent(cue.text));
            if (cue.endTime > 0) {
                cues.push(cue);
            }
        };
        parser.onparsingerror = function (e) {
            parsingError = e;
        };
        parser.onflush = function () {
            if (parsingError && errorCallBack) {
                errorCallBack(parsingError);
                return;
            }
            callBack(cues);
        };
        // Go through contents line by line.
        vttLines.forEach(function (line) {
            if (inHeader) {
                // Look for X-TIMESTAMP-MAP in header.
                if (startsWith(line, 'X-TIMESTAMP-MAP=')) {
                    // Once found, no more are allowed anyway, so stop searching.
                    inHeader = false;
                    // Extract LOCAL and MPEGTS.
                    line.substr(16).split(',').forEach(function (timestamp) {
                        if (startsWith(timestamp, 'LOCAL:')) {
                            cueTime = timestamp.substr(6);
                        }
                        else if (startsWith(timestamp, 'MPEGTS:')) {
                            mpegTs = parseInt(timestamp.substr(7));
                        }
                    });
                    try {
                        // Calculate subtitle offset in milliseconds.
                        if (syncPTS + ((vttCCs[cc].start * 90000) || 0) < 0) {
                            syncPTS += 8589934592;
                        }
                        // Adjust MPEGTS by sync PTS.
                        mpegTs -= syncPTS;
                        // Convert cue time to seconds
                        localTime = cueString2millis(cueTime) / 1000;
                        // Convert MPEGTS to seconds from 90kHz.
                        presentationTime = mpegTs / 90000;
                        if (localTime === -1) {
                            parsingError = new Error("Malformed X-TIMESTAMP-MAP: " + line);
                        }
                    }
                    catch (e) {
                        parsingError = new Error("Malformed X-TIMESTAMP-MAP: " + line);
                    }
                    // Return without parsing X-TIMESTAMP-MAP line.
                    return;
                }
                else if (line === '') {
                    inHeader = false;
                }
            }
            // Parse line by default.
            parser.parse(line + '\n');
        });
        parser.flush();
    }
};
exports.default = WebVTTParser;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.js")["Number"]))

/***/ }),

/***/ "./src/utils/xhr-loader.js":
/*!*********************************!*\
  !*** ./src/utils/xhr-loader.js ***!
  \*********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * XHR based logger
*/
Object.defineProperty(exports, "__esModule", { value: true });
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
var performance = window.performance, XMLHttpRequest = window.XMLHttpRequest;
var XhrLoader = /** @class */ (function () {
    function XhrLoader(config) {
        if (config && config.xhrSetup) {
            this.xhrSetup = config.xhrSetup;
        }
    }
    XhrLoader.prototype.destroy = function () {
        this.abort();
        this.loader = null;
    };
    XhrLoader.prototype.abort = function () {
        var loader = this.loader;
        if (loader && loader.readyState !== 4) {
            this.stats.aborted = true;
            loader.abort();
        }
        window.clearTimeout(this.requestTimeout);
        this.requestTimeout = null;
        window.clearTimeout(this.retryTimeout);
        this.retryTimeout = null;
    };
    XhrLoader.prototype.load = function (context, config, callbacks) {
        this.context = context;
        this.config = config;
        this.callbacks = callbacks;
        this.stats = { trequest: performance.now(), retry: 0 };
        this.retryDelay = config.retryDelay;
        this.loadInternal();
    };
    XhrLoader.prototype.loadInternal = function () {
        var xhr, context = this.context;
        xhr = this.loader = new XMLHttpRequest();
        var stats = this.stats;
        stats.tfirst = 0;
        stats.loaded = 0;
        var xhrSetup = this.xhrSetup;
        try {
            if (xhrSetup) {
                try {
                    xhrSetup(xhr, context.url);
                }
                catch (e) {
                    // fix xhrSetup: (xhr, url) => {xhr.setRequestHeader("Content-Language", "test");}
                    // not working, as xhr.setRequestHeader expects xhr.readyState === OPEN
                    xhr.open('GET', context.url, true);
                    xhrSetup(xhr, context.url);
                }
            }
            if (!xhr.readyState) {
                xhr.open('GET', context.url, true);
            }
        }
        catch (e) {
            // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS
            this.callbacks.onError({ code: xhr.status, text: e.message }, context, xhr);
            return;
        }
        if (context.rangeEnd) {
            xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));
        }
        xhr.onreadystatechange = this.readystatechange.bind(this);
        xhr.onprogress = this.loadprogress.bind(this);
        xhr.responseType = context.responseType;
        // setup timeout before we perform request
        this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout);
        xhr.send();
    };
    XhrLoader.prototype.readystatechange = function (event) {
        var xhr = event.currentTarget, readyState = xhr.readyState, stats = this.stats, context = this.context, config = this.config;
        // don't proceed if xhr has been aborted
        if (stats.aborted) {
            return;
        }
        // >= HEADERS_RECEIVED
        if (readyState >= 2) {
            // clear xhr timeout and rearm it if readyState less than 4
            window.clearTimeout(this.requestTimeout);
            if (stats.tfirst === 0) {
                stats.tfirst = Math.max(performance.now(), stats.trequest);
            }
            if (readyState === 4) {
                var status_1 = xhr.status;
                // http status between 200 to 299 are all successful
                if (status_1 >= 200 && status_1 < 300) {
                    stats.tload = Math.max(stats.tfirst, performance.now());
                    var data = void 0, len = void 0;
                    if (context.responseType === 'arraybuffer') {
                        data = xhr.response;
                        len = data.byteLength;
                    }
                    else {
                        data = xhr.responseText;
                        len = data.length;
                    }
                    stats.loaded = stats.total = len;
                    var response = { url: xhr.responseURL, data: data };
                    this.callbacks.onSuccess(response, stats, context, xhr);
                }
                else {
                    // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error
                    if (stats.retry >= config.maxRetry || (status_1 >= 400 && status_1 < 499)) {
                        logger_1.logger.error(status_1 + " while loading " + context.url);
                        this.callbacks.onError({ code: status_1, text: xhr.statusText }, context, xhr);
                    }
                    else {
                        // retry
                        logger_1.logger.warn(status_1 + " while loading " + context.url + ", retrying in " + this.retryDelay + "...");
                        // aborts and resets internal state
                        this.destroy();
                        // schedule retry
                        this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay);
                        // set exponential backoff
                        this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);
                        stats.retry++;
                    }
                }
            }
            else {
                // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet
                this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), config.timeout);
            }
        }
    };
    XhrLoader.prototype.loadtimeout = function () {
        logger_1.logger.warn("timeout while loading " + this.context.url);
        this.callbacks.onTimeout(this.stats, this.context, null);
    };
    XhrLoader.prototype.loadprogress = function (event) {
        var xhr = event.currentTarget, stats = this.stats;
        stats.loaded = event.loaded;
        if (event.lengthComputable) {
            stats.total = event.total;
        }
        var onProgress = this.callbacks.onProgress;
        if (onProgress) {
            // third arg is to provide on progress data
            onProgress(stats, this.context, null, xhr);
        }
    };
    return XhrLoader;
}());
exports.default = XhrLoader;


/***/ })

/******/ })["default"];
});

},{}],115:[function(require,module,exports){
/*!
 * jQuery JavaScript Library v3.3.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2018-01-20T17:24Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		noModule: true
	};

	function DOMEval( code, doc, node ) {
		doc = doc || document;

		var i,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {
				if ( node[ i ] ) {
					script[ i ] = node[ i ];
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.3.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && Array.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						disabledAncestor( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
        if ( nodeName( elem, "iframe" ) ) {
            return elem.contentDocument;
        }

        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
        // Treat the template element as a regular one in browsers that
        // don't support it.
        if ( nodeName( elem, "template" ) ) {
            elem = elem.content || elem;
        }

        return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc, node );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		div.style.position = "absolute";
		scrollboxSizeVal = div.offsetWidth === 36 || "absolute";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a property mapped along what jQuery.cssProps suggests or to
// a vendor prefixed property.
function finalPropName( name ) {
	var ret = jQuery.cssProps[ name ];
	if ( !ret ) {
		ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
	}
	return ret;
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5
		) );
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),
		val = curCSS( elem, dimension, styles ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox;

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}

	// Check for style in case a browser which returns unreliable values
	// for getComputedStyle silently falls back to the reliable elem.style
	valueIsBorderBox = valueIsBorderBox &&
		( support.boxSizingReliable() || val === elem.style[ dimension ] );

	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	if ( val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) {

		val = elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];

		// offsetWidth/offsetHeight provide border-box values
		valueIsBorderBox = true;
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),
				isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra && boxModelAdjustment(
					elem,
					dimension,
					extra,
					isBorderBox,
					styles
				);

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && support.scrollboxSize() === styles.position ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );

},{}],116:[function(require,module,exports){
/*!
 * JavaScript Cookie v2.2.0
 * https://github.com/js-cookie/js-cookie
 *
 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
 * Released under the MIT license
 */
;(function (factory) {
	var registeredInModuleLoader = false;
	if (typeof define === 'function' && define.amd) {
		define(factory);
		registeredInModuleLoader = true;
	}
	if (typeof exports === 'object') {
		module.exports = factory();
		registeredInModuleLoader = true;
	}
	if (!registeredInModuleLoader) {
		var OldCookies = window.Cookies;
		var api = window.Cookies = factory();
		api.noConflict = function () {
			window.Cookies = OldCookies;
			return api;
		};
	}
}(function () {
	function extend () {
		var i = 0;
		var result = {};
		for (; i < arguments.length; i++) {
			var attributes = arguments[ i ];
			for (var key in attributes) {
				result[key] = attributes[key];
			}
		}
		return result;
	}

	function init (converter) {
		function api (key, value, attributes) {
			var result;
			if (typeof document === 'undefined') {
				return;
			}

			// Write

			if (arguments.length > 1) {
				attributes = extend({
					path: '/'
				}, api.defaults, attributes);

				if (typeof attributes.expires === 'number') {
					var expires = new Date();
					expires.setMilliseconds(expires.getMilliseconds() + attributes.expires * 864e+5);
					attributes.expires = expires;
				}

				// We're using "expires" because "max-age" is not supported by IE
				attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';

				try {
					result = JSON.stringify(value);
					if (/^[\{\[]/.test(result)) {
						value = result;
					}
				} catch (e) {}

				if (!converter.write) {
					value = encodeURIComponent(String(value))
						.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
				} else {
					value = converter.write(value, key);
				}

				key = encodeURIComponent(String(key));
				key = key.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent);
				key = key.replace(/[\(\)]/g, escape);

				var stringifiedAttributes = '';

				for (var attributeName in attributes) {
					if (!attributes[attributeName]) {
						continue;
					}
					stringifiedAttributes += '; ' + attributeName;
					if (attributes[attributeName] === true) {
						continue;
					}
					stringifiedAttributes += '=' + attributes[attributeName];
				}
				return (document.cookie = key + '=' + value + stringifiedAttributes);
			}

			// Read

			if (!key) {
				result = {};
			}

			// To prevent the for loop in the first place assign an empty array
			// in case there are no cookies at all. Also prevents odd result when
			// calling "get()"
			var cookies = document.cookie ? document.cookie.split('; ') : [];
			var rdecode = /(%[0-9A-Z]{2})+/g;
			var i = 0;

			for (; i < cookies.length; i++) {
				var parts = cookies[i].split('=');
				var cookie = parts.slice(1).join('=');

				if (!this.json && cookie.charAt(0) === '"') {
					cookie = cookie.slice(1, -1);
				}

				try {
					var name = parts[0].replace(rdecode, decodeURIComponent);
					cookie = converter.read ?
						converter.read(cookie, name) : converter(cookie, name) ||
						cookie.replace(rdecode, decodeURIComponent);

					if (this.json) {
						try {
							cookie = JSON.parse(cookie);
						} catch (e) {}
					}

					if (key === name) {
						result = cookie;
						break;
					}

					if (!key) {
						result[name] = cookie;
					}
				} catch (e) {}
			}

			return result;
		}

		api.set = api;
		api.get = function (key) {
			return api.call(api, key);
		};
		api.getJSON = function () {
			return api.apply({
				json: true
			}, [].slice.call(arguments));
		};
		api.defaults = {};

		api.remove = function (key, attributes) {
			api(key, '', extend(attributes, {
				expires: -1
			}));
		};

		api.withConverter = init;

		return api;
	}

	return init(function () {});
}));

},{}],117:[function(require,module,exports){
"use strict";

require("core-js/modules/es6.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BrowserNotSupportError = void 0;

require("core-js/modules/es7.symbol.async-iterator");

require("core-js/modules/es6.symbol");

require("core-js/modules/es6.object.create");

require("core-js/modules/web.dom.iterable");

require("core-js/modules/es6.array.iterator");

require("core-js/modules/es6.string.iterator");

require("core-js/modules/es6.map");

require("core-js/modules/es6.function.bind");

require("core-js/modules/es6.reflect.construct");

require("core-js/modules/es6.regexp.to-string");

require("core-js/modules/es6.date.to-string");

require("core-js/modules/es6.array.index-of");

require("core-js/modules/es6.object.set-prototype-of");

var _resources = require("./lib/resources");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/** 
 * 浏览器不支持所引发的错误
 * @deprecated 浏览器不支持所引发的错误。有关基类的详细信息，请参阅 MDN [Error]{@link https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error} 。
 * @alias openBSE.BrowserNotSupportError
 * @extends Error
 */
var BrowserNotSupportError = function (_Error) {
  _inherits(BrowserNotSupportError, _Error);

  /**
   * 创建一个异常对象
   * @param {string} message - 消息
   */
  function BrowserNotSupportError(message) {
    var _this;

    _classCallCheck(this, BrowserNotSupportError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(BrowserNotSupportError).call(this, _resources.Resources.BROWSER_NOT_SUPPORT_ERROR.fillData({
      message: message
    })));
    _this.name = "BrowserNotSupportError";
    return _this;
  }

  return BrowserNotSupportError;
}(_wrapNativeSuper(Error));

exports.BrowserNotSupportError = BrowserNotSupportError;


},{"./lib/resources":133,"core-js/modules/es6.array.index-of":92,"core-js/modules/es6.array.iterator":93,"core-js/modules/es6.date.to-string":95,"core-js/modules/es6.function.bind":96,"core-js/modules/es6.map":97,"core-js/modules/es6.object.create":98,"core-js/modules/es6.object.define-property":99,"core-js/modules/es6.object.set-prototype-of":100,"core-js/modules/es6.reflect.construct":101,"core-js/modules/es6.regexp.to-string":108,"core-js/modules/es6.string.iterator":109,"core-js/modules/es6.symbol":110,"core-js/modules/es7.symbol.async-iterator":112,"core-js/modules/web.dom.iterable":113}],118:[function(require,module,exports){
module.exports={"version":"2.1","home":"https://iamscottxu.github.io/openBSE/","name":"openBSE","description":"openBSE is a high-performance JavaScript bullet-screen (danmaku) engine.","buildDate":"Tue, 05 Mar 2019 01:19:16 GMT"}

},{}],119:[function(require,module,exports){
"use strict";

require("core-js/modules/es6.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BulletScreenEngine = void 0;

require("core-js/modules/es6.array.index-of");

require("core-js/modules/web.dom.iterable");

require("core-js/modules/es6.array.for-each");

require("core-js/modules/es6.function.bind");

var _linkedList = require("./lib/linkedList");

var _event2 = require("./lib/event");

var _renderersFactory = require("./lib/renderers/renderersFactory");

var _bulletScreenType2 = require("./bulletScreenType");

var _helper = require("./lib/helper");

var _resources = require("./lib/resources");

var build = _interopRequireWildcard(require("./build.json"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** 
 * 弹幕引擎对象类 
 * @alias openBSE.BulletScreenEngine
 * @throws {openBSE.BrowserNotSupportError} 浏览器不支持特定渲染模式时引发错误。
 * @throws {TypeError} 传入的参数错误时引发错误。请参阅 MDN [TypeError]{@link https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError} 。
 */
var BulletScreenEngine =
/**
 * 创建一个弹幕引擎对象。
 * @param {Element} element - 要加载弹幕的元素：有关 Element 接口的信息请参阅MDN [Element]{@link https://developer.mozilla.org/zh-CN/docs/Web/API/Element} 。
 * @param {openBSE~Options} [_options] - 全局选项：一个 {@link openBSE~Options} 结构。
 * @param {string} [renderMode="canvas"] - 渲染模式：默认为“canvas”, “可选css3”， “webgl”和“svg”。一般建议使用“canvas”（特别是 FireFox 浏览器 CSS3 渲染效率较低）。在一些版本较老的浏览器中“window.devicePixelRatio”变量不被支持或支持不完整，这会导致在高DPI和页面被缩放的情况下“canvas”和“webgl”渲染模式弹幕显示不正常的情况（弹幕模糊），此时建议使用“css3”渲染模式。
 */
function BulletScreenEngine(element, options) {
  var renderMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'canvas';

  _classCallCheck(this, BulletScreenEngine);

  /**
   * 开始时间
   * @private @type {number}
   */
  var _startTime;
  /**
   * 暂停时间
   * @private @type {number}
   */


  var _pauseTime = 0;
  /**
   * 剩余弹幕
   * @private @type {LinkedList}
   */

  var _bulletScreens = new _linkedList.LinkedList();
  /**
   * 屏幕上的弹幕
   * @private @type {LinkedList}
   */


  var _bulletScreensOnScreen = new _linkedList.LinkedList();
  /**
   * 延迟弹幕总数
   * @private @type {number}
   */


  var _delayBulletScreensCount = 0;
  /**
   * 延迟（单位：毫秒）
   * @private @type {number}
   */

  var _delay = 0;
  /**
   * 播放标志
   * @private @type {boolean}
   */

  var _playing;
  /**
   * 刷新频率
   * @private @type {number}
   */


  var _refreshRate = 0.06;
  /**
   * 上一次刷新时间
   * @private @type {number}
   */

  var _lastRefreshTime;
  /**
   * 全局选项
   * @private @type {openBSE~Options}
   */


  var _options;
  /**
   * 默认全局变量
   * @private @readonly
   */


  var _defaultOptions = {
    /** 垂直间距 */
    verticalInterval: 8,

    /** 播放速度(倍数) */
    playSpeed: 1,

    /** 时间基准 */
    clock: function clock(time) {
      return new Date().getTime() - _startTime;
    },

    /** 缩放比例 */
    scaling: 1,

    /** 超时丢弃 */
    timeOutDiscard: true,

    /** 要隐藏的弹幕类型 */
    hiddenTypes: 0,

    /** 弹幕不透明度 */
    opacity: 1,

    /** 鼠标经过样式 */
    cursorOnMouseOver: 'pointer',

    /** 默认弹幕样式 */
    defaultStyle: {
      /** 阴影的模糊级别，0为不显示阴影 */
      shadowBlur: 2,

      /** 字体粗细 */
      fontWeight: '600',

      /** 字体系列 */
      fontFamily: 'sans-serif',

      /** 字体大小（单位：像素） */
      size: 25,

      /** 外框颜色 */
      boxColor: null,

      /** 字体颜色 */
      color: 'white',

      /** 描边颜色 */
      borderColor: null,

      /** 弹幕速度（单位：像素/毫秒） 仅流弹幕类型有效 */
      speed: 0.15,

      /** 弹幕停留时间 仅固定弹幕类型有效 */
      residenceTime: 5000
    }
    /**
     * 全局选项类型
     * @private @readonly
     */

  };
  var _optionsType = {
    verticalInterval: 'number',
    playSpeed: 'number',
    clock: 'function',
    scaling: 'number',
    timeOutDiscard: 'boolean',
    hiddenTypes: 'number',
    opacity: 'number',
    cursorOnMouseOver: 'string',
    defaultStyle: {
      shadowBlur: 'number',
      fontWeight: ['string', 'number'],
      fontFamily: 'string',
      size: 'number',
      boxColor: ['string', 'null'],
      color: 'string',
      borderColor: ['string', 'null'],
      speed: 'number',
      residenceTime: 'number'
    }
    /**
     * 默认弹幕数据
     * @private @readonly
     */

  };
  var _defaultBulletScreen = {
    /** 弹幕文本 */
    text: null,

    /** 是否允许丢弃 */
    canDiscard: true,

    /** 弹幕进入时间 */
    startTime: null,

    /** 弹幕类型 */
    type: _bulletScreenType2.BulletScreenType.rightToLeft,

    /** 弹幕层级（越大越前） */
    layer: 0
    /**
     * 弹幕数据类型
     * @private @readonly
     */

  };
  var _bulletScreenType = {
    text: 'string',
    canDiscard: 'boolean',
    startTime: 'number',
    type: 'number',
    layer: 'number'
    /**
     * requestAnimationFrame 定义（一些老式浏览器不支持 requestAnimationFrame ）
     * @param {function} fun - 回调方法 
     * @function
     */

  };
  var requestAnimationFrame;
  if (typeof window.requestAnimationFrame === 'function') requestAnimationFrame = window.requestAnimationFrame;else {
    console.warn(_resources.Resources.REQUESTANIMATIONFRAME_NOT_SUPPORT_WARN);

    requestAnimationFrame = function requestAnimationFrame(fun) {
      return window.setTimeout(fun, 17);
    };
  }
  _options = _helper.Helper.setValues(options, _defaultOptions, _optionsType);

  var _event = new _event2.Event();
  /**
   * 弹幕单击事件。当单击弹幕时触发。
   * @event openBSE.BulletScreenEngine#click
   * @property {openBSE~BulletScreenEvent} e - 弹幕事件结构
   */


  _event.add('click');
  /**
   * 弹幕上下文菜单事件。当触发弹幕上下文菜单时触发。
   * @event openBSE.BulletScreenEngine#contextmenu
   * @property {openBSE~BulletScreenEvent} e - 弹幕事件结构
   */


  _event.add('contextmenu');
  /**
  * 弹幕鼠标离开事件。当鼠标离开弹幕时触发。
  * @event openBSE.BulletScreenEngine#mouseleave
  * @property {openBSE~BulletScreenEvent} e - 弹幕事件结构
  */


  _event.add('mouseleave');
  /**
   * 弹幕鼠标进入事件。当鼠标进入弹幕时触发。
   * @event openBSE.BulletScreenEngine#mouseenter
   * @property {openBSE~BulletScreenEvent} e - 弹幕事件结构
   */


  _event.add('mouseenter');
  /**
   * 绑定事件处理程序
   * @function
   * @description 绑定事件处理程序。当事件处理程序返回值为 false 时停止冒泡。
   * @param {string} name - 事件名称
   * @param {function} fun - 事件处理程序
   * @listens openBSE.BulletScreenEngine#click
   * @listens openBSE.BulletScreenEngine#contextmenu
   * @listens openBSE.BulletScreenEngine#mouseleave
   * @listens openBSE.BulletScreenEngine#mouseenter
   * @throws {TypeError} 传入的参数错误或事件不存在时引发错误。请参阅 MDN [TypeError]{@link https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError} 。
   */


  this.bind = _event.bind;
  /**
   * 解绑事件处理程序（fun为空解绑所有事件处理程序）
   * @function
   * @param {string} name - 事件名称
   * @param {function} fun - 事件处理程序
   * @throws {TypeError} 传入的参数错误或事件不存在时引发错误。请参阅 MDN [TypeError]{@link https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError} 。
   */

  this.unbind = _event.unbind;
  var _elementSize = {
    width: element.clientWidth / _options.scaling,
    height: element.clientHeight / _options.scaling
  };

  var _oldDevicePixelRatio = _helper.Helper.getDevicePixelRatio();

  var _oldScaling = _options.scaling;
  var _oldClientWidth = element.clientWidth;
  var _oldClientHeight = element.clientHeight;
  var _oldHiddenTypes = _options.hiddenTypes;
  var _oldOpacity = _options.opacity;
  var renderersFactory = new _renderersFactory.RenderersFactory(element, _options, _elementSize, bulletScreenEventTrigger);

  var _renderer = renderersFactory.getRenderer(renderMode);

  setInterval(setSize, 100);
  /**
   * 设置全局选项
   * @param {openBSE~Options} options - 全局选项：一个 {@link openBSE~Options} 结构。
   * @throws {TypeError} 传入的参数错误时引发错误。请参阅 MDN [TypeError]{@link https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError} 。
   */

  this.setOptions = function (options) {
    _options = _helper.Helper.setValues(options, _options, _optionsType, false);

    if (_oldHiddenTypes != _options.hiddenTypes) {
      _oldHiddenTypes = _options.hiddenTypes;
      if (!_playing) _renderer.draw();
    }

    if (_oldOpacity != _options.opacity) {
      _oldOpacity = _options.opacity;

      _renderer.setOpacity();
    }
  };
  /**
   * 获取全局选项
   * @returns {openBSE~Options} 全局选项：一个 {@link openBSE~Options} 结构。
   */


  this.getOptions = function () {
    return _options;
  };
  /**
   * 添加弹幕到弹幕列表。
   * @description 添加弹幕到弹幕列表。由于弹幕在屏幕上出现过后，弹幕引擎将从列表中彻底删除此弹幕。所以，在改变播放进度时，可能需要先[清空弹幕列表]{@link openBSE.BulletScreenEngine#cleanBulletScreenList}，然后重新加载此播放进度以后的弹幕。
   * @param {openBSE~BulletScreen} bulletScreen - 单条弹幕数据：一个 {@link openBSE~BulletScreen} 结构。
   * @throws {TypeError} 传入的参数错误时引发错误。请参阅 MDN [TypeError]{@link https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError} 。
   */


  this.addBulletScreen = function (bulletScreen) {
    _defaultBulletScreen.startTime = _options.clock();
    bulletScreen = _helper.Helper.setValues(bulletScreen, _defaultBulletScreen, _bulletScreenType);
    if (bulletScreen.type != _bulletScreenType2.BulletScreenType.leftToRight && bulletScreen.type != _bulletScreenType2.BulletScreenType.rightToLeft && bulletScreen.type != _bulletScreenType2.BulletScreenType.top && bulletScreen.type != _bulletScreenType2.BulletScreenType.bottom) throw new TypeError(_resources.Resources.PARAMETERS_TYPE_ERROR);

    _helper.Helper.checkTypes(bulletScreen.style, _optionsType.defaultStyle);

    var oldLength = _bulletScreens.getLength();

    _bulletScreens.forEach(function (lastBulletScreen) {
      if (bulletScreen.startTime > lastBulletScreen.startTime) return {
        add: {
          addToUp: true,
          element: bulletScreen
        },
        stop: true
      };
    }, true);

    if (oldLength === _bulletScreens.getLength()) _bulletScreens.push(bulletScreen, false);
  };
  /**
   * 开始播放弹幕。
   */


  this.play = function () {
    if (!_playing) {
      if (!_startTime) _startTime = new Date().getTime();
      if (_pauseTime) _startTime += _options.clock() - _pauseTime;
      _lastRefreshTime = null;
      _playing = true;
      requestAnimationFrame(refresh);
    }
  };
  /**
   * 继续所有在事件响应中设置了 e.pause = true; 弹幕的播放。
   */


  this.playAllBulletScreens = function () {
    return _bulletScreensOnScreen.forEach(function (bulletScreenOnScreen) {
      return bulletScreenOnScreen.pause = false;
    });
  };
  /**
   * 暂停播放弹幕。
   * @description 暂停播放弹幕。暂停播放弹幕是指弹幕播放暂停，所有未出现的弹幕将停止出现，已出现的弹幕停止运动，停止消失。
   */


  this.pause = function () {
    if (_playing) {
      _pauseTime = _options.clock();
      _playing = false;
    }
  };
  /**
   * 清空弹幕列表。
   * @description 清空弹幕列表，但屏幕上已经出现的弹幕不会被清除。
   */


  this.cleanBulletScreenList = function () {
    _bulletScreens.clean();
  };
  /**
   * 清空屏幕内容。
   * @description 清空屏幕内容。清空屏幕上已经出现的弹幕，不包括弹幕列表中的弹幕。
   */


  this.cleanScreen = function () {
    _bulletScreensOnScreen.clean();

    _renderer.cleanScreen();
  };
  /**
   * 停止播放弹幕。
   * @description 停止播放弹幕。停止播放弹幕是指停止播放弹幕，默认[时间基准（options.clock）]{@link openBSE~BulletScreenStyle}归零，并[清空弹幕列表]{@link openBSE.BulletScreenEngine#cleanBulletScreenList}、[清空屏幕内容]{@link openBSE.BulletScreenEngine#cleanScreen}。
   */


  this.stop = function () {
    if (_playing) {
      this.pause();
    }

    this.cleanBulletScreenList();
    this.cleanScreen();
    _pauseTime = 0;
    _startTime = null;
  };
  /**
   * 隐藏弹幕。
   * @function
   */


  this.hide = _renderer.hide;
  /**
   * 显示弹幕。
   * @function
   */

  this.show = _renderer.show;
  /**
   * 获取弹幕可见性。
   * @function
   * @returns {boolean} - 指示弹幕是否可见。
   * @description 获取弹幕可见性。如要显示弹幕请调用 [bulletScreenEngine.show();]{@link openBSE.BulletScreenEngine#show} ，要隐藏弹幕请调用 [bulletScreenEngine.hide();]{@link openBSE.BulletScreenEngine#hide} 。
   */

  this.getVisibility = _renderer.getVisibility;
  /**
   * 获取渲染模式。
   * @returns {string} - 弹幕渲染模式： 取值为“canvas”、“css3”、“webgl”或“svg”。
   */

  this.getRenderMode = function () {
    return renderMode;
  };
  /**
   * 获取播放状态。
   * @returns {boolean} - 正在播放标志：true：正在播放；false：已暂停/停止播放。
   */


  this.getPlayState = function () {
    return _playing;
  };
  /**
  * 获取调试信息。
  * @returns {openBSE~DebugInfo} - 调试信息：一个 {@link openBSE~DebugInfo} 结构。
  */


  this.getDebugInfo = function () {
    return {
      time: _playing ? _options.clock() : _pauseTime,
      bulletScreensOnScreenCount: _bulletScreensOnScreen.getLength(),
      bulletScreensCount: _bulletScreens.getLength(),
      delay: _delay,
      delayBulletScreensCount: _delayBulletScreensCount,
      fps: _playing ? Math.floor(_refreshRate * 1000) : 0
    };
  };
  /**
   * 弹幕事件响应
   * @param {string} name - 事件名称
   * @param {object} bulletScreenOnScreen - 屏幕弹幕对象
   * @param {object} e - 事件信息
   */


  function bulletScreenEventTrigger(name, bulletScreenOnScreen, e) {
    if (typeof e.pageX === 'undefined' || e.pageX === null) {
      var doc = document.documentElement,
          body = document.body;
      e.pageX = e.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
      e.pageY = e.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
    }

    _event.trigger(name, {
      /**
       * 获取引发事件的弹幕弹幕的数据
       * @private
       * @returns {openBSE~BulletScreen} 引发事件的弹幕的数据：一个 {@link openBSE~BulletScreen} 结构。（注意：不要试图与[添加弹幕]{@link openBSE.BulletScreenEngine#addBulletScreen}时创建的对象进行比较，这个对象是克隆得到的，并不相等。正确的方法是在添加弹幕时一并插入 id 等自定义字段来唯一标识一条弹幕。）
       */
      getBulletScreen: function getBulletScreen() {
        return _helper.Helper.clone(bulletScreenOnScreen.bulletScreen);
      },

      /**
       * 设置引发事件的弹幕弹幕的数据
       * @private
       * @param {openBSE~BulletScreen} bulletScreen - 引发事件的弹幕的数据：一个 {@link openBSE~BulletScreen} 结构。设置此参数以便动态调整弹幕样式，但是一些参数在事件中修改无效，查看此结构的说明以了解详情。
       * @param {boolean} [redraw=false] - 是否重绘弹幕：此参数在每次引发事件时的初始值为 false ，如果修改了 bulletScreen 中的值，此参数必须设为 true 。
       */
      setBulletScreen: function setBulletScreen(bulletScreen) {
        var redraw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        if (typeof redraw != 'boolean') throw new TypeError(_resources.Resources.PARAMETERS_TYPE_ERROR);

        var bulletScreenType = _helper.Helper.clone(_bulletScreenType);

        bulletScreenType.style = _optionsType.defaultStyle;
        bulletScreenOnScreen.bulletScreen = _helper.Helper.setValues(bulletScreen, bulletScreenOnScreen.bulletScreen, bulletScreenType);
        if (redraw === true) _renderer.reCreatAndgetWidth(bulletScreenOnScreen);
        if (!_playing && redraw) _renderer.draw();
      },

      /**
       * 获取引发事件的弹幕的播放状态
       * @private
       * @returns {boolean} 取引发事件的弹幕是否在播放/移动：如果设置为 true 则该弹幕暂停，直到将此参数设为 false 或调用 {@link openBSE.BulletScreenEngine#playAllBulletScreens} 方法。
       */
      getPlayState: function getPlayState() {
        return !bulletScreenOnScreen.pause;
      },

      /**
       * 设置引发事件的弹幕的播放状态
       * @private
       * @param {boolean} paly - 是否继续播放/移动引发事件的弹幕：读取此参数可判断这条弹幕是否处于暂停状态。
       */
      setPlayState: function setPlayState(play) {
        if (typeof play != 'boolean') throw new TypeError(_resources.Resources.PARAMETERS_TYPE_ERROR);
        bulletScreenOnScreen.pause = !play;
      },
      screenX: e.screenX,
      screenY: e.screenY,
      pageX: e.pageX,
      pageY: e.pageY,
      clientX: e.clientX,
      clientY: e.clientY
    });
  }
  /**
   * 刷新弹幕函数
   * @private
   */


  function refresh() {
    var nowTime = new Date().getTime();
    if (_lastRefreshTime != null) _refreshRate = 1 / (nowTime - _lastRefreshTime);
    _lastRefreshTime = nowTime;
    addBulletScreensToScreen();
    moveBulletScreenOnScreen();

    _renderer.draw();

    if (_playing) requestAnimationFrame(refresh);
  }
  /**
   * 移动弹幕函数
   * @private
   */


  function moveBulletScreenOnScreen() {
    _bulletScreensOnScreen.forEach(function (bulletScreenOnScreen) {
      if (bulletScreenOnScreen.pause) return;

      var nowTime = _options.clock();

      switch (bulletScreenOnScreen.type) {
        case _bulletScreenType2.BulletScreenType.rightToLeft:
          if (bulletScreenOnScreen.x > -bulletScreenOnScreen.width) {
            bulletScreenOnScreen.x -= bulletScreenOnScreen.bulletScreen.style.speed * _options.playSpeed / _refreshRate;
          } else {
            _renderer.delete(bulletScreenOnScreen);

            return {
              remove: true
            };
          }

          break;

        case _bulletScreenType2.BulletScreenType.leftToRight:
          if (bulletScreenOnScreen.x < _elementSize.width) {
            bulletScreenOnScreen.x += bulletScreenOnScreen.bulletScreen.style.speed * _options.playSpeed / _refreshRate;
          } else {
            _renderer.delete(bulletScreenOnScreen);

            return {
              remove: true
            };
          }

          break;

        case _bulletScreenType2.BulletScreenType.top:
        case _bulletScreenType2.BulletScreenType.bottom:
          if (bulletScreenOnScreen.endTime < nowTime) {
            _renderer.delete(bulletScreenOnScreen);

            return {
              remove: true
            };
          }

          break;
      }
    }, true);
  }
  /**
   * 添加弹幕到屏幕函数
   * @private
   */


  function addBulletScreensToScreen() {
    if (_bulletScreensOnScreen.getLength() === 0) _delay = 0;
    var times = Math.floor(_refreshRate * 2000);

    do {
      var bulletScreen = _bulletScreens.pop(false, false);

      if (bulletScreen === null) return;

      var nowTime = _options.clock();

      if (bulletScreen.startTime > nowTime) return;

      if (!_options.timeOutDiscard || !bulletScreen.canDiscard || bulletScreen.startTime > nowTime - Math.floor(1 / _refreshRate) * 60) {
        bulletScreen.style = _helper.Helper.setValues(bulletScreen.style, _options.defaultStyle, _optionsType.defaultStyle);
        getBulletScreenOnScreen(nowTime, bulletScreen);
      } else _delayBulletScreensCount++;

      _bulletScreens.pop(true, false);

      times--;
    } while (_bulletScreensOnScreen.getLength() === 0 || times > 0);
  }
  /**
   * 生成屏幕弹幕对象函数
   * @private
   * @param {number} nowTime - 当前时间
   * @param {openBSE~BulletScreen} bulletScreen - 弹幕
   */


  function getBulletScreenOnScreen(nowTime, bulletScreen) {
    _delay = nowTime - bulletScreen.startTime;
    var bulletScreenOnScreen = {};
    bulletScreenOnScreen.pause = false;
    bulletScreenOnScreen.bulletScreen = bulletScreen;
    bulletScreenOnScreen.startTime = nowTime;
    bulletScreenOnScreen.size = bulletScreen.style.size;
    bulletScreenOnScreen.type = bulletScreen.type;
    bulletScreenOnScreen.height = bulletScreenOnScreen.size;

    _renderer.creatAndgetWidth(bulletScreenOnScreen);

    switch (bulletScreen.type) {
      case _bulletScreenType2.BulletScreenType.rightToLeft:
        bulletScreenOnScreen.endTime = Math.round(nowTime + (_elementSize.width + bulletScreenOnScreen.width) / (bulletScreen.style.speed * _options.playSpeed));
        bulletScreenOnScreen.x = _elementSize.width;
        bulletScreenOnScreen.y = _options.verticalInterval;
        break;

      case _bulletScreenType2.BulletScreenType.leftToRight:
        bulletScreenOnScreen.endTime = Math.round(nowTime + (_elementSize.width + bulletScreenOnScreen.width) / (bulletScreen.style.speed * _options.playSpeed));
        bulletScreenOnScreen.x = -bulletScreenOnScreen.width;
        bulletScreenOnScreen.y = _options.verticalInterval;
        break;

      case _bulletScreenType2.BulletScreenType.top:
        bulletScreenOnScreen.endTime = bulletScreenOnScreen.startTime + bulletScreen.style.residenceTime * _options.playSpeed;
        bulletScreenOnScreen.x = Math.round((_elementSize.width - bulletScreenOnScreen.width) / 2);
        bulletScreenOnScreen.y = _options.verticalInterval;
        break;

      case _bulletScreenType2.BulletScreenType.bottom:
        bulletScreenOnScreen.endTime = bulletScreenOnScreen.startTime + bulletScreen.style.residenceTime * _options.playSpeed;
        bulletScreenOnScreen.x = Math.round((_elementSize.width - bulletScreenOnScreen.width) / 2);
        bulletScreenOnScreen.y = -_options.verticalInterval - bulletScreenOnScreen.height;
        break;
    }

    var oldLength = _bulletScreensOnScreen.getLength();

    if (bulletScreen.type === _bulletScreenType2.BulletScreenType.top || bulletScreen.type === _bulletScreenType2.BulletScreenType.bottom) {
      _bulletScreensOnScreen.forEach(function (nextBulletScreenOnScreen) {
        if (nextBulletScreenOnScreen.bulletScreen.type != bulletScreen.type) return;

        if (bulletScreen.type === _bulletScreenType2.BulletScreenType.top) {
          if (bulletScreenOnScreen.y + bulletScreenOnScreen.height < nextBulletScreenOnScreen.y) return {
            add: {
              addToUp: true,
              element: setActualY(bulletScreenOnScreen)
            },
            stop: true
          };
          if (nextBulletScreenOnScreen.endTime < nowTime) bulletScreenOnScreen.y = nextBulletScreenOnScreen.y;else bulletScreenOnScreen.y = nextBulletScreenOnScreen.y + nextBulletScreenOnScreen.height + _options.verticalInterval;
        } else {
          if (bulletScreenOnScreen.y > nextBulletScreenOnScreen.y + nextBulletScreenOnScreen.height) {
            return {
              add: {
                addToUp: true,
                element: setActualY(bulletScreenOnScreen)
              },
              stop: true
            };
          }

          if (nextBulletScreenOnScreen.endTime < nowTime) bulletScreenOnScreen.y = nextBulletScreenOnScreen.y;else bulletScreenOnScreen.y = nextBulletScreenOnScreen.y - bulletScreenOnScreen.height - _options.verticalInterval;
        }
      }, true);
    } else {
      var bulletScreenOnScreenWidthTime = bulletScreenOnScreen.width / (bulletScreen.style.speed * _options.playSpeed);

      _bulletScreensOnScreen.forEach(function (nextBulletScreenOnScreen) {
        if (nextBulletScreenOnScreen.bulletScreen.type === _bulletScreenType2.BulletScreenType.top || nextBulletScreenOnScreen.bulletScreen.type === _bulletScreenType2.BulletScreenType.bottom) return;
        if (bulletScreenOnScreen.y + bulletScreenOnScreen.height < nextBulletScreenOnScreen.y) return {
          add: {
            addToUp: true,
            element: setActualY(bulletScreenOnScreen)
          },
          stop: true
        };
        var nextBulletScreenOnScreenWidthTime = nextBulletScreenOnScreen.width / (nextBulletScreenOnScreen.bulletScreen.style.speed * _options.playSpeed);
        if (nextBulletScreenOnScreen.startTime + nextBulletScreenOnScreenWidthTime >= nowTime || nextBulletScreenOnScreen.endTime >= bulletScreenOnScreen.endTime - bulletScreenOnScreenWidthTime) bulletScreenOnScreen.y = nextBulletScreenOnScreen.y + nextBulletScreenOnScreen.height + _options.verticalInterval;else bulletScreenOnScreen.y = nextBulletScreenOnScreen.y;
      }, true);
    }

    if (_bulletScreensOnScreen.getLength() === oldLength) _bulletScreensOnScreen.push(setActualY(bulletScreenOnScreen), false);
  }
  /**
   * 设置真实的Y坐标
   * @private
   * @param {object} bulletScreenOnScreen - 屏幕弹幕事件
   * @returns {object} 屏幕弹幕事件
   */


  function setActualY(bulletScreenOnScreen) {
    var bulletScreen = bulletScreenOnScreen.bulletScreen;

    if (bulletScreen.type === _bulletScreenType2.BulletScreenType.leftToRight || bulletScreen.type === _bulletScreenType2.BulletScreenType.rightToLeft || bulletScreen.type === _bulletScreenType2.BulletScreenType.top) {
      bulletScreenOnScreen.actualY = bulletScreenOnScreen.y % (_elementSize.height - bulletScreenOnScreen.height);
    } else if (bulletScreen.type === _bulletScreenType2.BulletScreenType.bottom) {
      bulletScreenOnScreen.actualY = _elementSize.height + bulletScreenOnScreen.y % _elementSize.height;
    }

    return bulletScreenOnScreen;
  }
  /**
   * 设置尺寸
   * @private
   */


  function setSize() {
    var devicePixelRatio = _helper.Helper.getDevicePixelRatio();

    if (_oldDevicePixelRatio != devicePixelRatio || _oldClientWidth != element.clientWidth || _oldClientHeight != element.clientHeight || _oldScaling != _options.scaling) {
      _oldScaling = _options.scaling;
      _elementSize.width = element.clientWidth / _options.scaling;
      _elementSize.height = element.clientHeight / _options.scaling;
      _oldClientWidth = element.clientWidth;
      _oldClientHeight = element.clientHeight;
      _oldDevicePixelRatio = devicePixelRatio;

      _renderer.setSize();

      if (!_playing) _renderer.draw();
    }
  }

  if (!!window.ActiveXObject || "ActiveXObject" in window || navigator.userAgent.indexOf("Trident") > -1 || navigator.userAgent.indexOf("MSIE") > -1 || navigator.userAgent.indexOf("Edge") > -1) console.info(_resources.Resources.LOADED_INFO_IE.fillData(build));else console.info(_resources.Resources.LOADED_INFO.fillData(build), 'font-weight:bold; color:#0099FF;', '', 'font-style:italic;', '');
};

exports.BulletScreenEngine = BulletScreenEngine;


},{"./build.json":118,"./bulletScreenType":120,"./lib/event":122,"./lib/helper":123,"./lib/linkedList":124,"./lib/renderers/renderersFactory":129,"./lib/resources":133,"core-js/modules/es6.array.for-each":91,"core-js/modules/es6.array.index-of":92,"core-js/modules/es6.function.bind":96,"core-js/modules/es6.object.define-property":99,"core-js/modules/web.dom.iterable":113}],120:[function(require,module,exports){
"use strict";

require("core-js/modules/es6.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BulletScreenType = void 0;

/**
 * 弹幕类型枚举
 * @alias openBSE.BulletScreenType
 * @readonly
 * @enum {number}
 */
var BulletScreenType = {
  /** 
   * 从右到左弹幕
   * @readonly
   */
  rightToLeft: 1,

  /** 
   * 从左到右弹幕（逆向弹幕）
   * @readonly
   */
  leftToRight: 2,

  /** 
   * 顶部弹幕
   * @readonly
   */
  top: 4,

  /** 
   * 底部弹幕
   * @readonly
   */
  bottom: 8
};
exports.BulletScreenType = BulletScreenType;


},{"core-js/modules/es6.object.define-property":99}],121:[function(require,module,exports){
"use strict";

require("core-js/modules/es6.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Contextmenu = void 0;

require("core-js/modules/es7.symbol.async-iterator");

require("core-js/modules/es6.symbol");

require("core-js/modules/es6.function.bind");

var _resources = require("./lib/resources");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * 上下文菜单类
 * @alias openBSE.Contextmenu
 * @description 上下文菜单对象。用于实现一个弹幕上下文菜单。
 */
var Contextmenu =
/**
 * 创建弹幕引擎对象的上下文菜单。
 * @param {openBSE.BulletScreenEngine} bulletScreenEngine - 弹幕引擎对象：一个弹幕 {@link openBSE.BulletScreenEngine} 对象。要添加上下文菜单的
 * @param {Element} element - 上下文菜单元素：当显示上下文菜单时要显示的 div 。有关 Element 接口的信息请参阅MDN [Element]{@link https://developer.mozilla.org/zh-CN/docs/Web/API/Element} 。
 * @param {number} [layer=10] - 弹幕层级：当显示上下文菜单或鼠标指向弹幕时弹幕要移动到的层级。有关弹幕层级的详细说明请参阅 {@link openBSE~options} 结构。
 * @param {boolean} [pause=true] - 是否暂停：当鼠标指向弹幕或单开上下文菜单时弹幕是否暂停移动/播放。
 */
function Contextmenu(bulletScreenEngine, element) {
  var layer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
  var pause = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  _classCallCheck(this, Contextmenu);

  if (_typeof(bulletScreenEngine) != 'object' || _typeof(element) != 'object' || typeof pause != 'boolean' || typeof layer != 'number' && layer != null) throw new TypeError(_resources.Resources.PARAMETERS_TYPE_ERROR);
  element.bulletScreenEvent = null;

  var _getContextmenuState = function _getContextmenuState() {
    return contextmenu.style.display != 'none';
  };
  /**
   * 获取上下文菜单的状态
   * @function
   * @returns {boolean} 指示上下文菜单是否正处于激活/显示状态。
   */


  this.getContextmenuState = _getContextmenuState;
  /**
   * 获取激活上下文菜单的弹幕的弹幕事件结构
   * @returns {openBSE~BulletScreenEvent} 弹幕事件结构：一个 {@link openBSE~BulletScreenEvent} 结构。
   */

  this.getBulletScreenEvent = function () {
    return element.bulletScreenEvent;
  };
  /**
   * 关闭上下文菜单：如果当前上下文菜单正处于激活/显示状态则立即关闭。
   */


  this.closeContextmenu = function () {
    if (_getContextmenuState()) {
      element.style.display = 'none';
      if (pause) element.bulletScreenEvent.setPlayState(true);
      element.bulletScreenEvent.setBulletScreen({
        _contextmenu: false
      }, false);
      element.bulletScreenEvent = null;
    }
  };

  element.style.position = 'fixed';
  element.style.display = 'none';

  element.oncontextmenu = function () {
    return false;
  };

  var _closeContextmenu = function _closeContextmenu(e) {
    if (_getContextmenuState() && e.target != element) {
      element.style.display = 'none';
      if (pause) element.bulletScreenEvent.setPlayState(true);
      element.bulletScreenEvent.setBulletScreen({
        _contextmenu: false
      }, false);
      element.bulletScreenEvent = null;
      if (e.type === 'click') e.stopPropagation();
    }
  };

  window.addEventListener('click', _closeContextmenu, true);
  window.addEventListener('contextmenu', _closeContextmenu, true);
  window.addEventListener('scroll', _closeContextmenu, true);
  bulletScreenEngine.bind('contextmenu', function (e) {
    e.setBulletScreen({
      layer: layer,
      _contextmenu: true
    }, layer != null);
    if (pause) e.setPlayState(false);
    element.style.display = '';
    var top = e.clientY,
        left = e.clientX;
    if (top + element.clientHeight > document.documentElement.clientHeight) top -= element.clientHeight;
    if (left + element.clientWidth > document.documentElement.clientWidth) left -= element.clientWidth;
    element.style.top = "".concat(top, "px");
    element.style.left = "".concat(left, "px");
    element.bulletScreenEvent = e;
  });
  bulletScreenEngine.bind('mouseenter', function (e) {
    if (layer != null) e.setBulletScreen({
      layer: layer
    }, true);
    if (pause) e.setPlayState(false);
  });
  bulletScreenEngine.bind('mouseleave', function (e) {
    if (!e.getBulletScreen()._contextmenu && pause) e.setPlayState(true);
  });
};

exports.Contextmenu = Contextmenu;


},{"./lib/resources":133,"core-js/modules/es6.function.bind":96,"core-js/modules/es6.object.define-property":99,"core-js/modules/es6.symbol":110,"core-js/modules/es7.symbol.async-iterator":112}],122:[function(require,module,exports){
"use strict";

require("core-js/modules/es6.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Event = void 0;

require("core-js/modules/es7.symbol.async-iterator");

require("core-js/modules/es6.symbol");

require("core-js/modules/web.dom.iterable");

var _resources = require("./resources");

var _helper = require("./helper");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * 事件模型类
 */
var Event =
/**
 * 创建一个新的事件模型。
 */
function Event() {
  _classCallCheck(this, Event);

  /**
   * 事件列表
   * @private
   */
  var eventList = {};
  /**
   * 添加事件
   * @public
   * @param {string} name - 事件名称
   * @throws {TypeError} 传入的参数错误或事件已存在时引发错误。请参阅 MDN [TypeError]{@link https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError} 。
   */

  this.add = function (name) {
    if (typeof name != 'string') throw new TypeError(_resources.Resources.PARAMETERS_TYPE_ERROR);
    if (typeof eventList[name] != 'undefined') throw new TypeError(_resources.Resources.EVENT_ALREADY_EXISTS_ERROR);
    eventList[name] = [];
  };
  /**
   * 删除事件
   * @public
   * @param {string} name - 事件名称
   * @throws {TypeError} 传入的参数错误或事件不存在时引发错误。请参阅 MDN [TypeError]{@link https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError} 。
   */


  this.remove = function (name) {
    if (typeof name != 'string') throw new TypeError(_resources.Resources.PARAMETERS_TYPE_ERROR);
    if (typeof eventList[name] === 'undefined') throw new TypeError(_resources.Resources.EVENT_NAME_NOT_FOUND);
    delete eventList[name];
  };
  /**
   * 绑定事件处理程序
   * @public
   * @param {string} name - 事件名称
   * @param {function} fun - 事件处理程序
   * @returns {number} 添加后的事件数
   * @throws {TypeError} 传入的参数错误或事件不存在时引发错误。请参阅 MDN [TypeError]{@link https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError} 。
   */


  this.bind = function (name, fun) {
    if (typeof name != 'string' || typeof fun != 'function') throw new TypeError(_resources.Resources.PARAMETERS_TYPE_ERROR);
    var event = eventList[name];
    if (typeof event === 'undefined') throw new TypeError(_resources.Resources.EVENT_NAME_NOT_FOUND);

    for (var index in event) {
      if (event[index] === fun) return false;
    }

    return event.unshift(fun);
  };
  /**
   * 解绑事件处理程序（fun为空解绑所有事件处理程序）
   * @public
   * @param {string} name - 事件名称
   * @param {function} fun - 事件处理程序
   * @returns {number} 删除后的事件数
   * @throws {TypeError} 传入的参数错误或事件不存在时引发错误。请参阅 MDN [TypeError]{@link https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError} 。
   */


  this.unbind = function (name, fun) {
    if (typeof name != 'string') throw new TypeError(_resources.Resources.PARAMETERS_TYPE_ERROR);
    var event = eventList[name];
    if (typeof event === 'undefined') throw new TypeError(_resources.Resources.EVENT_NAME_NOT_FOUND);
    if (typeof fun == 'function') for (var index in event) {
      if (event[index] === fun) {
        event.splice(fun, 1);
        return event.length;
      }
    } else eventList[name] = [];
  };
  /**
   * 触发事件
   * @public
   * @param {string} name - 事件名称
   * @param {object} e - 事件数据
   * @throws {TypeError} 传入的参数错误或事件不存在时引发错误。请参阅 MDN [TypeError]{@link https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError} 。
   */


  this.trigger = function (name, e) {
    if (typeof name != 'string' || _helper.Helper._typeof(e) != 'object') throw new TypeError(_resources.Resources.PARAMETERS_TYPE_ERROR);
    var event = eventList[name];
    if (typeof event === 'undefined') throw new TypeError(_resources.Resources.EVENT_NAME_NOT_FOUND);
    e.type = name;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = event[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var fun = _step.value;
        if (!fun(e)) return;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return;
  };
};

exports.Event = Event;


},{"./helper":123,"./resources":133,"core-js/modules/es6.object.define-property":99,"core-js/modules/es6.symbol":110,"core-js/modules/es7.symbol.async-iterator":112,"core-js/modules/web.dom.iterable":113}],123:[function(require,module,exports){
"use strict";

require("core-js/modules/es6.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Helper = void 0;

require("core-js/modules/es6.regexp.to-string");

require("core-js/modules/es6.date.to-string");

require("core-js/modules/es7.symbol.async-iterator");

require("core-js/modules/es6.symbol");

require("core-js/modules/web.dom.iterable");

var _resources = require("./resources");

/**
 * 设置值
 * @alias Helper.setValue
 * @param {*} value - 值
 * @param {*} defaultValue - 默认值
 * @param {string} type - 类型
 * @returns {*} - 值
 */
function setValue(value, defaultValue, type) {
  var returnValue;
  if (isEmpty(value)) returnValue = clone(defaultValue);else returnValue = clone(value);
  if (!isEmpty(type)) checkType(returnValue, type);else if (!isEmpty(defaultValue)) checkType(returnValue, _typeof(defaultValue));
  return returnValue;
}
/**
 * 设置多个值
 * @alias Helper.setValues
 * @param {object} values - 值
 * @param {object} defaultValues - 默认值
 * @param {object} types - 类型
 * @returns {object} - 值
 */


function setValues(values, defaultValues, types) {
  var clone = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var returnValues = clone ? setValue(values, {}) : defaultValues;

  var _values = clone ? returnValues : setValue(values, {});

  for (var key in defaultValues) {
    if (_typeof(defaultValues[key]) === 'object') returnValues[key] = setValues(_values[key], defaultValues[key], types[key]);else returnValues[key] = setValue(_values[key], defaultValues[key], types[key]);
  }

  return returnValues;
}
/**
 * 检查类型
 * @alias Helper.checkType
 * @param {string} value - 值
 * @param {string} type - 类型
 * @param {boolean} canBeNull - 可以为空
 */


function checkType(value, type) {
  var canBeNull = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  if (typeof type != 'string' && _typeof(type) != 'array') throw new TypeError(_resources.Resources.PARAMETERS_TYPE_ERROR);
  if (canBeNull && isEmpty(value)) return;

  if (_typeof(type) === 'array') {
    var flat = false;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = type[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var item = _step.value;
        if (typeof item != 'string') throw new TypeError(_resources.Resources.PARAMETERS_TYPE_ERROR);

        if (_typeof(value) === item) {
          flat = true;
          break;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (!flat) throw new TypeError(_resources.Resources.PARAMETERS_TYPE_ERROR);
  } else if (_typeof(value) != type) throw new TypeError(_resources.Resources.PARAMETERS_TYPE_ERROR);
}
/**
 * 检查多个值
 * @alias Helper.checkTypes
 * @param {object} values - 值
 * @param {object} types - 类型
 * @returns {object} - 值
 */


function checkTypes(values, types) {
  var canBeNull = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  if (canBeNull && isEmpty(values)) return;

  for (var key in types) {
    if (_typeof(types[key]) === 'object') checkTypes(values[key], types[key]);else checkType(values[key], types[key], canBeNull);
  }
}
/**
 * 检查是否为空
 * @alias Helper.isEmpty
 * @param {*} value - 值
 */


function isEmpty(value) {
  return typeof value === 'undefined' || typeof value === 'number' && isNaN(value) || value === null;
}
/**
 * 获取对象的类型（可区分数组等）
 * @alias Helper._typeof
 * @param {*} object - 对象
 */


function _typeof(object) {
  return Object.prototype.toString.call(object).slice(8, -1).toLowerCase();
}
/**
 * 克隆对象
 * @param {*} object 
 */


function clone(object) {
  var result,
      type = _typeof(object);

  if (type === 'object') result = {};else if (type === 'array') result = [];else return object;

  for (var key in object) {
    result[key] = clone(object[key]);
  }

  return result;
}
/**
 * 清空元素
 * @param {Element} element 
 */


function cleanElement(element) {
  var lastChild;

  while ((lastChild = element.lastChild) != null) {
    element.removeChild(lastChild);
  }
}
/**
 * 获取屏幕的设备像素比
 * @param {boolean} showWarn - 显示警告
 */


function getDevicePixelRatio() {
  var showWarn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  if (typeof window.devicePixelRatio === 'number') return window.devicePixelRatio;
  if (typeof window.screen.deviceXDPI === 'number' && typeof window.screen.logicalXDPI === 'number') return screen.deviceXDPI / screen.logicalXDPI;
  if (showWarn) console.warn(_resources.Resources.DEVICEPIXELRATIO_NOT_SUPPORT_WARN);
  return 1;
}
/**
 * 帮助对象
 * @namespace
 */


var Helper = {
  setValue: setValue,
  setValues: setValues,
  checkType: checkType,
  checkTypes: checkTypes,
  isEmpty: isEmpty,
  _typeof: _typeof,
  clone: clone,
  cleanElement: cleanElement,
  getDevicePixelRatio: getDevicePixelRatio
};
exports.Helper = Helper;


},{"./resources":133,"core-js/modules/es6.date.to-string":95,"core-js/modules/es6.object.define-property":99,"core-js/modules/es6.regexp.to-string":108,"core-js/modules/es6.symbol":110,"core-js/modules/es7.symbol.async-iterator":112,"core-js/modules/web.dom.iterable":113}],124:[function(require,module,exports){
"use strict";

require("core-js/modules/es6.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LinkedList = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * 双向链表类
 */
var LinkedList =
/**
 * 创建一个双向链表。
 */
function LinkedList() {
  _classCallCheck(this, LinkedList);

  /**
   * 双向链表节点
   * @private
  */
  var node = function node(element) {
    _classCallCheck(this, node);

    this.element = element;
    this.next = null;
    this.previous = null;
  };

  var topNode = new node(null);
  var bottomNode = new node(null);
  var length = 0;
  topNode.next = bottomNode;
  bottomNode.previous = topNode;
  /**
   * 获取元素个数
   * @returns {number} 元素个数
   */

  this.getLength = function (l) {
    return length;
  };
  /**
   * 插入元素
   * @param {*} element - 元素
   * @param {boolean} top - true: 插入到顶部 false: 插入到底部
   */


  this.push = function (element, top) {
    var thisNode = new node(element);

    if (top) {
      thisNode.next = topNode.next;
      thisNode.previous = topNode;
      topNode.next = topNode.next.previous = thisNode;
    } else {
      thisNode.previous = bottomNode.previous;
      thisNode.next = bottomNode;
      bottomNode.previous = bottomNode.previous.next = thisNode;
    }

    length++;
  };
  /**
   * 读取元素
   * @param {boolean} remove - 读取后是否删除
   * @param {boolean} top - true: 读取顶部 false: 读取底部
   * @returns {*} 元素
   */


  this.pop = function (remove, top) {
    var thisNode;

    if (top) {
      thisNode = topNode.next;

      if (topNode.next != bottomNode && remove) {
        thisNode.next.previous = topNode;
        topNode.next = thisNode.next;
      }
    } else {
      thisNode = bottomNode.previous;

      if (bottomNode.previous != topNode && remove) {
        thisNode.previous.next = bottomNode;
        bottomNode.previous = thisNode.previous;
      }
    }

    if (remove) length--;
    return thisNode.element;
  };
  /**
   * 清空链表
   */


  this.clean = function () {
    topNode = new node(null);
    bottomNode = new node(null);
    topNode.next = bottomNode;
    bottomNode.previous = topNode;
    length = 0;
  };
  /**
   * 遍历链表
   * @param {function} fun - 遍历回调函数
   * 回调函数（参数：元素，返回：{remove：删除此元素，add:插入元素(add.addToUp:插入到上方, add.element:元素), stop：停止遍历}）
   * @param {boolean} topToBottom - true: 从顶到底 false: 从底到顶
   */


  this.forEach = function (fun, topToBottom) {
    var thisNode = topToBottom ? topNode : bottomNode;

    while (topToBottom ? (thisNode = thisNode.next) != bottomNode : (thisNode = thisNode.previous) != topNode) {
      var _return = fun(thisNode.element);

      if (_return) {
        if (_return.add) {
          var newNode = new node(_return.add.element);

          if (_return.add.addToUp) {
            newNode.previous = thisNode.previous;
            newNode.next = thisNode;
            thisNode.previous.next = newNode;
            thisNode.previous = newNode;
          } else {
            newNode.previous = thisNode;
            newNode.next = thisNode.next;
            thisNode.next.previous = newNode;
            thisNode.next = newNode;
          }

          length++;
        }

        if (_return.remove) {
          thisNode.previous.next = thisNode.next;
          thisNode.next.previous = thisNode.previous;
          length--;
        }

        if (_return.stop) {
          return;
        }
      }
    }
  };
};

exports.LinkedList = LinkedList;


},{"core-js/modules/es6.object.define-property":99}],125:[function(require,module,exports){
"use strict";

require("core-js/modules/es6.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseRenderer = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * 渲染器抽象类
 */
var BaseRenderer =
/**
 * 实例化一个渲染器抽象类
 * @param {object} element - Element 元素
 * @param {openBSE~Options} options - 全局选项
 * @param {object} elementSize - 元素大小
 */
function BaseRenderer(element, options, elementSize) {
  _classCallCheck(this, BaseRenderer);

  if ((this instanceof BaseRenderer ? this.constructor : void 0) === BaseRenderer) {
    throw new SyntaxError();
  }

  init();
  /**
   * 隐藏弹幕
   * @private @type {boolean}
   */

  var _hide = false;
  /**
   * 透明度
   * @private @type {number}
   */

  var _opacity = 0.0;
  /**
   * 清除屏幕内容
   * @abstract
   */

  this.cleanScreen = function () {
    throw new SyntaxError();
  };
  /**
   * 隐藏弹幕。
   */


  this.hide = function () {
    _hide = true;
    element.style.visibility = 'hidden';
  };
  /**
   * 显示弹幕。
   */


  this.show = function () {
    _hide = false;
    element.style.visibility = '';
  };
  /**
   * 设置弹幕不透明度。
   */


  this.setOpacity = _setOpacity;
  /**
   * 设置弹幕不透明度。
   */

  function _setOpacity() {
    if (options.opacity === 1) element.style.opacity = '';else element.style.opacity = options.opacity;
  }
  /**
   * 获取弹幕不透明度。
   * @returns {number} 弹幕不透明度：取值范围 0.0 到 1.0，0.0 全透明；1.0 不透明。
   */


  this.getOpacity = function () {
    return _opacity;
  };
  /**
   * 获取弹幕可见性。
   * @returns {boolean} 指示弹幕是否可见。
   * @description 获取弹幕可见性。
   */


  this.getVisibility = function () {
    return !_hide;
  };
  /**
   * 绘制函数
   * @abstract
   */


  this.draw = function () {
    throw new SyntaxError();
  };
  /**
   * 创建弹幕元素
   * @abstract
   * @param {object} bulletScreenOnScreen - 屏幕弹幕对象
   */


  this.creatAndgetWidth = function (bulletScreenOnScreen) {
    throw new SyntaxError();
  };
  /**
   * 删除弹幕元素
   * @abstract
   * @param {object} bulletScreenOnScreen - 屏幕弹幕对象
   */


  this.delete = function (bulletScreenOnScreen) {
    throw new SyntaxError();
  };
  /**
   * 重新添加弹幕
   * @abstract
   * @param {object} bulletScreenOnScreen - 屏幕弹幕对象
   */


  this.reCreatAndgetWidth = function (bulletScreenOnScreen) {
    throw new SyntaxError();
  };
  /**
   * 检查弹幕是否被隐藏
   * @param {object} bulletScreenOnScreen - 屏幕弹幕对象
   */


  this.checkWhetherHide = function (bulletScreenOnScreen) {
    return (bulletScreenOnScreen.bulletScreen.type & options.hiddenTypes) === bulletScreenOnScreen.bulletScreen.type;
  };
  /**
  * 设置尺寸
  * @function
  */


  this.setSize = setSize;
  /**
   * 设置尺寸
   * @private
   */

  function setSize() {
    element.style.width = "".concat(elementSize.width, "px");
    element.style.height = "".concat(elementSize.height, "px");

    if (options.scaling != 1) {
      element.style.transform = element.style.webkitTransform = element.style.msTransform = "scale(".concat(options.scaling, ",").concat(options.scaling, ")");
      element.style.transformOrigin = element.style.webkitTransformOrigin = element.style.msTransformOrigin = "left top";
    } else {
      element.style.transform = element.style.webkitTransform = element.style.msTransform = element.style.transformOrigin = element.style.webkitTransformOrigin = element.style.msTransformOrigin = '';
    }
  }
  /**
   * 初始化
   * @private
   */


  function init() {
    setSize();

    _setOpacity();

    element.style.position = 'relative';
  }
};

exports.BaseRenderer = BaseRenderer;


},{"core-js/modules/es6.object.define-property":99}],126:[function(require,module,exports){
"use strict";

require("core-js/modules/es6.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CanvasBaseRenderer = void 0;

require("core-js/modules/es7.symbol.async-iterator");

require("core-js/modules/es6.symbol");

require("core-js/modules/es6.object.create");

require("core-js/modules/es6.object.set-prototype-of");

require("core-js/modules/web.dom.iterable");

require("core-js/modules/es6.array.for-each");

var _baseRenderer = require("./baseRenderer");

var _linkedList = require("../linkedList");

var _helper = require("../helper");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * Canvas 渲染器抽象类
 */
var CanvasBaseRenderer = function (_BaseRenderer) {
  _inherits(CanvasBaseRenderer, _BaseRenderer);

  /**
   * 实例化一个 Canvas 渲染器抽象类
   * @param {object} element - Element 元素
   * @param {openBSE~Options} options - 全局选项
   * @param {object} elementSize - 元素大小
   * @param {function} eventTrigger - 事件引发方法
   */
  function CanvasBaseRenderer(element, options, elementSize, eventTrigger) {
    var _this;

    _classCallCheck(this, CanvasBaseRenderer);

    if ((this instanceof CanvasBaseRenderer ? this.constructor : void 0) === CanvasBaseRenderer) {
      throw new SyntaxError();
    }
    /**
     * 屏幕上的弹幕
     * @private @type {LinkedList}
     */


    var _bulletScreensOnScreen = new _linkedList.LinkedList();
    /**
     * DPI 缩放比例（倍数）
     * @private @type {number}
     */


    var _devicePixelRatio = _helper.Helper.getDevicePixelRatio(true);

    _devicePixelRatio *= options.scaling;
    /**
     * 画布元素
     * @private @type {Element}
     */

    var _canvas = init();

    _this = _possibleConstructorReturn(this, _getPrototypeOf(CanvasBaseRenderer).call(this, _canvas, options, elementSize));
    /**
     * 清除屏幕内容
     * @function
     * @override
     */

    _this.cleanScreen = _bulletScreensOnScreen.clean;
    /**
     * 创建弹幕元素
     * @override
     * @param {object} bulletScreenOnScreen - 屏幕弹幕对象
     */

    _this.creatAndgetWidth = function (bulletScreenOnScreen) {
      var bulletScreen = bulletScreenOnScreen.bulletScreen;
      var hideCanvas = document.createElement('canvas');
      var hideCanvasContext = hideCanvas.getContext('2d');
      hideCanvasContext.font = "".concat(bulletScreen.style.fontWeight, " ").concat(bulletScreenOnScreen.size, "px ").concat(bulletScreen.style.fontFamily);
      bulletScreenOnScreen.width = hideCanvasContext.measureText(bulletScreen.text).width;
      hideCanvas.width = (bulletScreenOnScreen.width + 8) * _devicePixelRatio;
      hideCanvas.height = (bulletScreenOnScreen.height + 8) * _devicePixelRatio;
      hideCanvasContext.shadowColor = 'black';
      hideCanvasContext.font = "".concat(bulletScreen.style.fontWeight, " ").concat(bulletScreenOnScreen.size * _devicePixelRatio, "px ").concat(bulletScreen.style.fontFamily);
      var textX = 4 * _devicePixelRatio;
      var textY = (4 + bulletScreenOnScreen.size * 0.8) * _devicePixelRatio;

      if (bulletScreen.style.color != null) {
        hideCanvasContext.shadowBlur = (bulletScreen.style.shadowBlur + 0.5) * _devicePixelRatio;
        hideCanvasContext.fillStyle = bulletScreen.style.color;
        hideCanvasContext.fillText(bulletScreen.text, textX, textY);
      }

      if (bulletScreen.style.borderColor != null) {
        hideCanvasContext.shadowBlur = 0;
        hideCanvasContext.lineWidth = 0.5 * _devicePixelRatio;
        hideCanvasContext.strokeStyle = bulletScreen.style.borderColor;
        hideCanvasContext.strokeText(bulletScreen.text, textX, textY);
      }

      if (bulletScreen.style.boxColor != null) {
        hideCanvasContext.shadowBlur = 0;
        hideCanvasContext.lineWidth = _devicePixelRatio;
        hideCanvasContext.strokeStyle = bulletScreen.style.boxColor;
        hideCanvasContext.strokeRect(_devicePixelRatio, _devicePixelRatio, hideCanvas.width - _devicePixelRatio, hideCanvas.height - _devicePixelRatio);
      }

      bulletScreenOnScreen.hideCanvas = hideCanvas;
      if (_bulletScreensOnScreen.getLength() === 0) _bulletScreensOnScreen.push(bulletScreenOnScreen, true);
      var flag = false;

      _bulletScreensOnScreen.forEach(function (_bulletScreenOnScreen) {
        if (_bulletScreenOnScreen.bulletScreen.layer <= bulletScreen.layer) {
          flag = true;
          return {
            add: {
              element: bulletScreenOnScreen,
              addToUp: false
            },
            stop: true
          };
        }
      }, false);

      if (!flag) _bulletScreensOnScreen.push(bulletScreenOnScreen, false);
    };
    /**
     * 删除弹幕元素
     * @override
     * @param {object} bulletScreenOnScreen - 屏幕弹幕对象
     */


    _this.delete = function (bulletScreenOnScreen) {
      return _bulletScreensOnScreen.forEach(function (_bulletScreenOnScreen) {
        return _bulletScreenOnScreen === bulletScreenOnScreen ? {
          remove: true,
          stop: true
        } : null;
      }, true);
    };
    /**
     * 重新添加弹幕
     * @override
     * @param {object} bulletScreenOnScreen - 屏幕弹幕对象
     */


    _this.reCreatAndgetWidth = function (bulletScreenOnScreen) {
      this.delete(bulletScreenOnScreen);
      this.creatAndgetWidth(bulletScreenOnScreen);
    };

    var _setSize = _this.setSize;
    /**
     * 设置尺寸
     * @override
     */

    _this.setSize = function () {
      _setSize();

      _devicePixelRatio = _helper.Helper.getDevicePixelRatio();
      _devicePixelRatio *= options.scaling;
      _canvas.width = elementSize.width * _devicePixelRatio;
      _canvas.height = elementSize.height * _devicePixelRatio;
    };
    /**
     * 获取缩放比例
     * @returns {number} 缩放比例
     */


    _this.getDevicePixelRatio = function () {
      return _devicePixelRatio;
    };
    /**
     * 获取画布对象
     * @returns {Element} 画布对象
     */


    _this.getCanvas = function () {
      return _canvas;
    };
    /**
     * 获取屏幕弹幕对象
     * @returns {LinkedList} 画布对象
     */


    _this.getBulletScreensOnScreen = function () {
      return _bulletScreensOnScreen;
    };
    /**
     * 添加Canvas
     * @private
     * @returns {Element} 画布对象
     */


    function init() {
      var canvas = document.createElement('canvas');

      _helper.Helper.cleanElement(element);

      element.appendChild(canvas);
      canvas.width = elementSize.width * _devicePixelRatio;
      canvas.height = elementSize.height * _devicePixelRatio;
      registerEvent(canvas);
      return canvas;
    }

    var _checkWhetherHide = _this.checkWhetherHide;
    /**
     * 注册事件响应程序
     * @private
     * @param {Element} element - 元素
     */

    function registerEvent(element) {
      function getBulletScreenOnScreenByLocation(location) {
        var _bulletScreenOnScreen = null;

        _bulletScreensOnScreen.forEach(function (bulletScreenOnScreen) {
          if (_checkWhetherHide(bulletScreenOnScreen)) return;
          var x1 = bulletScreenOnScreen.x - 4;
          var x2 = x1 + bulletScreenOnScreen.width + 8;
          var y1 = bulletScreenOnScreen.actualY - 4;
          var y2 = y1 + bulletScreenOnScreen.height + 8;

          if (location.x >= x1 && location.x <= x2 && location.y >= y1 && location.y <= y2) {
            _bulletScreenOnScreen = bulletScreenOnScreen;
            return {
              stop: true
            };
          }
        }, false);

        return _bulletScreenOnScreen;
      }

      function getLocation(e) {
        function getOffsetTop(element) {
          var offsetTop = 0;

          do {
            offsetTop += element.offsetTop;
          } while ((element = element.offsetParent) != null);

          return offsetTop;
        }

        function getOffsetLeft(element) {
          var offsetLeft = 0;

          do {
            offsetLeft += element.offsetLeft;
          } while ((element = element.offsetParent) != null);

          return offsetLeft;
        }

        if (typeof e.offsetX === 'undefined' || e.offsetX === null) {
          if (typeof e.layerX === 'undefined' || e.layerX === null) {
            if (typeof e.pageX === 'undefined' || e.pageX === null) {
              var doc = document.documentElement,
                  body = document.body;
              e.pageX = e.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
              e.pageY = e.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
            }

            e.layerX = e.pageX - getOffsetLeft(e.target);
            e.layerY = e.pageY - getOffsetTop(e.target);
          }

          e.offsetX = e.layerX - e.target.clientLeft;
          e.offsetY = e.layerY - e.target.clientTop;
        }

        return {
          x: e.offsetX,
          y: e.offsetY
        };
      }

      element.oncontextmenu = function (e) {
        var bulletScreenOnScreen = getBulletScreenOnScreenByLocation(getLocation(e));
        if (bulletScreenOnScreen) eventTrigger('contextmenu', bulletScreenOnScreen, e);
        return false;
      };

      element.onclick = function (e) {
        var bulletScreenOnScreen = getBulletScreenOnScreenByLocation(getLocation(e));
        if (bulletScreenOnScreen) eventTrigger('click', bulletScreenOnScreen, e);
        return false;
      };

      element.onmousemove = function (e) {
        var bulletScreenOnScreen = getBulletScreenOnScreenByLocation(getLocation(e));

        _bulletScreensOnScreen.forEach(function (_bulletScreenOnScreen) {
          if (bulletScreenOnScreen != _bulletScreenOnScreen && _bulletScreenOnScreen.mousein) {
            _bulletScreenOnScreen.mousein = false;
            element.style.cursor = '';
            eventTrigger('mouseleave', _bulletScreenOnScreen, e);
          }
        }, true);

        if (bulletScreenOnScreen === null || bulletScreenOnScreen.mousein) return false;
        bulletScreenOnScreen.mousein = true;
        element.style.cursor = options.cursorOnMouseOver;
        eventTrigger('mouseenter', bulletScreenOnScreen, e);
        return false;
      };

      element.onmouseout = function (e) {
        _bulletScreensOnScreen.forEach(function (_bulletScreenOnScreen) {
          if (_bulletScreenOnScreen.mousein) {
            _bulletScreenOnScreen.mousein = false;
            element.style.cursor = '';
            eventTrigger('mouseleave', _bulletScreenOnScreen, e);
          }
        }, true);
      };
    }

    return _this;
  }

  return CanvasBaseRenderer;
}(_baseRenderer.BaseRenderer);

exports.CanvasBaseRenderer = CanvasBaseRenderer;


},{"../helper":123,"../linkedList":124,"./baseRenderer":125,"core-js/modules/es6.array.for-each":91,"core-js/modules/es6.object.create":98,"core-js/modules/es6.object.define-property":99,"core-js/modules/es6.object.set-prototype-of":100,"core-js/modules/es6.symbol":110,"core-js/modules/es7.symbol.async-iterator":112,"core-js/modules/web.dom.iterable":113}],127:[function(require,module,exports){
"use strict";

require("core-js/modules/es6.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CanvasRenderer = void 0;

require("core-js/modules/es7.symbol.async-iterator");

require("core-js/modules/es6.symbol");

require("core-js/modules/es6.object.create");

require("core-js/modules/es6.object.set-prototype-of");

require("core-js/modules/web.dom.iterable");

require("core-js/modules/es6.array.for-each");

var _canvasBaseRenderer = require("./canvasBaseRenderer");

var _browserNotSupportError = require("../../browserNotSupportError");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * Canvas 渲染器类
 */
var CanvasRenderer = function (_CanvasBaseRenderer) {
  _inherits(CanvasRenderer, _CanvasBaseRenderer);

  /**
   * 实例化一个 Canvas 渲染器类
   * @param {object} element - Element 元素
   * @param {openBSE~Options} options - 全局选项
   * @param {object} elementSize - 元素大小
   * @param {Event} eventTrigger - 事件引发方法
   * @throws {openBSE.BrowserNotSupportError} 浏览器不支持特定渲染模式时引发错误
   */
  function CanvasRenderer(element, options, elementSize, eventTrigger) {
    var _this;

    _classCallCheck(this, CanvasRenderer);

    supportCheck();
    _this = _possibleConstructorReturn(this, _getPrototypeOf(CanvasRenderer).call(this, element, options, elementSize, eventTrigger));
    /**
     * 屏幕上的弹幕
     * @private @type {LinkedList}
     */

    var _bulletScreensOnScreen = _this.getBulletScreensOnScreen();

    var _cleanScreen = _this.cleanScreen;
    /**
     * 清除屏幕内容
     * @override
     */

    _this.cleanScreen = function () {
      _cleanScreen();

      var canvas = this.getCanvas();
      canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
    };
    /**
     * 绘制函数
     * @override
     */


    _this.draw = function () {
      var _this2 = this;

      var canvas = this.getCanvas();
      var devicePixelRatio = this.getDevicePixelRatio();
      var canvasContext = canvas.getContext('2d');
      canvasContext.clearRect(0, 0, canvas.width, canvas.height);

      _bulletScreensOnScreen.forEach(function (bulletScreenOnScreen) {
        if (_this2.checkWhetherHide(bulletScreenOnScreen)) return;
        canvasContext.drawImage(bulletScreenOnScreen.hideCanvas, Math.round((bulletScreenOnScreen.x - 4) * devicePixelRatio), Math.round((bulletScreenOnScreen.actualY - 4) * devicePixelRatio), Math.round((bulletScreenOnScreen.width + 8) * devicePixelRatio), Math.round((bulletScreenOnScreen.height + 8) * devicePixelRatio));
      }, true);
    };
    /**
     * 浏览器支持检测
     * @private
     * @throws {openBSE.BrowserNotSupportError} 浏览器不支持特定渲染模式时引发错误
     */


    function supportCheck() {
      var canvas = document.createElement('canvas');
      if (typeof canvas.getContext != 'function') throw new _browserNotSupportError.BrowserNotSupportError('Canvas');
      var context = canvas.getContext('2d');
      if (context === null) throw new _browserNotSupportError.BrowserNotSupportError('Canvas 2D');
      if (typeof context.fillText != 'function') throw new _browserNotSupportError.BrowserNotSupportError('Canvas 2D fillText Function');
    }

    return _this;
  }

  return CanvasRenderer;
}(_canvasBaseRenderer.CanvasBaseRenderer);

exports.CanvasRenderer = CanvasRenderer;


},{"../../browserNotSupportError":117,"./canvasBaseRenderer":126,"core-js/modules/es6.array.for-each":91,"core-js/modules/es6.object.create":98,"core-js/modules/es6.object.define-property":99,"core-js/modules/es6.object.set-prototype-of":100,"core-js/modules/es6.symbol":110,"core-js/modules/es7.symbol.async-iterator":112,"core-js/modules/web.dom.iterable":113}],128:[function(require,module,exports){
"use strict";

require("core-js/modules/es6.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CSS3Renderer = void 0;

require("core-js/modules/es6.object.create");

require("core-js/modules/es6.object.set-prototype-of");

require("core-js/modules/es7.symbol.async-iterator");

require("core-js/modules/es6.symbol");

require("core-js/modules/web.dom.iterable");

var _baseRenderer = require("./baseRenderer");

var _browserNotSupportError = require("../../browserNotSupportError");

var _helper = require("../helper");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * CSS3 渲染器类
 */
var CSS3Renderer = function (_BaseRenderer) {
  _inherits(CSS3Renderer, _BaseRenderer);

  /**
   * 实例化一个 CSS3 渲染器类
   * @param {object} element - Element 元素
   * @param {openBSE~Options} options - 全局选项
   * @param {object} elementSize - 元素大小
   * @param {Event} eventTrigger - 事件引发方法
   * @throws {openBSE.BrowserNotSupportError} 浏览器不支持特定渲染模式时引发错误
   */
  function CSS3Renderer(element, options, elementSize, eventTrigger) {
    var _this;

    _classCallCheck(this, CSS3Renderer);

    supportCheck();

    var _div = init();

    _this = _possibleConstructorReturn(this, _getPrototypeOf(CSS3Renderer).call(this, _div, options, elementSize));
    /**
     * 清除屏幕内容
     * @override
     */

    _this.cleanScreen = function () {
      _helper.Helper.cleanElement(_div);
    };
    /**
     * 绘制函数
     * @override
     */


    _this.draw = function () {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _div.getElementsByTagName('div')[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var bulletScreenDiv = _step.value;
          if (_typeof(bulletScreenDiv.bulletScreenOnScreen) != 'object') continue;

          if (this.checkWhetherHide(bulletScreenDiv.bulletScreenOnScreen)) {
            bulletScreenDiv.style.visibility = 'hidden';
            continue;
          }

          bulletScreenDiv.style.visibility = 'visible';
          bulletScreenDiv.style.transform = bulletScreenDiv.style.webkitTransform = bulletScreenDiv.style.msTransform = "translate(".concat(Math.round(bulletScreenDiv.bulletScreenOnScreen.x - 4), "px,").concat(Math.round(bulletScreenDiv.bulletScreenOnScreen.actualY - 4), "px)");
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    };
    /**
     * 创建弹幕元素
     * @override
     * @param {object} bulletScreenOnScreen - 屏幕弹幕对象
     */


    _this.creatAndgetWidth = function (bulletScreenOnScreen) {
      var bulletScreen = bulletScreenOnScreen.bulletScreen;
      var bulletScreenDiv = bulletScreenOnScreen.div ? bulletScreenOnScreen.div : document.createElement('div');
      bulletScreenDiv.style.position = 'absolute';
      bulletScreenDiv.style.whiteSpace = 'nowrap';
      bulletScreenDiv.style.fontWeight = bulletScreen.style.fontWeight;
      bulletScreenDiv.style.fontSize = "".concat(bulletScreenOnScreen.size, "px");
      bulletScreenDiv.style.fontFamily = bulletScreen.style.fontFamily;
      bulletScreenDiv.style.lineHeight = "".concat(bulletScreenOnScreen.size, "px");
      bulletScreenDiv.style.color = bulletScreen.style.color;
      if (bulletScreen.style.shadowBlur != null) bulletScreenDiv.style.textShadow = "0 0 ".concat(bulletScreen.style.shadowBlur, "px black");

      if (bulletScreen.style.borderColor != null) {
        bulletScreenDiv.style.textStroke = bulletScreenDiv.style.webkitTextStroke = "0.5px";
        bulletScreenDiv.style.textStrokeColor = bulletScreenDiv.style.webkitTextStrokeColor = bulletScreen.style.borderColor;
      }

      if (bulletScreen.style.boxColor != null) {
        bulletScreenDiv.style.padding = '3px';
        bulletScreenDiv.style.border = '1px solid';
        bulletScreenDiv.style.borderColor = bulletScreen.style.boxColor;
      } else {
        bulletScreenDiv.style.padding = '4px';
      }

      _helper.Helper.cleanElement(bulletScreenDiv);

      bulletScreenDiv.appendChild(document.createTextNode(bulletScreen.text));
      bulletScreenDiv.bulletScreenOnScreen = bulletScreenOnScreen;
      insertElement(bulletScreenDiv);
      bulletScreenOnScreen.width = bulletScreenDiv.clientWidth - 8;
      bulletScreenOnScreen.div = bulletScreenDiv;
    };
    /**
    * 删除弹幕元素
    * @override
    * @param {object} bulletScreenOnScreen - 屏幕弹幕对象
    */


    _this.delete = function (bulletScreenOnScreen) {
      _div.removeChild(bulletScreenOnScreen.div);
    };
    /**
     * 重新添加弹幕
     * @override
     * @param {object} bulletScreenOnScreen - 屏幕弹幕对象
     */


    _this.reCreatAndgetWidth = function (bulletScreenOnScreen) {
      this.delete(bulletScreenOnScreen);
      this.creatAndgetWidth(bulletScreenOnScreen);
    };
    /**
     * 添加Div
     * @private
     * @returns {Element} Div
     */


    function init() {
      var div = document.createElement('div');

      _helper.Helper.cleanElement(element);

      element.appendChild(div);
      div.style.overflow = 'hidden';
      div.style.padding = '0';
      div.style.margin = '0';
      div.style.userSelect = div.style.webkitUserSelect = div.style.msUserSelect = 'none';
      div.style.cursor = 'default';
      registerEvent(div);
      return div;
    }
    /**
     * 浏览器支持检测
     * @private
     * @throws {openBSE.BrowserNotSupportError} 浏览器不支持特定渲染模式时引发错误
     */


    function supportCheck() {
      var style = document.createElement('div').style;
      if (typeof style.transform === 'undefined' && typeof style.msTransform === 'undefined' && typeof style.webkitTransform === 'undefined') throw new _browserNotSupportError.BrowserNotSupportError('CSS3 transform');
    }
    /**
     * 注册事件响应程序
     * @private
     * @param {Element} element - 元素
     */


    function registerEvent(element) {
      element.oncontextmenu = function (e) {
        if (e.target != this) eventTrigger('contextmenu', e.target.bulletScreenOnScreen, e);
        return false;
      };

      element.onclick = function (e) {
        if (e.target != this) eventTrigger('click', e.target.bulletScreenOnScreen, e);
        return false;
      };

      element.onmousemove = function (e) {
        var bulletScreenOnScreen = e.target.bulletScreenOnScreen;
        if (e.target === this || bulletScreenOnScreen.mousein) return;
        bulletScreenOnScreen.mousein = true;
        e.target.style.cursor = options.cursorOnMouseOver;
        eventTrigger('mouseenter', bulletScreenOnScreen, e);
      };

      element.onmouseout = function (e) {
        var bulletScreenOnScreen = e.target.bulletScreenOnScreen;
        if (e.target === this || !bulletScreenOnScreen.mousein) return;
        bulletScreenOnScreen.mousein = false;
        e.target.style.cursor = '';
        eventTrigger('mouseleave', bulletScreenOnScreen, e);
      };
    }
    /**
     * 按 layer 插入元素
     * @param {Element} element - 元素
     */


    function insertElement(element) {
      var elements = _div.getElementsByTagName(element.tagName);

      if (elements.length === 0) _div.appendChild(element);
      var index;

      for (index = elements.length - 1; index > 0; index--) {
        var _layer = elements[index].bulletScreenOnScreen.bulletScreen.layer;
        if (_layer <= element.bulletScreenOnScreen.bulletScreen.layer) break;
      }

      if (++index === elements.length) _div.appendChild(element);else _div.insertBefore(element, elements[index]);
    }

    return _this;
  }

  return CSS3Renderer;
}(_baseRenderer.BaseRenderer);

exports.CSS3Renderer = CSS3Renderer;


},{"../../browserNotSupportError":117,"../helper":123,"./baseRenderer":125,"core-js/modules/es6.object.create":98,"core-js/modules/es6.object.define-property":99,"core-js/modules/es6.object.set-prototype-of":100,"core-js/modules/es6.symbol":110,"core-js/modules/es7.symbol.async-iterator":112,"core-js/modules/web.dom.iterable":113}],129:[function(require,module,exports){
"use strict";

require("core-js/modules/es6.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RenderersFactory = void 0;

var _resources = require("../resources");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * 渲染器
 * @private @constant
 */
var RENDERERS = {
  /**
   * CSS3 渲染模式
   * @private @readonly
   */
  css3: require('./css3Renderer').CSS3Renderer,

  /**
   * SVG 渲染模式
   * @private @readonly
   */
  svg: require('./svgRenderer').SVGRenderer,

  /**
   * WebGL 渲染模式
   * @private @readonly
   */
  webgl: require('./webglRenderer').WebGLRenderer,

  /**
   * Canvas 2D 渲染模式
   * @private @readonly
   */
  canvas: require('./canvasRenderer').CanvasRenderer
  /**
   * 渲染器工厂
   */

};

var RenderersFactory =
/**
 * 实例化一个渲染器工厂
 * @param {object} element - Element 元素
 * @param {openBSE~Options} options - 全局选项
 * @param {object} elementSize - 元素大小
 * @param {Event} eventTrigger - 事件引发方法
 */
function RenderersFactory(element, options, elementSize, eventTrigger) {
  _classCallCheck(this, RenderersFactory);

  /**
   * 获取渲染器
   * @param {string} renderMode - 渲染模式
   * @returns {BaseRenderer} 渲染器的实例
   * @throws {openBSE.BrowserNotSupportError} 浏览器不支持特定渲染模式时引发错误
   * @throws {TypeError} 传入的参数错误时引发错误。请参阅 MDN [TypeError]{@link https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError} 。
   */
  this.getRenderer = function (renderMode) {
    var renderer = RENDERERS[renderMode];
    if (typeof renderer === 'undefined') throw new TypeError(_resources.Resources.RENDER_MODE_ERROR.fillData({
      renderMode: renderMode
    }));
    return new renderer(element, options, elementSize, eventTrigger);
  };
};

exports.RenderersFactory = RenderersFactory;


},{"../resources":133,"./canvasRenderer":127,"./css3Renderer":128,"./svgRenderer":130,"./webglRenderer":131,"core-js/modules/es6.object.define-property":99}],130:[function(require,module,exports){
"use strict";

require("core-js/modules/es6.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SVGRenderer = void 0;

require("core-js/modules/es6.object.create");

require("core-js/modules/es6.object.set-prototype-of");

require("core-js/modules/es7.symbol.async-iterator");

require("core-js/modules/es6.symbol");

require("core-js/modules/web.dom.iterable");

var _baseRenderer = require("./baseRenderer");

var _browserNotSupportError = require("../../browserNotSupportError");

var _helper = require("../helper");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * SVG 渲染器类
 */
var SVGRenderer = function (_BaseRenderer) {
  _inherits(SVGRenderer, _BaseRenderer);

  /**
   * 实例化一个 SVG 渲染器类
   * @param {object} element - Element 元素
   * @param {openBSE~Options} options - 全局选项
   * @param {object} elementSize - 元素大小
   * @param {Event} eventTrigger - 事件引发方法
   * @throws {openBSE.BrowserNotSupportError} 浏览器不支持特定渲染模式时引发错误
   */
  function SVGRenderer(element, options, elementSize, eventTrigger) {
    var _this;

    _classCallCheck(this, SVGRenderer);

    supportCheck();

    var _svg;

    var _defsSvg;

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SVGRenderer).call(this, init(), options, elementSize));
    /**
     * 清除屏幕内容
     * @override
     */

    _this.cleanScreen = function () {
      _helper.Helper.cleanElement(_svg);

      _defsSvg = createElementSVG('defs');

      _svg.appendChild(_defsSvg);
    };
    /**
     * 绘制函数
     * @override
     */


    _this.draw = function () {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _svg.getElementsByTagName('text')[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var textSvg = _step.value;
          var bulletScreenOnScreen = textSvg.bulletScreenOnScreen;

          for (var key in bulletScreenOnScreen.svg) {
            var item = bulletScreenOnScreen.svg[key];
            if (this.checkWhetherHide(bulletScreenOnScreen)) item.setAttribute('opacity', '0');else item.setAttribute('opacity', '1');
            item.setAttribute('transform', "translate(".concat(Math.round(bulletScreenOnScreen.x - 4), ",").concat(Math.round(bulletScreenOnScreen.actualY - 4), ")"));
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    };
    /**
     * 创建弹幕元素
     * @override
     * @param {object} bulletScreenOnScreen - 屏幕弹幕对象
     */


    _this.creatAndgetWidth = function (bulletScreenOnScreen) {
      var bulletScreen = bulletScreenOnScreen.bulletScreen;
      bulletScreenOnScreen.svg = _typeof(bulletScreenOnScreen.svg) === 'object' ? bulletScreenOnScreen.svg : {};
      var textSvg = _typeof(bulletScreenOnScreen.svg.text) === 'object' ? bulletScreenOnScreen.svg.text : createElementSVG('text');
      textSvg.setAttribute('x', 0);
      textSvg.setAttribute('y', bulletScreenOnScreen.size * 0.8);
      textSvg.setAttribute('font-family', bulletScreen.style.fontFamily);
      textSvg.setAttribute('font-size', bulletScreenOnScreen.size);
      textSvg.setAttribute('font-weight', bulletScreen.style.fontWeight);
      textSvg.setAttribute('fill', bulletScreen.style.color);

      _helper.Helper.cleanElement(textSvg);

      textSvg.appendChild(document.createTextNode(bulletScreen.text));

      if (bulletScreen.style.borderColor != null) {
        textSvg.setAttribute('stroke', bulletScreen.borderColor);
        textSvg.setAttribute('stroke-width', 0.5);
      }

      if (bulletScreen.style.shadowBlur != null) {
        var filterId = "bulletScreenEngine_svgFilter_shadow_".concat(bulletScreen.style.shadowBlur);
        var filterSvg = document.getElementById(filterId);

        if (filterSvg === null) {
          filterSvg = createElementSVG('filter');
          filterSvg.id = filterId;
          filterSvg.setAttribute('x', '-100%');
          filterSvg.setAttribute('y', '-100%');
          filterSvg.setAttribute('width', '300%');
          filterSvg.setAttribute('height', '300%');
          var feOffsetSvg = createElementSVG('feOffset');
          feOffsetSvg.setAttribute('result', 'offOut');
          feOffsetSvg.setAttribute('in', 'SourceAlpha');
          filterSvg.appendChild(feOffsetSvg);
          var feGaussianBlurSvg = createElementSVG('feGaussianBlur');
          feGaussianBlurSvg.setAttribute('result', 'blurOut');
          feGaussianBlurSvg.setAttribute('in', 'offOut');
          feGaussianBlurSvg.setAttribute('stdDeviation', bulletScreen.style.shadowBlur);
          filterSvg.appendChild(feGaussianBlurSvg);
          var feBlendSvg = createElementSVG('feBlend');
          feBlendSvg.setAttribute('in', 'SourceGraphic');
          feBlendSvg.setAttribute('in2', 'blurOut');
          feBlendSvg.setAttribute('mode', 'normal');
          filterSvg.appendChild(feBlendSvg);
          filterSvg.bulletScreenCount = 0;

          _defsSvg.appendChild(filterSvg);
        }

        filterSvg.bulletScreenCount++;
        textSvg.setAttribute('filter', "url(#".concat(filterId, ")"));
        bulletScreenOnScreen.filterId = filterId;
      }

      bulletScreenOnScreen.svg.text = textSvg;
      textSvg.bulletScreenOnScreen = bulletScreenOnScreen;
      insertElement(textSvg);
      bulletScreenOnScreen.width = textSvg.getComputedTextLength();

      if (bulletScreen.style.boxColor != null) {
        var rectSvg = _typeof(bulletScreenOnScreen.svg.rect) === 'object' ? bulletScreenOnScreen.svg.rect : createElementSVG('rect');
        rectSvg.setAttribute('x', -3);
        rectSvg.setAttribute('y', -3);
        rectSvg.setAttribute('fill', 'none');
        rectSvg.setAttribute('height', bulletScreenOnScreen.height + 7);
        rectSvg.setAttribute('width', bulletScreenOnScreen.width + 7);
        rectSvg.setAttribute('stroke', bulletScreen.style.boxColor);
        rectSvg.setAttribute('stroke-width', 1);
        bulletScreenOnScreen.svg.rect = rectSvg;
        rectSvg.bulletScreenOnScreen = bulletScreenOnScreen;

        _svg.insertBefore(rectSvg, textSvg);
      }
    };
    /**
    * 删除弹幕元素
    * @override
    * @param {object} bulletScreenOnScreen - 屏幕弹幕对象
    */


    _this.delete = function (bulletScreenOnScreen) {
      if (typeof bulletScreenOnScreen.filterId != 'undefined') {
        var filterSvg = document.getElementById(bulletScreenOnScreen.filterId);
        if (filterSvg != null && --filterSvg.bulletScreenCount === 0) _defsSvg.removeChild(filterSvg);
      }

      for (var index in bulletScreenOnScreen.svg) {
        _svg.removeChild(bulletScreenOnScreen.svg[index]);
      }
    };
    /**
     * 重新添加弹幕
     * @override
     * @param {object} bulletScreenOnScreen - 屏幕弹幕对象
     */


    _this.reCreatAndgetWidth = function (bulletScreenOnScreen) {
      this.delete(bulletScreenOnScreen);
      this.creatAndgetWidth(bulletScreenOnScreen);
    };

    var _setSize = _this.setSize;
    /**
     * 设置尺寸
     * @override
     */

    _this.setSize = function () {
      _setSize();

      _svg.setAttribute('height', elementSize.height);

      _svg.setAttribute('width', elementSize.width);
    };
    /**
     * 添加Div
     * @private
     * @returns {Element} Div
     */


    function init() {
      var div = document.createElement('div');

      _helper.Helper.cleanElement(element);

      element.appendChild(div);
      div.style.padding = '0';
      div.style.margin = '0';
      _svg = createElementSVG('svg');
      _defsSvg = createElementSVG('defs');

      _svg.appendChild(_defsSvg);

      _svg.setAttribute('height', elementSize.height);

      _svg.setAttribute('width', elementSize.width);

      div.appendChild(_svg);
      var eventDiv = document.createElement('div');
      eventDiv.style.position = 'absolute';
      eventDiv.style.top = eventDiv.style.right = eventDiv.style.bottom = eventDiv.style.left = '0';
      div.appendChild(eventDiv);
      registerEvent(eventDiv);
      return div;
    }
    /**
     * 浏览器支持检测
     * @private
     * @throws {openBSE.BrowserNotSupportError} 浏览器不支持特定渲染模式时引发错误
     */


    function supportCheck() {
      if (typeof document.createElementNS != 'function') throw new _browserNotSupportError.BrowserNotSupportError('createElementNS Function');
      if (typeof createElementSVG('svg').createSVGRect != 'function') throw new _browserNotSupportError.BrowserNotSupportError('SVG');
    }

    var _checkWhetherHide = _this.checkWhetherHide;
    /**
     * 注册事件响应程序
     * @private
     * @param {Element} element - 元素
     */

    function registerEvent(element) {
      function getBulletScreenOnScreenByLocation(location) {
        var textSvgs = _svg.getElementsByTagName('text');

        for (var index = textSvgs.length - 1; index > 0; index--) {
          var bulletScreenOnScreen = textSvgs[index].bulletScreenOnScreen;
          if (_checkWhetherHide(bulletScreenOnScreen)) return;
          var x1 = bulletScreenOnScreen.x - 4;
          var x2 = x1 + bulletScreenOnScreen.width + 8;
          var y1 = bulletScreenOnScreen.actualY - 4;
          var y2 = y1 + bulletScreenOnScreen.height + 8;
          if (location.x >= x1 && location.x <= x2 && location.y >= y1 && location.y <= y2) return bulletScreenOnScreen;
        }

        return null;
      }

      function getLocation(e) {
        function getOffsetTop(element) {
          var offsetTop = 0;

          do {
            offsetTop += element.offsetTop;
          } while ((element = element.offsetParent) != null);

          return offsetTop;
        }

        function getOffsetLeft(element) {
          var offsetLeft = 0;

          do {
            offsetLeft += element.offsetLeft;
          } while ((element = element.offsetParent) != null);

          return offsetLeft;
        }

        if (typeof e.offsetX === 'undefined' || e.offsetX === null) {
          if (typeof e.layerX === 'undefined' || e.layerX === null) {
            if (typeof e.pageX === 'undefined' || e.pageX === null) {
              var doc = document.documentElement,
                  body = document.body;
              e.pageX = e.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
              e.pageY = e.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
            }

            e.layerX = e.pageX - getOffsetLeft(e.target);
            e.layerY = e.pageY - getOffsetTop(e.target);
          }

          e.offsetX = e.layerX - e.target.clientLeft;
          e.offsetY = e.layerY - e.target.clientTop;
        }

        return {
          x: e.offsetX,
          y: e.offsetY
        };
      }

      element.oncontextmenu = function (e) {
        var bulletScreenOnScreen = getBulletScreenOnScreenByLocation(getLocation(e));
        if (bulletScreenOnScreen) eventTrigger('contextmenu', bulletScreenOnScreen, e);
        return false;
      };

      element.onclick = function (e) {
        var bulletScreenOnScreen = getBulletScreenOnScreenByLocation(getLocation(e));
        if (bulletScreenOnScreen) eventTrigger('click', bulletScreenOnScreen, e);
        return false;
      };

      element.onmousemove = function (e) {
        var bulletScreenOnScreen = getBulletScreenOnScreenByLocation(getLocation(e));
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = _svg.getElementsByTagName('text')[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var textSvg = _step2.value;
            var _bulletScreenOnScreen = textSvg.bulletScreenOnScreen;

            if (_bulletScreenOnScreen != bulletScreenOnScreen && _bulletScreenOnScreen.mousein) {
              _bulletScreenOnScreen.mousein = false;
              element.style.cursor = '';
              eventTrigger('mouseleave', _bulletScreenOnScreen, e);
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        if (bulletScreenOnScreen === null || bulletScreenOnScreen.mousein) return false;
        bulletScreenOnScreen.mousein = true;
        element.style.cursor = options.cursorOnMouseOver;
        eventTrigger('mouseenter', bulletScreenOnScreen, e);
        return false;
      };

      element.onmouseout = function (e) {
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = _svg.getElementsByTagName('text')[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var textSvg = _step3.value;
            var _bulletScreenOnScreen = textSvg.bulletScreenOnScreen;

            if (_bulletScreenOnScreen.mousein) {
              _bulletScreenOnScreen.mousein = false;
              element.style.cursor = '';
              eventTrigger('mouseleave', _bulletScreenOnScreen, e);
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      };
    }
    /**
     * 创建 SVG 元素
     * @private
     * @param {string} qualifiedName - Element 名称
     * @param {object} options - 选项
     */


    function createElementSVG(qualifiedName, options) {
      return document.createElementNS('http://www.w3.org/2000/svg', qualifiedName, options);
    }
    /**
     * 按 layer 插入元素
     * @param {Element} element - 元素
     */


    function insertElement(element) {
      var elements = _svg.getElementsByTagName(element.tagName);

      if (elements.length === 0) _svg.appendChild(element);
      var index;

      for (index = elements.length - 1; index > 0; index--) {
        var _layer = elements[index].bulletScreenOnScreen.bulletScreen.layer;
        if (_layer <= element.bulletScreenOnScreen.bulletScreen.layer) break;
      }

      if (++index === elements.length) _svg.appendChild(element);else _svg.insertBefore(element, elements[index]);
    }

    return _this;
  }

  return SVGRenderer;
}(_baseRenderer.BaseRenderer);

exports.SVGRenderer = SVGRenderer;


},{"../../browserNotSupportError":117,"../helper":123,"./baseRenderer":125,"core-js/modules/es6.object.create":98,"core-js/modules/es6.object.define-property":99,"core-js/modules/es6.object.set-prototype-of":100,"core-js/modules/es6.symbol":110,"core-js/modules/es7.symbol.async-iterator":112,"core-js/modules/web.dom.iterable":113}],131:[function(require,module,exports){
"use strict";

require("core-js/modules/es6.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebGLRenderer = void 0;

require("core-js/modules/es7.symbol.async-iterator");

require("core-js/modules/es6.symbol");

require("core-js/modules/es6.object.create");

require("core-js/modules/es6.object.set-prototype-of");

require("core-js/modules/es6.typed.float32-array");

require("core-js/modules/web.dom.iterable");

require("core-js/modules/es6.array.for-each");

var _canvasBaseRenderer = require("./canvasBaseRenderer");

var _browserNotSupportError = require("../../browserNotSupportError");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * WebGL 渲染器类
 */
var WebGLRenderer = function (_CanvasBaseRenderer) {
  _inherits(WebGLRenderer, _CanvasBaseRenderer);

  /**
   * 实例化一个 WebGL 渲染器类
   * @param {object} element - Element 元素
   * @param {openBSE~Options} options - 全局选项
   * @param {object} elementSize - 元素大小
   * @param {Event} eventTrigger - 事件引发方法
   * @throws {openBSE.BrowserNotSupportError} 浏览器不支持特定渲染模式时引发错误
   */
  function WebGLRenderer(element, options, elementSize, eventTrigger) {
    var _this;

    _classCallCheck(this, WebGLRenderer);

    supportCheck();
    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLRenderer).call(this, element, options, elementSize, eventTrigger));
    /**
     * 屏幕上的弹幕
     * @private @type {LinkedList}
     */

    var _bulletScreensOnScreen = _this.getBulletScreensOnScreen();
    /**
     * WebGL 上下文对象
     * @private @type {object}
     */


    var _webglContext;

    var _positionAttributeLocation;

    var _resolutionUniformLocation;
    /**
     * Canvas 元素
     * @private @type {object}
     */


    var _canvas = _this.getCanvas();

    init();
    var _cleanScreen = _this.cleanScreen;
    /**
     * 清除屏幕内容
     * @override
     */

    _this.cleanScreen = function () {
      _cleanScreen();

      _webglContext.clear(_webglContext.COLOR_BUFFER_BIT);
    };
    /**
     * 绘制函数
     * @override
     */


    _this.draw = function () {
      var _this2 = this;

      var devicePixelRatio = this.getDevicePixelRatio();

      _webglContext.clear(_webglContext.COLOR_BUFFER_BIT);

      _bulletScreensOnScreen.forEach(function (bulletScreenOnScreen) {
        if (_this2.checkWhetherHide(bulletScreenOnScreen)) return;
        var x1 = (bulletScreenOnScreen.x - 4) * devicePixelRatio;
        var x2 = x1 + (bulletScreenOnScreen.width + 8) * devicePixelRatio;
        var y1 = (bulletScreenOnScreen.actualY - 4) * devicePixelRatio;
        var y2 = y1 + (bulletScreenOnScreen.height + 8) * devicePixelRatio;

        _webglContext.bindTexture(_webglContext.TEXTURE_2D, bulletScreenOnScreen.texture2D);

        var positionBuffer = _webglContext.createBuffer();

        _webglContext.bindBuffer(_webglContext.ARRAY_BUFFER, positionBuffer);

        _webglContext.enableVertexAttribArray(_positionAttributeLocation);

        _webglContext.vertexAttribPointer(_positionAttributeLocation, 2, _webglContext.FLOAT, false, 0, 0);

        _webglContext.bufferData(_webglContext.ARRAY_BUFFER, new Float32Array([x1, y1, x2, y1, x1, y2, x1, y2, x2, y1, x2, y2]), _webglContext.STATIC_DRAW);

        _webglContext.drawArrays(_webglContext.TRIANGLES, 0, 6);
      }, true);
    };

    var _creatAndgetWidth = _this.creatAndgetWidth;
    /**
     * 创建弹幕元素
     * @override
     * @param {object} bulletScreenOnScreen - 屏幕弹幕对象
     */

    _this.creatAndgetWidth = function (bulletScreenOnScreen) {
      _creatAndgetWidth(bulletScreenOnScreen);

      var texture = _webglContext.createTexture();

      _webglContext.bindTexture(_webglContext.TEXTURE_2D, texture);

      _webglContext.texParameteri(_webglContext.TEXTURE_2D, _webglContext.TEXTURE_MIN_FILTER, _webglContext.NEAREST);

      _webglContext.texParameteri(_webglContext.TEXTURE_2D, _webglContext.TEXTURE_MAG_FILTER, _webglContext.NEAREST);

      _webglContext.texParameteri(_webglContext.TEXTURE_2D, _webglContext.TEXTURE_WRAP_S, _webglContext.CLAMP_TO_EDGE);

      _webglContext.texParameteri(_webglContext.TEXTURE_2D, _webglContext.TEXTURE_WRAP_T, _webglContext.CLAMP_TO_EDGE);

      _webglContext.texImage2D(_webglContext.TEXTURE_2D, 0, _webglContext.RGBA, _webglContext.RGBA, _webglContext.UNSIGNED_BYTE, bulletScreenOnScreen.hideCanvas);

      bulletScreenOnScreen.texture2D = texture;
    };

    var _setSize = _this.setSize;
    /**
     * 设置尺寸
     * @override
     */

    _this.setSize = function () {
      _setSize();

      _webglContext.viewport(0, 0, _canvas.width, _canvas.height);

      _webglContext.uniform2f(_resolutionUniformLocation, _canvas.width, _canvas.height);
    };
    /**
     * 初始化
     */


    function init() {
      var createShader = function createShader(gl, type, source) {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

        if (success) {
          return shader;
        }

        gl.deleteShader(shader);
      };

      var createProgram = function createProgram(gl, vertexShader, fragmentShader) {
        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        var success = gl.getProgramParameter(program, gl.LINK_STATUS);

        if (success) {
          return program;
        }

        gl.deleteProgram(program);
      };

      var vertexShaderSource = 'attribute vec2 a_position;';
      vertexShaderSource += 'attribute vec2 a_texcoord;';
      vertexShaderSource += 'uniform vec2 u_resolution;';
      vertexShaderSource += 'varying vec2 v_texcoord;';
      vertexShaderSource += 'void main() {';
      vertexShaderSource += 'vec2 zeroToOne = a_position / u_resolution;';
      vertexShaderSource += 'vec2 zeroToTwo = zeroToOne * 2.0;';
      vertexShaderSource += 'vec2 clipSpace = zeroToTwo - 1.0;';
      vertexShaderSource += 'gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);';
      vertexShaderSource += 'v_texcoord = a_texcoord;';
      vertexShaderSource += '}';
      var fragmentShaderSource = 'precision mediump float;';
      fragmentShaderSource += 'varying vec2 v_texcoord;';
      fragmentShaderSource += 'uniform sampler2D u_texture;';
      fragmentShaderSource += 'void main() {';
      fragmentShaderSource += 'gl_FragColor = texture2D(u_texture, v_texcoord);';
      fragmentShaderSource += '}';
      _webglContext = _canvas.getContext('webgl');

      _webglContext.enable(_webglContext.BLEND);

      _webglContext.clearColor(0, 0, 0, 0);

      _webglContext.blendFunc(_webglContext.SRC_ALPHA, _webglContext.ONE_MINUS_SRC_ALPHA);

      var vertexShader = createShader(_webglContext, _webglContext.VERTEX_SHADER, vertexShaderSource);
      var fragmentShader = createShader(_webglContext, _webglContext.FRAGMENT_SHADER, fragmentShaderSource);
      var program = createProgram(_webglContext, vertexShader, fragmentShader);

      _webglContext.useProgram(program);

      _positionAttributeLocation = _webglContext.getAttribLocation(program, 'a_position');

      var texcoordAttributeLocation = _webglContext.getAttribLocation(program, 'a_texcoord');

      _resolutionUniformLocation = _webglContext.getUniformLocation(program, 'u_resolution');

      _webglContext.viewport(0, 0, _canvas.width, _canvas.height);

      _webglContext.uniform2f(_resolutionUniformLocation, _canvas.width, _canvas.height);

      var texcoordBuffer = _webglContext.createBuffer();

      _webglContext.bindBuffer(_webglContext.ARRAY_BUFFER, texcoordBuffer);

      _webglContext.enableVertexAttribArray(texcoordAttributeLocation);

      _webglContext.vertexAttribPointer(texcoordAttributeLocation, 2, _webglContext.FLOAT, false, 0, 0);

      _webglContext.bufferData(_webglContext.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), _webglContext.STATIC_DRAW);
    }
    /**
     * 浏览器支持检测
     * @throws {openBSE.BrowserNotSupportError} 浏览器不支持特定渲染模式时引发错误
     */


    function supportCheck() {
      var canvas = document.createElement('canvas');
      if (typeof canvas.getContext != 'function') throw new _browserNotSupportError.BrowserNotSupportError('Canvas');
      var context = canvas.getContext('2d');
      if (context === null) throw new _browserNotSupportError.BrowserNotSupportError('Canvas 2D');
      if (typeof context.fillText != 'function') throw new _browserNotSupportError.BrowserNotSupportError('Canvas 2D fillText Function');
      canvas = document.createElement('canvas');
      context = canvas.getContext('webgl');
      if (context === null) throw new _browserNotSupportError.BrowserNotSupportError('WebGL');
    }

    return _this;
  }

  return WebGLRenderer;
}(_canvasBaseRenderer.CanvasBaseRenderer);

exports.WebGLRenderer = WebGLRenderer;


},{"../../browserNotSupportError":117,"./canvasBaseRenderer":126,"core-js/modules/es6.array.for-each":91,"core-js/modules/es6.object.create":98,"core-js/modules/es6.object.define-property":99,"core-js/modules/es6.object.set-prototype-of":100,"core-js/modules/es6.symbol":110,"core-js/modules/es6.typed.float32-array":111,"core-js/modules/es7.symbol.async-iterator":112,"core-js/modules/web.dom.iterable":113}],132:[function(require,module,exports){
module.exports={
    "EVENT_NAME_NOT_FOUND_ERROR": "Event name not found.",
    "EVENT_ALREADY_EXISTS_ERROR": "Event already exists.",
    "PARAMETERS_TYPE_ERROR": "Parameters type error.",
    "RENDER_MODE_ERROR": "The render mode \"{renderMode}\" is undefined.",
    "BROWSER_NOT_SUPPORT_ERROR": "This browser does not support \"{message}\".",
    "REQUESTANIMATIONFRAME_NOT_SUPPORT_WARN": "Your browser does not support method \"requestAnimationFrame\" and will switch to method \"setTimeout\", which may affect performance.",
    "DEVICEPIXELRATIO_NOT_SUPPORT_WARN": "Your browser does not support variable \"devicePixelRatio\", which may cause canvas unable to display properly in high DPI mode. It is recommended to use CSS3 render mode.",
    "LOADED_INFO": "%c{name}%c now loaded.\n\n%cVersion: {version}\nBuild Date: {buildDate}\n\n%c{description}\nHome: {home}",
    "LOADED_INFO_IE": "{name} now loaded.\n\nVersion: {version}\nBuild Date: {buildDate}\n\n{description}\nHome: {home}"
}
},{}],133:[function(require,module,exports){
"use strict";

require("core-js/modules/es6.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Resources = void 0;

require("core-js/modules/es7.symbol.async-iterator");

require("core-js/modules/es6.symbol");

require("core-js/modules/es6.regexp.constructor");

require("core-js/modules/es6.regexp.replace");

var Resources = _interopRequireWildcard(require("./resources.json"));

exports.Resources = Resources;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * 数据填充（占位符拼接）
 * @param {object|...string} sign - 一组字符串或一个对象
 */
function fillData() {
  if (arguments.length === 0) return this;
  var param = arguments[0],
      str = this;

  if (_typeof(param) === 'object') {
    for (var key in param) {
      str = str.replace(new RegExp("\\{" + key + "\\}", "g"), param[key]);
    }

    return str;
  } else {
    for (var i = 0; i < arguments.length; i++) {
      str = str.replace(new RegExp("\\{" + i + "\\}", "g"), arguments[i]);
    }

    return str;
  }
}

for (var key in Resources) {
  if (typeof Resources[key] === 'string') {
    Resources[key] = new String(Resources[key]);
    Resources[key].fillData = fillData;
  }
}


},{"./resources.json":132,"core-js/modules/es6.object.define-property":99,"core-js/modules/es6.regexp.constructor":102,"core-js/modules/es6.regexp.replace":106,"core-js/modules/es6.symbol":110,"core-js/modules/es7.symbol.async-iterator":112}],134:[function(require,module,exports){
"use strict";

require("core-js/modules/es6.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getVersion = getVersion;
Object.defineProperty(exports, "BulletScreenEngine", {
  enumerable: true,
  get: function get() {
    return _bulletScreenEngine.BulletScreenEngine;
  }
});
Object.defineProperty(exports, "BrowserNotSupportError", {
  enumerable: true,
  get: function get() {
    return _browserNotSupportError.BrowserNotSupportError;
  }
});
Object.defineProperty(exports, "BulletScreenType", {
  enumerable: true,
  get: function get() {
    return _bulletScreenType.BulletScreenType;
  }
});
Object.defineProperty(exports, "Contextmenu", {
  enumerable: true,
  get: function get() {
    return _contextmenu.Contextmenu;
  }
});

var _helper = require("./lib/helper");

var _bulletScreenEngine = require("./bulletScreenEngine");

var _browserNotSupportError = require("./browserNotSupportError");

var _bulletScreenType = require("./bulletScreenType");

var _contextmenu = require("./contextmenu");

var build = _interopRequireWildcard(require("./build.json"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * 获取版本信息。
 * @alias openBSE.getVersion
 * @returns {openBSE~VersionInfo} 版本信息：一个 {@link openBSE~VersionInfo} 结构。
 */
function getVersion() {
  return _helper.Helper.clone(build);
}
/**
 * 全局选项
 * @typedef {object} openBSE~Options
 * @description Option 结构用于存放全局选项。
 * @property {number} [verticalInterval=8] - 弹幕垂直行间距
 * @property {number} [verticalInterval=1] - 弹幕播放速度（倍数）
 * @property {openBSE~clockCallback} [clock=time => new Date().getTime() - startTime] - 时间基准：此时间基准可指向一个方法用于获取播放器当前进度，这个方法返回值即为播放进度（单位：毫秒）。
 * @property {number} [scaling=1] 弹幕缩放比例（倍数）
 * @property {openBSE~BulletScreenStyle} [defaultStyle] 默认弹幕样式：一个 {@link openBSE~BulletScreenStyle} 结构。
 * @property {openBSE.BulletScreenType} [hiddenTypes=0] 隐藏的弹幕类型：一个 {@link openBSE.BulletScreenType} 枚举。将要隐藏的弹幕类型相加，0为不隐藏任何类型的弹幕。
 * @property {number} [opacity=1.0] 弹幕不透明度：取值范围 0.0 到 1.0，0.0 全透明；1.0 不透明。
 * @property {string} [cursorOnMouseOver='pointer'] 鼠标经过样式：当鼠标经过弹幕时的样式，可设置的值可参考 MDN [cursor] {@link https://developer.mozilla.org/zh-CN/docs/Web/CSS/cursor} 。
 */

/**
 * 时间基准回调方法
 * @callback openBSE~clockCallback
 * @description ClockCallback 回调方法用于播放器当前进度。
 * @returns {number} 播放进度：单位：毫秒。
 */

/**
 * 单条弹幕数据
 * @typedef {object} openBSE~BulletScreen
 * @description BulletScreen 结构用于存放单条弹幕数据。
 * @property {string} text 弹幕文本
 * @property {boolean} [canDiscard=true] 是否允许丢弃：（此参数在事件中修改无效）在弹幕过多时，程序将自动丢弃一些延迟过高的弹幕。此选项为 false 时本条弹幕无论如何都不会被丢弃，使用本选项的场景如本用户发送的弹幕。（注意：不要将太多的弹幕的 canDiscard 设为 false， 否则会因超时的弹幕不会被丢弃而造成意外的问题。）
 * @property {number} [startTime=options.clock()] 弹幕进入时间：（此参数在事件中修改无效）单位：毫秒，默认为[时间基准（options.clock）]{@link openBSE~Options}当前时间。
 * @property {openBSE.BulletScreenType} [type=openBSE.BulletScreenType.rightToLeft] 弹幕类型：（此参数在事件中修改无效）一个类型为 {@link openBSE.BulletScreenType} 的枚举。
 * @property {openBSE~BulletScreenStyle} style 弹幕样式：一个 {@link openBSE~BulletScreenStyle} 结构。设置此选项中的任何一个值，将覆盖对应的全局设置。
 * @property {number} [layer=0] 弹幕层级：此参数越大，弹幕越靠前。一条弹幕在比它层级小的弹幕前面，在比它层级大的弹幕后面。如果层级相同按照进入时间确定层级顺序。
 * @property {any} more... 其他自定义字段：（在事件中修改修改此参数无需将 e.redraw 设置为 true）例如 uuid 、 id 等。（注意：因为在事件响应方法中返回的弹幕对象是原对象克隆的，所以无法直接比较，必须使用自定义字段唯一标识一条弹幕。）
 */

/**
 * 弹幕样式
 * @typedef {object} openBSE~BulletScreenStyle
 * @description BulletScreenStyle 结构用于存放弹幕样式信息。
 * @property {number} [shadowBlur=2] 弹幕阴影的模糊级别：0为不显示阴影。
 * @property {string} [fontWeight="600"] 字体粗细：可选值：lighter：更细；normal：标准；bold：粗体；bolder: 更粗；100、200、300、400、500、600、700、800、900：定义由粗到细的字符（400 等同于 normal；700 等同于 bold）。
 * @property {string} [fontFamily="sans-serif"] 字体系列：弹幕的字体族名称或/及类族名称的一个优先表。（注意：如果使用了用“@font-face”定义的字体，请确保在使用前完全加载完成，否则弹幕可能无法显示。如果要预加载这些字体，建议使用 [Web Font Loader]{@link https://github.com/typekit/webfontloader} 。）
 * @property {number} [size=19] 字体大小：单位：像素。
 * @property {string} [boxColor] 外框颜色：参照CSS颜色设置方法，为 null 不显示外框。
 * @property {string} [color="white"] 弹幕颜色：参照CSS颜色设置方法，为 null 不显示此弹幕。
 * @property {string} [borderColor] 描边颜色：参照CSS颜色设置方法，为 null 没有描边。
 * @property {number} [speed=0.15] 弹幕速度：（在事件中修改修改此参数无需将 e.redraw 设置为 true）单位：像素/毫秒，仅弹幕类型为0、1时有效。
 * @property {number} [residenceTime=5000] 弹幕停留时间：（此参数在事件中修改无效）单位：毫秒，仅弹幕类型2、3时有效。
 */

/**
 * 弹幕事件
 * @typedef {object} openBSE~BulletScreenEvent
 * @property {function} getBulletScreen() - 获取引发事件的弹幕弹幕的数据：retun: {@link openBSE~BulletScreen} 引发事件的弹幕的数据：一个 {@link openBSE~BulletScreen} 结构。（注意：不要试图与[添加弹幕]{@link openBSE.BulletScreenEngine#addBulletScreen}时创建的对象进行比较，这个对象是克隆得到的，并不相等。正确的方法是在添加弹幕时一并插入 id 等自定义字段来唯一标识一条弹幕。）
 * @property {function} setBulletScreen(bulletScreen,redraw) - 设置引发事件的弹幕弹幕的数据：params: {@link openBSE~BulletScreen} bulletScreen - 引发事件的弹幕的数据：一个 {@link openBSE~BulletScreen} 结构。设置此参数以便动态调整弹幕样式，但是一些参数在事件中修改无效，查看此结构的说明以了解详情。 boolean [redraw=false] - 是否重绘弹幕：此参数在每次引发事件时的初始值为 false ，如果修改了 bulletScreen 中的值，此参数必须设为 true 。
 * @property {function} getPlayState() - 获取引发事件的弹幕的播放状态：retun: boolean 取引发事件的弹幕是否在播放/移动：如果设置为 true 则该弹幕暂停，直到将此参数设为 false 或调用 {@link openBSE.BulletScreenEngine#playAllBulletScreens} 方法。
 * @property {function} setPlayState(play) - 设置引发事件的弹幕的播放状态：params: boolean paly - 是否继续播放/移动引发事件的弹幕：读取此参数可判断这条弹幕是否处于暂停状态。
 * @property {string} type - 事件类型（事件名称）
 * @property {number} screenX - 当事件发生时，鼠标相对于显示器屏的 X 坐标。
 * @property {number} screenY - 当事件发生时，鼠标相对于显示器屏的 Y 坐标。
 * @property {number} clientX - 当事件发生时，鼠标相对于浏览器有效区域的 X 坐标。
 * @property {number} pageX - 当事件发生时，鼠标相对于页面的 X 坐标。
 * @property {number} pageY - 当事件发生时，鼠标相对于页面的 Y 坐标。
 * @property {number} pageY - 当事件发生时，鼠标相对于页面的 Y 坐标。
 */

/**
 * 调试信息
 * @typedef {object} openBSE~DebugInfo
 * @description DebugInfo 结构用于存放调试信息。
 * @property {number} time [时间基准（options.clock）]{@link openBSE~Options}当前时间。
 * @property {number} bulletScreensOnScreenCount 实时弹幕总数
 * @property {number} bulletScreensCount 剩余弹幕总数
 * @property {number} delay 延迟：单位：毫秒。
 * @property {number} delayBulletScreensCount 丢弃弹幕数：因延迟过高而丢弃的弹幕总数。
 * @property {number} fps 帧频：单位：帧/秒。
 */

/**
 * 版本信息
 * @typedef {object} openBSE~VersionInfo
 * @description VersionInfo 结构用于存放版本信息。
 * @property {string} version 版本号
 * @property {string} buildDate 构建日期：时区：UTC。
 * @property {string} name 名称
 * @property {string} description 描述
 * @property {string} home 主页
 */


},{"./browserNotSupportError":117,"./build.json":118,"./bulletScreenEngine":119,"./bulletScreenType":120,"./contextmenu":121,"./lib/helper":123,"core-js/modules/es6.object.define-property":99}],135:[function(require,module,exports){
/*!
 * perfect-scrollbar v1.4.0
 * (c) 2018 Hyunje Jun
 * @license MIT
 */
'use strict';

function get(element) {
  return getComputedStyle(element);
}

function set(element, obj) {
  for (var key in obj) {
    var val = obj[key];
    if (typeof val === 'number') {
      val = val + "px";
    }
    element.style[key] = val;
  }
  return element;
}

function div(className) {
  var div = document.createElement('div');
  div.className = className;
  return div;
}

var elMatches =
  typeof Element !== 'undefined' &&
  (Element.prototype.matches ||
    Element.prototype.webkitMatchesSelector ||
    Element.prototype.mozMatchesSelector ||
    Element.prototype.msMatchesSelector);

function matches(element, query) {
  if (!elMatches) {
    throw new Error('No element matching method supported');
  }

  return elMatches.call(element, query);
}

function remove(element) {
  if (element.remove) {
    element.remove();
  } else {
    if (element.parentNode) {
      element.parentNode.removeChild(element);
    }
  }
}

function queryChildren(element, selector) {
  return Array.prototype.filter.call(element.children, function (child) { return matches(child, selector); }
  );
}

var cls = {
  main: 'ps',
  element: {
    thumb: function (x) { return ("ps__thumb-" + x); },
    rail: function (x) { return ("ps__rail-" + x); },
    consuming: 'ps__child--consume',
  },
  state: {
    focus: 'ps--focus',
    clicking: 'ps--clicking',
    active: function (x) { return ("ps--active-" + x); },
    scrolling: function (x) { return ("ps--scrolling-" + x); },
  },
};

/*
 * Helper methods
 */
var scrollingClassTimeout = { x: null, y: null };

function addScrollingClass(i, x) {
  var classList = i.element.classList;
  var className = cls.state.scrolling(x);

  if (classList.contains(className)) {
    clearTimeout(scrollingClassTimeout[x]);
  } else {
    classList.add(className);
  }
}

function removeScrollingClass(i, x) {
  scrollingClassTimeout[x] = setTimeout(
    function () { return i.isAlive && i.element.classList.remove(cls.state.scrolling(x)); },
    i.settings.scrollingThreshold
  );
}

function setScrollingClassInstantly(i, x) {
  addScrollingClass(i, x);
  removeScrollingClass(i, x);
}

var EventElement = function EventElement(element) {
  this.element = element;
  this.handlers = {};
};

var prototypeAccessors = { isEmpty: { configurable: true } };

EventElement.prototype.bind = function bind (eventName, handler) {
  if (typeof this.handlers[eventName] === 'undefined') {
    this.handlers[eventName] = [];
  }
  this.handlers[eventName].push(handler);
  this.element.addEventListener(eventName, handler, false);
};

EventElement.prototype.unbind = function unbind (eventName, target) {
    var this$1 = this;

  this.handlers[eventName] = this.handlers[eventName].filter(function (handler) {
    if (target && handler !== target) {
      return true;
    }
    this$1.element.removeEventListener(eventName, handler, false);
    return false;
  });
};

EventElement.prototype.unbindAll = function unbindAll () {
    var this$1 = this;

  for (var name in this$1.handlers) {
    this$1.unbind(name);
  }
};

prototypeAccessors.isEmpty.get = function () {
    var this$1 = this;

  return Object.keys(this.handlers).every(
    function (key) { return this$1.handlers[key].length === 0; }
  );
};

Object.defineProperties( EventElement.prototype, prototypeAccessors );

var EventManager = function EventManager() {
  this.eventElements = [];
};

EventManager.prototype.eventElement = function eventElement (element) {
  var ee = this.eventElements.filter(function (ee) { return ee.element === element; })[0];
  if (!ee) {
    ee = new EventElement(element);
    this.eventElements.push(ee);
  }
  return ee;
};

EventManager.prototype.bind = function bind (element, eventName, handler) {
  this.eventElement(element).bind(eventName, handler);
};

EventManager.prototype.unbind = function unbind (element, eventName, handler) {
  var ee = this.eventElement(element);
  ee.unbind(eventName, handler);

  if (ee.isEmpty) {
    // remove
    this.eventElements.splice(this.eventElements.indexOf(ee), 1);
  }
};

EventManager.prototype.unbindAll = function unbindAll () {
  this.eventElements.forEach(function (e) { return e.unbindAll(); });
  this.eventElements = [];
};

EventManager.prototype.once = function once (element, eventName, handler) {
  var ee = this.eventElement(element);
  var onceHandler = function (evt) {
    ee.unbind(eventName, onceHandler);
    handler(evt);
  };
  ee.bind(eventName, onceHandler);
};

function createEvent(name) {
  if (typeof window.CustomEvent === 'function') {
    return new CustomEvent(name);
  } else {
    var evt = document.createEvent('CustomEvent');
    evt.initCustomEvent(name, false, false, undefined);
    return evt;
  }
}

var processScrollDiff = function(
  i,
  axis,
  diff,
  useScrollingClass,
  forceFireReachEvent
) {
  if ( useScrollingClass === void 0 ) useScrollingClass = true;
  if ( forceFireReachEvent === void 0 ) forceFireReachEvent = false;

  var fields;
  if (axis === 'top') {
    fields = [
      'contentHeight',
      'containerHeight',
      'scrollTop',
      'y',
      'up',
      'down' ];
  } else if (axis === 'left') {
    fields = [
      'contentWidth',
      'containerWidth',
      'scrollLeft',
      'x',
      'left',
      'right' ];
  } else {
    throw new Error('A proper axis should be provided');
  }

  processScrollDiff$1(i, diff, fields, useScrollingClass, forceFireReachEvent);
};

function processScrollDiff$1(
  i,
  diff,
  ref,
  useScrollingClass,
  forceFireReachEvent
) {
  var contentHeight = ref[0];
  var containerHeight = ref[1];
  var scrollTop = ref[2];
  var y = ref[3];
  var up = ref[4];
  var down = ref[5];
  if ( useScrollingClass === void 0 ) useScrollingClass = true;
  if ( forceFireReachEvent === void 0 ) forceFireReachEvent = false;

  var element = i.element;

  // reset reach
  i.reach[y] = null;

  // 1 for subpixel rounding
  if (element[scrollTop] < 1) {
    i.reach[y] = 'start';
  }

  // 1 for subpixel rounding
  if (element[scrollTop] > i[contentHeight] - i[containerHeight] - 1) {
    i.reach[y] = 'end';
  }

  if (diff) {
    element.dispatchEvent(createEvent(("ps-scroll-" + y)));

    if (diff < 0) {
      element.dispatchEvent(createEvent(("ps-scroll-" + up)));
    } else if (diff > 0) {
      element.dispatchEvent(createEvent(("ps-scroll-" + down)));
    }

    if (useScrollingClass) {
      setScrollingClassInstantly(i, y);
    }
  }

  if (i.reach[y] && (diff || forceFireReachEvent)) {
    element.dispatchEvent(createEvent(("ps-" + y + "-reach-" + (i.reach[y]))));
  }
}

function toInt(x) {
  return parseInt(x, 10) || 0;
}

function isEditable(el) {
  return (
    matches(el, 'input,[contenteditable]') ||
    matches(el, 'select,[contenteditable]') ||
    matches(el, 'textarea,[contenteditable]') ||
    matches(el, 'button,[contenteditable]')
  );
}

function outerWidth(element) {
  var styles = get(element);
  return (
    toInt(styles.width) +
    toInt(styles.paddingLeft) +
    toInt(styles.paddingRight) +
    toInt(styles.borderLeftWidth) +
    toInt(styles.borderRightWidth)
  );
}

var env = {
  isWebKit:
    typeof document !== 'undefined' &&
    'WebkitAppearance' in document.documentElement.style,
  supportsTouch:
    typeof window !== 'undefined' &&
    ('ontouchstart' in window ||
      (window.DocumentTouch && document instanceof window.DocumentTouch)),
  supportsIePointer:
    typeof navigator !== 'undefined' && navigator.msMaxTouchPoints,
  isChrome:
    typeof navigator !== 'undefined' &&
    /Chrome/i.test(navigator && navigator.userAgent),
};

var updateGeometry = function(i) {
  var element = i.element;
  var roundedScrollTop = Math.floor(element.scrollTop);

  i.containerWidth = element.clientWidth;
  i.containerHeight = element.clientHeight;
  i.contentWidth = element.scrollWidth;
  i.contentHeight = element.scrollHeight;

  if (!element.contains(i.scrollbarXRail)) {
    // clean up and append
    queryChildren(element, cls.element.rail('x')).forEach(function (el) { return remove(el); }
    );
    element.appendChild(i.scrollbarXRail);
  }
  if (!element.contains(i.scrollbarYRail)) {
    // clean up and append
    queryChildren(element, cls.element.rail('y')).forEach(function (el) { return remove(el); }
    );
    element.appendChild(i.scrollbarYRail);
  }

  if (
    !i.settings.suppressScrollX &&
    i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth
  ) {
    i.scrollbarXActive = true;
    i.railXWidth = i.containerWidth - i.railXMarginWidth;
    i.railXRatio = i.containerWidth / i.railXWidth;
    i.scrollbarXWidth = getThumbSize(
      i,
      toInt(i.railXWidth * i.containerWidth / i.contentWidth)
    );
    i.scrollbarXLeft = toInt(
      (i.negativeScrollAdjustment + element.scrollLeft) *
        (i.railXWidth - i.scrollbarXWidth) /
        (i.contentWidth - i.containerWidth)
    );
  } else {
    i.scrollbarXActive = false;
  }

  if (
    !i.settings.suppressScrollY &&
    i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight
  ) {
    i.scrollbarYActive = true;
    i.railYHeight = i.containerHeight - i.railYMarginHeight;
    i.railYRatio = i.containerHeight / i.railYHeight;
    i.scrollbarYHeight = getThumbSize(
      i,
      toInt(i.railYHeight * i.containerHeight / i.contentHeight)
    );
    i.scrollbarYTop = toInt(
      roundedScrollTop *
        (i.railYHeight - i.scrollbarYHeight) /
        (i.contentHeight - i.containerHeight)
    );
  } else {
    i.scrollbarYActive = false;
  }

  if (i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth) {
    i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth;
  }
  if (i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight) {
    i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight;
  }

  updateCss(element, i);

  if (i.scrollbarXActive) {
    element.classList.add(cls.state.active('x'));
  } else {
    element.classList.remove(cls.state.active('x'));
    i.scrollbarXWidth = 0;
    i.scrollbarXLeft = 0;
    element.scrollLeft = 0;
  }
  if (i.scrollbarYActive) {
    element.classList.add(cls.state.active('y'));
  } else {
    element.classList.remove(cls.state.active('y'));
    i.scrollbarYHeight = 0;
    i.scrollbarYTop = 0;
    element.scrollTop = 0;
  }
};

function getThumbSize(i, thumbSize) {
  if (i.settings.minScrollbarLength) {
    thumbSize = Math.max(thumbSize, i.settings.minScrollbarLength);
  }
  if (i.settings.maxScrollbarLength) {
    thumbSize = Math.min(thumbSize, i.settings.maxScrollbarLength);
  }
  return thumbSize;
}

function updateCss(element, i) {
  var xRailOffset = { width: i.railXWidth };
  var roundedScrollTop = Math.floor(element.scrollTop);

  if (i.isRtl) {
    xRailOffset.left =
      i.negativeScrollAdjustment +
      element.scrollLeft +
      i.containerWidth -
      i.contentWidth;
  } else {
    xRailOffset.left = element.scrollLeft;
  }
  if (i.isScrollbarXUsingBottom) {
    xRailOffset.bottom = i.scrollbarXBottom - roundedScrollTop;
  } else {
    xRailOffset.top = i.scrollbarXTop + roundedScrollTop;
  }
  set(i.scrollbarXRail, xRailOffset);

  var yRailOffset = { top: roundedScrollTop, height: i.railYHeight };
  if (i.isScrollbarYUsingRight) {
    if (i.isRtl) {
      yRailOffset.right =
        i.contentWidth -
        (i.negativeScrollAdjustment + element.scrollLeft) -
        i.scrollbarYRight -
        i.scrollbarYOuterWidth;
    } else {
      yRailOffset.right = i.scrollbarYRight - element.scrollLeft;
    }
  } else {
    if (i.isRtl) {
      yRailOffset.left =
        i.negativeScrollAdjustment +
        element.scrollLeft +
        i.containerWidth * 2 -
        i.contentWidth -
        i.scrollbarYLeft -
        i.scrollbarYOuterWidth;
    } else {
      yRailOffset.left = i.scrollbarYLeft + element.scrollLeft;
    }
  }
  set(i.scrollbarYRail, yRailOffset);

  set(i.scrollbarX, {
    left: i.scrollbarXLeft,
    width: i.scrollbarXWidth - i.railBorderXWidth,
  });
  set(i.scrollbarY, {
    top: i.scrollbarYTop,
    height: i.scrollbarYHeight - i.railBorderYWidth,
  });
}

var clickRail = function(i) {
  i.event.bind(i.scrollbarY, 'mousedown', function (e) { return e.stopPropagation(); });
  i.event.bind(i.scrollbarYRail, 'mousedown', function (e) {
    var positionTop =
      e.pageY -
      window.pageYOffset -
      i.scrollbarYRail.getBoundingClientRect().top;
    var direction = positionTop > i.scrollbarYTop ? 1 : -1;

    i.element.scrollTop += direction * i.containerHeight;
    updateGeometry(i);

    e.stopPropagation();
  });

  i.event.bind(i.scrollbarX, 'mousedown', function (e) { return e.stopPropagation(); });
  i.event.bind(i.scrollbarXRail, 'mousedown', function (e) {
    var positionLeft =
      e.pageX -
      window.pageXOffset -
      i.scrollbarXRail.getBoundingClientRect().left;
    var direction = positionLeft > i.scrollbarXLeft ? 1 : -1;

    i.element.scrollLeft += direction * i.containerWidth;
    updateGeometry(i);

    e.stopPropagation();
  });
};

var dragThumb = function(i) {
  bindMouseScrollHandler(i, [
    'containerWidth',
    'contentWidth',
    'pageX',
    'railXWidth',
    'scrollbarX',
    'scrollbarXWidth',
    'scrollLeft',
    'x',
    'scrollbarXRail' ]);
  bindMouseScrollHandler(i, [
    'containerHeight',
    'contentHeight',
    'pageY',
    'railYHeight',
    'scrollbarY',
    'scrollbarYHeight',
    'scrollTop',
    'y',
    'scrollbarYRail' ]);
};

function bindMouseScrollHandler(
  i,
  ref
) {
  var containerHeight = ref[0];
  var contentHeight = ref[1];
  var pageY = ref[2];
  var railYHeight = ref[3];
  var scrollbarY = ref[4];
  var scrollbarYHeight = ref[5];
  var scrollTop = ref[6];
  var y = ref[7];
  var scrollbarYRail = ref[8];

  var element = i.element;

  var startingScrollTop = null;
  var startingMousePageY = null;
  var scrollBy = null;

  function mouseMoveHandler(e) {
    element[scrollTop] =
      startingScrollTop + scrollBy * (e[pageY] - startingMousePageY);
    addScrollingClass(i, y);
    updateGeometry(i);

    e.stopPropagation();
    e.preventDefault();
  }

  function mouseUpHandler() {
    removeScrollingClass(i, y);
    i[scrollbarYRail].classList.remove(cls.state.clicking);
    i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);
  }

  i.event.bind(i[scrollbarY], 'mousedown', function (e) {
    startingScrollTop = element[scrollTop];
    startingMousePageY = e[pageY];
    scrollBy =
      (i[contentHeight] - i[containerHeight]) /
      (i[railYHeight] - i[scrollbarYHeight]);

    i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);
    i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);

    i[scrollbarYRail].classList.add(cls.state.clicking);

    e.stopPropagation();
    e.preventDefault();
  });
}

var keyboard = function(i) {
  var element = i.element;

  var elementHovered = function () { return matches(element, ':hover'); };
  var scrollbarFocused = function () { return matches(i.scrollbarX, ':focus') || matches(i.scrollbarY, ':focus'); };

  function shouldPreventDefault(deltaX, deltaY) {
    var scrollTop = Math.floor(element.scrollTop);
    if (deltaX === 0) {
      if (!i.scrollbarYActive) {
        return false;
      }
      if (
        (scrollTop === 0 && deltaY > 0) ||
        (scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0)
      ) {
        return !i.settings.wheelPropagation;
      }
    }

    var scrollLeft = element.scrollLeft;
    if (deltaY === 0) {
      if (!i.scrollbarXActive) {
        return false;
      }
      if (
        (scrollLeft === 0 && deltaX < 0) ||
        (scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0)
      ) {
        return !i.settings.wheelPropagation;
      }
    }
    return true;
  }

  i.event.bind(i.ownerDocument, 'keydown', function (e) {
    if (
      (e.isDefaultPrevented && e.isDefaultPrevented()) ||
      e.defaultPrevented
    ) {
      return;
    }

    if (!elementHovered() && !scrollbarFocused()) {
      return;
    }

    var activeElement = document.activeElement
      ? document.activeElement
      : i.ownerDocument.activeElement;
    if (activeElement) {
      if (activeElement.tagName === 'IFRAME') {
        activeElement = activeElement.contentDocument.activeElement;
      } else {
        // go deeper if element is a webcomponent
        while (activeElement.shadowRoot) {
          activeElement = activeElement.shadowRoot.activeElement;
        }
      }
      if (isEditable(activeElement)) {
        return;
      }
    }

    var deltaX = 0;
    var deltaY = 0;

    switch (e.which) {
      case 37: // left
        if (e.metaKey) {
          deltaX = -i.contentWidth;
        } else if (e.altKey) {
          deltaX = -i.containerWidth;
        } else {
          deltaX = -30;
        }
        break;
      case 38: // up
        if (e.metaKey) {
          deltaY = i.contentHeight;
        } else if (e.altKey) {
          deltaY = i.containerHeight;
        } else {
          deltaY = 30;
        }
        break;
      case 39: // right
        if (e.metaKey) {
          deltaX = i.contentWidth;
        } else if (e.altKey) {
          deltaX = i.containerWidth;
        } else {
          deltaX = 30;
        }
        break;
      case 40: // down
        if (e.metaKey) {
          deltaY = -i.contentHeight;
        } else if (e.altKey) {
          deltaY = -i.containerHeight;
        } else {
          deltaY = -30;
        }
        break;
      case 32: // space bar
        if (e.shiftKey) {
          deltaY = i.containerHeight;
        } else {
          deltaY = -i.containerHeight;
        }
        break;
      case 33: // page up
        deltaY = i.containerHeight;
        break;
      case 34: // page down
        deltaY = -i.containerHeight;
        break;
      case 36: // home
        deltaY = i.contentHeight;
        break;
      case 35: // end
        deltaY = -i.contentHeight;
        break;
      default:
        return;
    }

    if (i.settings.suppressScrollX && deltaX !== 0) {
      return;
    }
    if (i.settings.suppressScrollY && deltaY !== 0) {
      return;
    }

    element.scrollTop -= deltaY;
    element.scrollLeft += deltaX;
    updateGeometry(i);

    if (shouldPreventDefault(deltaX, deltaY)) {
      e.preventDefault();
    }
  });
};

var wheel = function(i) {
  var element = i.element;

  function shouldPreventDefault(deltaX, deltaY) {
    var roundedScrollTop = Math.floor(element.scrollTop);
    var isTop = element.scrollTop === 0;
    var isBottom =
      roundedScrollTop + element.offsetHeight === element.scrollHeight;
    var isLeft = element.scrollLeft === 0;
    var isRight =
      element.scrollLeft + element.offsetWidth === element.scrollWidth;

    var hitsBound;

    // pick axis with primary direction
    if (Math.abs(deltaY) > Math.abs(deltaX)) {
      hitsBound = isTop || isBottom;
    } else {
      hitsBound = isLeft || isRight;
    }

    return hitsBound ? !i.settings.wheelPropagation : true;
  }

  function getDeltaFromEvent(e) {
    var deltaX = e.deltaX;
    var deltaY = -1 * e.deltaY;

    if (typeof deltaX === 'undefined' || typeof deltaY === 'undefined') {
      // OS X Safari
      deltaX = -1 * e.wheelDeltaX / 6;
      deltaY = e.wheelDeltaY / 6;
    }

    if (e.deltaMode && e.deltaMode === 1) {
      // Firefox in deltaMode 1: Line scrolling
      deltaX *= 10;
      deltaY *= 10;
    }

    if (deltaX !== deltaX && deltaY !== deltaY /* NaN checks */) {
      // IE in some mouse drivers
      deltaX = 0;
      deltaY = e.wheelDelta;
    }

    if (e.shiftKey) {
      // reverse axis with shift key
      return [-deltaY, -deltaX];
    }
    return [deltaX, deltaY];
  }

  function shouldBeConsumedByChild(target, deltaX, deltaY) {
    // FIXME: this is a workaround for <select> issue in FF and IE #571
    if (!env.isWebKit && element.querySelector('select:focus')) {
      return true;
    }

    if (!element.contains(target)) {
      return false;
    }

    var cursor = target;

    while (cursor && cursor !== element) {
      if (cursor.classList.contains(cls.element.consuming)) {
        return true;
      }

      var style = get(cursor);
      var overflow = [style.overflow, style.overflowX, style.overflowY].join(
        ''
      );

      // if scrollable
      if (overflow.match(/(scroll|auto)/)) {
        var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;
        if (maxScrollTop > 0) {
          if (
            !(cursor.scrollTop === 0 && deltaY > 0) &&
            !(cursor.scrollTop === maxScrollTop && deltaY < 0)
          ) {
            return true;
          }
        }
        var maxScrollLeft = cursor.scrollWidth - cursor.clientWidth;
        if (maxScrollLeft > 0) {
          if (
            !(cursor.scrollLeft === 0 && deltaX < 0) &&
            !(cursor.scrollLeft === maxScrollLeft && deltaX > 0)
          ) {
            return true;
          }
        }
      }

      cursor = cursor.parentNode;
    }

    return false;
  }

  function mousewheelHandler(e) {
    var ref = getDeltaFromEvent(e);
    var deltaX = ref[0];
    var deltaY = ref[1];

    if (shouldBeConsumedByChild(e.target, deltaX, deltaY)) {
      return;
    }

    var shouldPrevent = false;
    if (!i.settings.useBothWheelAxes) {
      // deltaX will only be used for horizontal scrolling and deltaY will
      // only be used for vertical scrolling - this is the default
      element.scrollTop -= deltaY * i.settings.wheelSpeed;
      element.scrollLeft += deltaX * i.settings.wheelSpeed;
    } else if (i.scrollbarYActive && !i.scrollbarXActive) {
      // only vertical scrollbar is active and useBothWheelAxes option is
      // active, so let's scroll vertical bar using both mouse wheel axes
      if (deltaY) {
        element.scrollTop -= deltaY * i.settings.wheelSpeed;
      } else {
        element.scrollTop += deltaX * i.settings.wheelSpeed;
      }
      shouldPrevent = true;
    } else if (i.scrollbarXActive && !i.scrollbarYActive) {
      // useBothWheelAxes and only horizontal bar is active, so use both
      // wheel axes for horizontal bar
      if (deltaX) {
        element.scrollLeft += deltaX * i.settings.wheelSpeed;
      } else {
        element.scrollLeft -= deltaY * i.settings.wheelSpeed;
      }
      shouldPrevent = true;
    }

    updateGeometry(i);

    shouldPrevent = shouldPrevent || shouldPreventDefault(deltaX, deltaY);
    if (shouldPrevent && !e.ctrlKey) {
      e.stopPropagation();
      e.preventDefault();
    }
  }

  if (typeof window.onwheel !== 'undefined') {
    i.event.bind(element, 'wheel', mousewheelHandler);
  } else if (typeof window.onmousewheel !== 'undefined') {
    i.event.bind(element, 'mousewheel', mousewheelHandler);
  }
};

var touch = function(i) {
  if (!env.supportsTouch && !env.supportsIePointer) {
    return;
  }

  var element = i.element;

  function shouldPrevent(deltaX, deltaY) {
    var scrollTop = Math.floor(element.scrollTop);
    var scrollLeft = element.scrollLeft;
    var magnitudeX = Math.abs(deltaX);
    var magnitudeY = Math.abs(deltaY);

    if (magnitudeY > magnitudeX) {
      // user is perhaps trying to swipe up/down the page

      if (
        (deltaY < 0 && scrollTop === i.contentHeight - i.containerHeight) ||
        (deltaY > 0 && scrollTop === 0)
      ) {
        // set prevent for mobile Chrome refresh
        return window.scrollY === 0 && deltaY > 0 && env.isChrome;
      }
    } else if (magnitudeX > magnitudeY) {
      // user is perhaps trying to swipe left/right across the page

      if (
        (deltaX < 0 && scrollLeft === i.contentWidth - i.containerWidth) ||
        (deltaX > 0 && scrollLeft === 0)
      ) {
        return true;
      }
    }

    return true;
  }

  function applyTouchMove(differenceX, differenceY) {
    element.scrollTop -= differenceY;
    element.scrollLeft -= differenceX;

    updateGeometry(i);
  }

  var startOffset = {};
  var startTime = 0;
  var speed = {};
  var easingLoop = null;

  function getTouch(e) {
    if (e.targetTouches) {
      return e.targetTouches[0];
    } else {
      // Maybe IE pointer
      return e;
    }
  }

  function shouldHandle(e) {
    if (e.pointerType && e.pointerType === 'pen' && e.buttons === 0) {
      return false;
    }
    if (e.targetTouches && e.targetTouches.length === 1) {
      return true;
    }
    if (
      e.pointerType &&
      e.pointerType !== 'mouse' &&
      e.pointerType !== e.MSPOINTER_TYPE_MOUSE
    ) {
      return true;
    }
    return false;
  }

  function touchStart(e) {
    if (!shouldHandle(e)) {
      return;
    }

    var touch = getTouch(e);

    startOffset.pageX = touch.pageX;
    startOffset.pageY = touch.pageY;

    startTime = new Date().getTime();

    if (easingLoop !== null) {
      clearInterval(easingLoop);
    }
  }

  function shouldBeConsumedByChild(target, deltaX, deltaY) {
    if (!element.contains(target)) {
      return false;
    }

    var cursor = target;

    while (cursor && cursor !== element) {
      if (cursor.classList.contains(cls.element.consuming)) {
        return true;
      }

      var style = get(cursor);
      var overflow = [style.overflow, style.overflowX, style.overflowY].join(
        ''
      );

      // if scrollable
      if (overflow.match(/(scroll|auto)/)) {
        var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;
        if (maxScrollTop > 0) {
          if (
            !(cursor.scrollTop === 0 && deltaY > 0) &&
            !(cursor.scrollTop === maxScrollTop && deltaY < 0)
          ) {
            return true;
          }
        }
        var maxScrollLeft = cursor.scrollLeft - cursor.clientWidth;
        if (maxScrollLeft > 0) {
          if (
            !(cursor.scrollLeft === 0 && deltaX < 0) &&
            !(cursor.scrollLeft === maxScrollLeft && deltaX > 0)
          ) {
            return true;
          }
        }
      }

      cursor = cursor.parentNode;
    }

    return false;
  }

  function touchMove(e) {
    if (shouldHandle(e)) {
      var touch = getTouch(e);

      var currentOffset = { pageX: touch.pageX, pageY: touch.pageY };

      var differenceX = currentOffset.pageX - startOffset.pageX;
      var differenceY = currentOffset.pageY - startOffset.pageY;

      if (shouldBeConsumedByChild(e.target, differenceX, differenceY)) {
        return;
      }

      applyTouchMove(differenceX, differenceY);
      startOffset = currentOffset;

      var currentTime = new Date().getTime();

      var timeGap = currentTime - startTime;
      if (timeGap > 0) {
        speed.x = differenceX / timeGap;
        speed.y = differenceY / timeGap;
        startTime = currentTime;
      }

      if (shouldPrevent(differenceX, differenceY)) {
        e.preventDefault();
      }
    }
  }
  function touchEnd() {
    if (i.settings.swipeEasing) {
      clearInterval(easingLoop);
      easingLoop = setInterval(function() {
        if (i.isInitialized) {
          clearInterval(easingLoop);
          return;
        }

        if (!speed.x && !speed.y) {
          clearInterval(easingLoop);
          return;
        }

        if (Math.abs(speed.x) < 0.01 && Math.abs(speed.y) < 0.01) {
          clearInterval(easingLoop);
          return;
        }

        applyTouchMove(speed.x * 30, speed.y * 30);

        speed.x *= 0.8;
        speed.y *= 0.8;
      }, 10);
    }
  }

  if (env.supportsTouch) {
    i.event.bind(element, 'touchstart', touchStart);
    i.event.bind(element, 'touchmove', touchMove);
    i.event.bind(element, 'touchend', touchEnd);
  } else if (env.supportsIePointer) {
    if (window.PointerEvent) {
      i.event.bind(element, 'pointerdown', touchStart);
      i.event.bind(element, 'pointermove', touchMove);
      i.event.bind(element, 'pointerup', touchEnd);
    } else if (window.MSPointerEvent) {
      i.event.bind(element, 'MSPointerDown', touchStart);
      i.event.bind(element, 'MSPointerMove', touchMove);
      i.event.bind(element, 'MSPointerUp', touchEnd);
    }
  }
};

var defaultSettings = function () { return ({
  handlers: ['click-rail', 'drag-thumb', 'keyboard', 'wheel', 'touch'],
  maxScrollbarLength: null,
  minScrollbarLength: null,
  scrollingThreshold: 1000,
  scrollXMarginOffset: 0,
  scrollYMarginOffset: 0,
  suppressScrollX: false,
  suppressScrollY: false,
  swipeEasing: true,
  useBothWheelAxes: false,
  wheelPropagation: true,
  wheelSpeed: 1,
}); };

var handlers = {
  'click-rail': clickRail,
  'drag-thumb': dragThumb,
  keyboard: keyboard,
  wheel: wheel,
  touch: touch,
};

var PerfectScrollbar = function PerfectScrollbar(element, userSettings) {
  var this$1 = this;
  if ( userSettings === void 0 ) userSettings = {};

  if (typeof element === 'string') {
    element = document.querySelector(element);
  }

  if (!element || !element.nodeName) {
    throw new Error('no element is specified to initialize PerfectScrollbar');
  }

  this.element = element;

  element.classList.add(cls.main);

  this.settings = defaultSettings();
  for (var key in userSettings) {
    this$1.settings[key] = userSettings[key];
  }

  this.containerWidth = null;
  this.containerHeight = null;
  this.contentWidth = null;
  this.contentHeight = null;

  var focus = function () { return element.classList.add(cls.state.focus); };
  var blur = function () { return element.classList.remove(cls.state.focus); };

  this.isRtl = get(element).direction === 'rtl';
  this.isNegativeScroll = (function () {
    var originalScrollLeft = element.scrollLeft;
    var result = null;
    element.scrollLeft = -1;
    result = element.scrollLeft < 0;
    element.scrollLeft = originalScrollLeft;
    return result;
  })();
  this.negativeScrollAdjustment = this.isNegativeScroll
    ? element.scrollWidth - element.clientWidth
    : 0;
  this.event = new EventManager();
  this.ownerDocument = element.ownerDocument || document;

  this.scrollbarXRail = div(cls.element.rail('x'));
  element.appendChild(this.scrollbarXRail);
  this.scrollbarX = div(cls.element.thumb('x'));
  this.scrollbarXRail.appendChild(this.scrollbarX);
  this.scrollbarX.setAttribute('tabindex', 0);
  this.event.bind(this.scrollbarX, 'focus', focus);
  this.event.bind(this.scrollbarX, 'blur', blur);
  this.scrollbarXActive = null;
  this.scrollbarXWidth = null;
  this.scrollbarXLeft = null;
  var railXStyle = get(this.scrollbarXRail);
  this.scrollbarXBottom = parseInt(railXStyle.bottom, 10);
  if (isNaN(this.scrollbarXBottom)) {
    this.isScrollbarXUsingBottom = false;
    this.scrollbarXTop = toInt(railXStyle.top);
  } else {
    this.isScrollbarXUsingBottom = true;
  }
  this.railBorderXWidth =
    toInt(railXStyle.borderLeftWidth) + toInt(railXStyle.borderRightWidth);
  // Set rail to display:block to calculate margins
  set(this.scrollbarXRail, { display: 'block' });
  this.railXMarginWidth =
    toInt(railXStyle.marginLeft) + toInt(railXStyle.marginRight);
  set(this.scrollbarXRail, { display: '' });
  this.railXWidth = null;
  this.railXRatio = null;

  this.scrollbarYRail = div(cls.element.rail('y'));
  element.appendChild(this.scrollbarYRail);
  this.scrollbarY = div(cls.element.thumb('y'));
  this.scrollbarYRail.appendChild(this.scrollbarY);
  this.scrollbarY.setAttribute('tabindex', 0);
  this.event.bind(this.scrollbarY, 'focus', focus);
  this.event.bind(this.scrollbarY, 'blur', blur);
  this.scrollbarYActive = null;
  this.scrollbarYHeight = null;
  this.scrollbarYTop = null;
  var railYStyle = get(this.scrollbarYRail);
  this.scrollbarYRight = parseInt(railYStyle.right, 10);
  if (isNaN(this.scrollbarYRight)) {
    this.isScrollbarYUsingRight = false;
    this.scrollbarYLeft = toInt(railYStyle.left);
  } else {
    this.isScrollbarYUsingRight = true;
  }
  this.scrollbarYOuterWidth = this.isRtl ? outerWidth(this.scrollbarY) : null;
  this.railBorderYWidth =
    toInt(railYStyle.borderTopWidth) + toInt(railYStyle.borderBottomWidth);
  set(this.scrollbarYRail, { display: 'block' });
  this.railYMarginHeight =
    toInt(railYStyle.marginTop) + toInt(railYStyle.marginBottom);
  set(this.scrollbarYRail, { display: '' });
  this.railYHeight = null;
  this.railYRatio = null;

  this.reach = {
    x:
      element.scrollLeft <= 0
        ? 'start'
        : element.scrollLeft >= this.contentWidth - this.containerWidth
          ? 'end'
          : null,
    y:
      element.scrollTop <= 0
        ? 'start'
        : element.scrollTop >= this.contentHeight - this.containerHeight
          ? 'end'
          : null,
  };

  this.isAlive = true;

  this.settings.handlers.forEach(function (handlerName) { return handlers[handlerName](this$1); });

  this.lastScrollTop = Math.floor(element.scrollTop); // for onScroll only
  this.lastScrollLeft = element.scrollLeft; // for onScroll only
  this.event.bind(this.element, 'scroll', function (e) { return this$1.onScroll(e); });
  updateGeometry(this);
};

PerfectScrollbar.prototype.update = function update () {
  if (!this.isAlive) {
    return;
  }

  // Recalcuate negative scrollLeft adjustment
  this.negativeScrollAdjustment = this.isNegativeScroll
    ? this.element.scrollWidth - this.element.clientWidth
    : 0;

  // Recalculate rail margins
  set(this.scrollbarXRail, { display: 'block' });
  set(this.scrollbarYRail, { display: 'block' });
  this.railXMarginWidth =
    toInt(get(this.scrollbarXRail).marginLeft) +
    toInt(get(this.scrollbarXRail).marginRight);
  this.railYMarginHeight =
    toInt(get(this.scrollbarYRail).marginTop) +
    toInt(get(this.scrollbarYRail).marginBottom);

  // Hide scrollbars not to affect scrollWidth and scrollHeight
  set(this.scrollbarXRail, { display: 'none' });
  set(this.scrollbarYRail, { display: 'none' });

  updateGeometry(this);

  processScrollDiff(this, 'top', 0, false, true);
  processScrollDiff(this, 'left', 0, false, true);

  set(this.scrollbarXRail, { display: '' });
  set(this.scrollbarYRail, { display: '' });
};

PerfectScrollbar.prototype.onScroll = function onScroll (e) {
  if (!this.isAlive) {
    return;
  }

  updateGeometry(this);
  processScrollDiff(this, 'top', this.element.scrollTop - this.lastScrollTop);
  processScrollDiff(
    this,
    'left',
    this.element.scrollLeft - this.lastScrollLeft
  );

  this.lastScrollTop = Math.floor(this.element.scrollTop);
  this.lastScrollLeft = this.element.scrollLeft;
};

PerfectScrollbar.prototype.destroy = function destroy () {
  if (!this.isAlive) {
    return;
  }

  this.event.unbindAll();
  remove(this.scrollbarX);
  remove(this.scrollbarY);
  remove(this.scrollbarXRail);
  remove(this.scrollbarYRail);
  this.removePsClasses();

  // unset elements
  this.element = null;
  this.scrollbarX = null;
  this.scrollbarY = null;
  this.scrollbarXRail = null;
  this.scrollbarYRail = null;

  this.isAlive = false;
};

PerfectScrollbar.prototype.removePsClasses = function removePsClasses () {
  this.element.className = this.element.className
    .split(' ')
    .filter(function (name) { return !name.match(/^ps([-_].+|)$/); })
    .join(' ');
};

module.exports = PerfectScrollbar;

},{}],136:[function(require,module,exports){
/*! tooltipster v4.2.6 */!function(a,b){"function"==typeof define&&define.amd?define(["jquery"],function(a){return b(a)}):"object"==typeof exports?module.exports=b(require("jquery")):b(jQuery)}(this,function(a){function b(a){this.$container,this.constraints=null,this.__$tooltip,this.__init(a)}function c(b,c){var d=!0;return a.each(b,function(a,e){return void 0===c[a]||b[a]!==c[a]?(d=!1,!1):void 0}),d}function d(b){var c=b.attr("id"),d=c?h.window.document.getElementById(c):null;return d?d===b[0]:a.contains(h.window.document.body,b[0])}function e(){if(!g)return!1;var a=g.document.body||g.document.documentElement,b=a.style,c="transition",d=["Moz","Webkit","Khtml","O","ms"];if("string"==typeof b[c])return!0;c=c.charAt(0).toUpperCase()+c.substr(1);for(var e=0;e<d.length;e++)if("string"==typeof b[d[e]+c])return!0;return!1}var f={animation:"fade",animationDuration:350,content:null,contentAsHTML:!1,contentCloning:!1,debug:!0,delay:300,delayTouch:[300,500],functionInit:null,functionBefore:null,functionReady:null,functionAfter:null,functionFormat:null,IEmin:6,interactive:!1,multiple:!1,parent:null,plugins:["sideTip"],repositionOnScroll:!1,restoration:"none",selfDestruction:!0,theme:[],timer:0,trackerInterval:500,trackOrigin:!1,trackTooltip:!1,trigger:"hover",triggerClose:{click:!1,mouseleave:!1,originClick:!1,scroll:!1,tap:!1,touchleave:!1},triggerOpen:{click:!1,mouseenter:!1,tap:!1,touchstart:!1},updateAnimation:"rotate",zIndex:9999999},g="undefined"!=typeof window?window:null,h={hasTouchCapability:!(!g||!("ontouchstart"in g||g.DocumentTouch&&g.document instanceof g.DocumentTouch||g.navigator.maxTouchPoints)),hasTransitions:e(),IE:!1,semVer:"4.2.6",window:g},i=function(){this.__$emitterPrivate=a({}),this.__$emitterPublic=a({}),this.__instancesLatestArr=[],this.__plugins={},this._env=h};i.prototype={__bridge:function(b,c,d){if(!c[d]){var e=function(){};e.prototype=b;var g=new e;g.__init&&g.__init(c),a.each(b,function(a,b){0!=a.indexOf("__")&&(c[a]?f.debug&&console.log("The "+a+" method of the "+d+" plugin conflicts with another plugin or native methods"):(c[a]=function(){return g[a].apply(g,Array.prototype.slice.apply(arguments))},c[a].bridged=g))}),c[d]=g}return this},__setWindow:function(a){return h.window=a,this},_getRuler:function(a){return new b(a)},_off:function(){return this.__$emitterPrivate.off.apply(this.__$emitterPrivate,Array.prototype.slice.apply(arguments)),this},_on:function(){return this.__$emitterPrivate.on.apply(this.__$emitterPrivate,Array.prototype.slice.apply(arguments)),this},_one:function(){return this.__$emitterPrivate.one.apply(this.__$emitterPrivate,Array.prototype.slice.apply(arguments)),this},_plugin:function(b){var c=this;if("string"==typeof b){var d=b,e=null;return d.indexOf(".")>0?e=c.__plugins[d]:a.each(c.__plugins,function(a,b){return b.name.substring(b.name.length-d.length-1)=="."+d?(e=b,!1):void 0}),e}if(b.name.indexOf(".")<0)throw new Error("Plugins must be namespaced");return c.__plugins[b.name]=b,b.core&&c.__bridge(b.core,c,b.name),this},_trigger:function(){var a=Array.prototype.slice.apply(arguments);return"string"==typeof a[0]&&(a[0]={type:a[0]}),this.__$emitterPrivate.trigger.apply(this.__$emitterPrivate,a),this.__$emitterPublic.trigger.apply(this.__$emitterPublic,a),this},instances:function(b){var c=[],d=b||".tooltipstered";return a(d).each(function(){var b=a(this),d=b.data("tooltipster-ns");d&&a.each(d,function(a,d){c.push(b.data(d))})}),c},instancesLatest:function(){return this.__instancesLatestArr},off:function(){return this.__$emitterPublic.off.apply(this.__$emitterPublic,Array.prototype.slice.apply(arguments)),this},on:function(){return this.__$emitterPublic.on.apply(this.__$emitterPublic,Array.prototype.slice.apply(arguments)),this},one:function(){return this.__$emitterPublic.one.apply(this.__$emitterPublic,Array.prototype.slice.apply(arguments)),this},origins:function(b){var c=b?b+" ":"";return a(c+".tooltipstered").toArray()},setDefaults:function(b){return a.extend(f,b),this},triggerHandler:function(){return this.__$emitterPublic.triggerHandler.apply(this.__$emitterPublic,Array.prototype.slice.apply(arguments)),this}},a.tooltipster=new i,a.Tooltipster=function(b,c){this.__callbacks={close:[],open:[]},this.__closingTime,this.__Content,this.__contentBcr,this.__destroyed=!1,this.__$emitterPrivate=a({}),this.__$emitterPublic=a({}),this.__enabled=!0,this.__garbageCollector,this.__Geometry,this.__lastPosition,this.__namespace="tooltipster-"+Math.round(1e6*Math.random()),this.__options,this.__$originParents,this.__pointerIsOverOrigin=!1,this.__previousThemes=[],this.__state="closed",this.__timeouts={close:[],open:null},this.__touchEvents=[],this.__tracker=null,this._$origin,this._$tooltip,this.__init(b,c)},a.Tooltipster.prototype={__init:function(b,c){var d=this;if(d._$origin=a(b),d.__options=a.extend(!0,{},f,c),d.__optionsFormat(),!h.IE||h.IE>=d.__options.IEmin){var e=null;if(void 0===d._$origin.data("tooltipster-initialTitle")&&(e=d._$origin.attr("title"),void 0===e&&(e=null),d._$origin.data("tooltipster-initialTitle",e)),null!==d.__options.content)d.__contentSet(d.__options.content);else{var g,i=d._$origin.attr("data-tooltip-content");i&&(g=a(i)),g&&g[0]?d.__contentSet(g.first()):d.__contentSet(e)}d._$origin.removeAttr("title").addClass("tooltipstered"),d.__prepareOrigin(),d.__prepareGC(),a.each(d.__options.plugins,function(a,b){d._plug(b)}),h.hasTouchCapability&&a(h.window.document.body).on("touchmove."+d.__namespace+"-triggerOpen",function(a){d._touchRecordEvent(a)}),d._on("created",function(){d.__prepareTooltip()})._on("repositioned",function(a){d.__lastPosition=a.position})}else d.__options.disabled=!0},__contentInsert:function(){var a=this,b=a._$tooltip.find(".tooltipster-content"),c=a.__Content,d=function(a){c=a};return a._trigger({type:"format",content:a.__Content,format:d}),a.__options.functionFormat&&(c=a.__options.functionFormat.call(a,a,{origin:a._$origin[0]},a.__Content)),"string"!=typeof c||a.__options.contentAsHTML?b.empty().append(c):b.text(c),a},__contentSet:function(b){return b instanceof a&&this.__options.contentCloning&&(b=b.clone(!0)),this.__Content=b,this._trigger({type:"updated",content:b}),this},__destroyError:function(){throw new Error("This tooltip has been destroyed and cannot execute your method call.")},__geometry:function(){var b=this,c=b._$origin,d=b._$origin.is("area");if(d){var e=b._$origin.parent().attr("name");c=a('img[usemap="#'+e+'"]')}var f=c[0].getBoundingClientRect(),g=a(h.window.document),i=a(h.window),j=c,k={available:{document:null,window:null},document:{size:{height:g.height(),width:g.width()}},window:{scroll:{left:h.window.scrollX||h.window.document.documentElement.scrollLeft,top:h.window.scrollY||h.window.document.documentElement.scrollTop},size:{height:i.height(),width:i.width()}},origin:{fixedLineage:!1,offset:{},size:{height:f.bottom-f.top,width:f.right-f.left},usemapImage:d?c[0]:null,windowOffset:{bottom:f.bottom,left:f.left,right:f.right,top:f.top}}};if(d){var l=b._$origin.attr("shape"),m=b._$origin.attr("coords");if(m&&(m=m.split(","),a.map(m,function(a,b){m[b]=parseInt(a)})),"default"!=l)switch(l){case"circle":var n=m[0],o=m[1],p=m[2],q=o-p,r=n-p;k.origin.size.height=2*p,k.origin.size.width=k.origin.size.height,k.origin.windowOffset.left+=r,k.origin.windowOffset.top+=q;break;case"rect":var s=m[0],t=m[1],u=m[2],v=m[3];k.origin.size.height=v-t,k.origin.size.width=u-s,k.origin.windowOffset.left+=s,k.origin.windowOffset.top+=t;break;case"poly":for(var w=0,x=0,y=0,z=0,A="even",B=0;B<m.length;B++){var C=m[B];"even"==A?(C>y&&(y=C,0===B&&(w=y)),w>C&&(w=C),A="odd"):(C>z&&(z=C,1==B&&(x=z)),x>C&&(x=C),A="even")}k.origin.size.height=z-x,k.origin.size.width=y-w,k.origin.windowOffset.left+=w,k.origin.windowOffset.top+=x}}var D=function(a){k.origin.size.height=a.height,k.origin.windowOffset.left=a.left,k.origin.windowOffset.top=a.top,k.origin.size.width=a.width};for(b._trigger({type:"geometry",edit:D,geometry:{height:k.origin.size.height,left:k.origin.windowOffset.left,top:k.origin.windowOffset.top,width:k.origin.size.width}}),k.origin.windowOffset.right=k.origin.windowOffset.left+k.origin.size.width,k.origin.windowOffset.bottom=k.origin.windowOffset.top+k.origin.size.height,k.origin.offset.left=k.origin.windowOffset.left+k.window.scroll.left,k.origin.offset.top=k.origin.windowOffset.top+k.window.scroll.top,k.origin.offset.bottom=k.origin.offset.top+k.origin.size.height,k.origin.offset.right=k.origin.offset.left+k.origin.size.width,k.available.document={bottom:{height:k.document.size.height-k.origin.offset.bottom,width:k.document.size.width},left:{height:k.document.size.height,width:k.origin.offset.left},right:{height:k.document.size.height,width:k.document.size.width-k.origin.offset.right},top:{height:k.origin.offset.top,width:k.document.size.width}},k.available.window={bottom:{height:Math.max(k.window.size.height-Math.max(k.origin.windowOffset.bottom,0),0),width:k.window.size.width},left:{height:k.window.size.height,width:Math.max(k.origin.windowOffset.left,0)},right:{height:k.window.size.height,width:Math.max(k.window.size.width-Math.max(k.origin.windowOffset.right,0),0)},top:{height:Math.max(k.origin.windowOffset.top,0),width:k.window.size.width}};"html"!=j[0].tagName.toLowerCase();){if("fixed"==j.css("position")){k.origin.fixedLineage=!0;break}j=j.parent()}return k},__optionsFormat:function(){return"number"==typeof this.__options.animationDuration&&(this.__options.animationDuration=[this.__options.animationDuration,this.__options.animationDuration]),"number"==typeof this.__options.delay&&(this.__options.delay=[this.__options.delay,this.__options.delay]),"number"==typeof this.__options.delayTouch&&(this.__options.delayTouch=[this.__options.delayTouch,this.__options.delayTouch]),"string"==typeof this.__options.theme&&(this.__options.theme=[this.__options.theme]),null===this.__options.parent?this.__options.parent=a(h.window.document.body):"string"==typeof this.__options.parent&&(this.__options.parent=a(this.__options.parent)),"hover"==this.__options.trigger?(this.__options.triggerOpen={mouseenter:!0,touchstart:!0},this.__options.triggerClose={mouseleave:!0,originClick:!0,touchleave:!0}):"click"==this.__options.trigger&&(this.__options.triggerOpen={click:!0,tap:!0},this.__options.triggerClose={click:!0,tap:!0}),this._trigger("options"),this},__prepareGC:function(){var b=this;return b.__options.selfDestruction?b.__garbageCollector=setInterval(function(){var c=(new Date).getTime();b.__touchEvents=a.grep(b.__touchEvents,function(a,b){return c-a.time>6e4}),d(b._$origin)||b.close(function(){b.destroy()})},2e4):clearInterval(b.__garbageCollector),b},__prepareOrigin:function(){var a=this;if(a._$origin.off("."+a.__namespace+"-triggerOpen"),h.hasTouchCapability&&a._$origin.on("touchstart."+a.__namespace+"-triggerOpen touchend."+a.__namespace+"-triggerOpen touchcancel."+a.__namespace+"-triggerOpen",function(b){a._touchRecordEvent(b)}),a.__options.triggerOpen.click||a.__options.triggerOpen.tap&&h.hasTouchCapability){var b="";a.__options.triggerOpen.click&&(b+="click."+a.__namespace+"-triggerOpen "),a.__options.triggerOpen.tap&&h.hasTouchCapability&&(b+="touchend."+a.__namespace+"-triggerOpen"),a._$origin.on(b,function(b){a._touchIsMeaningfulEvent(b)&&a._open(b)})}if(a.__options.triggerOpen.mouseenter||a.__options.triggerOpen.touchstart&&h.hasTouchCapability){var b="";a.__options.triggerOpen.mouseenter&&(b+="mouseenter."+a.__namespace+"-triggerOpen "),a.__options.triggerOpen.touchstart&&h.hasTouchCapability&&(b+="touchstart."+a.__namespace+"-triggerOpen"),a._$origin.on(b,function(b){!a._touchIsTouchEvent(b)&&a._touchIsEmulatedEvent(b)||(a.__pointerIsOverOrigin=!0,a._openShortly(b))})}if(a.__options.triggerClose.mouseleave||a.__options.triggerClose.touchleave&&h.hasTouchCapability){var b="";a.__options.triggerClose.mouseleave&&(b+="mouseleave."+a.__namespace+"-triggerOpen "),a.__options.triggerClose.touchleave&&h.hasTouchCapability&&(b+="touchend."+a.__namespace+"-triggerOpen touchcancel."+a.__namespace+"-triggerOpen"),a._$origin.on(b,function(b){a._touchIsMeaningfulEvent(b)&&(a.__pointerIsOverOrigin=!1)})}return a},__prepareTooltip:function(){var b=this,c=b.__options.interactive?"auto":"";return b._$tooltip.attr("id",b.__namespace).css({"pointer-events":c,zIndex:b.__options.zIndex}),a.each(b.__previousThemes,function(a,c){b._$tooltip.removeClass(c)}),a.each(b.__options.theme,function(a,c){b._$tooltip.addClass(c)}),b.__previousThemes=a.merge([],b.__options.theme),b},__scrollHandler:function(b){var c=this;if(c.__options.triggerClose.scroll)c._close(b);else if(d(c._$origin)&&d(c._$tooltip)){var e=null;if(b.target===h.window.document)c.__Geometry.origin.fixedLineage||c.__options.repositionOnScroll&&c.reposition(b);else{e=c.__geometry();var f=!1;if("fixed"!=c._$origin.css("position")&&c.__$originParents.each(function(b,c){var d=a(c),g=d.css("overflow-x"),h=d.css("overflow-y");if("visible"!=g||"visible"!=h){var i=c.getBoundingClientRect();if("visible"!=g&&(e.origin.windowOffset.left<i.left||e.origin.windowOffset.right>i.right))return f=!0,!1;if("visible"!=h&&(e.origin.windowOffset.top<i.top||e.origin.windowOffset.bottom>i.bottom))return f=!0,!1}return"fixed"==d.css("position")?!1:void 0}),f)c._$tooltip.css("visibility","hidden");else if(c._$tooltip.css("visibility","visible"),c.__options.repositionOnScroll)c.reposition(b);else{var g=e.origin.offset.left-c.__Geometry.origin.offset.left,i=e.origin.offset.top-c.__Geometry.origin.offset.top;c._$tooltip.css({left:c.__lastPosition.coord.left+g,top:c.__lastPosition.coord.top+i})}}c._trigger({type:"scroll",event:b,geo:e})}return c},__stateSet:function(a){return this.__state=a,this._trigger({type:"state",state:a}),this},__timeoutsClear:function(){return clearTimeout(this.__timeouts.open),this.__timeouts.open=null,a.each(this.__timeouts.close,function(a,b){clearTimeout(b)}),this.__timeouts.close=[],this},__trackerStart:function(){var a=this,b=a._$tooltip.find(".tooltipster-content");return a.__options.trackTooltip&&(a.__contentBcr=b[0].getBoundingClientRect()),a.__tracker=setInterval(function(){if(d(a._$origin)&&d(a._$tooltip)){if(a.__options.trackOrigin){var e=a.__geometry(),f=!1;c(e.origin.size,a.__Geometry.origin.size)&&(a.__Geometry.origin.fixedLineage?c(e.origin.windowOffset,a.__Geometry.origin.windowOffset)&&(f=!0):c(e.origin.offset,a.__Geometry.origin.offset)&&(f=!0)),f||(a.__options.triggerClose.mouseleave?a._close():a.reposition())}if(a.__options.trackTooltip){var g=b[0].getBoundingClientRect();g.height===a.__contentBcr.height&&g.width===a.__contentBcr.width||(a.reposition(),a.__contentBcr=g)}}else a._close()},a.__options.trackerInterval),a},_close:function(b,c,d){var e=this,f=!0;if(e._trigger({type:"close",event:b,stop:function(){f=!1}}),f||d){c&&e.__callbacks.close.push(c),e.__callbacks.open=[],e.__timeoutsClear();var g=function(){a.each(e.__callbacks.close,function(a,c){c.call(e,e,{event:b,origin:e._$origin[0]})}),e.__callbacks.close=[]};if("closed"!=e.__state){var i=!0,j=new Date,k=j.getTime(),l=k+e.__options.animationDuration[1];if("disappearing"==e.__state&&l>e.__closingTime&&e.__options.animationDuration[1]>0&&(i=!1),i){e.__closingTime=l,"disappearing"!=e.__state&&e.__stateSet("disappearing");var m=function(){clearInterval(e.__tracker),e._trigger({type:"closing",event:b}),e._$tooltip.off("."+e.__namespace+"-triggerClose").removeClass("tooltipster-dying"),a(h.window).off("."+e.__namespace+"-triggerClose"),e.__$originParents.each(function(b,c){a(c).off("scroll."+e.__namespace+"-triggerClose")}),e.__$originParents=null,a(h.window.document.body).off("."+e.__namespace+"-triggerClose"),e._$origin.off("."+e.__namespace+"-triggerClose"),e._off("dismissable"),e.__stateSet("closed"),e._trigger({type:"after",event:b}),e.__options.functionAfter&&e.__options.functionAfter.call(e,e,{event:b,origin:e._$origin[0]}),g()};h.hasTransitions?(e._$tooltip.css({"-moz-animation-duration":e.__options.animationDuration[1]+"ms","-ms-animation-duration":e.__options.animationDuration[1]+"ms","-o-animation-duration":e.__options.animationDuration[1]+"ms","-webkit-animation-duration":e.__options.animationDuration[1]+"ms","animation-duration":e.__options.animationDuration[1]+"ms","transition-duration":e.__options.animationDuration[1]+"ms"}),e._$tooltip.clearQueue().removeClass("tooltipster-show").addClass("tooltipster-dying"),e.__options.animationDuration[1]>0&&e._$tooltip.delay(e.__options.animationDuration[1]),e._$tooltip.queue(m)):e._$tooltip.stop().fadeOut(e.__options.animationDuration[1],m)}}else g()}return e},_off:function(){return this.__$emitterPrivate.off.apply(this.__$emitterPrivate,Array.prototype.slice.apply(arguments)),this},_on:function(){return this.__$emitterPrivate.on.apply(this.__$emitterPrivate,Array.prototype.slice.apply(arguments)),this},_one:function(){return this.__$emitterPrivate.one.apply(this.__$emitterPrivate,Array.prototype.slice.apply(arguments)),this},_open:function(b,c){var e=this;if(!e.__destroying&&d(e._$origin)&&e.__enabled){var f=!0;if("closed"==e.__state&&(e._trigger({type:"before",event:b,stop:function(){f=!1}}),f&&e.__options.functionBefore&&(f=e.__options.functionBefore.call(e,e,{event:b,origin:e._$origin[0]}))),f!==!1&&null!==e.__Content){c&&e.__callbacks.open.push(c),e.__callbacks.close=[],e.__timeoutsClear();var g,i=function(){"stable"!=e.__state&&e.__stateSet("stable"),a.each(e.__callbacks.open,function(a,b){b.call(e,e,{origin:e._$origin[0],tooltip:e._$tooltip[0]})}),e.__callbacks.open=[]};if("closed"!==e.__state)g=0,"disappearing"===e.__state?(e.__stateSet("appearing"),h.hasTransitions?(e._$tooltip.clearQueue().removeClass("tooltipster-dying").addClass("tooltipster-show"),e.__options.animationDuration[0]>0&&e._$tooltip.delay(e.__options.animationDuration[0]),e._$tooltip.queue(i)):e._$tooltip.stop().fadeIn(i)):"stable"==e.__state&&i();else{if(e.__stateSet("appearing"),g=e.__options.animationDuration[0],e.__contentInsert(),e.reposition(b,!0),h.hasTransitions?(e._$tooltip.addClass("tooltipster-"+e.__options.animation).addClass("tooltipster-initial").css({"-moz-animation-duration":e.__options.animationDuration[0]+"ms","-ms-animation-duration":e.__options.animationDuration[0]+"ms","-o-animation-duration":e.__options.animationDuration[0]+"ms","-webkit-animation-duration":e.__options.animationDuration[0]+"ms","animation-duration":e.__options.animationDuration[0]+"ms","transition-duration":e.__options.animationDuration[0]+"ms"}),setTimeout(function(){"closed"!=e.__state&&(e._$tooltip.addClass("tooltipster-show").removeClass("tooltipster-initial"),e.__options.animationDuration[0]>0&&e._$tooltip.delay(e.__options.animationDuration[0]),e._$tooltip.queue(i))},0)):e._$tooltip.css("display","none").fadeIn(e.__options.animationDuration[0],i),e.__trackerStart(),a(h.window).on("resize."+e.__namespace+"-triggerClose",function(b){var c=a(document.activeElement);(c.is("input")||c.is("textarea"))&&a.contains(e._$tooltip[0],c[0])||e.reposition(b)}).on("scroll."+e.__namespace+"-triggerClose",function(a){e.__scrollHandler(a)}),e.__$originParents=e._$origin.parents(),e.__$originParents.each(function(b,c){a(c).on("scroll."+e.__namespace+"-triggerClose",function(a){e.__scrollHandler(a)})}),e.__options.triggerClose.mouseleave||e.__options.triggerClose.touchleave&&h.hasTouchCapability){e._on("dismissable",function(a){a.dismissable?a.delay?(m=setTimeout(function(){e._close(a.event)},a.delay),e.__timeouts.close.push(m)):e._close(a):clearTimeout(m)});var j=e._$origin,k="",l="",m=null;e.__options.interactive&&(j=j.add(e._$tooltip)),e.__options.triggerClose.mouseleave&&(k+="mouseenter."+e.__namespace+"-triggerClose ",l+="mouseleave."+e.__namespace+"-triggerClose "),e.__options.triggerClose.touchleave&&h.hasTouchCapability&&(k+="touchstart."+e.__namespace+"-triggerClose",l+="touchend."+e.__namespace+"-triggerClose touchcancel."+e.__namespace+"-triggerClose"),j.on(l,function(a){if(e._touchIsTouchEvent(a)||!e._touchIsEmulatedEvent(a)){var b="mouseleave"==a.type?e.__options.delay:e.__options.delayTouch;e._trigger({delay:b[1],dismissable:!0,event:a,type:"dismissable"})}}).on(k,function(a){!e._touchIsTouchEvent(a)&&e._touchIsEmulatedEvent(a)||e._trigger({dismissable:!1,event:a,type:"dismissable"})})}e.__options.triggerClose.originClick&&e._$origin.on("click."+e.__namespace+"-triggerClose",function(a){e._touchIsTouchEvent(a)||e._touchIsEmulatedEvent(a)||e._close(a)}),(e.__options.triggerClose.click||e.__options.triggerClose.tap&&h.hasTouchCapability)&&setTimeout(function(){if("closed"!=e.__state){var b="",c=a(h.window.document.body);e.__options.triggerClose.click&&(b+="click."+e.__namespace+"-triggerClose "),e.__options.triggerClose.tap&&h.hasTouchCapability&&(b+="touchend."+e.__namespace+"-triggerClose"),c.on(b,function(b){e._touchIsMeaningfulEvent(b)&&(e._touchRecordEvent(b),e.__options.interactive&&a.contains(e._$tooltip[0],b.target)||e._close(b))}),e.__options.triggerClose.tap&&h.hasTouchCapability&&c.on("touchstart."+e.__namespace+"-triggerClose",function(a){e._touchRecordEvent(a)})}},0),e._trigger("ready"),e.__options.functionReady&&e.__options.functionReady.call(e,e,{origin:e._$origin[0],tooltip:e._$tooltip[0]})}if(e.__options.timer>0){var m=setTimeout(function(){e._close()},e.__options.timer+g);e.__timeouts.close.push(m)}}}return e},_openShortly:function(a){var b=this,c=!0;if("stable"!=b.__state&&"appearing"!=b.__state&&!b.__timeouts.open&&(b._trigger({type:"start",event:a,stop:function(){c=!1}}),c)){var d=0==a.type.indexOf("touch")?b.__options.delayTouch:b.__options.delay;d[0]?b.__timeouts.open=setTimeout(function(){b.__timeouts.open=null,b.__pointerIsOverOrigin&&b._touchIsMeaningfulEvent(a)?(b._trigger("startend"),b._open(a)):b._trigger("startcancel")},d[0]):(b._trigger("startend"),b._open(a))}return b},_optionsExtract:function(b,c){var d=this,e=a.extend(!0,{},c),f=d.__options[b];return f||(f={},a.each(c,function(a,b){var c=d.__options[a];void 0!==c&&(f[a]=c)})),a.each(e,function(b,c){void 0!==f[b]&&("object"!=typeof c||c instanceof Array||null==c||"object"!=typeof f[b]||f[b]instanceof Array||null==f[b]?e[b]=f[b]:a.extend(e[b],f[b]))}),e},_plug:function(b){var c=a.tooltipster._plugin(b);if(!c)throw new Error('The "'+b+'" plugin is not defined');return c.instance&&a.tooltipster.__bridge(c.instance,this,c.name),this},_touchIsEmulatedEvent:function(a){for(var b=!1,c=(new Date).getTime(),d=this.__touchEvents.length-1;d>=0;d--){var e=this.__touchEvents[d];if(!(c-e.time<500))break;e.target===a.target&&(b=!0)}return b},_touchIsMeaningfulEvent:function(a){return this._touchIsTouchEvent(a)&&!this._touchSwiped(a.target)||!this._touchIsTouchEvent(a)&&!this._touchIsEmulatedEvent(a)},_touchIsTouchEvent:function(a){return 0==a.type.indexOf("touch")},_touchRecordEvent:function(a){return this._touchIsTouchEvent(a)&&(a.time=(new Date).getTime(),this.__touchEvents.push(a)),this},_touchSwiped:function(a){for(var b=!1,c=this.__touchEvents.length-1;c>=0;c--){var d=this.__touchEvents[c];if("touchmove"==d.type){b=!0;break}if("touchstart"==d.type&&a===d.target)break}return b},_trigger:function(){var b=Array.prototype.slice.apply(arguments);return"string"==typeof b[0]&&(b[0]={type:b[0]}),b[0].instance=this,b[0].origin=this._$origin?this._$origin[0]:null,b[0].tooltip=this._$tooltip?this._$tooltip[0]:null,this.__$emitterPrivate.trigger.apply(this.__$emitterPrivate,b),a.tooltipster._trigger.apply(a.tooltipster,b),this.__$emitterPublic.trigger.apply(this.__$emitterPublic,b),this},_unplug:function(b){var c=this;if(c[b]){var d=a.tooltipster._plugin(b);d.instance&&a.each(d.instance,function(a,d){c[a]&&c[a].bridged===c[b]&&delete c[a]}),c[b].__destroy&&c[b].__destroy(),delete c[b]}return c},close:function(a){return this.__destroyed?this.__destroyError():this._close(null,a),this},content:function(a){var b=this;if(void 0===a)return b.__Content;if(b.__destroyed)b.__destroyError();else if(b.__contentSet(a),null!==b.__Content){if("closed"!==b.__state&&(b.__contentInsert(),b.reposition(),b.__options.updateAnimation))if(h.hasTransitions){var c=b.__options.updateAnimation;b._$tooltip.addClass("tooltipster-update-"+c),setTimeout(function(){"closed"!=b.__state&&b._$tooltip.removeClass("tooltipster-update-"+c)},1e3)}else b._$tooltip.fadeTo(200,.5,function(){"closed"!=b.__state&&b._$tooltip.fadeTo(200,1)})}else b._close();return b},destroy:function(){var b=this;if(b.__destroyed)b.__destroyError();else{"closed"!=b.__state?b.option("animationDuration",0)._close(null,null,!0):b.__timeoutsClear(),b._trigger("destroy"),b.__destroyed=!0,b._$origin.removeData(b.__namespace).off("."+b.__namespace+"-triggerOpen"),a(h.window.document.body).off("."+b.__namespace+"-triggerOpen");var c=b._$origin.data("tooltipster-ns");if(c)if(1===c.length){var d=null;"previous"==b.__options.restoration?d=b._$origin.data("tooltipster-initialTitle"):"current"==b.__options.restoration&&(d="string"==typeof b.__Content?b.__Content:a("<div></div>").append(b.__Content).html()),d&&b._$origin.attr("title",d),b._$origin.removeClass("tooltipstered"),b._$origin.removeData("tooltipster-ns").removeData("tooltipster-initialTitle")}else c=a.grep(c,function(a,c){return a!==b.__namespace}),b._$origin.data("tooltipster-ns",c);b._trigger("destroyed"),b._off(),b.off(),b.__Content=null,b.__$emitterPrivate=null,b.__$emitterPublic=null,b.__options.parent=null,b._$origin=null,b._$tooltip=null,a.tooltipster.__instancesLatestArr=a.grep(a.tooltipster.__instancesLatestArr,function(a,c){return b!==a}),clearInterval(b.__garbageCollector)}return b},disable:function(){return this.__destroyed?(this.__destroyError(),this):(this._close(),this.__enabled=!1,this)},elementOrigin:function(){return this.__destroyed?void this.__destroyError():this._$origin[0]},elementTooltip:function(){return this._$tooltip?this._$tooltip[0]:null},enable:function(){return this.__enabled=!0,this},hide:function(a){return this.close(a)},instance:function(){return this},off:function(){return this.__destroyed||this.__$emitterPublic.off.apply(this.__$emitterPublic,Array.prototype.slice.apply(arguments)),this},on:function(){return this.__destroyed?this.__destroyError():this.__$emitterPublic.on.apply(this.__$emitterPublic,Array.prototype.slice.apply(arguments)),this},one:function(){return this.__destroyed?this.__destroyError():this.__$emitterPublic.one.apply(this.__$emitterPublic,Array.prototype.slice.apply(arguments)),this},open:function(a){return this.__destroyed?this.__destroyError():this._open(null,a),this},option:function(b,c){return void 0===c?this.__options[b]:(this.__destroyed?this.__destroyError():(this.__options[b]=c,this.__optionsFormat(),a.inArray(b,["trigger","triggerClose","triggerOpen"])>=0&&this.__prepareOrigin(),"selfDestruction"===b&&this.__prepareGC()),this)},reposition:function(a,b){var c=this;return c.__destroyed?c.__destroyError():"closed"!=c.__state&&d(c._$origin)&&(b||d(c._$tooltip))&&(b||c._$tooltip.detach(),c.__Geometry=c.__geometry(),c._trigger({type:"reposition",event:a,helper:{geo:c.__Geometry}})),c},show:function(a){return this.open(a)},status:function(){return{destroyed:this.__destroyed,enabled:this.__enabled,open:"closed"!==this.__state,state:this.__state}},triggerHandler:function(){return this.__destroyed?this.__destroyError():this.__$emitterPublic.triggerHandler.apply(this.__$emitterPublic,Array.prototype.slice.apply(arguments)),this}},a.fn.tooltipster=function(){var b=Array.prototype.slice.apply(arguments),c="You are using a single HTML element as content for several tooltips. You probably want to set the contentCloning option to TRUE.";if(0===this.length)return this;if("string"==typeof b[0]){var d="#*$~&";return this.each(function(){var e=a(this).data("tooltipster-ns"),f=e?a(this).data(e[0]):null;if(!f)throw new Error("You called Tooltipster's \""+b[0]+'" method on an uninitialized element');if("function"!=typeof f[b[0]])throw new Error('Unknown method "'+b[0]+'"');this.length>1&&"content"==b[0]&&(b[1]instanceof a||"object"==typeof b[1]&&null!=b[1]&&b[1].tagName)&&!f.__options.contentCloning&&f.__options.debug&&console.log(c);var g=f[b[0]](b[1],b[2]);return g!==f||"instance"===b[0]?(d=g,!1):void 0}),"#*$~&"!==d?d:this}a.tooltipster.__instancesLatestArr=[];var e=b[0]&&void 0!==b[0].multiple,g=e&&b[0].multiple||!e&&f.multiple,h=b[0]&&void 0!==b[0].content,i=h&&b[0].content||!h&&f.content,j=b[0]&&void 0!==b[0].contentCloning,k=j&&b[0].contentCloning||!j&&f.contentCloning,l=b[0]&&void 0!==b[0].debug,m=l&&b[0].debug||!l&&f.debug;return this.length>1&&(i instanceof a||"object"==typeof i&&null!=i&&i.tagName)&&!k&&m&&console.log(c),this.each(function(){var c=!1,d=a(this),e=d.data("tooltipster-ns"),f=null;e?g?c=!0:m&&(console.log("Tooltipster: one or more tooltips are already attached to the element below. Ignoring."),console.log(this)):c=!0,c&&(f=new a.Tooltipster(this,b[0]),e||(e=[]),e.push(f.__namespace),d.data("tooltipster-ns",e),d.data(f.__namespace,f),f.__options.functionInit&&f.__options.functionInit.call(f,f,{origin:this}),f._trigger("init")),a.tooltipster.__instancesLatestArr.push(f)}),this},b.prototype={__init:function(b){this.__$tooltip=b,this.__$tooltip.css({left:0,overflow:"hidden",position:"absolute",top:0}).find(".tooltipster-content").css("overflow","auto"),this.$container=a('<div class="tooltipster-ruler"></div>').append(this.__$tooltip).appendTo(h.window.document.body)},__forceRedraw:function(){var a=this.__$tooltip.parent();this.__$tooltip.detach(),this.__$tooltip.appendTo(a)},constrain:function(a,b){return this.constraints={width:a,height:b},this.__$tooltip.css({display:"block",height:"",overflow:"auto",width:a}),this},destroy:function(){this.__$tooltip.detach().find(".tooltipster-content").css({display:"",overflow:""}),this.$container.remove()},free:function(){return this.constraints=null,this.__$tooltip.css({display:"",height:"",overflow:"visible",width:""}),this},measure:function(){this.__forceRedraw();var a=this.__$tooltip[0].getBoundingClientRect(),b={size:{height:a.height||a.bottom-a.top,width:a.width||a.right-a.left}};if(this.constraints){var c=this.__$tooltip.find(".tooltipster-content"),d=this.__$tooltip.outerHeight(),e=c[0].getBoundingClientRect(),f={height:d<=this.constraints.height,width:a.width<=this.constraints.width&&e.width>=c[0].scrollWidth-1};b.fits=f.height&&f.width}return h.IE&&h.IE<=11&&b.size.width!==h.window.document.documentElement.clientWidth&&(b.size.width=Math.ceil(b.size.width)+1),b}};var j=navigator.userAgent.toLowerCase();-1!=j.indexOf("msie")?h.IE=parseInt(j.split("msie")[1]):-1!==j.toLowerCase().indexOf("trident")&&-1!==j.indexOf(" rv:11")?h.IE=11:-1!=j.toLowerCase().indexOf("edge/")&&(h.IE=parseInt(j.toLowerCase().split("edge/")[1]));var k="tooltipster.sideTip";return a.tooltipster._plugin({name:k,instance:{__defaults:function(){return{arrow:!0,distance:6,functionPosition:null,maxWidth:null,minIntersection:16,minWidth:0,position:null,side:"top",viewportAware:!0}},__init:function(a){var b=this;b.__instance=a,b.__namespace="tooltipster-sideTip-"+Math.round(1e6*Math.random()),b.__previousState="closed",b.__options,b.__optionsFormat(),b.__instance._on("state."+b.__namespace,function(a){"closed"==a.state?b.__close():"appearing"==a.state&&"closed"==b.__previousState&&b.__create(),b.__previousState=a.state}),b.__instance._on("options."+b.__namespace,function(){b.__optionsFormat()}),b.__instance._on("reposition."+b.__namespace,function(a){b.__reposition(a.event,a.helper)})},__close:function(){this.__instance.content()instanceof a&&this.__instance.content().detach(),this.__instance._$tooltip.remove(),this.__instance._$tooltip=null},__create:function(){var b=a('<div class="tooltipster-base tooltipster-sidetip"><div class="tooltipster-box"><div class="tooltipster-content"></div></div><div class="tooltipster-arrow"><div class="tooltipster-arrow-uncropped"><div class="tooltipster-arrow-border"></div><div class="tooltipster-arrow-background"></div></div></div></div>');this.__options.arrow||b.find(".tooltipster-box").css("margin",0).end().find(".tooltipster-arrow").hide(),this.__options.minWidth&&b.css("min-width",this.__options.minWidth+"px"),this.__options.maxWidth&&b.css("max-width",this.__options.maxWidth+"px"),
this.__instance._$tooltip=b,this.__instance._trigger("created")},__destroy:function(){this.__instance._off("."+self.__namespace)},__optionsFormat:function(){var b=this;if(b.__options=b.__instance._optionsExtract(k,b.__defaults()),b.__options.position&&(b.__options.side=b.__options.position),"object"!=typeof b.__options.distance&&(b.__options.distance=[b.__options.distance]),b.__options.distance.length<4&&(void 0===b.__options.distance[1]&&(b.__options.distance[1]=b.__options.distance[0]),void 0===b.__options.distance[2]&&(b.__options.distance[2]=b.__options.distance[0]),void 0===b.__options.distance[3]&&(b.__options.distance[3]=b.__options.distance[1]),b.__options.distance={top:b.__options.distance[0],right:b.__options.distance[1],bottom:b.__options.distance[2],left:b.__options.distance[3]}),"string"==typeof b.__options.side){var c={top:"bottom",right:"left",bottom:"top",left:"right"};b.__options.side=[b.__options.side,c[b.__options.side]],"left"==b.__options.side[0]||"right"==b.__options.side[0]?b.__options.side.push("top","bottom"):b.__options.side.push("right","left")}6===a.tooltipster._env.IE&&b.__options.arrow!==!0&&(b.__options.arrow=!1)},__reposition:function(b,c){var d,e=this,f=e.__targetFind(c),g=[];e.__instance._$tooltip.detach();var h=e.__instance._$tooltip.clone(),i=a.tooltipster._getRuler(h),j=!1,k=e.__instance.option("animation");switch(k&&h.removeClass("tooltipster-"+k),a.each(["window","document"],function(d,k){var l=null;if(e.__instance._trigger({container:k,helper:c,satisfied:j,takeTest:function(a){l=a},results:g,type:"positionTest"}),1==l||0!=l&&0==j&&("window"!=k||e.__options.viewportAware))for(var d=0;d<e.__options.side.length;d++){var m={horizontal:0,vertical:0},n=e.__options.side[d];"top"==n||"bottom"==n?m.vertical=e.__options.distance[n]:m.horizontal=e.__options.distance[n],e.__sideChange(h,n),a.each(["natural","constrained"],function(a,d){if(l=null,e.__instance._trigger({container:k,event:b,helper:c,mode:d,results:g,satisfied:j,side:n,takeTest:function(a){l=a},type:"positionTest"}),1==l||0!=l&&0==j){var h={container:k,distance:m,fits:null,mode:d,outerSize:null,side:n,size:null,target:f[n],whole:null},o="natural"==d?i.free():i.constrain(c.geo.available[k][n].width-m.horizontal,c.geo.available[k][n].height-m.vertical),p=o.measure();if(h.size=p.size,h.outerSize={height:p.size.height+m.vertical,width:p.size.width+m.horizontal},"natural"==d?c.geo.available[k][n].width>=h.outerSize.width&&c.geo.available[k][n].height>=h.outerSize.height?h.fits=!0:h.fits=!1:h.fits=p.fits,"window"==k&&(h.fits?"top"==n||"bottom"==n?h.whole=c.geo.origin.windowOffset.right>=e.__options.minIntersection&&c.geo.window.size.width-c.geo.origin.windowOffset.left>=e.__options.minIntersection:h.whole=c.geo.origin.windowOffset.bottom>=e.__options.minIntersection&&c.geo.window.size.height-c.geo.origin.windowOffset.top>=e.__options.minIntersection:h.whole=!1),g.push(h),h.whole)j=!0;else if("natural"==h.mode&&(h.fits||h.size.width<=c.geo.available[k][n].width))return!1}})}}),e.__instance._trigger({edit:function(a){g=a},event:b,helper:c,results:g,type:"positionTested"}),g.sort(function(a,b){if(a.whole&&!b.whole)return-1;if(!a.whole&&b.whole)return 1;if(a.whole&&b.whole){var c=e.__options.side.indexOf(a.side),d=e.__options.side.indexOf(b.side);return d>c?-1:c>d?1:"natural"==a.mode?-1:1}if(a.fits&&!b.fits)return-1;if(!a.fits&&b.fits)return 1;if(a.fits&&b.fits){var c=e.__options.side.indexOf(a.side),d=e.__options.side.indexOf(b.side);return d>c?-1:c>d?1:"natural"==a.mode?-1:1}return"document"==a.container&&"bottom"==a.side&&"natural"==a.mode?-1:1}),d=g[0],d.coord={},d.side){case"left":case"right":d.coord.top=Math.floor(d.target-d.size.height/2);break;case"bottom":case"top":d.coord.left=Math.floor(d.target-d.size.width/2)}switch(d.side){case"left":d.coord.left=c.geo.origin.windowOffset.left-d.outerSize.width;break;case"right":d.coord.left=c.geo.origin.windowOffset.right+d.distance.horizontal;break;case"top":d.coord.top=c.geo.origin.windowOffset.top-d.outerSize.height;break;case"bottom":d.coord.top=c.geo.origin.windowOffset.bottom+d.distance.vertical}"window"==d.container?"top"==d.side||"bottom"==d.side?d.coord.left<0?c.geo.origin.windowOffset.right-this.__options.minIntersection>=0?d.coord.left=0:d.coord.left=c.geo.origin.windowOffset.right-this.__options.minIntersection-1:d.coord.left>c.geo.window.size.width-d.size.width&&(c.geo.origin.windowOffset.left+this.__options.minIntersection<=c.geo.window.size.width?d.coord.left=c.geo.window.size.width-d.size.width:d.coord.left=c.geo.origin.windowOffset.left+this.__options.minIntersection+1-d.size.width):d.coord.top<0?c.geo.origin.windowOffset.bottom-this.__options.minIntersection>=0?d.coord.top=0:d.coord.top=c.geo.origin.windowOffset.bottom-this.__options.minIntersection-1:d.coord.top>c.geo.window.size.height-d.size.height&&(c.geo.origin.windowOffset.top+this.__options.minIntersection<=c.geo.window.size.height?d.coord.top=c.geo.window.size.height-d.size.height:d.coord.top=c.geo.origin.windowOffset.top+this.__options.minIntersection+1-d.size.height):(d.coord.left>c.geo.window.size.width-d.size.width&&(d.coord.left=c.geo.window.size.width-d.size.width),d.coord.left<0&&(d.coord.left=0)),e.__sideChange(h,d.side),c.tooltipClone=h[0],c.tooltipParent=e.__instance.option("parent").parent[0],c.mode=d.mode,c.whole=d.whole,c.origin=e.__instance._$origin[0],c.tooltip=e.__instance._$tooltip[0],delete d.container,delete d.fits,delete d.mode,delete d.outerSize,delete d.whole,d.distance=d.distance.horizontal||d.distance.vertical;var l=a.extend(!0,{},d);if(e.__instance._trigger({edit:function(a){d=a},event:b,helper:c,position:l,type:"position"}),e.__options.functionPosition){var m=e.__options.functionPosition.call(e,e.__instance,c,l);m&&(d=m)}i.destroy();var n,o;"top"==d.side||"bottom"==d.side?(n={prop:"left",val:d.target-d.coord.left},o=d.size.width-this.__options.minIntersection):(n={prop:"top",val:d.target-d.coord.top},o=d.size.height-this.__options.minIntersection),n.val<this.__options.minIntersection?n.val=this.__options.minIntersection:n.val>o&&(n.val=o);var p;p=c.geo.origin.fixedLineage?c.geo.origin.windowOffset:{left:c.geo.origin.windowOffset.left+c.geo.window.scroll.left,top:c.geo.origin.windowOffset.top+c.geo.window.scroll.top},d.coord={left:p.left+(d.coord.left-c.geo.origin.windowOffset.left),top:p.top+(d.coord.top-c.geo.origin.windowOffset.top)},e.__sideChange(e.__instance._$tooltip,d.side),c.geo.origin.fixedLineage?e.__instance._$tooltip.css("position","fixed"):e.__instance._$tooltip.css("position",""),e.__instance._$tooltip.css({left:d.coord.left,top:d.coord.top,height:d.size.height,width:d.size.width}).find(".tooltipster-arrow").css({left:"",top:""}).css(n.prop,n.val),e.__instance._$tooltip.appendTo(e.__instance.option("parent")),e.__instance._trigger({type:"repositioned",event:b,position:d})},__sideChange:function(a,b){a.removeClass("tooltipster-bottom").removeClass("tooltipster-left").removeClass("tooltipster-right").removeClass("tooltipster-top").addClass("tooltipster-"+b)},__targetFind:function(a){var b={},c=this.__instance._$origin[0].getClientRects();if(c.length>1){var d=this.__instance._$origin.css("opacity");1==d&&(this.__instance._$origin.css("opacity",.99),c=this.__instance._$origin[0].getClientRects(),this.__instance._$origin.css("opacity",1))}if(c.length<2)b.top=Math.floor(a.geo.origin.windowOffset.left+a.geo.origin.size.width/2),b.bottom=b.top,b.left=Math.floor(a.geo.origin.windowOffset.top+a.geo.origin.size.height/2),b.right=b.left;else{var e=c[0];b.top=Math.floor(e.left+(e.right-e.left)/2),e=c.length>2?c[Math.ceil(c.length/2)-1]:c[0],b.right=Math.floor(e.top+(e.bottom-e.top)/2),e=c[c.length-1],b.bottom=Math.floor(e.left+(e.right-e.left)/2),e=c.length>2?c[Math.ceil((c.length+1)/2)-1]:c[c.length-1],b.left=Math.floor(e.top+(e.bottom-e.top)/2)}return b}}}),a});
},{"jquery":115}],137:[function(require,module,exports){
"use strict";

require("core-js/modules/es6.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChangeBangumi = void 0;

var $ = require('jquery');
/**
 * Bangumi 切换模块
 * @param {Player} player - 播放器对象
 */


var ChangeBangumi = function ChangeBangumi(player) {
  var _autoPlay = false;

  window.useH5Player = function (info) {
    $('#ACHtml5Player_loadingCover').css('background-image', "url(".concat(info.backgroundUrl, ")"));
    loadBangumi(info.sourceId, _autoPlay);
    _autoPlay = false;
  };

  setNextBangumi(pageInfo.video.videos[0].videoId);

  function setNextBangumi(id) {
    if ($(".aa-info > .container > .cont li[data-vid='".concat(id, "']")).next('li').length === 0) player.setPlayNextPartFun(null);else player.setPlayNextPartFun(function () {
      $(".aa-info > .container > .cont li[data-vid='".concat(id, "']")).each(function () {
        if ($(this).parent().hasClass('hidden')) return true;
        _autoPlay = true;
        $(this).next('li').click();
        return false;
      });
    });
  }

  function loadBangumi(id, autoPlay) {
    player.load(id, autoPlay);
    setNextBangumi(id);
  }
};

exports.ChangeBangumi = ChangeBangumi;

},{"core-js/modules/es6.object.define-property":99,"jquery":115}],138:[function(require,module,exports){
"use strict";

require("core-js/modules/es6.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChangePart = void 0;

require("core-js/modules/es7.symbol.async-iterator");

require("core-js/modules/es6.symbol");

require("core-js/modules/web.dom.iterable");

var _helper = require("./lib/helper");

var $ = require('jquery');
/**
 * 非刷新 Part 切换模块
 * @param {Player} player - 播放器对象
 */


var ChangePart = function ChangePart(player) {
  $('.part-wrap > .scroll-div > a').each(function (index, element) {
    $(element).attr('data-href', $(element).attr('href'));
    $(element).removeAttr('href');
    $(element).attr('data-id', pageInfo.videoList[index].id);
  });
  $('.part-wrap > .scroll-div > *').click(function (e) {
    e.stopPropagation();
    var link = $(e.target);
    link.siblings().removeClass('active');
    link.addClass('active');
    if (link.data('id') === pageInfo.videoId) return;
    history.pushState(null, null, link.data('href'));
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = pageInfo.videoList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var videoInfo = _step.value;

        if (videoInfo.id === link.data('id')) {
          loadPart(videoInfo.index);
          break;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  });
  getNextPart();

  function getNextPart() {
    if (pageInfo.P + 1 != pageInfo.videoList.length) {
      var netxPart = pageInfo.P + 1;
      player.setPlayNextPartFun(function () {
        activeLink(netxPart);
        loadPart(netxPart, true);
      });
      return;
    }

    player.setPlayNextPartFun(null);
  }

  function activeLink(index) {
    var videoId = pageInfo.videoList[index].id;
    var link = $(".part-wrap > .scroll-div > [data-id='".concat(videoId, "']"));
    if (link.length != 1) return;
    link.siblings().removeClass('active');
    link.addClass('active');
    history.pushState(null, null, link.data('href'));
  }

  function loadPart(index) {
    var autoplay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    pageInfo.P = index;
    pageInfo.videoId = pageInfo.videoList[index].id;
    player.load(pageInfo.videoId, autoplay);
    getPlayCount();
    getNextPart();
  }

  function getPlayCount() {
    $.getJSON("http://www.acfun.cn/content_view.aspx?contentId=".concat(pageInfo.id), function (result) {
      $('.view.fl > .sp2').text(_helper.Helper.separateNumber(result[0]));
    });
  }
};

exports.ChangePart = ChangePart;

},{"./lib/helper":145,"core-js/modules/es6.object.define-property":99,"core-js/modules/es6.symbol":110,"core-js/modules/es7.symbol.async-iterator":112,"core-js/modules/web.dom.iterable":113,"jquery":115}],139:[function(require,module,exports){
"use strict";

require("core-js/modules/es7.symbol.async-iterator");

require("core-js/modules/es6.symbol");

require("core-js/modules/web.dom.iterable");

require("core-js/modules/es6.regexp.split");

require("core-js/modules/es6.regexp.to-string");

require("core-js/modules/es6.date.to-string");

var _player = require("./lib/player");

var _ui = require("./ui");

var _Part = require("./Part");

var _Bangumi = require("./Bangumi");

var $ = require('jquery');

window.H5Player = {
  resize: function resize() {},
  isSupported: function isSupported() {
    return true;
  }
};
$(function () {
  var videoInfo = {
    videoId: pageInfo.videoId ? pageInfo.videoId : bgmInfo.videoId ? bgmInfo.videoId : pageInfo.video.videos[0].videoId,
    coverImage: pageInfo.coverImage ? pageInfo.coverImage : bgmInfo.image ? bgmInfo.image : pageInfo.video.videos[0].image
  };
  var player = new _player.Player($('#ACHtml5Player_player > video')[0], $('#ACHtml5Player_bulletScreens')[0]);
  if (pageInfo && pageInfo.videoList && pageInfo.videoList.length > 1) (0, _Part.ChangePart)(player);else if (pageInfo && pageInfo.album) (0, _Bangumi.ChangeBangumi)(player);
  (0, _ui.LoadUI)(player, videoInfo.coverImage);
  player.load(videoInfo.videoId, GetUrlParameter('autoplay') != null);

  function GetUrlParameter(parameterName) {
    var url = document.location.toString();
    var splitUrl = url.split('#');
    if (splitUrl.length === 1) return null;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = splitUrl[1].split('&')[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var parameter = _step.value;
        var splitParameter = parameter.split('=');

        if (splitParameter[0].toLowerCase() === parameterName.toLowerCase()) {
          if (splitParameter.length == 1) return '';else return decodeURIComponent(splitParameter[1]);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return null;
  }
});

},{"./Bangumi":137,"./Part":138,"./lib/player":146,"./ui":150,"core-js/modules/es6.date.to-string":95,"core-js/modules/es6.regexp.split":107,"core-js/modules/es6.regexp.to-string":108,"core-js/modules/es6.symbol":110,"core-js/modules/es7.symbol.async-iterator":112,"core-js/modules/web.dom.iterable":113,"jquery":115}],140:[function(require,module,exports){
module.exports=[
    "|∀",
    "(´ﾟДﾟ`)",
    "(;´Д`)",
    "(=ﾟωﾟ)=",
    "| ω・´)",
    "|∀` )",
    "(つд⊂)",
    "(ﾟДﾟ≡ﾟДﾟ)?!",
    "(|||ﾟДﾟ)",
    "( ﾟ∀ﾟ)",
    "(*´∀`)",
    "(*ﾟ∇ﾟ)",
    "(　ﾟ 3ﾟ)",
    "( ´_ゝ`)",
    "(・∀・)",
    "(ゝ∀･)",
    "(〃∀〃)",
    "(*ﾟ∀ﾟ*)",
    "( ﾟ∀。)",
    "σ`∀´)",
    " ﾟ∀ﾟ)σ",
    "(＞д＜)",
    "(|||ﾟдﾟ)",
    "( ;ﾟдﾟ)",
    "(>д<)",
    "･ﾟ( ﾉд`ﾟ)",
    "( TдT)",
    "(￣∇￣)",
    "(￣3￣)",
    "(￣ . ￣)",
    "(￣艸￣)",
    "(*´ω`*)",
    "(´・ω・`)",
    "(oﾟωﾟo)",
    "(ノﾟ∀ﾟ)ノ",
    "|дﾟ )",
    "┃電柱┃",
    "⊂彡☆))д`)",
    "(´∀((☆ミつ",
    "_(:з」∠)_",
    "(●′ω`●) ",
    "(｡・`ω´･)",
    "(￢ω￢)",
    "(」・ω・)」",
    "Σ( ￣□￣||)",
    "Σ( ° △ °|||)",
    "(*/ω＼*)",
    "(｡ゝω･｡)ゞ",
    "(ノ＝Д＝)ノ┻━┻",
    "┯━┯ノ(\\'－\\'ノ)",
    "(<;ゝω·）~☆"
]
},{}],141:[function(require,module,exports){
"use strict";

require("core-js/modules/es6.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ACWebSocketClient = void 0;

require("core-js/modules/es6.regexp.to-string");

require("core-js/modules/es6.date.to-string");

require("core-js/modules/es6.function.bind");

var _event2 = require("./event");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var config = {
  serverUrl: 'ws://danmaku.acfun.cn:443',
  clientId: '2a3k3748137544',
  clientHash: '14390187'
};

var ACWebSocketClient = function ACWebSocketClient(userId, userIdSHA1, udid) {
  _classCallCheck(this, ACWebSocketClient);

  var _event = new _event2.Event();

  _event.add('loaderror');

  _event.add('statuschanged');

  _event.add('onlineuserscountchanged');

  _event.add('newbulletscreenreceived');

  this.bind = _event.bind;
  this.unbind = _event.unbind;
  var close = false;
  var _status = 'ready';

  var _socket;

  this.connect = function (videoId, duration) {
    changeStatus('connecting');
    if (_socket == null) _socket = new WebSocket("".concat(config.serverUrl, "/").concat(videoId));

    _socket.onclose = function () {
      changeStatus('closed');
      _socket = null;

      if (close) {
        close = false;
        return;
      }

      if (this.reConnect != null) {
        if (this.reConnect()) {
          changeStatus('reconnecting');
          setTimeout(this.connect, 5000);
        }
      }
    };

    _socket.onerror = function (e) {
      return triggerLoaderrorEvent('CONNECTED_ERROR');
    }, _socket.onmessage = function (evt) {
      var data = JSON.parse(evt.data);

      if (typeof data.status != "undefined") {
        switch (parseInt(data.status)) {
          case 202:
            if (_status == "authenticateing") {
              var message = JSON.parse(data.msg);

              if (message.identified) {
                if (message.disabled) {
                  changeStatus("connected");
                } else {
                  changeStatus("connected_disabled");
                }
              } else {
                changeStatus("connected_notIdentified");
              }
            }

            break;

          case 600:
            _event.trigger('onlineuserscountchanged', {
              onlineUsersCount: parseInt(data.msg)
            });

        }
      } else if (data.action === 'post') _event.trigger('newbulletscreenreceived', {
        bulletScreenData: JSON.parse(data.command)
      });
    };

    _socket.onopen = function () {
      changeStatus('authenticateing');
      var authInfo = {
        client: config.clientId,
        client_ck: config.clientHash,
        vid: videoId,
        vlength: duration,
        time: new Date().getTime(),
        uid: userId,
        uid_ck: userIdSHA1
      };
      sendMessane(null, 'auth', null, JSON.stringify(authInfo));
    };
  };

  this.close = function () {
    changeStatus('closeing');

    if (_socket != null) {
      close = true;

      _socket.close();
    }
  };

  this.getStatus = function () {
    return _status;
  };

  this.refreshOnlineUsersCount = function () {
    if (!getIsConnected()) return;
    sendMessane(null, 'onlanNumber', null, 'WALLE DOES NOT HAVE PENNIS');
  };

  this.sendbulletScreen = function (stime, mode, time, color, message, size) {
    if (!getIsConnected()) return;
    sendMessane('web', 'post', udid, JSON.stringify({
      user: userId,
      stime: Math.round(stime).toString(),
      mode: mode.toString(),
      time: time.toString(),
      color: color,
      message: message,
      islock: '2',
      size: size.toString()
    }));
  };

  this.getIsConnected = getIsConnected;

  function getIsConnected() {
    return _status === 'connected' || _status === 'connected_disabled' || _status === 'connected_notIdentified';
  }

  function sendMessane(platform, acthon, udid, message) {
    if (_socket == null) return;
    if (_socket.readyState != 1) return;
    var data = {
      action: acthon,
      command: message
    };
    if (typeof platform === 'string') data.platform = platform;
    if (typeof udid === 'string') data.udid = udid;

    _socket.send(JSON.stringify(data));
  }

  function changeStatus(newStatus) {
    var oldStatus = _status;
    _status = newStatus;

    _event.trigger('statuschanged', {
      oldStatus: oldStatus,
      newStatus: newStatus
    });
  }

  function triggerLoaderrorEvent(type) {
    _event.trigger('loaderror', {
      type: type,
      message: Resources["WEBSOCKETCONNECT_".concat(type)].toString()
    });
  }
};

exports.ACWebSocketClient = ACWebSocketClient;

},{"./event":144,"core-js/modules/es6.date.to-string":95,"core-js/modules/es6.function.bind":96,"core-js/modules/es6.object.define-property":99,"core-js/modules/es6.regexp.to-string":108}],142:[function(require,module,exports){
"use strict";

require("core-js/modules/es6.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AcFunVideoAdapter = void 0;

require("core-js/modules/es7.symbol.async-iterator");

require("core-js/modules/es6.symbol");

require("core-js/modules/web.dom.iterable");

require("core-js/modules/es6.array.sort");

require("core-js/modules/es6.regexp.to-string");

require("core-js/modules/es6.date.to-string");

require("core-js/modules/es6.function.bind");

var _event2 = require("../event");

var _resources = require("../resources");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Hls = require('hls.js');

var $ = require('jquery');

var AcFunVideoAdapter = function AcFunVideoAdapter(videoElement) {
  _classCallCheck(this, AcFunVideoAdapter);

  var _hls;

  var _videoData;

  var _loaded = 0;

  var _event = new _event2.Event();

  _event.add('loadsuccess');

  _event.add('videoloadsuccess');

  _event.add('loaderror');

  _event.add('destroy');

  _event.add('qualityswitching');

  _event.add('qualityswitched');

  this.bind = _event.bind;
  this.unbind = _event.unbind;
  var config = {
    ek: {
      a1: 'bf',
      a8: 'f',
      x2: 'Kz0mooZM'
    },
    mk: {
      a3: '1z4i',
      a4: '86rv',
      a5: 'f45',
      k3: 'b7',
      nk: 'm1uN9G6c'
    },
    ctype: '86',
    ev: 4
  };

  function decode64(a) {
    if (!a) return '';
    a = a.toString();
    var b,
        c,
        d,
        e,
        f,
        g,
        h,
        i = new Array(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1);

    for (g = a.length, f = 0, h = ''; f < g;) {
      do {
        b = i[255 & a.charCodeAt(f++)];
      } while (f < g && -1 == b);

      if (-1 == b) break;

      do {
        c = i[255 & a.charCodeAt(f++)];
      } while (f < g && -1 == c);

      if (-1 == c) break;
      h += String.fromCharCode(b << 2 | (48 & c) >> 4);

      do {
        if (61 == (d = 255 & a.charCodeAt(f++))) return h;
        d = i[d];
      } while (f < g && -1 == d);

      if (-1 == d) break;
      h += String.fromCharCode((15 & c) << 4 | (60 & d) >> 2);

      do {
        if (61 == (e = 255 & a.charCodeAt(f++))) return h;
        e = i[e];
      } while (f < g && -1 == e);

      if (-1 == e) break;
      h += String.fromCharCode((3 & d) << 6 | e);
    }

    return h;
  }

  function jie(a, b) {
    for (var c, d = [], e = 0, f = '', g = 0; g < 256; g++) {
      d[g] = g;
    }

    for (g = 0; g < 256; g++) {
      e = (e + d[g] + a.charCodeAt(g % a.length)) % 256, c = d[g], d[g] = d[e], d[e] = c;
    }

    g = 0, e = 0;

    for (var h = 0; h < b.length; h++) {
      g = (g + 1) % 256, e = (e + d[g]) % 256, c = d[g], d[g] = d[e], d[e] = c, f += String.fromCharCode(b.charCodeAt(h) ^ d[(d[g] + d[e]) % 256]);
    }

    return f;
  }
  /**
   * 加载适配器
   * @param {string} videoId - 视频编号
   */


  this.load = function (videoId) {
    var qualityIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
    if (_loaded === 1) throw new Error();

    var loadHls = function loadHls(success) {
      var hls = new Hls({
        xhrSetup: function xhrSetup(xhr, url) {
          xhr.withCredentials = true;
        },
        debug: true
      });
      hls.attachMedia(videoElement);
      hls.on(Hls.Events.LEVEL_SWITCHING, function (event, data) {
        _event.trigger('qualityswitching', {
          qualityIndex: getQualityIndexByHLSQualityIndex(data.level)
        });
      });
      hls.on(Hls.Events.LEVEL_SWITCHED, function (event, data) {
        _event.trigger('qualityswitched', {
          qualityIndex: getQualityIndexByHLSQualityIndex(data.level)
        });
      });
      hls.on(Hls.Events.ERROR, function (event, data) {
        console.error(_resources.Resources.VIDEOLOAD_HLS_ERROR.fillData({
          code: data.details
        }));

        if (data.fatal) {
          switch (data.type) {
            case Hls.ErrorTypes.NETWORK_ERROR:
              console.warn(_resources.Resources.VIDEOLOAD_HLS_NETWORK_ERROR.toString());
              hls.startLoad();
              break;

            case Hls.ErrorTypes.MEDIA_ERROR:
              console.warn(_resources.Resources.VIDEOLOAD_HLS_MEDIA_ERROR.toString());
              hls.recoverMediaError();
              break;

            default:
              hls.destroy();
              triggerLoaderrorEvent('HLS_OTHER_ERROR');
              break;
          }
        }
      });
      hls.on(Hls.Events.MEDIA_ATTACHED, function () {
        return success(hls);
      });
    };

    var getVideoData = function getVideoData(_success, error) {
      $.ajax({
        type: 'GET',
        url: "http://api.aixifan.com/plays/youku/".concat(videoId),
        dataType: 'json',
        headers: {
          deviceType: 2
        },
        success: function success(result) {
          $.ajax({
            type: 'GET',
            url: 'http://player.acfun.cn/js_data',
            dataType: 'jsonp',
            data: {
              sign: result.data.embsig,
              vid: result.data.sourceId,
              ct: config.ctype,
              ev: config.ev
            },
            success: function success(result) {
              if (result.encrypt = '1') result.data = JSON.parse(jie(config.mk.nk + config.ek.x2, decode64(result.data)));

              _success(result.data);
            },
            error: error
          });
        },
        error: error
      });
    };

    var loadVideo = function loadVideo(success) {
      if (qualityIndex >= 0) _hls.loadLevel = _hls.startLevel = getQualityIndexByHLSQualityIndex(qualityIndex);

      _hls.loadSource(createM3U8ListFile(_videoData.stream));

      _hls.on(Hls.Events.MANIFEST_PARSED, function (event, data) {
        success();
      });
    };

    loadHls(function (hls) {
      _hls = hls;
      getVideoData(function (videoData) {
        _videoData = videoData;
        loadVideo(function () {
          _loaded = 1;

          _event.trigger('loadsuccess', {});
        });
      }, function () {
        triggerLoaderrorEvent('GET_DATA_FAILED');
      });
    });
  };
  /**
   * 卸载视频
   */


  this.destroy = function () {
    if (_loaded != 1) throw new Error();
    _loaded = 0;

    _hls.destroy();

    _event.trigger('destroy', {});
  };
  /**
   * 获取当前视频清晰度
   * @returns {number} 视频清晰度索引
   */


  this.getQualityIndex = function () {
    return getQualityIndexByHLSQualityIndex(_hls.currentLevel);
  };
  /**
   * 获取是否启用了自动质量选择
   */


  this.getAutoQualityEnabled = function () {
    return _hls.autoLevelEnabled;
  };
  /**
   * 获取视频清晰度列表
   * @function
   * @returns {Array} 视频清晰度索引列表（从质量差到质量好排序）
   */


  this.getQualityIndexList = getQualityIndexList;
  /**
   * 切换视频质量
   */

  this.setQualityIndex = function (qualityIndex) {
    _hls.nextLevel = getHLSQualityIndexByQualityIndex(qualityIndex);

    _hls.startLoad(0);
  };
  /**
   * 获取加载状态
   */


  this.getLoadedState = function () {
    return _loaded;
  };
  /**
   * 创建m3u8文件
   * @param {object} stream - 流信息
   */


  function createM3U8ListFile(stream) {
    var m3u8 = ['#EXTM3U\n#EXT-X-VERSION:4\n'];
    stream.sort(function (a, b) {
      return parseInt(a.quality) < parseInt(b.quality) ? 1 : parseInt(a.quality) > parseInt(b.quality) ? -1 : 0;
    });
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = stream[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _stream = _step.value;
        if (typeof _stream.m3u8 === 'string') m3u8.push("#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=".concat(Math.round(_stream.size / _stream.duration * 8), ",RESOLUTION=").concat(_stream.width, "x").concat(_stream.height, "\n").concat(_stream.m3u8, "\n"));
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return URL.createObjectURL(new Blob(m3u8, {
      type: 'application/x-mpegURL'
    }));
  }

  function triggerLoaderrorEvent(type) {
    _loaded = -1;

    _event.trigger('loaderror', {
      type: type,
      message: _resources.Resources["VIDEOLOAD_".concat(type)].toString()
    });
  }
  /**
   * 获取 HLS 的质量级别索引
   * @param {*} QualityIndex 
   */


  function getHLSQualityIndexByQualityIndex(qualityIndex) {
    if (qualityIndex === -1) return -1;
    var qualityIndexList = getQualityIndexList();

    for (var _qualityIndex = qualityIndex; qualityIndex >= 0; qualityIndex--) {
      for (var hlsQualityIndex = 0; hlsQualityIndex < qualityIndexList.length; hlsQualityIndex++) {
        if (qualityIndexList[hlsQualityIndex] === _qualityIndex) return hlsQualityIndex;
      }
    }

    return null;
  }
  /**
   * 获取的质量级别索引
   * @param {*} hlsQualityIndex 
   */


  function getQualityIndexByHLSQualityIndex(hlsQualityIndex) {
    var qualityIndexList = getQualityIndexList();
    return qualityIndexList[hlsQualityIndex];
  }
  /**
   * 获取视频清晰度列表
   * @function
   * @returns {Array} 视频清晰度索引列表（从质量差到质量好排序）
   */


  function getQualityIndexList() {
    if (_videoData === null) return null;
    var qualityIndexList = [];
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = _videoData.stream[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var stream = _step2.value;
        if (typeof stream.m3u8 === 'string') qualityIndexList.push(parseInt(stream.quality) - 1);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    qualityIndexList.sort(function (a, b) {
      return a > b ? 1 : a < b ? -1 : 0;
    });
    return qualityIndexList;
  }
};

exports.AcFunVideoAdapter = AcFunVideoAdapter;

},{"../event":144,"../resources":148,"core-js/modules/es6.array.sort":94,"core-js/modules/es6.date.to-string":95,"core-js/modules/es6.function.bind":96,"core-js/modules/es6.object.define-property":99,"core-js/modules/es6.regexp.to-string":108,"core-js/modules/es6.symbol":110,"core-js/modules/es7.symbol.async-iterator":112,"core-js/modules/web.dom.iterable":113,"hls.js":114,"jquery":115}],143:[function(require,module,exports){
"use strict";

require("core-js/modules/es6.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BulletScreen = void 0;

require("core-js/modules/es6.regexp.to-string");

require("core-js/modules/es6.date.to-string");

require("core-js/modules/es6.regexp.split");

require("core-js/modules/es7.symbol.async-iterator");

require("core-js/modules/es6.symbol");

require("core-js/modules/web.dom.iterable");

require("core-js/modules/es6.function.bind");

var openBSE = _interopRequireWildcard(require("openbse"));

var _jsCookie = _interopRequireDefault(require("js-cookie"));

var _event2 = require("./event");

var _helper = require("./helper");

var _acWebSocketClient2 = require("./acWebSocketClient");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BulletScreen =
/**
 * 
 * @param {Element} bulletElement 
 * @param {Element} videoElement 
 */
function BulletScreen(bulletElement, videoElement) {
  _classCallCheck(this, BulletScreen);

  var _event = new _event2.Event();

  var _loaded = 0;
  var _bulletScreenCount = 0;
  var _bulletScreenList = [];
  var _videoId = null;
  var _refreshOnlineUsersCountTimer = null;

  var _userId = _jsCookie.default.get('auth_key');

  _event.add('loadsuccess');

  _event.add('loaderror');

  _event.add('bulletscreencountchanged');

  _event.add('addbulletscreens');

  _event.add('destroy');

  _event.add('acwebsocketstatuschanged');

  _event.add('onlineuserscountchanged');

  this.bind = _event.bind;
  this.unbind = _event.unbind;
  var bulletScreenEngine = new openBSE.BulletScreenEngine(bulletElement, {
    defaultStyle: {
      fontFamily: 'Microsoft YaHei UI, Microsoft YaHei, SimHei, Heiti SC, sans-serif',
      borderColor: 'rgba(0,0,0,0.4)'
    },
    clock: function clock() {
      return videoElement.currentTime * 1000;
    }
  }, 'canvas');

  var _acWebSocketClient = new _acWebSocketClient2.ACWebSocketClient(_userId, _jsCookie.default.get('auth_key_ac_sha1'), _jsCookie.default.get('_did'));

  _acWebSocketClient.bind('statuschanged', function (e) {
    if (_acWebSocketClient.getIsConnected()) {
      _refreshOnlineUsersCountTimer = setInterval(_acWebSocketClient.refreshOnlineUsersCount, 10000);

      _acWebSocketClient.refreshOnlineUsersCount();
    } else clearInterval(_refreshOnlineUsersCountTimer);

    _event.trigger('acwebsocketstatuschanged', e);
  });

  _acWebSocketClient.bind('onlineuserscountchanged', function (e) {
    _event.trigger('onlineuserscountchanged', e);
  });

  _acWebSocketClient.bind('newbulletscreenreceived', function (e) {
    var speed = 0.10 + e.bulletScreenData.message.length / 200;
    var bulletScreen = {
      uuid: e.bulletScreenData.commentid,
      userid: e.bulletScreenData.user,
      text: e.bulletScreenData.message,
      type: getBulletScreenType(e.bulletScreenData.mode),
      startTime: parseFloat(e.bulletScreenData.stime) * 1000,
      style: {
        speed: speed,
        color: "#".concat(_helper.Helper.pad((e.bulletScreenData.color, 10), 6, 16)),
        size: parseInt(e.bulletScreenData.size, 10)
      }
    };

    _bulletScreenList.unshift(bulletScreen);

    if (bulletScreen.startTime >= videoElement.currentTime * 1000 && e.bulletScreenData.user != _userId) bulletScreenEngine.addBulletScreen(bulletScreen);
    _bulletScreenCount[2]++;
    triggerbulletScreenCountChangedEvent();
    triggerAddBulletScreens([bulletScreen]);
  });

  _acWebSocketClient.bind('loaderror', function (e) {
    _event.trigger('loaderror', e);
  });

  videoElement.addEventListener('playing', function () {
    if (!_loaded === 1) return;
    bulletScreenEngine.play();
  });
  videoElement.addEventListener('waiting', function () {
    if (!_loaded === 1) return;
    bulletScreenEngine.pause();
  });
  videoElement.addEventListener('pause', function () {
    if (!_loaded === 1) return;
    bulletScreenEngine.pause();
  });
  videoElement.addEventListener('ended', function () {
    if (!_loaded === 1) return;
    bulletScreenEngine.stop();
    addBulletScreenList();
  });
  videoElement.addEventListener('seeking', function () {
    if (!_loaded === 1) return;
    bulletScreenEngine.cleanScreen();
    bulletScreenEngine.pause();
  });
  videoElement.addEventListener('seeked', function () {
    if (!_loaded === 1) return;
    addBulletScreenList(videoElement.currentTime * 1000);
    if (!videoElement.paused) bulletScreenEngine.play();
  });
  videoElement.addEventListener('ratechange', function () {
    bulletScreenEngine.setOptions({
      playSpeed: videoElement.playbackRate
    });
  });
  /**
   * 加载弹幕
   * @param {string} videoId - 视频编号
   */

  this.load = function (videoId, duration) {
    if (_loaded === 1) throw new Error();

    function loadBulletScreen(_success, error) {
      $.ajax({
        type: 'GET',
        url: "http://danmu.aixifan.com/auth/".concat(videoId),
        success: function success(result) {
          $.ajax({
            type: 'GET',
            url: "http://danmu.aixifan.com/size/".concat(videoId),
            success: function success(result) {
              _bulletScreenCount = result;
              triggerbulletScreenCountChangedEvent();
              $.ajax({
                type: 'GET',
                url: "http://danmu.aixifan.com/V4/".concat(videoId, "/4073558400000/2000?order=-1"),
                dataType: "json",
                success: function success(result) {
                  var _iteratorNormalCompletion = true;
                  var _didIteratorError = false;
                  var _iteratorError = undefined;

                  try {
                    for (var _iterator = result[2][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                      var resultItem = _step.value;
                      loadBulletScreenFromResultItem(resultItem);
                    }
                  } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                      }
                    } finally {
                      if (_didIteratorError) {
                        throw _iteratorError;
                      }
                    }
                  }

                  triggerAddBulletScreens(_bulletScreenList);
                  addBulletScreenList();

                  _success();
                },
                error: error
              });
            },
            error: error
          });
        },
        error: error
      });
    }

    loadBulletScreen(function () {
      _loaded = 1;
      _videoId = videoId;

      _event.trigger('loadsuccess', {});
    }, function () {
      triggerLoaderrorEvent('REQUEST_BULLETSCREEN_FAILED');
    });
  };

  this.connect = function (duration) {
    return _acWebSocketClient.connect(_videoId, duration);
  };

  this.getVisibility = bulletScreenEngine.getVisibility;

  this.getOpacity = function () {
    return bulletScreenEngine.getOptions().opacity;
  };

  this.setOpacity = function (opacity) {
    return bulletScreenEngine.setOptions({
      opacity: opacity
    });
  };

  this.hide = bulletScreenEngine.hide;
  this.show = bulletScreenEngine.show;
  /**
   * 卸载弹幕
   */

  this.destroy = function () {
    if (_loaded != 1) throw new Error();
    _loaded = 0;
    _videoId = null;
    bulletScreenEngine.stop();

    _acWebSocketClient.close();

    _bulletScreenList = [];

    _event.trigger('destroy', {});
  };
  /**
   * 获取加载状态
   */


  this.getLoadedState = function () {
    return _loaded;
  };
  /**
   * 获取弹幕总数
   */


  this.getBulletScreenCount = function () {
    return _bulletScreenCount;
  };
  /**
   * 获取弹幕列表
   */


  this.getBulletScreenList = function () {
    return _bulletScreenList;
  };
  /**
   * 获取隐藏弹幕类型
   */


  this.getHiddenTypes = function () {
    return bulletScreenEngine.getOptions().hiddenTypes;
  };
  /**
   * 设置隐藏弹幕类型
   */


  this.setHiddenTypes = function (hiddenTypes) {
    return bulletScreenEngine.setOptions({
      hiddenTypes: hiddenTypes
    });
  };
  /**
   * 清空屏幕弹幕
   */


  this.cleanScreen = function () {
    return bulletScreenEngine.cleanScreen();
  };

  this.sendbulletScreen = function (startTime, typeName, color, text, size) {
    var type = openBSE.BulletScreenType[typeName];
    var speed = 0.10 + text.length / 200;
    bulletScreenEngine.addBulletScreen({
      text: text,
      type: type,
      startTime: startTime * 1000,
      layer: 1,
      canDiscard: false,
      style: {
        speed: speed,
        color: color,
        size: size,
        boxColor: '#6EFFFE'
      }
    });

    _acWebSocketClient.sendbulletScreen(startTime, getBulletScreenMode(type), new Date().getTime(), parseInt(color.substring(1, color.length - 2), 16), text, size);
  };
  /**
   * 从请求结果加载弹幕列表
   * @param {object} resultItem - 请求返回的结果
   */


  function loadBulletScreenFromResultItem(resultItem) {
    var info = resultItem.c.split(',');
    var text = resultItem.m;
    var speed = 0.10 + resultItem.m.length / 200;
    if (speed > 0.20) speed = 0.20;

    _bulletScreenList.unshift({
      uuid: info[6],
      userid: info[4],
      text: text,
      type: getBulletScreenType(info[2]),
      startTime: parseFloat(info[0]) * 1000,
      style: {
        speed: speed,
        color: "#".concat(_helper.Helper.pad(parseInt(info[1], 10), 6, 16)),
        size: parseInt(info[3], 10)
      }
    });
  }

  function getBulletScreenType(mode) {
    switch (parseInt(mode)) {
      case 1:
        return openBSE.BulletScreenType.rightToLeft;

      case 2:
        return openBSE.BulletScreenType.leftToRight;

      case 4:
        return openBSE.BulletScreenType.top;

      case 5:
        return openBSE.BulletScreenType.bottom;

      default:
        return openBSE.BulletScreenType.rightToLeft;
    }
  }

  function getBulletScreenMode(type) {
    switch (type) {
      case openBSE.BulletScreenType.rightToLeft:
        return 1;

      case openBSE.BulletScreenType.leftToRight:
        return 2;

      case openBSE.BulletScreenType.top:
        return 4;

      case openBSE.BulletScreenType.bottom:
        return 5;

      default:
        return 1;
    }
  }
  /**
   * 添加弹幕到弹幕引擎
   * @param {number} loadStartTime - 开始时间（单位：毫秒）
   */


  function addBulletScreenList() {
    var loadStartTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    bulletScreenEngine.cleanBulletScreenList();

    for (var _i = 0; _i < _bulletScreenList.length; _i++) {
      var bulletScreen = _bulletScreenList[_i];
      if (bulletScreen.startTime < loadStartTime - 1000) continue;
      bulletScreenEngine.addBulletScreen(bulletScreen);
    }
  }

  function triggerLoaderrorEvent(type) {
    _loaded = -1;

    _event.trigger('loaderror', {
      type: type,
      message: Resources["BULLETSCREENLOAD_".concat(type)].toString()
    });
  }

  function triggerbulletScreenCountChangedEvent() {
    _event.trigger('bulletscreencountchanged', {
      bulletScreenCount: _helper.Helper.clone(_bulletScreenCount)
    });
  }

  function triggerAddBulletScreens(newBulletScreens) {
    var cleanOld = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    _event.trigger('addbulletscreens', {
      newBulletScreens: _helper.Helper.clone(newBulletScreens),
      cleanOld: cleanOld
    });
  }

  setInterval(function () {
    if (bulletElement.clientWidth < 300) bulletScreenEngine.setOptions({
      scaling: 0.5
    });else bulletScreenEngine.setOptions({
      scaling: 1
    });
  }, 100);
};

exports.BulletScreen = BulletScreen;

},{"./acWebSocketClient":141,"./event":144,"./helper":145,"core-js/modules/es6.date.to-string":95,"core-js/modules/es6.function.bind":96,"core-js/modules/es6.object.define-property":99,"core-js/modules/es6.regexp.split":107,"core-js/modules/es6.regexp.to-string":108,"core-js/modules/es6.symbol":110,"core-js/modules/es7.symbol.async-iterator":112,"core-js/modules/web.dom.iterable":113,"js-cookie":116,"openbse":134}],144:[function(require,module,exports){
"use strict";

require("core-js/modules/es6.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Event = void 0;

require("core-js/modules/es7.symbol.async-iterator");

require("core-js/modules/es6.symbol");

require("core-js/modules/web.dom.iterable");

require("core-js/modules/es6.regexp.to-string");

require("core-js/modules/es6.date.to-string");

var _resources = require("./resources");

var _helper = require("./helper");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * 事件模型类
 */
var Event =
/**
 * 创建一个新的事件模型。
 */
function Event() {
  _classCallCheck(this, Event);

  /**
   * 事件列表
   * @private
   */
  var eventList = {};
  /**
   * 添加事件
   * @public
   * @param {string} name - 事件名称
   * @throws {TypeError} 传入的参数错误或事件已存在时引发错误。请参阅 MDN [TypeError]{@link https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError} 。
   */

  this.add = function (name) {
    if (typeof name != 'string') throw new TypeError(_resources.Resources.PARAMETERS_TYPE_ERROR.toString());
    if (typeof eventList[name] != 'undefined') throw new TypeError(_resources.Resources.EVENT_ALREADY_EXISTS_ERROR.toString());
    eventList[name] = [];
  };
  /**
   * 删除事件
   * @public
   * @param {string} name - 事件名称
   * @throws {TypeError} 传入的参数错误或事件不存在时引发错误。请参阅 MDN [TypeError]{@link https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError} 。
   */


  this.remove = function (name) {
    if (typeof name != 'string') throw new TypeError(_resources.Resources.PARAMETERS_TYPE_ERROR.toString());
    if (typeof eventList[name] === 'undefined') throw new TypeError(_resources.Resources.EVENT_NAME_NOT_FOUND_ERROR.toString());
    delete eventList[name];
  };
  /**
   * 绑定事件处理程序
   * @public
   * @param {string} name - 事件名称
   * @param {function} fun - 事件处理程序
   * @returns {number} 添加后的事件数
   * @throws {TypeError} 传入的参数错误或事件不存在时引发错误。请参阅 MDN [TypeError]{@link https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError} 。
   */


  this.bind = function (name, fun) {
    if (typeof name != 'string' || typeof fun != 'function') throw new TypeError(_resources.Resources.PARAMETERS_TYPE_ERROR.toString());
    var event = eventList[name];
    if (typeof event === 'undefined') throw new TypeError(_resources.Resources.EVENT_NAME_NOT_FOUND_ERROR.toString());

    for (var index in event) {
      if (event[index] === fun) return false;
    }

    return event.unshift(fun);
  };
  /**
   * 解绑事件处理程序（fun为空解绑所有事件处理程序）
   * @public
   * @param {string} name - 事件名称
   * @param {function} fun - 事件处理程序
   * @returns {number} 删除后的事件数
   * @throws {TypeError} 传入的参数错误或事件不存在时引发错误。请参阅 MDN [TypeError]{@link https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError} 。
   */


  this.unbind = function (name, fun) {
    if (typeof name != 'string') throw new TypeError(_resources.Resources.PARAMETERS_TYPE_ERROR.toString());
    var event = eventList[name];
    if (typeof event === 'undefined') throw new TypeError(_resources.Resources.EVENT_NAME_NOT_FOUND_ERROR.toString());
    if (typeof fun == 'function') for (var index in event) {
      if (event[index] === fun) {
        event.splice(fun, 1);
        return event.length;
      }
    } else eventList[name] = [];
  };
  /**
   * 触发事件
   * @public
   * @param {string} name - 事件名称
   * @param {object} e - 事件数据
   * @throws {TypeError} 传入的参数错误或事件不存在时引发错误。请参阅 MDN [TypeError]{@link https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError} 。
   */


  this.trigger = function (name, e) {
    if (typeof name != 'string' || _helper.Helper._typeof(e) != 'object') throw new TypeError(_resources.Resources.PARAMETERS_TYPE_ERROR.toString());
    var event = eventList[name];
    if (typeof event === 'undefined') throw new TypeError(_resources.Resources.EVENT_NAME_NOT_FOUND_ERROR.toString());
    e.type = name;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = event[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var fun = _step.value;
        if (!fun(e)) return;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return;
  };
};

exports.Event = Event;

},{"./helper":145,"./resources":148,"core-js/modules/es6.date.to-string":95,"core-js/modules/es6.object.define-property":99,"core-js/modules/es6.regexp.to-string":108,"core-js/modules/es6.symbol":110,"core-js/modules/es7.symbol.async-iterator":112,"core-js/modules/web.dom.iterable":113}],145:[function(require,module,exports){
"use strict";

require("core-js/modules/es6.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Helper = void 0;

require("core-js/modules/es6.regexp.match");

require("core-js/modules/es6.regexp.to-string");

require("core-js/modules/es6.date.to-string");

require("core-js/modules/es7.symbol.async-iterator");

require("core-js/modules/es6.symbol");

require("core-js/modules/web.dom.iterable");

var _resources = require("./resources");

/**
 * 设置值
 * @alias Helper.setValue
 * @param {*} value - 值
 * @param {*} defaultValue - 默认值
 * @param {string} type - 类型
 * @returns {*} - 值
 */
function setValue(value, defaultValue, type) {
  var returnValue;
  if (isEmpty(value)) returnValue = clone(defaultValue);else returnValue = clone(value);
  if (!isEmpty(type)) checkType(returnValue, type);else if (!isEmpty(defaultValue)) checkType(returnValue, _typeof(defaultValue));
  return returnValue;
}
/**
 * 设置多个值
 * @alias Helper.setValues
 * @param {object} values - 值
 * @param {object} defaultValues - 默认值
 * @param {object} types - 类型
 * @returns {object} - 值
 */


function setValues(values, defaultValues, types) {
  var clone = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var returnValues = clone ? setValue(values, {}) : defaultValues;

  var _values = clone ? returnValues : setValue(values, {});

  for (var key in defaultValues) {
    if (_typeof(defaultValues[key]) === 'object') returnValues[key] = setValues(_values[key], defaultValues[key], types[key]);else returnValues[key] = setValue(_values[key], defaultValues[key], types[key]);
  }

  return returnValues;
}
/**
 * 检查类型
 * @alias Helper.checkType
 * @param {string} value - 值
 * @param {string} type - 类型
 * @param {boolean} canBeNull - 可以为空
 */


function checkType(value, type) {
  var canBeNull = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  if (typeof type != 'string' && _typeof(type) != 'array') throw new TypeError(_resources.Resources.PARAMETERS_TYPE_ERROR);
  if (canBeNull && isEmpty(value)) return;

  if (_typeof(type) === 'array') {
    var flat = false;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = type[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var item = _step.value;
        if (typeof item != 'string') throw new TypeError(_resources.Resources.PARAMETERS_TYPE_ERROR);

        if (_typeof(value) === item) {
          flat = true;
          break;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (!flat) throw new TypeError(_resources.Resources.PARAMETERS_TYPE_ERROR);
  } else if (_typeof(value) != type) throw new TypeError(_resources.Resources.PARAMETERS_TYPE_ERROR);
}
/**
 * 检查多个值
 * @alias Helper.checkTypes
 * @param {object} values - 值
 * @param {object} types - 类型
 * @returns {object} - 值
 */


function checkTypes(values, types) {
  var canBeNull = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  if (canBeNull && isEmpty(values)) return;

  for (var key in types) {
    if (_typeof(types[key]) === 'object') checkTypes(values[key], types[key]);else checkType(values[key], types[key], canBeNull);
  }
}
/**
 * 检查是否为空
 * @alias Helper.isEmpty
 * @param {*} value - 值
 */


function isEmpty(value) {
  return typeof value === 'undefined' || typeof value === 'number' && isNaN(value) || value === null;
}
/**
 * 获取对象的类型（可区分数组等）
 * @alias Helper._typeof
 * @param {*} object - 对象
 */


function _typeof(object) {
  return Object.prototype.toString.call(object).slice(8, -1).toLowerCase();
}
/**
 * 克隆对象
 * @param {*} object 
 */


function clone(object) {
  var result,
      type = _typeof(object);

  if (type === 'object') result = {};else if (type === 'array') result = [];else return object;

  for (var key in object) {
    result[key] = clone(object[key]);
  }

  return result;
}
/**
 * 格式化数字（在数字前加0）
 * @param {number} num - 数字
 * @param {*} n - 位数
 * @param {number} radix - 表示数字的基数
 */


function pad(num, n) {
  var radix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
  num = num.toString(radix);
  var len = num.length;

  while (len++ < n) {
    num = "0" + num;
  }

  return num;
}
/**
 * 获取时间的文本
 * @param {*} second - 时间：单位：秒。
 */


function getTimeText(second) {
  if (typeof second != 'number' || isNaN(second) || second < 0) return '00:00';
  second = Math.round(second);
  var hour = Math.floor(second / 3600);
  second = second % 3600;
  var minute = Math.floor(second / 60);
  second = second % 60;
  return (hour === 0 ? '' : pad(hour, 2) + ':') + pad(minute, 2) + ':' + pad(second, 2);
}
/**
 * 把数字用逗号隔开
 * @param {number} n - 要分隔的数字
 */


function separateNumber(n) {
  var b = parseInt(n).toString();
  var len = b.length;

  if (len <= 3) {
    return b;
  }

  var r = len % 3;
  return r > 0 ? b.slice(0, r) + "," + b.slice(r, len).match(/\d{3}/g).join(",") : b.slice(r, len).match(/\d{3}/g).join(",");
}

function requestFullscreen(element) {
  if (typeof element.requestFullscreen === 'function') element.requestFullscreen();else if (typeof element.webkitRequestFullscreen === 'function') element.webkitRequestFullscreen();else if (typeof element.mozRequestFullScreen === 'function') element.mozRequestFullScreen();else if (typeof element.msRequestFullscreen === 'function') element.msRequestFullscreen();else if (typeof element.oRequestFullScreen === 'function') element.oRequestFullScreen();
}

function exitFullscreen() {
  if (typeof document.exitFullscreen === 'function') document.exitFullscreen();else if (typeof document.webkitExitFullscreen === 'function') document.webkitExitFullscreen();else if (typeof document.mozCancelFullScreen === 'function') document.mozCancelFullScreen();else if (typeof document.msExitFullscreen === 'function') document.msExitFullscreen();else if (typeof document.oExitFullscreen === 'function') document.oExitFullscreen();
}

function addScreenchangeEventListener(listerer, options) {
  document.addEventListener('fullscreenchange', listerer, options);
  document.addEventListener('webkitfullscreenchange', listerer, options);
  document.addEventListener('mozfullscreenchange', listerer, options);
  document.addEventListener('MSFullscreenChange', listerer, options);
  document.addEventListener('ofullscreenchange', listerer, options);
}

function getFullscreenElement() {
  if (typeof document.fullscreenElement != 'undefined') return document.fullscreenElement;else if (typeof document.webkitFullscreenElement != 'undefined') return document.webkitFullscreenElement;else if (typeof document.mozFullScreenElement != 'undefined') return document.mozFullScreenElement;else if (typeof document.msFullscreenElement != 'undefined') return document.msFullscreenElement;else if (typeof document.oFullscreenElement != 'undefined') return document.oFullscreenElement;
}
/**
 * 帮助对象
 * @namespace
 */


var Helper = {
  setValue: setValue,
  setValues: setValues,
  checkType: checkType,
  checkTypes: checkTypes,
  isEmpty: isEmpty,
  _typeof: _typeof,
  clone: clone,
  pad: pad,
  getTimeText: getTimeText,
  separateNumber: separateNumber,
  requestFullscreen: requestFullscreen,
  exitFullscreen: exitFullscreen,
  addScreenchangeEventListener: addScreenchangeEventListener,
  getFullscreenElement: getFullscreenElement
};
exports.Helper = Helper;

},{"./resources":148,"core-js/modules/es6.date.to-string":95,"core-js/modules/es6.object.define-property":99,"core-js/modules/es6.regexp.match":105,"core-js/modules/es6.regexp.to-string":108,"core-js/modules/es6.symbol":110,"core-js/modules/es7.symbol.async-iterator":112,"core-js/modules/web.dom.iterable":113}],146:[function(require,module,exports){
"use strict";

require("core-js/modules/es6.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Player = void 0;

require("core-js/modules/es7.symbol.async-iterator");

require("core-js/modules/es6.symbol");

require("core-js/modules/web.dom.iterable");

require("core-js/modules/es6.function.bind");

var _acfunVideoAdapter = require("./adapter/acfunVideoAdapter");

var _bulletScreen2 = require("./bulletScreen");

var _helper = require("./helper");

var _event2 = require("./event");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Player =
/**
 * 
 * @param {Element} videoElement 
 * @param {Element} bulletElement 
 */
function Player(videoElement, bulletElement) {
  var _this = this;

  _classCallCheck(this, Player);

  /**
   * requestAnimationFrame 定义（一些老式浏览器不支持 requestAnimationFrame ）
   * @param {function} fun - 回调方法 
   * @function
   */
  var requestAnimationFrame;
  if (typeof window.requestAnimationFrame === 'function') requestAnimationFrame = window.requestAnimationFrame;else requestAnimationFrame = function requestAnimationFrame(fun) {
    return window.setTimeout(fun, 17);
  };
  videoElement.controls = false;

  var _adapter = new _acfunVideoAdapter.AcFunVideoAdapter(videoElement);

  var _bulletScreen = new _bulletScreen2.BulletScreen(bulletElement, videoElement);

  var _event = new _event2.Event();

  var _playNextPartFun = null;
  var _playbackRate = 1;

  _event.add('loadsuccess');

  _event.add('loaderror');

  _event.add('currenttimechanged');

  _event.add('qualityswitching');

  _event.add('qualityswitched');

  _event.add('adapterdestroy');

  _event.add('bulletscreencountchanged');

  _event.add('addbulletscreens');

  _event.add('bulletscreendestroy');

  _event.add('acwebsocketstatuschanged');

  _event.add('onlineuserscountchanged');

  _event.add('loadstart');

  _event.add('progress');

  _event.add('suspend');

  _event.add('abort');

  _event.add('error');

  _event.add('emptied');

  _event.add('stalled');

  _event.add('play');

  _event.add('playing');

  _event.add('pause');

  _event.add('loadedmetadata');

  _event.add('waiting');

  _event.add('canplay');

  _event.add('canplaythrough');

  _event.add('seeking');

  _event.add('seeked');

  _event.add('timeupdate');

  _event.add('ended');

  _event.add('ratechanged');

  _event.add('druationchange');

  _event.add('volumeormutedchanged');

  this.bind = _event.bind;
  this.unbind = _event.unbind;

  _adapter.bind('loadsuccess', function () {
    if (_bulletScreen.getLoadedState() != 0) _event.trigger('loadsuccess', {});
  });

  _bulletScreen.bind('loadsuccess', function () {
    if (_adapter.getLoadedState() === 1) _event.trigger('loadsuccess', {});
  });

  _adapter.bind('destroy', function () {
    _event.trigger('bulletscreendestroy', {});
  });

  _bulletScreen.bind('destroy', function () {
    _event.trigger('adapterdestroy', {});
  });

  _adapter.bind('loaderror', function (e) {
    _event.trigger('loaderror', e);
  });

  _adapter.bind('qualityswitching', function (e) {
    _event.trigger('qualityswitching', e);
  });

  _adapter.bind('qualityswitched', function (e) {
    _event.trigger('qualityswitched', e);
  });

  _bulletScreen.bind('bulletscreencountchanged', function (e) {
    var count = 0;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = e.bulletScreenCount[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var n = _step.value;
        count += n;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    e.bulletScreenCountText = _helper.Helper.separateNumber(count);

    _event.trigger('bulletscreencountchanged', e);
  });

  _bulletScreen.bind('addbulletscreens', function (e) {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = e.newBulletScreens[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var bulletScreen = _step2.value;
        bulletScreen.startTimeText = _helper.Helper.getTimeText(bulletScreen.startTime /= 1000);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    _event.trigger('addbulletscreens', e);
  });

  _bulletScreen.bind('loaderror', function (e) {
    console.warn("".concat(e.type, " ").concat(e.message));
    if (_adapter.getLoadedState() === 1) _event.trigger('loadsuccess', {});
  });

  _bulletScreen.bind('acwebsocketstatuschanged', function (e) {
    _event.trigger('acwebsocketstatuschanged', e);
  });

  _bulletScreen.bind('onlineuserscountchanged', function (e) {
    e.onlineUsersCountText = _helper.Helper.separateNumber(e.onlineUsersCount);

    _event.trigger('onlineuserscountchanged', e);
  });

  videoElement.addEventListener('loadstart', function () {
    _event.trigger('loadstart', {});
  });
  videoElement.addEventListener('progress', function () {
    _event.trigger('progress', {});
  });
  videoElement.addEventListener('suspend', function () {
    _event.trigger('suspend', {});
  });
  videoElement.addEventListener('abort', function () {
    _event.trigger('abort', {});
  });
  videoElement.addEventListener('error', function () {
    _event.trigger('error', {});
  });
  videoElement.addEventListener('emptied', function () {
    _event.trigger('emptied', {});
  });
  videoElement.addEventListener('stalled', function () {
    _event.trigger('stalled', {});
  });
  videoElement.addEventListener('play', function () {
    _event.trigger('play', {});
  });
  videoElement.addEventListener('playing', function () {
    _event.trigger('playing', {});
  });
  videoElement.addEventListener('pause', function () {
    _event.trigger('pause', {});
  });
  videoElement.addEventListener('loadedmetadata', function () {
    _bulletScreen.connect(Math.round(videoElement.duration));

    _event.trigger('loadedmetadata', {});
  });
  videoElement.addEventListener('waiting', function () {
    _event.trigger('waiting', {});
  });
  videoElement.addEventListener('canplay', function () {
    videoElement.playbackRate = _playbackRate;

    _event.trigger('canplay', {});
  });
  videoElement.addEventListener('canplaythrough', function () {
    _event.trigger('canplaythrough', {});
  });
  videoElement.addEventListener('seeking', function () {
    _event.trigger('seeking', {});
  });
  videoElement.addEventListener('seeked', function () {
    _event.trigger('seeked', {});
  });
  videoElement.addEventListener('timeupdate', function () {
    _event.trigger('timeupdate', {});
  });
  videoElement.addEventListener('ended', function () {
    _event.trigger('ended', {});

    if (_playNextPartFun != null) _playNextPartFun();
  });
  videoElement.addEventListener('ratechange', function () {
    _event.trigger('ratechanged', {
      playbackRate: videoElement.playbackRate
    });
  });
  videoElement.addEventListener('druationchange', function () {
    _event.trigger('druationchange', {});
  });
  videoElement.addEventListener('volumechange', function () {
    _event.trigger('volumeormutedchanged', {
      volume: videoElement.muted ? 0 : videoElement.volume,
      muted: videoElement.muted
    });
  });

  this.load = function (videoId) {
    var autoplay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    _this.destroy();

    videoElement.autoplay = autoplay;

    _adapter.load(videoId, -1);

    _bulletScreen.load(videoId);
  };

  this.destroy = function () {
    if (_adapter.getLoadedState() === 1) {
      _adapter.destroy();
    }

    if (_bulletScreen.getLoadedState() === 1) _bulletScreen.destroy();
  };

  this.play = videoElement.play;
  this.pause = videoElement.pause;

  this.changePlayState = function () {
    if (videoElement.paused) videoElement.play();else videoElement.pause();
  };

  this.stop = function () {
    videoElement.pause();
    videoElement.currentTime = 0;
  };

  this.getPaused = function () {
    return videoElement.paused;
  };

  this.getLoop = function () {
    return videoElement.loop;
  };

  this.setLoop = function (loop) {
    videoElement.loop = loop;
  };

  this.getMuted = function () {
    return videoElement.muted;
  };

  this.setMuted = function (muted) {
    videoElement.muted = muted;
    if (videoElement.volume === 0 && !muted) videoElement.volume = 0.5;
  };

  this.getVolume = function () {
    return videoElement.volume;
  };

  this.setVolume = function (volume) {
    if (volume < 0) volume = 0;else if (volume > 1) volume = 1;
    videoElement.volume = volume;
    if (volume === 0) videoElement.muted = true;else videoElement.muted = false;
  };

  this.getCurrentTime = function () {
    return videoElement.currentTime;
  };

  this.setCurrentTime = function (currentTime) {
    if (currentTime < 0) currentTime = 0;else if (currentTime > videoElement.duration) currentTime = videoElement.duration;
    videoElement.currentTime = currentTime;
  };

  this.getPlaybackRate = function () {
    return _playbackRate;
  };

  this.setPlaybackRate = function (playbackRate) {
    _playbackRate = videoElement.playbackRate = playbackRate;
  };

  this.getBulletScreenOpacity = _bulletScreen.getOpacity;
  this.setBulletScreenOpacity = _bulletScreen.setOpacity;

  this.getDuration = function () {
    return videoElement.duration;
  };

  this.getBulletScreenVisibility = _bulletScreen.getVisibility;
  /**
   * 获取隐藏弹幕类型
   */

  this.getBulletScreenHiddenTypes = _bulletScreen.getHiddenTypes;
  /**
   * 设置隐藏弹幕类型
   */

  this.setBulletScreenHiddenTypes = _bulletScreen.setHiddenTypes;
  this.hideBulletScreen = _bulletScreen.hide;
  this.showBulletScreen = _bulletScreen.show;
  /**
   * 获取当前视频清晰度
   * @function
   * @returns {number} 视频清晰度索引
   */

  this.getQualityIndex = _adapter.getQualityIndex;
  /**
   * 获取是否启用了自动质量选择
   * @function
   */

  this.getAutoQualityEnabled = _adapter.getAutoQualityEnabled;
  /**
   * 获取视频清晰度列表
   * @function
   * @returns {Array} 视频清晰度索引列表（从质量差到质量好排序）
   */

  this.getQualityIndexList = _adapter.getQualityIndexList;
  /**
   * 切换视频质量
   */

  this.setQualityIndex = _adapter.setQualityIndex;
  /**
   * 清空屏幕弹幕
   */

  this.cleanBulletScreen = _bulletScreen.cleanScreen;

  this.changeBulletScreenVisibility = function () {
    if (_bulletScreen.getVisibility()) _bulletScreen.hide();else _bulletScreen.show();
  };

  this.setPlayNextPartFun = function (playNextPartFun) {
    _playNextPartFun = playNextPartFun;
  };

  this.getHasNextPart = function () {
    return _playNextPartFun != null;
  };

  this.playNextPart = function () {
    return _playNextPartFun();
  };

  this.sendbulletScreen = function (formData) {
    _bulletScreen.sendbulletScreen(videoElement.currentTime, formData.get('type'), formData.get('color'), formData.get('text'), parseInt(formData.get('size')));
  };
  /**
   * 获取缓冲进度
   */


  function _getBufferProgress() {
    var currentTime = videoElement.currentTime;
    var duration = videoElement.duration;
    if (typeof currentTime != 'number' || isNaN(currentTime) || typeof duration != 'number' || isNaN(duration) || duration === 0) return 0;
    var buffered = videoElement.buffered;

    if (buffered != null && buffered.length > 0) {
      for (var i = 0; i < buffered.length; i++) {
        if (buffered.start(i) <= currentTime && buffered.end(i) > currentTime) return buffered.end(i) / duration;
      }
    }

    return currentTime / duration;
  }

  this.getBufferProgress = _getBufferProgress;

  var triggerCurrentTimeChanged = function triggerCurrentTimeChanged() {
    var currentTime;
    var duration;

    var bufferProgress = _getBufferProgress();

    currentTime = videoElement.currentTime;
    duration = videoElement.duration;
    if (typeof currentTime != 'number' || isNaN(currentTime)) currentTime = 0;
    if (typeof duration != 'number' || isNaN(duration)) duration = 0;

    _event.trigger('currenttimechanged', {
      currentTime: currentTime,
      duration: duration,
      percent: currentTime === 0 ? 0 : currentTime / duration * 100,
      bufferProgress: bufferProgress,
      bufferPercent: bufferProgress * 100,
      currentTimeText: _helper.Helper.getTimeText(currentTime),
      durationText: _helper.Helper.getTimeText(duration)
    });

    requestAnimationFrame(triggerCurrentTimeChanged);
  };

  requestAnimationFrame(triggerCurrentTimeChanged);
};

exports.Player = Player;

},{"./adapter/acfunVideoAdapter":142,"./bulletScreen":143,"./event":144,"./helper":145,"core-js/modules/es6.function.bind":96,"core-js/modules/es6.object.define-property":99,"core-js/modules/es6.symbol":110,"core-js/modules/es7.symbol.async-iterator":112,"core-js/modules/web.dom.iterable":113}],147:[function(require,module,exports){
module.exports={
    "EVENT_NAME_NOT_FOUND_ERROR": "Event name not found.",
    "EVENT_ALREADY_EXISTS_ERROR": "Event already exists.",
    "PARAMETERS_TYPE_ERROR": "Parameters type error.",
    "VIDEOLOAD_GET_DATA_FAILED": "视频信息加载失败。",
    "VIDEOLOAD_HLS_NETWORK_ERROR": "网络错误。尝试恢复。",
    "VIDEOLOAD_HLS_MEDIA_ERROR": "媒体/视频错误。尝试恢复。",
    "VIDEOLOAD_HLS_OTHER_ERROR": "未知错误。",
    "VIDEOLOAD_HLS_ERROR": "HLS 错误代码：{code}",
    "BULLETSCREENLOAD_REQUEST_BULLETSCREEN_FAILED": "弹幕获取失败。",
    "WEBSOCKETCONNECT_CONNECTED_ERROR": "套接字连接错误。"
}
},{}],148:[function(require,module,exports){
"use strict";

require("core-js/modules/es6.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Resources = void 0;

require("core-js/modules/es7.symbol.async-iterator");

require("core-js/modules/es6.symbol");

require("core-js/modules/es6.regexp.constructor");

require("core-js/modules/es6.regexp.replace");

var Resources = _interopRequireWildcard(require("./resources.json"));

exports.Resources = Resources;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * 数据填充（占位符拼接）
 * @param {object|...string} sign - 一组字符串或一个对象
 */
function fillData() {
  if (arguments.length === 0) return this;
  var param = arguments[0],
      str = this;

  if (_typeof(param) === 'object') {
    for (var key in param) {
      str = str.replace(new RegExp("\\{" + key + "\\}", "g"), param[key]);
    }

    return str;
  } else {
    for (var i = 0; i < arguments.length; i++) {
      str = str.replace(new RegExp("\\{" + i + "\\}", "g"), arguments[i]);
    }

    return str;
  }
}

for (var key in Resources) {
  if (typeof Resources[key] === 'string') {
    Resources[key] = new String(Resources[key]);
    Resources[key].fillData = fillData;
  }
}

},{"./resources.json":147,"core-js/modules/es6.object.define-property":99,"core-js/modules/es6.regexp.constructor":102,"core-js/modules/es6.regexp.replace":106,"core-js/modules/es6.symbol":110,"core-js/modules/es7.symbol.async-iterator":112}],149:[function(require,module,exports){
"use strict";

require("core-js/modules/es6.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SlideBar = void 0;

require("core-js/modules/es6.function.bind");

var _event2 = require("./event");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var $ = require('jquery');

var SlideBar = function SlideBar(element) {
  var _this = this;

  var big = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var vertical = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  _classCallCheck(this, SlideBar);

  var SlideBarElement = $('<div class="ACHtml5Player-slideBar"></div>');
  SlideBarElement.addClass(big ? 'big' : 'small');
  SlideBarElement.addClass(vertical ? 'vertical' : 'horizontal');
  var slideBarFillElement = $('<div class="ACHtml5Player-slideBarFill"></div>');
  var slideBarHandShank = $('<div class="ACHtml5Player-slideBarHandShank"></div>');
  slideBarFillElement.append(slideBarHandShank);
  SlideBarElement.append(slideBarFillElement);
  $(element).append(SlideBarElement);
  var mousedown = false;
  slideBarHandShank.mousedown(function () {
    mousedown = true;
  });
  var _value = 0;

  var _event = new _event2.Event();

  _event.add('valuechanged');

  _event.add('valuechangedbyui');

  this.bind = _event.bind;
  this.unbind = _event.unbind;
  $('body').mouseup(function () {
    mousedown = false;
  });
  $('body').mouseleave(function () {
    mousedown = false;
  });
  $('body').mousemove(function (e) {
    if (mousedown) {
      if (SlideBarElement.innerHeight() === 0 || SlideBarElement.innerWidth() === 0) {
        mousedown = false;
        return;
      }

      var value;

      if (vertical) {
        var Y = e.pageY - SlideBarElement.offset().top;
        value = 1 - Y / SlideBarElement.innerHeight();
      } else {
        var X = e.pageX - SlideBarElement.offset().left;
        value = X / SlideBarElement.innerWidth();
      }

      _value = value > 1 ? 1 : value < 0 ? 0 : value;

      _this.set(_value);

      _event.trigger('valuechangedbyui', {
        value: _value
      });
    }
  });
  SlideBarElement.click(function (e) {
    if (SlideBarElement.height() === 0 || SlideBarElement.width() === 0) {
      mousedown = false;
      return;
    }

    var value;

    if (vertical) {
      var Y = e.pageY - SlideBarElement.offset().top;
      value = 1 - Y / SlideBarElement.innerHeight();
    } else {
      var X = e.pageX - SlideBarElement.offset().left;
      value = X / SlideBarElement.innerWidth();
    }

    _value = value > 1 ? 1 : value < 0 ? 0 : value;

    _this.set(_value);

    _event.trigger('valuechangedbyui', {
      value: _value
    });
  });

  this.set = function (value) {
    if (typeof value != 'number' || isNaN(value) || value > 1 || value < 0) throw new TypeError();
    if (vertical) slideBarFillElement.css('height', value * 100 + '%');else slideBarFillElement.css('width', value * 100 + '%');

    _event.trigger('valuechanged', {
      value: value
    });
  };

  this.get = function () {
    return _value;
  };
};

exports.SlideBar = SlideBar;

},{"./event":144,"core-js/modules/es6.function.bind":96,"core-js/modules/es6.object.define-property":99,"jquery":115}],150:[function(require,module,exports){
"use strict";

require("core-js/modules/es6.object.define-property");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LoadUI = void 0;

require("core-js/modules/es6.array.find");

require("core-js/modules/es7.symbol.async-iterator");

require("core-js/modules/es6.symbol");

require("core-js/modules/web.dom.iterable");

require("core-js/modules/es6.function.bind");

var _helper = require("./lib/helper");

var _slideBar = require("./lib/slideBar");

var _emoticons = _interopRequireDefault(require("./emoticons.json"));

var _perfectScrollbar = _interopRequireDefault(require("perfect-scrollbar"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var $ = require('jquery');

$ = require('tooltipster');
var qualityName = ['标清', '高清', '超清', '1080p'];

var LoadUI = function LoadUI(player, coverImage) {
  $('#player').css('position', '');
  $('.noflash-alert').remove();
  $('#ACHtml5Player_loadingCover').css('background-image', "url(".concat(coverImage, ")"));
  var bulletScreenScrollbar = new _perfectScrollbar.default('.ACHtml5Player-bulletScreenScrolly', {
    suppressScrollX: true
  });
  var boxEmoticonsScrollbar = new _perfectScrollbar.default('.ACHtml5Player-boxEmoticonsScrolly', {
    suppressScrollX: true
  });
  var volumeSlideBar = new _slideBar.SlideBar('#ACHtml5Player_volumeSlideBarBox', true, true);
  var bulletScreenOpacitySlideBar = new _slideBar.SlideBar('#ACHtml5Player_bulletScreenOpacitySlideBarBox', true, false);
  $('#ACHtml5Player_bulletScreenOpacitySlideBarBox .ACHtml5Player-slideBarHandShank').append('<span><span id="ACHtml5Player_bulletScreenOpacityNumber">0</span>%</span>');
  player.bind('loadsuccess', function () {
    loadQualityList();
    setBtnQuality();
  });
  player.bind('bulletscreendestroy', function () {
    $('#ACHtml5Player_bulletScreenList').empty();
    $('#ACHtml5Player_bulletScreenEmpty').show();
  });
  player.bind('adapterdestroy', function () {
    $('#ACFlashPlayer').remove();
    $('#ACHtml5Player_loadingShade').show();
  });
  player.bind('loadedmetadata', function () {
    setBtnNext();
    $('#ACHtml5Player_loadingShade').hide();
    $('#ACHtml5Player_acfunPlayPauseAnimate').addClass('ACHtml5Player-acfunPlayPauseAnimate-show');
  });
  player.bind('play', function () {
    $('#ACHtml5Player_btnPlayPause').removeClass('ACHtml5Player-resource-play');
    $('#ACHtml5Player_btnPlayPause').addClass('ACHtml5Player-resource-pause');
    $('#ACHtml5Player_acfunPlayPauseAnimate').removeClass('ACHtml5Player-acfunPlayPauseAnimate-show');
    $('#ACHtml5Player_acfunPlayPauseAnimate').addClass('ACHtml5Player-acfunPlayPauseAnimate-hide');
  });

  var _pauseEvent = function _pauseEvent() {
    $('#ACHtml5Player_btnPlayPause').removeClass('ACHtml5Player-resource-pause');
    $('#ACHtml5Player_btnPlayPause').addClass('ACHtml5Player-resource-play');
    $('#ACHtml5Player_acfunPlayPauseAnimate').removeClass('ACHtml5Player-acfunPlayPauseAnimate-hide');
    $('#ACHtml5Player_acfunPlayPauseAnimate').addClass('ACHtml5Player-acfunPlayPauseAnimate-show');
  };

  player.bind('emptied', _pauseEvent);
  player.bind('pause', _pauseEvent);
  player.bind('currenttimechanged', function (e) {
    $('#ACHtml5Player_textCurrentTime').text(e.currentTimeText);
    $('#ACHtml5Player_textDuration').text(e.durationText);
    $('#ACHtml5Player_progressBarBuffer').css('width', "".concat(e.bufferPercent, "%"));
    if (progressMousedown) return;
    $('#ACHtml5Player_progressBarComplete').css('width', "".concat(e.percent, "%"));
  });
  player.bind('bulletscreencountchanged', function (e) {
    $('.danmu.fl > .sp2').text(e.bulletScreenCountText);
    $('#ACHtml5Player_bulletScreenCount').text(e.bulletScreenCountText);
  });
  player.bind('onlineuserscountchanged', function (e) {
    $('#ACHtml5Player_onlineUsersCount').text(e.onlineUsersCountText);
  });
  player.bind('acwebsocketstatuschanged', function (e) {
    if (e.newStatus === 'connected') $('#ACHtml5Player_btnBulletScreenSend').removeClass('disable');else $('#ACHtml5Player_btnBulletScreenSend').addClass('disable');
  });
  player.bind('qualityswitching', function (e) {
    setBtnQuality(e.qualityIndex);
  });
  player.bind('qualityswitched', function (e) {
    setBtnQuality(e.qualityIndex);
  });
  4;
  player.bind('addbulletscreens', function (e) {
    if (e.cleanOld) {
      $('#ACHtml5Player_bulletScreenList').empty();
      $('#ACHtml5Player_bulletScreenEmpty').show();
    }

    if (e.newBulletScreens.length > 0) $('#ACHtml5Player_bulletScreenEmpty').hide();
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = e.newBulletScreens[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var bulletScreen = _step.value;
        var tr = $('<tr></tr>');
        tr.attr('data-uuid', bulletScreen.uuid);
        tr.attr('data-userid', bulletScreen.userid);
        tr.attr('data-starttime', bulletScreen.startTime);
        var startTimeTh = $('<th style="width:45px;text-align:center" class="ACHtml5Player-textTooltip"></th>');
        startTimeTh.text(bulletScreen.startTimeText);
        startTimeTh.attr('title', bulletScreen.startTimeText);
        tr.append(startTimeTh);
        var textTh = $('<th class="ACHtml5Player-textTooltip"></th>');
        textTh.text(bulletScreen.text);
        textTh.attr('title', bulletScreen.text);
        tr.append(textTh);
        $('#ACHtml5Player_bulletScreenList').prepend(tr);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    bulletScreenScrollbar.update();
    loadTextToolTip();
  });
  player.bind('volumeormutedchanged', function (e) {
    setVolmueAndMuted(e.volume, e.muted);
  });
  player.bind('ratechanged', function (e) {
    $('#ACHtml5Player_btnSpeed > span').text(e.playbackRate === 1 ? '倍速' : "".concat(e.playbackRate, "\u500D"));
  });
  bulletScreenOpacitySlideBar.bind('valuechanged', function (e) {
    $('#ACHtml5Player_bulletScreenOpacityNumber').text(Math.round(e.value * 100));
  });
  bulletScreenOpacitySlideBar.bind('valuechangedbyui', function (e) {
    player.setBulletScreenOpacity(e.value);
  });
  volumeSlideBar.bind('valuechanged', function (e) {
    $('#ACHtml5Player_volumeNumber').text(Math.round(e.value * 100));
  });
  volumeSlideBar.bind('valuechangedbyui', function (e) {
    player.setVolume(e.value);
  });
  $('#ACHtml5Player').keypress(function (e) {
    if (e.target.id === 'ACHtml5Player_bulletScreenInput') return true;

    switch (e.which) {
      case 32:
        player.changePlayState();
        return false;

      case 13:
        $('#ACHtml5Player_bulletScreenInput').focus();
        return false;

      case 67:
        if (e.shiftKey) {
          player.changeBulletScreenVisibility();
          setBtnBulletScreenIcon();
          return false;
        }

        break;

      case 79:
        if (e.shiftKey) {
          player.setLoop(!player.getLoop());
          setBtnLoopIcon();
          return false;
        }

        break;

      case 77:
        if (e.shiftKey) {
          player.setMuted(!player.getMuted());
          return false;
        }

        break;

      case 70:
        if (e.shiftKey) {
          changeFullScreen();
          return false;
        }

        break;

      case 81:
        if (e.shiftKey) {
          player.cleanBulletScreen();
          return false;
        }

        break;

      case 90:
        if (e.shiftKey) {
          changeFoldVisibility();
          return false;
        }

        break;
    }

    return true;
  });
  $('#ACHtml5Player').keydown(function (e) {
    if (e.target.id === 'ACHtml5Player_bulletScreenInput') return true;

    switch (e.which) {
      case 37:
        if (e.ctrlKey) player.setCurrentTime(player.getCurrentTime() - 20);else if (e.shiftKey) player.setCurrentTime(player.getCurrentTime() - 30);else player.setCurrentTime(player.getCurrentTime() - 10);
        return false;

      case 39:
        if (e.ctrlKey) player.setCurrentTime(player.getCurrentTime() + 20);else if (e.shiftKey) player.setCurrentTime(player.getCurrentTime() + 30);else player.setCurrentTime(player.getCurrentTime() + 10);
        return false;

      case 38:
        player.setVolume(player.getVolume() + 0.1);
        return false;

      case 40:
        player.setVolume(player.getVolume() - 0.1);
        return false;
    }

    return true;
  });
  $('#ACHtml5Player_bulletScreenInput').keydown(function (e) {
    if (e.which === 27) {
        $('#ACHtml5Player').focus();
        return false;
      }

    return true;
  });
  $('#ACHtml5Player_btnVolume').click(function (e) {
    if (e.target != this) return;
    player.setMuted(!player.getMuted());
  });
  $('#ACHtml5Player_bulletScreenList').click(function (e) {
    if (e.target.tagName.toLowerCase() === 'th') player.setCurrentTime(parseFloat($(e.target).parent('tr').data('starttime')));
  });
  $('#ACHtml5Player_acfunPlayPauseAnimate').click(function (e) {
    if ($(e.target).hasClass('ACHtml5Player-acfunPlayPauseAnimate-show')) player.changePlayState();
  });
  $('#ACHtml5Player_btnPlayPause').click(function () {
    player.changePlayState();
  });
  $('#ACHtml5Player_btnNext').click(function () {
    player.playNextPart();
  });
  var bulletScreensClickTimer = null;
  $('#ACHtml5Player_bulletScreens').click(function () {
    clearTimeout(bulletScreensClickTimer);
    bulletScreensClickTimer = setTimeout(player.changePlayState, 500);
  });
  $('#ACHtml5Player_bulletScreens').dblclick(function (e) {
    clearTimeout(bulletScreensClickTimer);
    changeFullScreen();
  });
  $('#ACHtml5Player_btnBulletScreen').click(function (e) {
    if (e.target != this) return;
    player.changeBulletScreenVisibility();
    setBtnBulletScreenIcon();
  });
  $('#ACHtml5Player_btnLoop').click(function () {
    player.setLoop(!player.getLoop());
    setBtnLoopIcon();
  });
  $('#ACHtml5Player_bulletScreenSendForm').submit(function (e) {
    var btn = $('#ACHtml5Player_btnBulletScreenSend');
    if (btn.hasClass('disable') || btn.hasClass('countdown')) return;
    var countdownNumber = 3;

    var countdown = function countdown() {
      if (countdownNumber === 0) btn.removeClass('countdown');else {
        $('#ACHtml5Player_btnBulletScreenSend_countdownNumber').text(countdownNumber--);
        setTimeout(countdown, 1000);
      }
    };

    btn.addClass('countdown');
    countdown();
    player.sendbulletScreen(new FormData($('#ACHtml5Player_bulletScreenSendForm')[0]));
    $('#ACHtml5Player_bulletScreenSendForm input[name="text"]').val('');
    return false;
  });
  $('#ACHtml5Player_qualityList').click(function (e) {
    if (e.target.tagName.toLowerCase() === 'li') {
      var qualityIndex = $(e.target).data('index');
      player.setQualityIndex(qualityIndex);
      $('#ACHtml5Player_btnQuality > span').text(qualityIndex === -1 ? "\u81EA\u52A8\uFF08".concat(qualityName[player.getQualityIndex()], "\uFF09") : qualityName[qualityIndex]);
    }
  });
  $('#ACHtml5Player_speedList').click(function (e) {
    if (e.target.tagName.toLowerCase() === 'li') player.setPlaybackRate($(e.target).data('rate'));
  });
  $('#ACHtml5Player_boxEmoticons').click(function (e) {
    if ($(e.target).hasClass('ACHtml5Player-btnEmoticons')) {
      var input = $('#ACHtml5Player_bulletScreenSendForm input[name="text"]');
      input.val(input.val() + $(e.target).text());
    }
  });
  $('#ACHtml5Player_foldBar').click(changeFoldVisibility);
  $('#ACHtml5Player_popupBulletScreenForm').click(function () {
    var formData = new FormData($('#ACHtml5Player_popupBulletScreenForm')[0]);
    var hiddenTypesList = formData.getAll('hiddenTypes');
    var hiddenTypes = 0;

    for (var index in hiddenTypesList) {
      hiddenTypes += parseInt(hiddenTypesList[index]);
    }

    player.setBulletScreenHiddenTypes(hiddenTypes);
  });
  $('#ACHtml5Player_progressBar').click(function (e) {
    if ($(e.target).hasClass('ACHtml5Player-progressBarTip') || $(e.target).hasClass('ACHtml5Player-progressBarHandShank')) return;
    var time = parseFloat($('#ACHtml5Player_progressBarTip').attr('data-time'));
    if (isNaN(time)) return;
    player.setCurrentTime(time);
  });
  $('#ACHtml5Player_progressBar').mousemove(function (e) {
    if ($(e.target).hasClass('ACHtml5Player-progressBarTip')) return;
    var progressBarDiv = $('#ACHtml5Player_progressBar'),
        progressBarTipDiv = $('#ACHtml5Player_progressBarTip');
    var progressBarTipDivOuterWidth = progressBarTipDiv.outerWidth(),
        progressBarDivWidth = progressBarDiv.width();
    var X = e.pageX - progressBarDiv.offset().left,
        left = X - progressBarTipDivOuterWidth / 2,
        duration = player.getDuration();
    if (typeof duration != 'number' || isNaN(duration) || duration === 0) progressBarTipDiv.text('00:00');else {
      var time = duration * X / progressBarDivWidth;
      progressBarTipDiv.text(_helper.Helper.getTimeText(time));
      progressBarTipDiv.attr('data-time', time);
    }
    progressBarTipDiv.css('left', left < 0 ? 0 : left + progressBarTipDivOuterWidth > progressBarDivWidth ? progressBarDivWidth - progressBarTipDivOuterWidth : left);
  });
  var progressMousedown;
  $('#ACHtml5Player_progressBarHandShank').mousedown(function (e) {
    progressMousedown = true;
    progressMousedownLastEvent = e;
  });
  $('body').mouseup(function () {
    progressMousedown = false;
  });
  $('body').mouseleave(function () {
    progressMousedown = false;
  });
  var progressMousedownLastEvent;
  $('body').mousemove(function (e) {
    if (progressMousedown) {
      var progressBarDiv = $('#ACHtml5Player_progressBar');
      var value = (e.pageX - progressBarDiv.offset().left) / progressBarDiv.width();
      $('#ACHtml5Player_progressBarComplete').css('width', "".concat(value * 100, "%"));
      if (Math.abs(e.pageX - progressMousedownLastEvent.pageX) <= 5) return;
      progressMousedownLastEvent = e;
      var duration = player.getDuration();
      if (typeof duration != 'number' || isNaN(duration) || duration === 0) return;
      player.setCurrentTime(duration * value);
    }
  });
  $('#ACHtml5Player_btnFullScreen').click(function (e) {
    if (e.target != this && e.target.tagName.toLowerCase() != 'input') return;
    changeFullScreen();
  });
  $('.ACHtml5Player-barButton,.ACHtml5Player-barButtonToolTip').click(function (e) {
    if (e.target != this) return;
    var clickPopupBoxDiv;
    if ($(this).hasClass('ACHtml5Player-barButtonToolTip')) clickPopupBoxDiv = $(this).siblings('.ACHtml5Player-clickPopupBox');else clickPopupBoxDiv = $(this).find('.ACHtml5Player-clickPopupBox');
    if (clickPopupBoxDiv.length != 1) return;

    if (clickPopupBoxDiv.css('display') == 'none') {
      $('.ACHtml5Player-clickPopupBox').hide(0);
      clickPopupBoxDiv.show();
    } else clickPopupBoxDiv.hide(0);
  });
  $('.ACHtml5Player-clickPopupBox').mouseleave(function (e) {
    if (e.target != this) return;
    $(e.target).delay(500).hide(0);
  });
  $('.ACHtml5Player-clickPopupBox').mouseenter(function (e) {
    if (e.target != this) return;
    $(e.target).clearQueue();
  });
  var controlBarsHideTimeOut;

  _helper.Helper.addScreenchangeEventListener(function () {
    if (_helper.Helper.getFullscreenElement() === $('#ACHtml5Player')[0]) {
      $('#ACHtml5Player_progressBar').prependTo('#ACHtml5Player_controlBars');
      $('body').addClass('ACHtml5Player-fullScreen');
      $('#ACHtml5Player_bulletScreenSendForm').prependTo('#ACHtml5Player_controlBar_control');
      $('body').addClass('ACHtml5Player-fullScreen-desktop');
      $('#ACHtml5Player').on('mousemove', controlBarsHideMousemoveEvent);
      controlBarsHideMousemoveEvent();
    } else {
      var fullScreenType = new FormData($('#ACHtml5Player_btnFullScreen form')[0]).get('fullScreenType');
      $('#ACHtml5Player').off('mousemove', controlBarsHideMousemoveEvent);
      if (controlBarsHideTimeOut) clearTimeout(controlBarsHideTimeOut);
      $('#ACHtml5Player').removeClass('ACHtml5Player-hideControlBars');
      $('#ACHtml5Player_progressBar').appendTo('#ACHtml5Player_main');
      $('body').removeClass('ACHtml5Player-fullScreen-desktop');

      if (fullScreenType === 'desktop') {
        $('body').removeClass('ACHtml5Player-fullScreen');
        $('#ACHtml5Player_bulletScreenSendForm').prependTo('#ACHtml5Player_controlBar_bulletScreen');
      }
    }
  });

  function controlBarsHideMousemoveEvent() {
    $('#ACHtml5Player').removeClass('ACHtml5Player-hideControlBars');
    if (controlBarsHideTimeOut) clearTimeout(controlBarsHideTimeOut);
    controlBarsHideTimeOut = setTimeout(function () {
      if (_helper.Helper.getFullscreenElement() != $('#ACHtml5Player')[0]) return;
      $('#ACHtml5Player').addClass('ACHtml5Player-hideControlBars');
    }, 2000);
  }

  function changeFoldVisibility() {
    if ($('#ACHtml5Player').hasClass('fold')) $('#ACHtml5Player').removeClass('fold');else $('#ACHtml5Player').addClass('fold');
  }

  function setBtnLoopIcon() {
    if (player.getLoop()) {
      $('#ACHtml5Player_btnLoop').removeClass('ACHtml5Player-resource-loopOff');
      $('#ACHtml5Player_btnLoop').addClass('ACHtml5Player-resource-loopOn');
    } else {
      $('#ACHtml5Player_btnLoop').removeClass('ACHtml5Player-resource-loopOn');
      $('#ACHtml5Player_btnLoop').addClass('ACHtml5Player-resource-loopOff');
    }
  }

  function setBtnBulletScreenIcon() {
    if (player.getBulletScreenVisibility()) {
      $('#ACHtml5Player_btnBulletScreen').removeClass('ACHtml5Player-resource-bulletScreenOff');
      $('#ACHtml5Player_btnBulletScreen').addClass('ACHtml5Player-resource-bulletScreenOn');
    } else {
      $('#ACHtml5Player_btnBulletScreen').removeClass('ACHtml5Player-resource-bulletScreenOn');
      $('#ACHtml5Player_btnBulletScreen').addClass('ACHtml5Player-resource-bulletScreenOff');
    }
  }

  function setBtnNext() {
    if (player.getHasNextPart()) $('#ACHtml5Player_btnNext').show();else $('#ACHtml5Player_btnNext').hide();
  }

  function setRadioFullScreen() {
    $('#ACHtml5Player_btnFullScreen form input[value="desktop"]').prop({
      checked: true
    });
  }

  function setVolmueAndMuted() {
    var volume = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : player.getVolume();
    var muted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : player.getMuted();

    if (muted) {
      $('#ACHtml5Player_btnVolume').removeClass('ACHtml5Player-resource-volume');
      $('#ACHtml5Player_btnVolume').addClass('ACHtml5Player-resource-mute');
    } else {
      $('#ACHtml5Player_btnVolume').removeClass('ACHtml5Player-resource-mute');
      $('#ACHtml5Player_btnVolume').addClass('ACHtml5Player-resource-volume');
    }

    volumeSlideBar.set(volume);
  }

  function loadBulletScreenSettings() {
    bulletScreenOpacitySlideBar.set(player.getBulletScreenOpacity());
  }

  function loadQualityList() {
    var qualityIndexList = player.getQualityIndexList();
    var ul = $('#ACHtml5Player_qualityList');
    ul.empty();
    ul.prepend('<li data-index="-1">自动</li>');
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = qualityIndexList[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var qualityIndex = _step2.value;
        var li = $('<li></li>');
        li.text(qualityName[qualityIndex]);
        li.attr('data-index', qualityIndex);
        ul.prepend(li);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  function loadEmoticons() {
    $('#ACHtml5Player_boxEmoticons').empty();
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = _emoticons.default[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var emoticon = _step3.value;
        var div = $('<div class="ACHtml5Player-btnEmoticons ACHtml5Player-textTooltip"></div>');
        div.attr('title', emoticon);
        div.text(emoticon);
        $('#ACHtml5Player_boxEmoticons').append(div);
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    loadTextToolTip();
  }

  function setBtnQuality() {
    var qualityIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : player.getQualityIndex();
    if (typeof qualityIndex === 'undefined') return;
    var span = $('#ACHtml5Player_btnQuality > span');
    if (player.getAutoQualityEnabled()) span.text("\u81EA\u52A8\uFF08".concat(qualityName[qualityIndex], "\uFF09"));else span.text(qualityName[qualityIndex]);
  }

  function loadTextToolTip() {
    $('.ACHtml5Player-textTooltip').tooltipster({
      theme: 'tooltipster-acfun',
      arrow: false,
      side: 'bottom',
      debug: false
    });
  }

  function loadToolTip() {
    $('.ACHtml5Player-tooltip,.ACHtml5Player-barButtonToolTip').tooltipster({
      theme: 'tooltipster-acfun',
      arrow: false,
      side: 'top',
      debug: false
    });
  }

  function changeFullScreen() {
    $(window).scrollTop(0);
    var fullScreenType = new FormData($('#ACHtml5Player_btnFullScreen form')[0]).get('fullScreenType');

    if (fullScreenType === 'page') {
      if (_helper.Helper.getFullscreenElement() === $('#ACHtml5Player')[0]) _helper.Helper.exitFullscreen();else if ($('body').hasClass('ACHtml5Player-fullScreen')) {
        $('body').removeClass('ACHtml5Player-fullScreen');
        $('#ACHtml5Player_bulletScreenSendForm').prependTo('#ACHtml5Player_controlBar_bulletScreen');
      } else {
        $('body').addClass('ACHtml5Player-fullScreen');
        $('#ACHtml5Player_bulletScreenSendForm').prependTo('#ACHtml5Player_controlBar_control');
      }
    } else if (fullScreenType === 'desktop') {
      if (_helper.Helper.getFullscreenElement() != $('#ACHtml5Player')[0]) _helper.Helper.requestFullscreen($('#ACHtml5Player')[0]);else _helper.Helper.exitFullscreen();
    }
  }

  loadToolTip();
  setBtnLoopIcon();
  setBtnBulletScreenIcon();
  setRadioFullScreen();
  setVolmueAndMuted();
  loadEmoticons();
  loadBulletScreenSettings();
};

exports.LoadUI = LoadUI;

},{"./emoticons.json":140,"./lib/helper":145,"./lib/slideBar":149,"core-js/modules/es6.array.find":90,"core-js/modules/es6.function.bind":96,"core-js/modules/es6.object.define-property":99,"core-js/modules/es6.symbol":110,"core-js/modules/es7.symbol.async-iterator":112,"core-js/modules/web.dom.iterable":113,"jquery":115,"perfect-scrollbar":135,"tooltipster":136}]},{},[139])


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYWR2YW5jZS1zdHJpbmctaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1pbnN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWNvcHktd2l0aGluLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktZmlsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2JpbmQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jbGFzc29mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2N0eC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZW51bS1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZXhwb3J0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19maXgtcmUtd2tzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmxhZ3MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mb3Itb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mdW5jdGlvbi10by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oYXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faHRtbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW5oZXJpdC1pZi1yZXF1aXJlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ludm9rZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lvYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1yZWdleHAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZXRlY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLXN0ZXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWV0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHBzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdwby5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVnZXhwLWV4ZWMtYWJzdHJhY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWdleHAtZXhlYy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1wcm90by5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1zcGVjaWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmljdC1tZXRob2QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1hYnNvbHV0ZS1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWluZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLWJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdmFsaWRhdGUtY29sbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MtZXh0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2guanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pbmRleC1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29ydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmNvbnN0cnVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5leGVjLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmZsYWdzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLm1hdGNoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnJlcGxhY2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAudG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZmxvYXQzMi1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9obHMuanMvZGlzdC9obHMuanMiLCJub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzIiwibm9kZV9tb2R1bGVzL2pzLWNvb2tpZS9zcmMvanMuY29va2llLmpzIiwibm9kZV9tb2R1bGVzL29wZW5ic2UvZGlzdC9icm93c2VyTm90U3VwcG9ydEVycm9yLmpzIiwibm9kZV9tb2R1bGVzL29wZW5ic2UvZGlzdC9idWlsZC5qc29uIiwibm9kZV9tb2R1bGVzL29wZW5ic2UvZGlzdC9idWxsZXRTY3JlZW5FbmdpbmUuanMiLCJub2RlX21vZHVsZXMvb3BlbmJzZS9kaXN0L2J1bGxldFNjcmVlblR5cGUuanMiLCJub2RlX21vZHVsZXMvb3BlbmJzZS9kaXN0L2NvbnRleHRtZW51LmpzIiwibm9kZV9tb2R1bGVzL29wZW5ic2UvZGlzdC9saWIvbGliL2V2ZW50LmpzIiwibm9kZV9tb2R1bGVzL29wZW5ic2UvZGlzdC9saWIvbGliL2hlbHBlci5qcyIsIm5vZGVfbW9kdWxlcy9vcGVuYnNlL2Rpc3QvbGliL2xpYi9saW5rZWRMaXN0LmpzIiwibm9kZV9tb2R1bGVzL29wZW5ic2UvZGlzdC9saWIvcmVuZGVyZXJzL2xpYi9yZW5kZXJlcnMvYmFzZVJlbmRlcmVyLmpzIiwibm9kZV9tb2R1bGVzL29wZW5ic2UvZGlzdC9saWIvcmVuZGVyZXJzL2xpYi9yZW5kZXJlcnMvY2FudmFzQmFzZVJlbmRlcmVyLmpzIiwibm9kZV9tb2R1bGVzL29wZW5ic2UvZGlzdC9saWIvcmVuZGVyZXJzL2xpYi9yZW5kZXJlcnMvY2FudmFzUmVuZGVyZXIuanMiLCJub2RlX21vZHVsZXMvb3BlbmJzZS9kaXN0L2xpYi9yZW5kZXJlcnMvbGliL3JlbmRlcmVycy9jc3MzUmVuZGVyZXIuanMiLCJub2RlX21vZHVsZXMvb3BlbmJzZS9kaXN0L2xpYi9yZW5kZXJlcnMvbGliL3JlbmRlcmVycy9yZW5kZXJlcnNGYWN0b3J5LmpzIiwibm9kZV9tb2R1bGVzL29wZW5ic2UvZGlzdC9saWIvcmVuZGVyZXJzL2xpYi9yZW5kZXJlcnMvc3ZnUmVuZGVyZXIuanMiLCJub2RlX21vZHVsZXMvb3BlbmJzZS9kaXN0L2xpYi9yZW5kZXJlcnMvbGliL3JlbmRlcmVycy93ZWJnbFJlbmRlcmVyLmpzIiwibm9kZV9tb2R1bGVzL29wZW5ic2UvZGlzdC9saWIvcmVzb3VyY2VzLmpzb24iLCJub2RlX21vZHVsZXMvb3BlbmJzZS9kaXN0L2xpYi9saWIvcmVzb3VyY2VzLmpzIiwibm9kZV9tb2R1bGVzL29wZW5ic2UvZGlzdC9vcGVuQlNFLmpzIiwibm9kZV9tb2R1bGVzL3BlcmZlY3Qtc2Nyb2xsYmFyL2Rpc3QvcGVyZmVjdC1zY3JvbGxiYXIuY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL3Rvb2x0aXBzdGVyL2Rpc3QvanMvdG9vbHRpcHN0ZXIuYnVuZGxlLm1pbi5qcyIsInNyYy9CYW5ndW1pLmpzIiwic3JjL1BhcnQuanMiLCJzcmMvYXBwLmpzIiwic3JjL2Vtb3RpY29ucy5qc29uIiwic3JjL2xpYi9hY1dlYlNvY2tldENsaWVudC5qcyIsInNyYy9saWIvYWRhcHRlci9hY2Z1blZpZGVvQWRhcHRlci5qcyIsInNyYy9saWIvYnVsbGV0U2NyZWVuLmpzIiwic3JjL2xpYi9ldmVudC5qcyIsInNyYy9saWIvaGVscGVyLmpzIiwic3JjL2xpYi9wbGF5ZXIuanMiLCJzcmMvbGliL3Jlc291cmNlcy5qc29uIiwic3JjL2xpYi9yZXNvdXJjZXMuanMiLCJzcmMvbGliL3NsaWRlQmFyLmpzIiwic3JjL3VpLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdnZqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVuVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdHlDQTtBQUNBOzs7Ozs7Ozs7OztBQ0RBLElBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQyxRQUFELENBQWY7QUFFQTs7Ozs7O0FBSUEsSUFBSSxhQUFhLEdBQUcsU0FBaEIsYUFBZ0IsQ0FBQyxNQUFELEVBQVk7QUFDNUIsTUFBSSxTQUFTLEdBQUcsS0FBaEI7O0FBQ0EsRUFBQSxNQUFNLENBQUMsV0FBUCxHQUFxQixVQUFDLElBQUQs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Q0FBRCxDQUFVLFdBQVYsQ0FBc0IsMEJBQXRCO0FBQ0EsUUFBQSxDQUFDLENBQUMscUNBQUQsQ0FBRCxDQUF5QyxTQUF6QyxDQUFtRCx3Q0FBbkQ7QUFDSCxPQUhJLE1BSUE7QUFDRCxRQUFBLENBQUMsQ0FBQyxNQUFELENBQUQsQ0FBVSxRQUFWLENBQW1CLDBCQUFuQjtBQUNBLFFBQUEsQ0FBQyxDQUFDLHFDQUFELENBQUQsQ0FBeUMsU0FBekMsQ0FBbUQsbUNBQW5EO0FBQ0g7QUFDSixLQVZELE1BVU8sSUFBSSxjQUFjLEtBQUssU0FBdkIsRUFBa0M7QUFDckMsVUFBSSxlQUFPLG9CQUFQLE1BQWlDLENBQUMsQ0FBQyxnQkFBRCxDQUFELENBQW9CLENBQXBCLENBQXJDLEVBQTZELGVBQU8saUJBQVAsQ0FBeUIsQ0FBQyxDQUFDLGdCQUFELENBQUQsQ0FBb0IsQ0FBcEIsQ0FBekIsRUFBN0QsS0FDSyxlQUFPLGNBQVA7QUFDUjtBQUNKOztBQUVELEVBQUEsV0FBVztBQUNYLEVBQUEsY0FBYztBQUNkLEVBQUEsc0JBQXNCO0FBQ3RCLEVBQUEsa0JBQWtCO0FBQ2xCLEVBQUEsaUJBQWlCO0FBQ2pCLEVBQUEsYUFBYTtBQUNiLEVBQUEsd0JBQXdCO0FBQzNCLENBdmhCRCIsImZpbGUiOiJhY2Z1bi1odG1sNXBsYXllci5hbGwuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gMjIuMS4zLjMxIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxudmFyIFVOU0NPUEFCTEVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3Vuc2NvcGFibGVzJyk7XG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbmlmIChBcnJheVByb3RvW1VOU0NPUEFCTEVTXSA9PSB1bmRlZmluZWQpIHJlcXVpcmUoJy4vX2hpZGUnKShBcnJheVByb3RvLCBVTlNDT1BBQkxFUywge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdW2tleV0gPSB0cnVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4gLy8gYEFkdmFuY2VTdHJpbmdJbmRleGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hZHZhbmNlc3RyaW5naW5kZXhcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFMsIGluZGV4LCB1bmljb2RlKSB7XG4gIHJldHVybiBpbmRleCArICh1bmljb2RlID8gYXQoUywgaW5kZXgpLmxlbmd0aCA6IDEpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSwgZm9yYmlkZGVuRmllbGQpIHtcbiAgaWYgKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikgfHwgKGZvcmJpZGRlbkZpZWxkICE9PSB1bmRlZmluZWQgJiYgZm9yYmlkZGVuRmllbGQgaW4gaXQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKG5hbWUgKyAnOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gMjIuMS4zLjMgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gW10uY29weVdpdGhpbiB8fCBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldCAvKiA9IDAgKi8sIHN0YXJ0IC8qID0gMCwgZW5kID0gQGxlbmd0aCAqLykge1xuICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICB2YXIgbGVuID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICB2YXIgdG8gPSB0b0Fic29sdXRlSW5kZXgodGFyZ2V0LCBsZW4pO1xuICB2YXIgZnJvbSA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuKTtcbiAgdmFyIGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICB2YXIgY291bnQgPSBNYXRoLm1pbigoZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW4pKSAtIGZyb20sIGxlbiAtIHRvKTtcbiAgdmFyIGluYyA9IDE7XG4gIGlmIChmcm9tIDwgdG8gJiYgdG8gPCBmcm9tICsgY291bnQpIHtcbiAgICBpbmMgPSAtMTtcbiAgICBmcm9tICs9IGNvdW50IC0gMTtcbiAgICB0byArPSBjb3VudCAtIDE7XG4gIH1cbiAgd2hpbGUgKGNvdW50LS0gPiAwKSB7XG4gICAgaWYgKGZyb20gaW4gTykgT1t0b10gPSBPW2Zyb21dO1xuICAgIGVsc2UgZGVsZXRlIE9bdG9dO1xuICAgIHRvICs9IGluYztcbiAgICBmcm9tICs9IGluYztcbiAgfSByZXR1cm4gTztcbn07XG4iLCIvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCh2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aClcbid1c2Ugc3RyaWN0JztcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiAsIHN0YXJ0ID0gMCwgZW5kID0gQGxlbmd0aCAqLykge1xuICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICB2YXIgZW5kUG9zID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW5ndGgpO1xuICB3aGlsZSAoZW5kUG9zID4gaW5kZXgpIE9baW5kZXgrK10gPSB2YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG4iLCIvLyAwIC0+IEFycmF5I2ZvckVhY2hcbi8vIDEgLT4gQXJyYXkjbWFwXG4vLyAyIC0+IEFycmF5I2ZpbHRlclxuLy8gMyAtPiBBcnJheSNzb21lXG4vLyA0IC0+IEFycmF5I2V2ZXJ5XG4vLyA1IC0+IEFycmF5I2ZpbmRcbi8vIDYgLT4gQXJyYXkjZmluZEluZGV4XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgYXNjID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRZUEUsICRjcmVhdGUpIHtcbiAgdmFyIElTX01BUCA9IFRZUEUgPT0gMTtcbiAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT0gMjtcbiAgdmFyIElTX1NPTUUgPSBUWVBFID09IDM7XG4gIHZhciBJU19FVkVSWSA9IFRZUEUgPT0gNDtcbiAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDY7XG4gIHZhciBOT19IT0xFUyA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYO1xuICB2YXIgY3JlYXRlID0gJGNyZWF0ZSB8fCBhc2M7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgc2VsZiA9IElPYmplY3QoTyk7XG4gICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgdGhhdCwgMyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciByZXN1bHQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWwsIHJlcztcbiAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpIHtcbiAgICAgIHZhbCA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzID0gZih2YWwsIGluZGV4LCBPKTtcbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHJlc3VsdFtpbmRleF0gPSByZXM7ICAgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYgKHJlcykgc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbDsgICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHJlc3VsdC5wdXNoKHZhbCk7ICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIGlmIChJU19FVkVSWSkgcmV0dXJuIGZhbHNlOyAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogcmVzdWx0O1xuICB9O1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICB2YXIgQztcbiAgaWYgKGlzQXJyYXkob3JpZ2luYWwpKSB7XG4gICAgQyA9IG9yaWdpbmFsLmNvbnN0cnVjdG9yO1xuICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgaWYgKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtcbiAgICBpZiAoaXNPYmplY3QoQykpIHtcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xuICAgICAgaWYgKEMgPT09IG51bGwpIEMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IHJldHVybiBDID09PSB1bmRlZmluZWQgPyBBcnJheSA6IEM7XG59O1xuIiwiLy8gOS40LjIuMyBBcnJheVNwZWNpZXNDcmVhdGUob3JpZ2luYWxBcnJheSwgbGVuZ3RoKVxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWwsIGxlbmd0aCkge1xuICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWwpKShsZW5ndGgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBpbnZva2UgPSByZXF1aXJlKCcuL19pbnZva2UnKTtcbnZhciBhcnJheVNsaWNlID0gW10uc2xpY2U7XG52YXIgZmFjdG9yaWVzID0ge307XG5cbnZhciBjb25zdHJ1Y3QgPSBmdW5jdGlvbiAoRiwgbGVuLCBhcmdzKSB7XG4gIGlmICghKGxlbiBpbiBmYWN0b3JpZXMpKSB7XG4gICAgZm9yICh2YXIgbiA9IFtdLCBpID0gMDsgaSA8IGxlbjsgaSsrKSBuW2ldID0gJ2FbJyArIGkgKyAnXSc7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgZmFjdG9yaWVzW2xlbl0gPSBGdW5jdGlvbignRixhJywgJ3JldHVybiBuZXcgRignICsgbi5qb2luKCcsJykgKyAnKScpO1xuICB9IHJldHVybiBmYWN0b3JpZXNbbGVuXShGLCBhcmdzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24uYmluZCB8fCBmdW5jdGlvbiBiaW5kKHRoYXQgLyogLCAuLi5hcmdzICovKSB7XG4gIHZhciBmbiA9IGFGdW5jdGlvbih0aGlzKTtcbiAgdmFyIHBhcnRBcmdzID0gYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBib3VuZCA9IGZ1bmN0aW9uICgvKiBhcmdzLi4uICovKSB7XG4gICAgdmFyIGFyZ3MgPSBwYXJ0QXJncy5jb25jYXQoYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgYm91bmQgPyBjb25zdHJ1Y3QoZm4sIGFyZ3MubGVuZ3RoLCBhcmdzKSA6IGludm9rZShmbiwgYXJncywgdGhhdCk7XG4gIH07XG4gIGlmIChpc09iamVjdChmbi5wcm90b3R5cGUpKSBib3VuZC5wcm90b3R5cGUgPSBmbi5wcm90b3R5cGU7XG4gIHJldHVybiBib3VuZDtcbn07XG4iLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBBUkcgPSBjb2YoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgJGl0ZXJEZWZpbmUgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgZmFzdEtleSA9IHJlcXVpcmUoJy4vX21ldGEnKS5mYXN0S2V5O1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFNJWkUgPSBERVNDUklQVE9SUyA/ICdfcycgOiAnc2l6ZSc7XG5cbnZhciBnZXRFbnRyeSA9IGZ1bmN0aW9uICh0aGF0LCBrZXkpIHtcbiAgLy8gZmFzdCBjYXNlXG4gIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KTtcbiAgdmFyIGVudHJ5O1xuICBpZiAoaW5kZXggIT09ICdGJykgcmV0dXJuIHRoYXQuX2lbaW5kZXhdO1xuICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgZm9yIChlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICBpZiAoZW50cnkuayA9PSBrZXkpIHJldHVybiBlbnRyeTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll90ID0gTkFNRTsgICAgICAgICAvLyBjb2xsZWN0aW9uIHR5cGVcbiAgICAgIHRoYXQuX2kgPSBjcmVhdGUobnVsbCk7IC8vIGluZGV4XG4gICAgICB0aGF0Ll9mID0gdW5kZWZpbmVkOyAgICAvLyBmaXJzdCBlbnRyeVxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgICAgLy8gbGFzdCBlbnRyeVxuICAgICAgdGhhdFtTSVpFXSA9IDA7ICAgICAgICAgLy8gc2l6ZVxuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICBmb3IgKHZhciB0aGF0ID0gdmFsaWRhdGUodGhpcywgTkFNRSksIGRhdGEgPSB0aGF0Ll9pLCBlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZW50cnkucCkgZW50cnkucCA9IGVudHJ5LnAubiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9mID0gdGhhdC5fbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhhdFtTSVpFXSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdGhhdCA9IHZhbGlkYXRlKHRoaXMsIE5BTUUpO1xuICAgICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm47XG4gICAgICAgICAgdmFyIHByZXYgPSBlbnRyeS5wO1xuICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9pW2VudHJ5LmldO1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmIChwcmV2KSBwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmIChuZXh0KSBuZXh0LnAgPSBwcmV2O1xuICAgICAgICAgIGlmICh0aGF0Ll9mID09IGVudHJ5KSB0aGF0Ll9mID0gbmV4dDtcbiAgICAgICAgICBpZiAodGhhdC5fbCA9PSBlbnRyeSkgdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgICAgIHZhbGlkYXRlKHRoaXMsIE5BTUUpO1xuICAgICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMyk7XG4gICAgICAgIHZhciBlbnRyeTtcbiAgICAgICAgd2hpbGUgKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhpcy5fZikge1xuICAgICAgICAgIGYoZW50cnkudiwgZW50cnkuaywgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnIpIGVudHJ5ID0gZW50cnkucDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHZhbGlkYXRlKHRoaXMsIE5BTUUpLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChERVNDUklQVE9SUykgZFAoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZSh0aGlzLCBOQU1FKVtTSVpFXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgdmFyIHByZXYsIGluZGV4O1xuICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgIGlmIChlbnRyeSkge1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsICAgICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYgKCF0aGF0Ll9mKSB0aGF0Ll9mID0gZW50cnk7XG4gICAgICBpZiAocHJldikgcHJldi5uID0gZW50cnk7XG4gICAgICB0aGF0W1NJWkVdKys7XG4gICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgIGlmIChpbmRleCAhPT0gJ0YnKSB0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbiAoQywgTkFNRSwgSVNfTUFQKSB7XG4gICAgLy8gYWRkIC5rZXlzLCAudmFsdWVzLCAuZW50cmllcywgW0BAaXRlcmF0b3JdXG4gICAgLy8gMjMuMS4zLjQsIDIzLjEuMy44LCAyMy4xLjMuMTEsIDIzLjEuMy4xMiwgMjMuMi4zLjUsIDIzLjIuMy44LCAyMy4yLjMuMTAsIDIzLjIuMy4xMVxuICAgICRpdGVyRGVmaW5lKEMsIE5BTUUsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICAgICAgdGhpcy5fdCA9IHZhbGlkYXRlKGl0ZXJhdGVkLCBOQU1FKTsgLy8gdGFyZ2V0XG4gICAgICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gICAgICB0aGlzLl9sID0gdW5kZWZpbmVkOyAgICAgICAgICAgICAgICAvLyBwcmV2aW91c1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciBraW5kID0gdGhhdC5faztcbiAgICAgIHZhciBlbnRyeSA9IHRoYXQuX2w7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yKSBlbnRyeSA9IGVudHJ5LnA7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYgKCF0aGF0Ll90IHx8ICEodGhhdC5fbCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhhdC5fdC5fZikpIHtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgdGhhdC5fdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHN0ZXAoMSk7XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXG4gICAgICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGVudHJ5LmspO1xuICAgICAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJywgIUlTX01BUCwgdHJ1ZSk7XG5cbiAgICAvLyBhZGQgW0BAc3BlY2llc10sIDIzLjEuMi4yLCAyMy4yLjIuMlxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciAkaXRlckRldGVjdCA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0Jyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSykge1xuICB2YXIgQmFzZSA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIEMgPSBCYXNlO1xuICB2YXIgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnO1xuICB2YXIgcHJvdG8gPSBDICYmIEMucHJvdG90eXBlO1xuICB2YXIgTyA9IHt9O1xuICB2YXIgZml4TWV0aG9kID0gZnVuY3Rpb24gKEtFWSkge1xuICAgIHZhciBmbiA9IHByb3RvW0tFWV07XG4gICAgcmVkZWZpbmUocHJvdG8sIEtFWSxcbiAgICAgIEtFWSA9PSAnZGVsZXRlJyA/IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnaGFzJyA/IGZ1bmN0aW9uIGhhcyhhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnZ2V0JyA/IGZ1bmN0aW9uIGdldChhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IHVuZGVmaW5lZCA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2FkZCcgPyBmdW5jdGlvbiBhZGQoYSkgeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7IHJldHVybiB0aGlzOyB9XG4gICAgICAgIDogZnVuY3Rpb24gc2V0KGEsIGIpIHsgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEsIGIpOyByZXR1cm4gdGhpczsgfVxuICAgICk7XG4gIH07XG4gIGlmICh0eXBlb2YgQyAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBwcm90by5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IEMoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpIHtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICAgIG1ldGEuTkVFRCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IEMoKTtcbiAgICAvLyBlYXJseSBpbXBsZW1lbnRhdGlvbnMgbm90IHN1cHBvcnRzIGNoYWluaW5nXG4gICAgdmFyIEhBU05UX0NIQUlOSU5HID0gaW5zdGFuY2VbQURERVJdKElTX1dFQUsgPyB7fSA6IC0wLCAxKSAhPSBpbnN0YW5jZTtcbiAgICAvLyBWOCB+ICBDaHJvbWl1bSA0MC0gd2Vhay1jb2xsZWN0aW9ucyB0aHJvd3Mgb24gcHJpbWl0aXZlcywgYnV0IHNob3VsZCByZXR1cm4gZmFsc2VcbiAgICB2YXIgVEhST1dTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IGluc3RhbmNlLmhhcygxKTsgfSk7XG4gICAgLy8gbW9zdCBlYXJseSBpbXBsZW1lbnRhdGlvbnMgZG9lc24ndCBzdXBwb3J0cyBpdGVyYWJsZXMsIG1vc3QgbW9kZXJuIC0gbm90IGNsb3NlIGl0IGNvcnJlY3RseVxuICAgIHZhciBBQ0NFUFRfSVRFUkFCTEVTID0gJGl0ZXJEZXRlY3QoZnVuY3Rpb24gKGl0ZXIpIHsgbmV3IEMoaXRlcik7IH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIC8vIGZvciBlYXJseSBpbXBsZW1lbnRhdGlvbnMgLTAgYW5kICswIG5vdCB0aGUgc2FtZVxuICAgIHZhciBCVUdHWV9aRVJPID0gIUlTX1dFQUsgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVjggfiBDaHJvbWl1bSA0Mi0gZmFpbHMgb25seSB3aXRoIDUrIGVsZW1lbnRzXG4gICAgICB2YXIgJGluc3RhbmNlID0gbmV3IEMoKTtcbiAgICAgIHZhciBpbmRleCA9IDU7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkgJGluc3RhbmNlW0FEREVSXShpbmRleCwgaW5kZXgpO1xuICAgICAgcmV0dXJuICEkaW5zdGFuY2UuaGFzKC0wKTtcbiAgICB9KTtcbiAgICBpZiAoIUFDQ0VQVF9JVEVSQUJMRVMpIHtcbiAgICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0YXJnZXQsIGl0ZXJhYmxlKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGFyZ2V0LCBDLCBOQU1FKTtcbiAgICAgICAgdmFyIHRoYXQgPSBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSgpLCB0YXJnZXQsIEMpO1xuICAgICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgfSk7XG4gICAgICBDLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgcHJvdG8uY29uc3RydWN0b3IgPSBDO1xuICAgIH1cbiAgICBpZiAoVEhST1dTX09OX1BSSU1JVElWRVMgfHwgQlVHR1lfWkVSTykge1xuICAgICAgZml4TWV0aG9kKCdkZWxldGUnKTtcbiAgICAgIGZpeE1ldGhvZCgnaGFzJyk7XG4gICAgICBJU19NQVAgJiYgZml4TWV0aG9kKCdnZXQnKTtcbiAgICB9XG4gICAgaWYgKEJVR0dZX1pFUk8gfHwgSEFTTlRfQ0hBSU5JTkcpIGZpeE1ldGhvZChBRERFUik7XG4gICAgLy8gd2VhayBjb2xsZWN0aW9ucyBzaG91bGQgbm90IGNvbnRhaW5zIC5jbGVhciBtZXRob2RcbiAgICBpZiAoSVNfV0VBSyAmJiBwcm90by5jbGVhcikgZGVsZXRlIHByb3RvLmNsZWFyO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQywgTkFNRSk7XG5cbiAgT1tOQU1FXSA9IEM7XG4gICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEMgIT0gQmFzZSksIE8pO1xuXG4gIGlmICghSVNfV0VBSykgY29tbW9uLnNldFN0cm9uZyhDLCBOQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDO1xufTtcbiIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjYuNScgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcbiIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuIiwiLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgcmVzdWx0ID0gZ2V0S2V5cyhpdCk7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICBpZiAoZ2V0U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdCk7XG4gICAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChzeW1ib2xzLmxlbmd0aCA+IGkpIGlmIChpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUztcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIHx8IChnbG9iYWxbbmFtZV0gPSB7fSkgOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdO1xuICB2YXIgZXhwb3J0cyA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV0gfHwgKGV4cG9ydHNbUFJPVE9UWVBFXSA9IHt9KTtcbiAgdmFyIGtleSwgb3duLCBvdXQsIGV4cDtcbiAgaWYgKElTX0dMT0JBTCkgc291cmNlID0gbmFtZTtcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IChvd24gPyB0YXJnZXQgOiBzb3VyY2UpW2tleV07XG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICBleHAgPSBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgaWYgKHRhcmdldCkgcmVkZWZpbmUodGFyZ2V0LCBrZXksIG91dCwgdHlwZSAmICRleHBvcnQuVSk7XG4gICAgLy8gZXhwb3J0XG4gICAgaWYgKGV4cG9ydHNba2V5XSAhPSBvdXQpIGhpZGUoZXhwb3J0cywga2V5LCBleHApO1xuICAgIGlmIChJU19QUk9UTyAmJiBleHBQcm90b1trZXldICE9IG91dCkgZXhwUHJvdG9ba2V5XSA9IG91dDtcbiAgfVxufTtcbmdsb2JhbC5jb3JlID0gY29yZTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnJlcXVpcmUoJy4vZXM2LnJlZ2V4cC5leGVjJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgcmVnZXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjJyk7XG5cbnZhciBTUEVDSUVTID0gd2tzKCdzcGVjaWVzJyk7XG5cbnZhciBSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vICNyZXBsYWNlIG5lZWRzIGJ1aWx0LWluIHN1cHBvcnQgZm9yIG5hbWVkIGdyb3Vwcy5cbiAgLy8gI21hdGNoIHdvcmtzIGZpbmUgYmVjYXVzZSBpdCBqdXN0IHJldHVybiB0aGUgZXhlYyByZXN1bHRzLCBldmVuIGlmIGl0IGhhc1xuICAvLyBhIFwiZ3JvcHNcIiBwcm9wZXJ0eS5cbiAgdmFyIHJlID0gLy4vO1xuICByZS5leGVjID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICByZXN1bHQuZ3JvdXBzID0geyBhOiAnNycgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICByZXR1cm4gJycucmVwbGFjZShyZSwgJyQ8YT4nKSAhPT0gJzcnO1xufSk7XG5cbnZhciBTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMgPSAoZnVuY3Rpb24gKCkge1xuICAvLyBDaHJvbWUgNTEgaGFzIGEgYnVnZ3kgXCJzcGxpdFwiIGltcGxlbWVudGF0aW9uIHdoZW4gUmVnRXhwI2V4ZWMgIT09IG5hdGl2ZUV4ZWNcbiAgdmFyIHJlID0gLyg/OikvO1xuICB2YXIgb3JpZ2luYWxFeGVjID0gcmUuZXhlYztcbiAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9yaWdpbmFsRXhlYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICB2YXIgcmVzdWx0ID0gJ2FiJy5zcGxpdChyZSk7XG4gIHJldHVybiByZXN1bHQubGVuZ3RoID09PSAyICYmIHJlc3VsdFswXSA9PT0gJ2EnICYmIHJlc3VsdFsxXSA9PT0gJ2InO1xufSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBsZW5ndGgsIGV4ZWMpIHtcbiAgdmFyIFNZTUJPTCA9IHdrcyhLRVkpO1xuXG4gIHZhciBERUxFR0FURVNfVE9fU1lNQk9MID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTdHJpbmcgbWV0aG9kcyBjYWxsIHN5bWJvbC1uYW1lZCBSZWdFcCBtZXRob2RzXG4gICAgdmFyIE8gPSB7fTtcbiAgICBPW1NZTUJPTF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9O1xuICAgIHJldHVybiAnJ1tLRVldKE8pICE9IDc7XG4gIH0pO1xuXG4gIHZhciBERUxFR0FURVNfVE9fRVhFQyA9IERFTEVHQVRFU19UT19TWU1CT0wgPyAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIFN5bWJvbC1uYW1lZCBSZWdFeHAgbWV0aG9kcyBjYWxsIC5leGVjXG4gICAgdmFyIGV4ZWNDYWxsZWQgPSBmYWxzZTtcbiAgICB2YXIgcmUgPSAvYS87XG4gICAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHsgZXhlY0NhbGxlZCA9IHRydWU7IHJldHVybiBudWxsOyB9O1xuICAgIGlmIChLRVkgPT09ICdzcGxpdCcpIHtcbiAgICAgIC8vIFJlZ0V4cFtAQHNwbGl0XSBkb2Vzbid0IGNhbGwgdGhlIHJlZ2V4J3MgZXhlYyBtZXRob2QsIGJ1dCBmaXJzdCBjcmVhdGVzXG4gICAgICAvLyBhIG5ldyBvbmUuIFdlIG5lZWQgdG8gcmV0dXJuIHRoZSBwYXRjaGVkIHJlZ2V4IHdoZW4gY3JlYXRpbmcgdGhlIG5ldyBvbmUuXG4gICAgICByZS5jb25zdHJ1Y3RvciA9IHt9O1xuICAgICAgcmUuY29uc3RydWN0b3JbU1BFQ0lFU10gPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZTsgfTtcbiAgICB9XG4gICAgcmVbU1lNQk9MXSgnJyk7XG4gICAgcmV0dXJuICFleGVjQ2FsbGVkO1xuICB9KSA6IHVuZGVmaW5lZDtcblxuICBpZiAoXG4gICAgIURFTEVHQVRFU19UT19TWU1CT0wgfHxcbiAgICAhREVMRUdBVEVTX1RPX0VYRUMgfHxcbiAgICAoS0VZID09PSAncmVwbGFjZScgJiYgIVJFUExBQ0VfU1VQUE9SVFNfTkFNRURfR1JPVVBTKSB8fFxuICAgIChLRVkgPT09ICdzcGxpdCcgJiYgIVNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQylcbiAgKSB7XG4gICAgdmFyIG5hdGl2ZVJlZ0V4cE1ldGhvZCA9IC8uL1tTWU1CT0xdO1xuICAgIHZhciBmbnMgPSBleGVjKFxuICAgICAgZGVmaW5lZCxcbiAgICAgIFNZTUJPTCxcbiAgICAgICcnW0tFWV0sXG4gICAgICBmdW5jdGlvbiBtYXliZUNhbGxOYXRpdmUobmF0aXZlTWV0aG9kLCByZWdleHAsIHN0ciwgYXJnMiwgZm9yY2VTdHJpbmdNZXRob2QpIHtcbiAgICAgICAgaWYgKHJlZ2V4cC5leGVjID09PSByZWdleHBFeGVjKSB7XG4gICAgICAgICAgaWYgKERFTEVHQVRFU19UT19TWU1CT0wgJiYgIWZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmF0aXZlIFN0cmluZyBtZXRob2QgYWxyZWFkeSBkZWxlZ2F0ZXMgdG8gQEBtZXRob2QgKHRoaXNcbiAgICAgICAgICAgIC8vIHBvbHlmaWxsZWQgZnVuY3Rpb24pLCBsZWFzaW5nIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgICAgICAgICAgIC8vIFdlIGF2b2lkIGl0IGJ5IGRpcmVjdGx5IGNhbGxpbmcgdGhlIG5hdGl2ZSBAQG1ldGhvZCBtZXRob2QuXG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbmF0aXZlUmVnRXhwTWV0aG9kLmNhbGwocmVnZXhwLCBzdHIsIGFyZzIpIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiBuYXRpdmVNZXRob2QuY2FsbChzdHIsIHJlZ2V4cCwgYXJnMikgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSB9O1xuICAgICAgfVxuICAgICk7XG4gICAgdmFyIHN0cmZuID0gZm5zWzBdO1xuICAgIHZhciByeGZuID0gZm5zWzFdO1xuXG4gICAgcmVkZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgS0VZLCBzdHJmbik7XG4gICAgaGlkZShSZWdFeHAucHJvdG90eXBlLCBTWU1CT0wsIGxlbmd0aCA9PSAyXG4gICAgICAvLyAyMS4yLjUuOCBSZWdFeHAucHJvdG90eXBlW0BAcmVwbGFjZV0oc3RyaW5nLCByZXBsYWNlVmFsdWUpXG4gICAgICAvLyAyMS4yLjUuMTEgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XShzdHJpbmcsIGxpbWl0KVxuICAgICAgPyBmdW5jdGlvbiAoc3RyaW5nLCBhcmcpIHsgcmV0dXJuIHJ4Zm4uY2FsbChzdHJpbmcsIHRoaXMsIGFyZyk7IH1cbiAgICAgIC8vIDIxLjIuNS42IFJlZ0V4cC5wcm90b3R5cGVbQEBtYXRjaF0oc3RyaW5nKVxuICAgICAgLy8gMjEuMi41LjkgUmVnRXhwLnByb3RvdHlwZVtAQHNlYXJjaF0oc3RyaW5nKVxuICAgICAgOiBmdW5jdGlvbiAoc3RyaW5nKSB7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzKTsgfVxuICAgICk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMS4yLjUuMyBnZXQgUmVnRXhwLnByb3RvdHlwZS5mbGFnc1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSBhbk9iamVjdCh0aGlzKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmICh0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmICh0aGF0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKHRoYXQudW5pY29kZSkgcmVzdWx0ICs9ICd1JztcbiAgaWYgKHRoYXQuc3RpY2t5KSByZXN1bHQgKz0gJ3knO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgQlJFQUsgPSB7fTtcbnZhciBSRVRVUk4gPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUikge1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSk7XG4gIHZhciBmID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmIChpc0FycmF5SXRlcihpdGVyRm4pKSBmb3IgKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOykge1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCduYXRpdmUtZnVuY3Rpb24tdG8tc3RyaW5nJywgRnVuY3Rpb24udG9TdHJpbmcpO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYgKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpIF9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcbiIsInZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCB0YXJnZXQsIEMpIHtcbiAgdmFyIFMgPSB0YXJnZXQuY29uc3RydWN0b3I7XG4gIHZhciBQO1xuICBpZiAoUyAhPT0gQyAmJiB0eXBlb2YgUyA9PSAnZnVuY3Rpb24nICYmIChQID0gUy5wcm90b3R5cGUpICE9PSBDLnByb3RvdHlwZSAmJiBpc09iamVjdChQKSAmJiBzZXRQcm90b3R5cGVPZikge1xuICAgIHNldFByb3RvdHlwZU9mKHRoYXQsIFApO1xuICB9IHJldHVybiB0aGF0O1xufTtcbiIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIGFyZ3MsIHRoYXQpIHtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcbiIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG4iLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcbiIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG4iLCIvLyA3LjIuOCBJc1JlZ0V4cChhcmd1bWVudClcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIE1BVENIID0gcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgaXNSZWdFeHA7XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgKChpc1JlZ0V4cCA9IGl0W01BVENIXSkgIT09IHVuZGVmaW5lZCA/ICEhaXNSZWdFeHAgOiBjb2YoaXQpID09ICdSZWdFeHAnKTtcbn07XG4iLCIvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIGFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyICRpdGVyQ3JlYXRlID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBCVUdHWSA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKTsgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxudmFyIEZGX0lURVJBVE9SID0gJ0BAaXRlcmF0b3InO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgaWYgKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKSByZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFUztcbiAgdmFyIFZBTFVFU19CVUcgPSBmYWxzZTtcbiAgdmFyIHByb3RvID0gQmFzZS5wcm90b3R5cGU7XG4gIHZhciAkbmF0aXZlID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdO1xuICB2YXIgJGRlZmF1bHQgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKTtcbiAgdmFyICRlbnRyaWVzID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZDtcbiAgdmFyICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlO1xuICB2YXIgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZiAoJGFueU5hdGl2ZSkge1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKCkpKTtcbiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgSXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmICghTElCUkFSWSAmJiB0eXBlb2YgSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIGhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmICgoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSkge1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gPSByZXR1cm5UaGlzO1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChrZXkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKCEoa2V5IGluIHByb3RvKSkgcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcbiIsInZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uICgpIHsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjLCBza2lwQ2xvc2luZykge1xuICBpZiAoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gWzddO1xuICAgIHZhciBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHsgZG9uZTogc2FmZSA9IHRydWUgfTsgfTtcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge307XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuIiwidmFyIE1FVEEgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgc2V0RGVzYyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaWQgPSAwO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uIChpdCkge1xuICBzZXREZXNjKGl0LCBNRVRBLCB7IHZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSB9KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xufTtcbnZhciBnZXRXZWFrID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpIHNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiBNRVRBLFxuICBORUVEOiBmYWxzZSxcbiAgZmFzdEtleTogZmFzdEtleSxcbiAgZ2V0V2VhazogZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBkUHMgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKTtcbiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuIiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG4iLCIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbiIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgaWYgKGtleSAhPSBJRV9QUk9UTykgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuIiwidmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBzYWZlKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgc2FmZSk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgU1JDID0gcmVxdWlyZSgnLi9fdWlkJykoJ3NyYycpO1xudmFyICR0b1N0cmluZyA9IHJlcXVpcmUoJy4vX2Z1bmN0aW9uLXRvLXN0cmluZycpO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgVFBMID0gKCcnICsgJHRvU3RyaW5nKS5zcGxpdChUT19TVFJJTkcpO1xuXG5yZXF1aXJlKCcuL19jb3JlJykuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gJHRvU3RyaW5nLmNhbGwoaXQpO1xufTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsLCBzYWZlKSB7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHZhbCA9PSAnZnVuY3Rpb24nO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgJ25hbWUnKSB8fCBoaWRlKHZhbCwgJ25hbWUnLCBrZXkpO1xuICBpZiAoT1trZXldID09PSB2YWwpIHJldHVybjtcbiAgaWYgKGlzRnVuY3Rpb24pIGhhcyh2YWwsIFNSQykgfHwgaGlkZSh2YWwsIFNSQywgT1trZXldID8gJycgKyBPW2tleV0gOiBUUEwuam9pbihTdHJpbmcoa2V5KSkpO1xuICBpZiAoTyA9PT0gZ2xvYmFsKSB7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2UgaWYgKCFzYWZlKSB7XG4gICAgZGVsZXRlIE9ba2V5XTtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfSBlbHNlIGlmIChPW2tleV0pIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgaGlkZShPLCBrZXksIHZhbCk7XG4gIH1cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzW1NSQ10gfHwgJHRvU3RyaW5nLmNhbGwodGhpcyk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgYnVpbHRpbkV4ZWMgPSBSZWdFeHAucHJvdG90eXBlLmV4ZWM7XG5cbiAvLyBgUmVnRXhwRXhlY2AgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHBleGVjXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChSLCBTKSB7XG4gIHZhciBleGVjID0gUi5leGVjO1xuICBpZiAodHlwZW9mIGV4ZWMgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgcmVzdWx0ID0gZXhlYy5jYWxsKFIsIFMpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVnRXhwIGV4ZWMgbWV0aG9kIHJldHVybmVkIHNvbWV0aGluZyBvdGhlciB0aGFuIGFuIE9iamVjdCBvciBudWxsJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGNsYXNzb2YoUikgIT09ICdSZWdFeHAnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVnRXhwI2V4ZWMgY2FsbGVkIG9uIGluY29tcGF0aWJsZSByZWNlaXZlcicpO1xuICB9XG4gIHJldHVybiBidWlsdGluRXhlYy5jYWxsKFIsIFMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlZ2V4cEZsYWdzID0gcmVxdWlyZSgnLi9fZmxhZ3MnKTtcblxudmFyIG5hdGl2ZUV4ZWMgPSBSZWdFeHAucHJvdG90eXBlLmV4ZWM7XG4vLyBUaGlzIGFsd2F5cyByZWZlcnMgdG8gdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiwgYmVjYXVzZSB0aGVcbi8vIFN0cmluZyNyZXBsYWNlIHBvbHlmaWxsIHVzZXMgLi9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljLmpzLFxuLy8gd2hpY2ggbG9hZHMgdGhpcyBmaWxlIGJlZm9yZSBwYXRjaGluZyB0aGUgbWV0aG9kLlxudmFyIG5hdGl2ZVJlcGxhY2UgPSBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2U7XG5cbnZhciBwYXRjaGVkRXhlYyA9IG5hdGl2ZUV4ZWM7XG5cbnZhciBMQVNUX0lOREVYID0gJ2xhc3RJbmRleCc7XG5cbnZhciBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgcmUxID0gL2EvLFxuICAgICAgcmUyID0gL2IqL2c7XG4gIG5hdGl2ZUV4ZWMuY2FsbChyZTEsICdhJyk7XG4gIG5hdGl2ZUV4ZWMuY2FsbChyZTIsICdhJyk7XG4gIHJldHVybiByZTFbTEFTVF9JTkRFWF0gIT09IDAgfHwgcmUyW0xBU1RfSU5ERVhdICE9PSAwO1xufSkoKTtcblxuLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXAsIGNvcGllZCBmcm9tIGVzNS1zaGltJ3MgU3RyaW5nI3NwbGl0IHBhdGNoLlxudmFyIE5QQ0dfSU5DTFVERUQgPSAvKCk/Py8uZXhlYygnJylbMV0gIT09IHVuZGVmaW5lZDtcblxudmFyIFBBVENIID0gVVBEQVRFU19MQVNUX0lOREVYX1dST05HIHx8IE5QQ0dfSU5DTFVERUQ7XG5cbmlmIChQQVRDSCkge1xuICBwYXRjaGVkRXhlYyA9IGZ1bmN0aW9uIGV4ZWMoc3RyKSB7XG4gICAgdmFyIHJlID0gdGhpcztcbiAgICB2YXIgbGFzdEluZGV4LCByZUNvcHksIG1hdGNoLCBpO1xuXG4gICAgaWYgKE5QQ0dfSU5DTFVERUQpIHtcbiAgICAgIHJlQ29weSA9IG5ldyBSZWdFeHAoJ14nICsgcmUuc291cmNlICsgJyQoPyFcXFxccyknLCByZWdleHBGbGFncy5jYWxsKHJlKSk7XG4gICAgfVxuICAgIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcpIGxhc3RJbmRleCA9IHJlW0xBU1RfSU5ERVhdO1xuXG4gICAgbWF0Y2ggPSBuYXRpdmVFeGVjLmNhbGwocmUsIHN0cik7XG5cbiAgICBpZiAoVVBEQVRFU19MQVNUX0lOREVYX1dST05HICYmIG1hdGNoKSB7XG4gICAgICByZVtMQVNUX0lOREVYXSA9IHJlLmdsb2JhbCA/IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIDogbGFzdEluZGV4O1xuICAgIH1cbiAgICBpZiAoTlBDR19JTkNMVURFRCAmJiBtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYFxuICAgICAgLy8gZm9yIE5QQ0csIGxpa2UgSUU4LiBOT1RFOiBUaGlzIGRvZXNuJyB3b3JrIGZvciAvKC4/KT8vXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9vcC1mdW5jXG4gICAgICBuYXRpdmVSZXBsYWNlLmNhbGwobWF0Y2hbMF0sIHJlQ29weSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaGVkRXhlYztcbiIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoTywgcHJvdG8pIHtcbiAgYW5PYmplY3QoTyk7XG4gIGlmICghaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKSB0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmdW5jdGlvbiAodGVzdCwgYnVnZ3ksIHNldCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZiAoYnVnZ3kpIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZKSB7XG4gIHZhciBDID0gZ2xvYmFsW0tFWV07XG4gIGlmIChERVNDUklQVE9SUyAmJiBDICYmICFDW1NQRUNJRVNdKSBkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG4gIH0pO1xufTtcbiIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgdGFnLCBzdGF0KSB7XG4gIGlmIChpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKSBkZWYoaXQsIFRBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWcgfSk7XG59O1xuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246IGNvcmUudmVyc2lvbixcbiAgbW9kZTogcmVxdWlyZSgnLi9fbGlicmFyeScpID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTkgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXG59KTtcbiIsIi8vIDcuMy4yMCBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKVxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywgRCkge1xuICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yO1xuICB2YXIgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBEIDogYUZ1bmN0aW9uKFMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1ldGhvZCwgYXJnKSB7XG4gIHJldHVybiAhIW1ldGhvZCAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtY2FsbFxuICAgIGFyZyA/IG1ldGhvZC5jYWxsKG51bGwsIGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgMSkgOiBtZXRob2QuY2FsbChudWxsKTtcbiAgfSk7XG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9pbmRleFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09PSB1bmRlZmluZWQpIHJldHVybiAwO1xuICB2YXIgbnVtYmVyID0gdG9JbnRlZ2VyKGl0KTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKG51bWJlcik7XG4gIGlmIChudW1iZXIgIT09IGxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcignV3JvbmcgbGVuZ3RoIScpO1xuICByZXR1cm4gbGVuZ3RoO1xufTtcbiIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgUykge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5pZiAocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSkge1xuICB2YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbiAgdmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xuICB2YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xuICB2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuICB2YXIgJHR5cGVkID0gcmVxdWlyZSgnLi9fdHlwZWQnKTtcbiAgdmFyICRidWZmZXIgPSByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKTtcbiAgdmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xuICB2YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG4gIHZhciBwcm9wZXJ0eURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG4gIHZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xuICB2YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbiAgdmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbiAgdmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG4gIHZhciB0b0luZGV4ID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKTtcbiAgdmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG4gIHZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuICB2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG4gIHZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xuICB2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbiAgdmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG4gIHZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbiAgdmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbiAgdmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuICB2YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbiAgdmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG4gIHZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbiAgdmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xuICB2YXIgY3JlYXRlQXJyYXlNZXRob2QgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJyk7XG4gIHZhciBjcmVhdGVBcnJheUluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKTtcbiAgdmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbiAgdmFyIEFycmF5SXRlcmF0b3JzID0gcmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbiAgdmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xuICB2YXIgJGl0ZXJEZXRlY3QgPSByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpO1xuICB2YXIgc2V0U3BlY2llcyA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJyk7XG4gIHZhciBhcnJheUZpbGwgPSByZXF1aXJlKCcuL19hcnJheS1maWxsJyk7XG4gIHZhciBhcnJheUNvcHlXaXRoaW4gPSByZXF1aXJlKCcuL19hcnJheS1jb3B5LXdpdGhpbicpO1xuICB2YXIgJERQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG4gIHZhciAkR09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG4gIHZhciBkUCA9ICREUC5mO1xuICB2YXIgZ09QRCA9ICRHT1BELmY7XG4gIHZhciBSYW5nZUVycm9yID0gZ2xvYmFsLlJhbmdlRXJyb3I7XG4gIHZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xuICB2YXIgVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5O1xuICB2YXIgQVJSQVlfQlVGRkVSID0gJ0FycmF5QnVmZmVyJztcbiAgdmFyIFNIQVJFRF9CVUZGRVIgPSAnU2hhcmVkJyArIEFSUkFZX0JVRkZFUjtcbiAgdmFyIEJZVEVTX1BFUl9FTEVNRU5UID0gJ0JZVEVTX1BFUl9FTEVNRU5UJztcbiAgdmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuICB2YXIgQXJyYXlQcm90byA9IEFycmF5W1BST1RPVFlQRV07XG4gIHZhciAkQXJyYXlCdWZmZXIgPSAkYnVmZmVyLkFycmF5QnVmZmVyO1xuICB2YXIgJERhdGFWaWV3ID0gJGJ1ZmZlci5EYXRhVmlldztcbiAgdmFyIGFycmF5Rm9yRWFjaCA9IGNyZWF0ZUFycmF5TWV0aG9kKDApO1xuICB2YXIgYXJyYXlGaWx0ZXIgPSBjcmVhdGVBcnJheU1ldGhvZCgyKTtcbiAgdmFyIGFycmF5U29tZSA9IGNyZWF0ZUFycmF5TWV0aG9kKDMpO1xuICB2YXIgYXJyYXlFdmVyeSA9IGNyZWF0ZUFycmF5TWV0aG9kKDQpO1xuICB2YXIgYXJyYXlGaW5kID0gY3JlYXRlQXJyYXlNZXRob2QoNSk7XG4gIHZhciBhcnJheUZpbmRJbmRleCA9IGNyZWF0ZUFycmF5TWV0aG9kKDYpO1xuICB2YXIgYXJyYXlJbmNsdWRlcyA9IGNyZWF0ZUFycmF5SW5jbHVkZXModHJ1ZSk7XG4gIHZhciBhcnJheUluZGV4T2YgPSBjcmVhdGVBcnJheUluY2x1ZGVzKGZhbHNlKTtcbiAgdmFyIGFycmF5VmFsdWVzID0gQXJyYXlJdGVyYXRvcnMudmFsdWVzO1xuICB2YXIgYXJyYXlLZXlzID0gQXJyYXlJdGVyYXRvcnMua2V5cztcbiAgdmFyIGFycmF5RW50cmllcyA9IEFycmF5SXRlcmF0b3JzLmVudHJpZXM7XG4gIHZhciBhcnJheUxhc3RJbmRleE9mID0gQXJyYXlQcm90by5sYXN0SW5kZXhPZjtcbiAgdmFyIGFycmF5UmVkdWNlID0gQXJyYXlQcm90by5yZWR1Y2U7XG4gIHZhciBhcnJheVJlZHVjZVJpZ2h0ID0gQXJyYXlQcm90by5yZWR1Y2VSaWdodDtcbiAgdmFyIGFycmF5Sm9pbiA9IEFycmF5UHJvdG8uam9pbjtcbiAgdmFyIGFycmF5U29ydCA9IEFycmF5UHJvdG8uc29ydDtcbiAgdmFyIGFycmF5U2xpY2UgPSBBcnJheVByb3RvLnNsaWNlO1xuICB2YXIgYXJyYXlUb1N0cmluZyA9IEFycmF5UHJvdG8udG9TdHJpbmc7XG4gIHZhciBhcnJheVRvTG9jYWxlU3RyaW5nID0gQXJyYXlQcm90by50b0xvY2FsZVN0cmluZztcbiAgdmFyIElURVJBVE9SID0gd2tzKCdpdGVyYXRvcicpO1xuICB2YXIgVEFHID0gd2tzKCd0b1N0cmluZ1RhZycpO1xuICB2YXIgVFlQRURfQ09OU1RSVUNUT1IgPSB1aWQoJ3R5cGVkX2NvbnN0cnVjdG9yJyk7XG4gIHZhciBERUZfQ09OU1RSVUNUT1IgPSB1aWQoJ2RlZl9jb25zdHJ1Y3RvcicpO1xuICB2YXIgQUxMX0NPTlNUUlVDVE9SUyA9ICR0eXBlZC5DT05TVFI7XG4gIHZhciBUWVBFRF9BUlJBWSA9ICR0eXBlZC5UWVBFRDtcbiAgdmFyIFZJRVcgPSAkdHlwZWQuVklFVztcbiAgdmFyIFdST05HX0xFTkdUSCA9ICdXcm9uZyBsZW5ndGghJztcblxuICB2YXIgJG1hcCA9IGNyZWF0ZUFycmF5TWV0aG9kKDEsIGZ1bmN0aW9uIChPLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gYWxsb2NhdGUoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSksIGxlbmd0aCk7XG4gIH0pO1xuXG4gIHZhciBMSVRUTEVfRU5ESUFOID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVWludDE2QXJyYXkoWzFdKS5idWZmZXIpWzBdID09PSAxO1xuICB9KTtcblxuICB2YXIgRk9SQ0VEX1NFVCA9ICEhVWludDhBcnJheSAmJiAhIVVpbnQ4QXJyYXlbUFJPVE9UWVBFXS5zZXQgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyBVaW50OEFycmF5KDEpLnNldCh7fSk7XG4gIH0pO1xuXG4gIHZhciB0b09mZnNldCA9IGZ1bmN0aW9uIChpdCwgQllURVMpIHtcbiAgICB2YXIgb2Zmc2V0ID0gdG9JbnRlZ2VyKGl0KTtcbiAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgJSBCWVRFUykgdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0IScpO1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgaWYgKGlzT2JqZWN0KGl0KSAmJiBUWVBFRF9BUlJBWSBpbiBpdCkgcmV0dXJuIGl0O1xuICAgIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgdHlwZWQgYXJyYXkhJyk7XG4gIH07XG5cbiAgdmFyIGFsbG9jYXRlID0gZnVuY3Rpb24gKEMsIGxlbmd0aCkge1xuICAgIGlmICghKGlzT2JqZWN0KEMpICYmIFRZUEVEX0NPTlNUUlVDVE9SIGluIEMpKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ0l0IGlzIG5vdCBhIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9yIScpO1xuICAgIH0gcmV0dXJuIG5ldyBDKGxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIHNwZWNpZXNGcm9tTGlzdCA9IGZ1bmN0aW9uIChPLCBsaXN0KSB7XG4gICAgcmV0dXJuIGZyb21MaXN0KHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pLCBsaXN0KTtcbiAgfTtcblxuICB2YXIgZnJvbUxpc3QgPSBmdW5jdGlvbiAoQywgbGlzdCkge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBhbGxvY2F0ZShDLCBsZW5ndGgpO1xuICAgIHdoaWxlIChsZW5ndGggPiBpbmRleCkgcmVzdWx0W2luZGV4XSA9IGxpc3RbaW5kZXgrK107XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgYWRkR2V0dGVyID0gZnVuY3Rpb24gKGl0LCBrZXksIGludGVybmFsKSB7XG4gICAgZFAoaXQsIGtleSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RbaW50ZXJuYWxdOyB9IH0pO1xuICB9O1xuXG4gIHZhciAkZnJvbSA9IGZ1bmN0aW9uIGZyb20oc291cmNlIC8qICwgbWFwZm4sIHRoaXNBcmcgKi8pIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHNvdXJjZSk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaXRlckZuID0gZ2V0SXRlckZuKE8pO1xuICAgIHZhciBpLCBsZW5ndGgsIHZhbHVlcywgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZiAoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhaXNBcnJheUl0ZXIoaXRlckZuKSkge1xuICAgICAgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCB2YWx1ZXMgPSBbXSwgaSA9IDA7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaSsrKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKHN0ZXAudmFsdWUpO1xuICAgICAgfSBPID0gdmFsdWVzO1xuICAgIH1cbiAgICBpZiAobWFwcGluZyAmJiBhTGVuID4gMikgbWFwZm4gPSBjdHgobWFwZm4sIGFyZ3VtZW50c1syXSwgMik7XG4gICAgZm9yIChpID0gMCwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpLCByZXN1bHQgPSBhbGxvY2F0ZSh0aGlzLCBsZW5ndGgpOyBsZW5ndGggPiBpOyBpKyspIHtcbiAgICAgIHJlc3VsdFtpXSA9IG1hcHBpbmcgPyBtYXBmbihPW2ldLCBpKSA6IE9baV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyICRvZiA9IGZ1bmN0aW9uIG9mKC8qIC4uLml0ZW1zICovKSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gYWxsb2NhdGUodGhpcywgbGVuZ3RoKTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHJlc3VsdFtpbmRleF0gPSBhcmd1bWVudHNbaW5kZXgrK107XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBpT1MgU2FmYXJpIDYueCBmYWlscyBoZXJlXG4gIHZhciBUT19MT0NBTEVfQlVHID0gISFVaW50OEFycmF5ICYmIGZhaWxzKGZ1bmN0aW9uICgpIHsgYXJyYXlUb0xvY2FsZVN0cmluZy5jYWxsKG5ldyBVaW50OEFycmF5KDEpKTsgfSk7XG5cbiAgdmFyICR0b0xvY2FsZVN0cmluZyA9IGZ1bmN0aW9uIHRvTG9jYWxlU3RyaW5nKCkge1xuICAgIHJldHVybiBhcnJheVRvTG9jYWxlU3RyaW5nLmFwcGx5KFRPX0xPQ0FMRV9CVUcgPyBhcnJheVNsaWNlLmNhbGwodmFsaWRhdGUodGhpcykpIDogdmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgdmFyIHByb3RvID0ge1xuICAgIGNvcHlXaXRoaW46IGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCAvKiAsIGVuZCAqLykge1xuICAgICAgcmV0dXJuIGFycmF5Q29weVdpdGhpbi5jYWxsKHZhbGlkYXRlKHRoaXMpLCB0YXJnZXQsIHN0YXJ0LCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBldmVyeTogZnVuY3Rpb24gZXZlcnkoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUV2ZXJ5KHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmaWxsOiBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qICwgc3RhcnQsIGVuZCAqLykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlGaWxsLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBzcGVjaWVzRnJvbUxpc3QodGhpcywgYXJyYXlGaWx0ZXIodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sXG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKSk7XG4gICAgfSxcbiAgICBmaW5kOiBmdW5jdGlvbiBmaW5kKHByZWRpY2F0ZSAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUZpbmQodmFsaWRhdGUodGhpcyksIHByZWRpY2F0ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgocHJlZGljYXRlIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIGFycmF5RmluZEluZGV4KHZhbGlkYXRlKHRoaXMpLCBwcmVkaWNhdGUsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIGFycmF5Rm9yRWFjaCh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlJbmRleE9mKHZhbGlkYXRlKHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCAqLykge1xuICAgICAgcmV0dXJuIGFycmF5SW5jbHVkZXModmFsaWRhdGUodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUpvaW4uYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCAqLykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlMYXN0SW5kZXhPZi5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIG1hcDogZnVuY3Rpb24gbWFwKG1hcGZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuICRtYXAodmFsaWRhdGUodGhpcyksIG1hcGZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheVJlZHVjZS5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbiByZWR1Y2VSaWdodChjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheVJlZHVjZVJpZ2h0LmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciBsZW5ndGggPSB2YWxpZGF0ZSh0aGF0KS5sZW5ndGg7XG4gICAgICB2YXIgbWlkZGxlID0gTWF0aC5mbG9vcihsZW5ndGggLyAyKTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICB3aGlsZSAoaW5kZXggPCBtaWRkbGUpIHtcbiAgICAgICAgdmFsdWUgPSB0aGF0W2luZGV4XTtcbiAgICAgICAgdGhhdFtpbmRleCsrXSA9IHRoYXRbLS1sZW5ndGhdO1xuICAgICAgICB0aGF0W2xlbmd0aF0gPSB2YWx1ZTtcbiAgICAgIH0gcmV0dXJuIHRoYXQ7XG4gICAgfSxcbiAgICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlTb21lKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICAgICAgcmV0dXJuIGFycmF5U29ydC5jYWxsKHZhbGlkYXRlKHRoaXMpLCBjb21wYXJlZm4pO1xuICAgIH0sXG4gICAgc3ViYXJyYXk6IGZ1bmN0aW9uIHN1YmFycmF5KGJlZ2luLCBlbmQpIHtcbiAgICAgIHZhciBPID0gdmFsaWRhdGUodGhpcyk7XG4gICAgICB2YXIgbGVuZ3RoID0gTy5sZW5ndGg7XG4gICAgICB2YXIgJGJlZ2luID0gdG9BYnNvbHV0ZUluZGV4KGJlZ2luLCBsZW5ndGgpO1xuICAgICAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSkpKFxuICAgICAgICBPLmJ1ZmZlcixcbiAgICAgICAgTy5ieXRlT2Zmc2V0ICsgJGJlZ2luICogTy5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgdG9MZW5ndGgoKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuZ3RoKSkgLSAkYmVnaW4pXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICB2YXIgJHNsaWNlID0gZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBzcGVjaWVzRnJvbUxpc3QodGhpcywgYXJyYXlTbGljZS5jYWxsKHZhbGlkYXRlKHRoaXMpLCBzdGFydCwgZW5kKSk7XG4gIH07XG5cbiAgdmFyICRzZXQgPSBmdW5jdGlvbiBzZXQoYXJyYXlMaWtlIC8qICwgb2Zmc2V0ICovKSB7XG4gICAgdmFsaWRhdGUodGhpcyk7XG4gICAgdmFyIG9mZnNldCA9IHRvT2Zmc2V0KGFyZ3VtZW50c1sxXSwgMSk7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIHZhciBzcmMgPSB0b09iamVjdChhcnJheUxpa2UpO1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aChzcmMubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGlmIChsZW4gKyBvZmZzZXQgPiBsZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICB3aGlsZSAoaW5kZXggPCBsZW4pIHRoaXNbb2Zmc2V0ICsgaW5kZXhdID0gc3JjW2luZGV4KytdO1xuICB9O1xuXG4gIHZhciAkaXRlcmF0b3JzID0ge1xuICAgIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgICByZXR1cm4gYXJyYXlFbnRyaWVzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH0sXG4gICAga2V5czogZnVuY3Rpb24ga2V5cygpIHtcbiAgICAgIHJldHVybiBhcnJheUtleXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfSxcbiAgICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgIHJldHVybiBhcnJheVZhbHVlcy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzVEFJbmRleCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHJldHVybiBpc09iamVjdCh0YXJnZXQpXG4gICAgICAmJiB0YXJnZXRbVFlQRURfQVJSQVldXG4gICAgICAmJiB0eXBlb2Yga2V5ICE9ICdzeW1ib2wnXG4gICAgICAmJiBrZXkgaW4gdGFyZ2V0XG4gICAgICAmJiBTdHJpbmcoK2tleSkgPT0gU3RyaW5nKGtleSk7XG4gIH07XG4gIHZhciAkZ2V0RGVzYyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkge1xuICAgIHJldHVybiBpc1RBSW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKVxuICAgICAgPyBwcm9wZXJ0eURlc2MoMiwgdGFyZ2V0W2tleV0pXG4gICAgICA6IGdPUEQodGFyZ2V0LCBrZXkpO1xuICB9O1xuICB2YXIgJHNldERlc2MgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIGlmIChpc1RBSW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKVxuICAgICAgJiYgaXNPYmplY3QoZGVzYylcbiAgICAgICYmIGhhcyhkZXNjLCAndmFsdWUnKVxuICAgICAgJiYgIWhhcyhkZXNjLCAnZ2V0JylcbiAgICAgICYmICFoYXMoZGVzYywgJ3NldCcpXG4gICAgICAvLyBUT0RPOiBhZGQgdmFsaWRhdGlvbiBkZXNjcmlwdG9yIHcvbyBjYWxsaW5nIGFjY2Vzc29yc1xuICAgICAgJiYgIWRlc2MuY29uZmlndXJhYmxlXG4gICAgICAmJiAoIWhhcyhkZXNjLCAnd3JpdGFibGUnKSB8fCBkZXNjLndyaXRhYmxlKVxuICAgICAgJiYgKCFoYXMoZGVzYywgJ2VudW1lcmFibGUnKSB8fCBkZXNjLmVudW1lcmFibGUpXG4gICAgKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IGRlc2MudmFsdWU7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0gcmV0dXJuIGRQKHRhcmdldCwga2V5LCBkZXNjKTtcbiAgfTtcblxuICBpZiAoIUFMTF9DT05TVFJVQ1RPUlMpIHtcbiAgICAkR09QRC5mID0gJGdldERlc2M7XG4gICAgJERQLmYgPSAkc2V0RGVzYztcbiAgfVxuXG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIUFMTF9DT05TVFJVQ1RPUlMsICdPYmplY3QnLCB7XG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0RGVzYyxcbiAgICBkZWZpbmVQcm9wZXJ0eTogJHNldERlc2NcbiAgfSk7XG5cbiAgaWYgKGZhaWxzKGZ1bmN0aW9uICgpIHsgYXJyYXlUb1N0cmluZy5jYWxsKHt9KTsgfSkpIHtcbiAgICBhcnJheVRvU3RyaW5nID0gYXJyYXlUb0xvY2FsZVN0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGFycmF5Sm9pbi5jYWxsKHRoaXMpO1xuICAgIH07XG4gIH1cblxuICB2YXIgJFR5cGVkQXJyYXlQcm90b3R5cGUkID0gcmVkZWZpbmVBbGwoe30sIHByb3RvKTtcbiAgcmVkZWZpbmVBbGwoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAkaXRlcmF0b3JzKTtcbiAgaGlkZSgkVHlwZWRBcnJheVByb3RvdHlwZSQsIElURVJBVE9SLCAkaXRlcmF0b3JzLnZhbHVlcyk7XG4gIHJlZGVmaW5lQWxsKCRUeXBlZEFycmF5UHJvdG90eXBlJCwge1xuICAgIHNsaWNlOiAkc2xpY2UsXG4gICAgc2V0OiAkc2V0LFxuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7IC8qIG5vb3AgKi8gfSxcbiAgICB0b1N0cmluZzogYXJyYXlUb1N0cmluZyxcbiAgICB0b0xvY2FsZVN0cmluZzogJHRvTG9jYWxlU3RyaW5nXG4gIH0pO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnVmZmVyJywgJ2InKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J5dGVPZmZzZXQnLCAnbycpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnl0ZUxlbmd0aCcsICdsJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdsZW5ndGgnLCAnZScpO1xuICBkUCgkVHlwZWRBcnJheVByb3RvdHlwZSQsIFRBRywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpc1tUWVBFRF9BUlJBWV07IH1cbiAgfSk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1zdGF0ZW1lbnRzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgQllURVMsIHdyYXBwZXIsIENMQU1QRUQpIHtcbiAgICBDTEFNUEVEID0gISFDTEFNUEVEO1xuICAgIHZhciBOQU1FID0gS0VZICsgKENMQU1QRUQgPyAnQ2xhbXBlZCcgOiAnJykgKyAnQXJyYXknO1xuICAgIHZhciBHRVRURVIgPSAnZ2V0JyArIEtFWTtcbiAgICB2YXIgU0VUVEVSID0gJ3NldCcgKyBLRVk7XG4gICAgdmFyIFR5cGVkQXJyYXkgPSBnbG9iYWxbTkFNRV07XG4gICAgdmFyIEJhc2UgPSBUeXBlZEFycmF5IHx8IHt9O1xuICAgIHZhciBUQUMgPSBUeXBlZEFycmF5ICYmIGdldFByb3RvdHlwZU9mKFR5cGVkQXJyYXkpO1xuICAgIHZhciBGT1JDRUQgPSAhVHlwZWRBcnJheSB8fCAhJHR5cGVkLkFCVjtcbiAgICB2YXIgTyA9IHt9O1xuICAgIHZhciBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheSAmJiBUeXBlZEFycmF5W1BST1RPVFlQRV07XG4gICAgdmFyIGdldHRlciA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCkge1xuICAgICAgdmFyIGRhdGEgPSB0aGF0Ll9kO1xuICAgICAgcmV0dXJuIGRhdGEudltHRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLm8sIExJVFRMRV9FTkRJQU4pO1xuICAgIH07XG4gICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhhdC5fZDtcbiAgICAgIGlmIChDTEFNUEVEKSB2YWx1ZSA9ICh2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUpKSA8IDAgPyAwIDogdmFsdWUgPiAweGZmID8gMHhmZiA6IHZhbHVlICYgMHhmZjtcbiAgICAgIGRhdGEudltTRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLm8sIHZhbHVlLCBMSVRUTEVfRU5ESUFOKTtcbiAgICB9O1xuICAgIHZhciBhZGRFbGVtZW50ID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4KSB7XG4gICAgICBkUCh0aGF0LCBpbmRleCwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0dGVyKHRoaXMsIGluZGV4KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gc2V0dGVyKHRoaXMsIGluZGV4LCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKEZPUkNFRCkge1xuICAgICAgVHlwZWRBcnJheSA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGRhdGEsICRvZmZzZXQsICRsZW5ndGgpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGF0LCBUeXBlZEFycmF5LCBOQU1FLCAnX2QnKTtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgIHZhciBidWZmZXIsIGJ5dGVMZW5ndGgsIGxlbmd0aCwga2xhc3M7XG4gICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgICBsZW5ndGggPSB0b0luZGV4KGRhdGEpO1xuICAgICAgICAgIGJ5dGVMZW5ndGggPSBsZW5ndGggKiBCWVRFUztcbiAgICAgICAgICBidWZmZXIgPSBuZXcgJEFycmF5QnVmZmVyKGJ5dGVMZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiAkQXJyYXlCdWZmZXIgfHwgKGtsYXNzID0gY2xhc3NvZihkYXRhKSkgPT0gQVJSQVlfQlVGRkVSIHx8IGtsYXNzID09IFNIQVJFRF9CVUZGRVIpIHtcbiAgICAgICAgICBidWZmZXIgPSBkYXRhO1xuICAgICAgICAgIG9mZnNldCA9IHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKTtcbiAgICAgICAgICB2YXIgJGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBpZiAoJGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoJGxlbiAlIEJZVEVTKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gJGxlbiAtIG9mZnNldDtcbiAgICAgICAgICAgIGlmIChieXRlTGVuZ3RoIDwgMCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gdG9MZW5ndGgoJGxlbmd0aCkgKiBCWVRFUztcbiAgICAgICAgICAgIGlmIChieXRlTGVuZ3RoICsgb2Zmc2V0ID4gJGxlbikgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGggPSBieXRlTGVuZ3RoIC8gQllURVM7XG4gICAgICAgIH0gZWxzZSBpZiAoVFlQRURfQVJSQVkgaW4gZGF0YSkge1xuICAgICAgICAgIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gJGZyb20uY2FsbChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBoaWRlKHRoYXQsICdfZCcsIHtcbiAgICAgICAgICBiOiBidWZmZXIsXG4gICAgICAgICAgbzogb2Zmc2V0LFxuICAgICAgICAgIGw6IGJ5dGVMZW5ndGgsXG4gICAgICAgICAgZTogbGVuZ3RoLFxuICAgICAgICAgIHY6IG5ldyAkRGF0YVZpZXcoYnVmZmVyKVxuICAgICAgICB9KTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSBhZGRFbGVtZW50KHRoYXQsIGluZGV4KyspO1xuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheVtQUk9UT1RZUEVdID0gY3JlYXRlKCRUeXBlZEFycmF5UHJvdG90eXBlJCk7XG4gICAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIFR5cGVkQXJyYXkpO1xuICAgIH0gZWxzZSBpZiAoIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIFR5cGVkQXJyYXkoMSk7XG4gICAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIG5ldyBUeXBlZEFycmF5KC0xKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICB9KSB8fCAhJGl0ZXJEZXRlY3QoZnVuY3Rpb24gKGl0ZXIpIHtcbiAgICAgIG5ldyBUeXBlZEFycmF5KCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICBuZXcgVHlwZWRBcnJheShudWxsKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIG5ldyBUeXBlZEFycmF5KDEuNSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICBuZXcgVHlwZWRBcnJheShpdGVyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICB9LCB0cnVlKSkge1xuICAgICAgVHlwZWRBcnJheSA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGRhdGEsICRvZmZzZXQsICRsZW5ndGgpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGF0LCBUeXBlZEFycmF5LCBOQU1FKTtcbiAgICAgICAgdmFyIGtsYXNzO1xuICAgICAgICAvLyBgd3NgIG1vZHVsZSBidWcsIHRlbXBvcmFyaWx5IHJlbW92ZSB2YWxpZGF0aW9uIGxlbmd0aCBmb3IgVWludDhBcnJheVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9wdWxsLzY0NVxuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSByZXR1cm4gbmV3IEJhc2UodG9JbmRleChkYXRhKSk7XG4gICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKSB7XG4gICAgICAgICAgcmV0dXJuICRsZW5ndGggIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBuZXcgQmFzZShkYXRhLCB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUyksICRsZW5ndGgpXG4gICAgICAgICAgICA6ICRvZmZzZXQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IG5ldyBCYXNlKGRhdGEsIHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKSlcbiAgICAgICAgICAgICAgOiBuZXcgQmFzZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVFlQRURfQVJSQVkgaW4gZGF0YSkgcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICByZXR1cm4gJGZyb20uY2FsbChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgIH0pO1xuICAgICAgYXJyYXlGb3JFYWNoKFRBQyAhPT0gRnVuY3Rpb24ucHJvdG90eXBlID8gZ09QTihCYXNlKS5jb25jYXQoZ09QTihUQUMpKSA6IGdPUE4oQmFzZSksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIFR5cGVkQXJyYXkpKSBoaWRlKFR5cGVkQXJyYXksIGtleSwgQmFzZVtrZXldKTtcbiAgICAgIH0pO1xuICAgICAgVHlwZWRBcnJheVtQUk9UT1RZUEVdID0gVHlwZWRBcnJheVByb3RvdHlwZTtcbiAgICAgIGlmICghTElCUkFSWSkgVHlwZWRBcnJheVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFR5cGVkQXJyYXk7XG4gICAgfVxuICAgIHZhciAkbmF0aXZlSXRlcmF0b3IgPSBUeXBlZEFycmF5UHJvdG90eXBlW0lURVJBVE9SXTtcbiAgICB2YXIgQ09SUkVDVF9JVEVSX05BTUUgPSAhISRuYXRpdmVJdGVyYXRvclxuICAgICAgJiYgKCRuYXRpdmVJdGVyYXRvci5uYW1lID09ICd2YWx1ZXMnIHx8ICRuYXRpdmVJdGVyYXRvci5uYW1lID09IHVuZGVmaW5lZCk7XG4gICAgdmFyICRpdGVyYXRvciA9ICRpdGVyYXRvcnMudmFsdWVzO1xuICAgIGhpZGUoVHlwZWRBcnJheSwgVFlQRURfQ09OU1RSVUNUT1IsIHRydWUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgVFlQRURfQVJSQVksIE5BTUUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgVklFVywgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBERUZfQ09OU1RSVUNUT1IsIFR5cGVkQXJyYXkpO1xuXG4gICAgaWYgKENMQU1QRUQgPyBuZXcgVHlwZWRBcnJheSgxKVtUQUddICE9IE5BTUUgOiAhKFRBRyBpbiBUeXBlZEFycmF5UHJvdG90eXBlKSkge1xuICAgICAgZFAoVHlwZWRBcnJheVByb3RvdHlwZSwgVEFHLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTkFNRTsgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgT1tOQU1FXSA9IFR5cGVkQXJyYXk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChUeXBlZEFycmF5ICE9IEJhc2UpLCBPKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5TLCBOQU1FLCB7XG4gICAgICBCWVRFU19QRVJfRUxFTUVOVDogQllURVNcbiAgICB9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkgeyBCYXNlLm9mLmNhbGwoVHlwZWRBcnJheSwgMSk7IH0pLCBOQU1FLCB7XG4gICAgICBmcm9tOiAkZnJvbSxcbiAgICAgIG9mOiAkb2ZcbiAgICB9KTtcblxuICAgIGlmICghKEJZVEVTX1BFUl9FTEVNRU5UIGluIFR5cGVkQXJyYXlQcm90b3R5cGUpKSBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIEJZVEVTX1BFUl9FTEVNRU5ULCBCWVRFUyk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCwgTkFNRSwgcHJvdG8pO1xuXG4gICAgc2V0U3BlY2llcyhOQU1FKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogRk9SQ0VEX1NFVCwgTkFNRSwgeyBzZXQ6ICRzZXQgfSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFDT1JSRUNUX0lURVJfTkFNRSwgTkFNRSwgJGl0ZXJhdG9ycyk7XG5cbiAgICBpZiAoIUxJQlJBUlkgJiYgVHlwZWRBcnJheVByb3RvdHlwZS50b1N0cmluZyAhPSBhcnJheVRvU3RyaW5nKSBUeXBlZEFycmF5UHJvdG90eXBlLnRvU3RyaW5nID0gYXJyYXlUb1N0cmluZztcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgbmV3IFR5cGVkQXJyYXkoMSkuc2xpY2UoKTtcbiAgICB9KSwgTkFNRSwgeyBzbGljZTogJHNsaWNlIH0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFsxLCAyXS50b0xvY2FsZVN0cmluZygpICE9IG5ldyBUeXBlZEFycmF5KFsxLCAyXSkudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgVHlwZWRBcnJheVByb3RvdHlwZS50b0xvY2FsZVN0cmluZy5jYWxsKFsxLCAyXSk7XG4gICAgfSkpLCBOQU1FLCB7IHRvTG9jYWxlU3RyaW5nOiAkdG9Mb2NhbGVTdHJpbmcgfSk7XG5cbiAgICBJdGVyYXRvcnNbTkFNRV0gPSBDT1JSRUNUX0lURVJfTkFNRSA/ICRuYXRpdmVJdGVyYXRvciA6ICRpdGVyYXRvcjtcbiAgICBpZiAoIUxJQlJBUlkgJiYgIUNPUlJFQ1RfSVRFUl9OQU1FKSBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIElURVJBVE9SLCAkaXRlcmF0b3IpO1xuICB9O1xufSBlbHNlIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICR0eXBlZCA9IHJlcXVpcmUoJy4vX3R5cGVkJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0luZGV4ID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKTtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBhcnJheUZpbGwgPSByZXF1aXJlKCcuL19hcnJheS1maWxsJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG52YXIgREFUQV9WSUVXID0gJ0RhdGFWaWV3JztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBXUk9OR19MRU5HVEggPSAnV3JvbmcgbGVuZ3RoISc7XG52YXIgV1JPTkdfSU5ERVggPSAnV3JvbmcgaW5kZXghJztcbnZhciAkQXJyYXlCdWZmZXIgPSBnbG9iYWxbQVJSQVlfQlVGRkVSXTtcbnZhciAkRGF0YVZpZXcgPSBnbG9iYWxbREFUQV9WSUVXXTtcbnZhciBNYXRoID0gZ2xvYmFsLk1hdGg7XG52YXIgUmFuZ2VFcnJvciA9IGdsb2JhbC5SYW5nZUVycm9yO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvdy1yZXN0cmljdGVkLW5hbWVzXG52YXIgSW5maW5pdHkgPSBnbG9iYWwuSW5maW5pdHk7XG52YXIgQmFzZUJ1ZmZlciA9ICRBcnJheUJ1ZmZlcjtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBwb3cgPSBNYXRoLnBvdztcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgbG9nID0gTWF0aC5sb2c7XG52YXIgTE4yID0gTWF0aC5MTjI7XG52YXIgQlVGRkVSID0gJ2J1ZmZlcic7XG52YXIgQllURV9MRU5HVEggPSAnYnl0ZUxlbmd0aCc7XG52YXIgQllURV9PRkZTRVQgPSAnYnl0ZU9mZnNldCc7XG52YXIgJEJVRkZFUiA9IERFU0NSSVBUT1JTID8gJ19iJyA6IEJVRkZFUjtcbnZhciAkTEVOR1RIID0gREVTQ1JJUFRPUlMgPyAnX2wnIDogQllURV9MRU5HVEg7XG52YXIgJE9GRlNFVCA9IERFU0NSSVBUT1JTID8gJ19vJyA6IEJZVEVfT0ZGU0VUO1xuXG4vLyBJRUVFNzU0IGNvbnZlcnNpb25zIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvaWVlZTc1NFxuZnVuY3Rpb24gcGFja0lFRUU3NTQodmFsdWUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KG5CeXRlcyk7XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgcnQgPSBtTGVuID09PSAyMyA/IHBvdygyLCAtMjQpIC0gcG93KDIsIC03NykgOiAwO1xuICB2YXIgaSA9IDA7XG4gIHZhciBzID0gdmFsdWUgPCAwIHx8IHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDAgPyAxIDogMDtcbiAgdmFyIGUsIG0sIGM7XG4gIHZhbHVlID0gYWJzKHZhbHVlKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICBpZiAodmFsdWUgIT0gdmFsdWUgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIG0gPSB2YWx1ZSAhPSB2YWx1ZSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBmbG9vcihsb2codmFsdWUpIC8gTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IHBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBwb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogcG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogcG93KDIsIGVCaWFzIC0gMSkgKiBwb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW2krK10gPSBtICYgMjU1LCBtIC89IDI1NiwgbUxlbiAtPSA4KTtcbiAgZSA9IGUgPDwgbUxlbiB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbaSsrXSA9IGUgJiAyNTUsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuICBidWZmZXJbLS1pXSB8PSBzICogMTI4O1xuICByZXR1cm4gYnVmZmVyO1xufVxuZnVuY3Rpb24gdW5wYWNrSUVFRTc1NChidWZmZXIsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIG5CaXRzID0gZUxlbiAtIDc7XG4gIHZhciBpID0gbkJ5dGVzIC0gMTtcbiAgdmFyIHMgPSBidWZmZXJbaS0tXTtcbiAgdmFyIGUgPSBzICYgMTI3O1xuICB2YXIgbTtcbiAgcyA+Pj0gNztcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbaV0sIGktLSwgbkJpdHMgLT0gOCk7XG4gIG0gPSBlICYgKDEgPDwgLW5CaXRzKSAtIDE7XG4gIGUgPj49IC1uQml0cztcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbaV0sIGktLSwgbkJpdHMgLT0gOCk7XG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiBzID8gLUluZmluaXR5IDogSW5maW5pdHk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBwb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfSByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIHBvdygyLCBlIC0gbUxlbik7XG59XG5cbmZ1bmN0aW9uIHVucGFja0kzMihieXRlcykge1xuICByZXR1cm4gYnl0ZXNbM10gPDwgMjQgfCBieXRlc1syXSA8PCAxNiB8IGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXTtcbn1cbmZ1bmN0aW9uIHBhY2tJOChpdCkge1xuICByZXR1cm4gW2l0ICYgMHhmZl07XG59XG5mdW5jdGlvbiBwYWNrSTE2KGl0KSB7XG4gIHJldHVybiBbaXQgJiAweGZmLCBpdCA+PiA4ICYgMHhmZl07XG59XG5mdW5jdGlvbiBwYWNrSTMyKGl0KSB7XG4gIHJldHVybiBbaXQgJiAweGZmLCBpdCA+PiA4ICYgMHhmZiwgaXQgPj4gMTYgJiAweGZmLCBpdCA+PiAyNCAmIDB4ZmZdO1xufVxuZnVuY3Rpb24gcGFja0Y2NChpdCkge1xuICByZXR1cm4gcGFja0lFRUU3NTQoaXQsIDUyLCA4KTtcbn1cbmZ1bmN0aW9uIHBhY2tGMzIoaXQpIHtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KGl0LCAyMywgNCk7XG59XG5cbmZ1bmN0aW9uIGFkZEdldHRlcihDLCBrZXksIGludGVybmFsKSB7XG4gIGRQKENbUFJPVE9UWVBFXSwga2V5LCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpc1tpbnRlcm5hbF07IH0gfSk7XG59XG5cbmZ1bmN0aW9uIGdldCh2aWV3LCBieXRlcywgaW5kZXgsIGlzTGl0dGxlRW5kaWFuKSB7XG4gIHZhciBudW1JbmRleCA9ICtpbmRleDtcbiAgdmFyIGludEluZGV4ID0gdG9JbmRleChudW1JbmRleCk7XG4gIGlmIChpbnRJbmRleCArIGJ5dGVzID4gdmlld1skTEVOR1RIXSkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gIHZhciBzdG9yZSA9IHZpZXdbJEJVRkZFUl0uX2I7XG4gIHZhciBzdGFydCA9IGludEluZGV4ICsgdmlld1skT0ZGU0VUXTtcbiAgdmFyIHBhY2sgPSBzdG9yZS5zbGljZShzdGFydCwgc3RhcnQgKyBieXRlcyk7XG4gIHJldHVybiBpc0xpdHRsZUVuZGlhbiA/IHBhY2sgOiBwYWNrLnJldmVyc2UoKTtcbn1cbmZ1bmN0aW9uIHNldCh2aWV3LCBieXRlcywgaW5kZXgsIGNvbnZlcnNpb24sIHZhbHVlLCBpc0xpdHRsZUVuZGlhbikge1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXg7XG4gIHZhciBpbnRJbmRleCA9IHRvSW5kZXgobnVtSW5kZXgpO1xuICBpZiAoaW50SW5kZXggKyBieXRlcyA+IHZpZXdbJExFTkdUSF0pIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgc3RvcmUgPSB2aWV3WyRCVUZGRVJdLl9iO1xuICB2YXIgc3RhcnQgPSBpbnRJbmRleCArIHZpZXdbJE9GRlNFVF07XG4gIHZhciBwYWNrID0gY29udmVyc2lvbigrdmFsdWUpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzOyBpKyspIHN0b3JlW3N0YXJ0ICsgaV0gPSBwYWNrW2lzTGl0dGxlRW5kaWFuID8gaSA6IGJ5dGVzIC0gaSAtIDFdO1xufVxuXG5pZiAoISR0eXBlZC5BQlYpIHtcbiAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSB0b0luZGV4KGxlbmd0aCk7XG4gICAgdGhpcy5fYiA9IGFycmF5RmlsbC5jYWxsKG5ldyBBcnJheShieXRlTGVuZ3RoKSwgMCk7XG4gICAgdGhpc1skTEVOR1RIXSA9IGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgJERhdGFWaWV3ID0gZnVuY3Rpb24gRGF0YVZpZXcoYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkRGF0YVZpZXcsIERBVEFfVklFVyk7XG4gICAgYW5JbnN0YW5jZShidWZmZXIsICRBcnJheUJ1ZmZlciwgREFUQV9WSUVXKTtcbiAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYnVmZmVyWyRMRU5HVEhdO1xuICAgIHZhciBvZmZzZXQgPSB0b0ludGVnZXIoYnl0ZU9mZnNldCk7XG4gICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gYnVmZmVyTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQhJyk7XG4gICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPT09IHVuZGVmaW5lZCA/IGJ1ZmZlckxlbmd0aCAtIG9mZnNldCA6IHRvTGVuZ3RoKGJ5dGVMZW5ndGgpO1xuICAgIGlmIChvZmZzZXQgKyBieXRlTGVuZ3RoID4gYnVmZmVyTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgdGhpc1skQlVGRkVSXSA9IGJ1ZmZlcjtcbiAgICB0aGlzWyRPRkZTRVRdID0gb2Zmc2V0O1xuICAgIHRoaXNbJExFTkdUSF0gPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gIGlmIChERVNDUklQVE9SUykge1xuICAgIGFkZEdldHRlcigkQXJyYXlCdWZmZXIsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCVUZGRVIsICdfYicpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCWVRFX09GRlNFVCwgJ19vJyk7XG4gIH1cblxuICByZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIGdldEludDg6IGZ1bmN0aW9uIGdldEludDgoYnl0ZU9mZnNldCkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXSA8PCAyNCA+PiAyNDtcbiAgICB9LFxuICAgIGdldFVpbnQ4OiBmdW5jdGlvbiBnZXRVaW50OChieXRlT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MTY6IGZ1bmN0aW9uIGdldEludDE2KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pO1xuICAgICAgcmV0dXJuIChieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF0pIDw8IDE2ID4+IDE2O1xuICAgIH0sXG4gICAgZ2V0VWludDE2OiBmdW5jdGlvbiBnZXRVaW50MTYoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICByZXR1cm4gYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MzI6IGZ1bmN0aW9uIGdldEludDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJMzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSkpO1xuICAgIH0sXG4gICAgZ2V0VWludDMyOiBmdW5jdGlvbiBnZXRVaW50MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0kzMihnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSkgPj4+IDA7XG4gICAgfSxcbiAgICBnZXRGbG9hdDMyOiBmdW5jdGlvbiBnZXRGbG9hdDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCAyMywgNCk7XG4gICAgfSxcbiAgICBnZXRGbG9hdDY0OiBmdW5jdGlvbiBnZXRGbG9hdDY0KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCA1MiwgOCk7XG4gICAgfSxcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0k4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSTgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldEludDE2OiBmdW5jdGlvbiBzZXRJbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJMTYsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0VWludDE2OiBmdW5jdGlvbiBzZXRVaW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSTE2LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEludDMyOiBmdW5jdGlvbiBzZXRJbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0VWludDMyOiBmdW5jdGlvbiBzZXRVaW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSTMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0MzI6IGZ1bmN0aW9uIHNldEZsb2F0MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrRjMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0NjQ6IGZ1bmN0aW9uIHNldEZsb2F0NjQoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBwYWNrRjY0LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgaWYgKCFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgJEFycmF5QnVmZmVyKDEpO1xuICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoLTEpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICB9KSB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3ICRBcnJheUJ1ZmZlcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoMS41KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBuZXcgJEFycmF5QnVmZmVyKE5hTik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgcmV0dXJuICRBcnJheUJ1ZmZlci5uYW1lICE9IEFSUkFZX0JVRkZFUjtcbiAgfSkpIHtcbiAgICAkQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhpcywgJEFycmF5QnVmZmVyKTtcbiAgICAgIHJldHVybiBuZXcgQmFzZUJ1ZmZlcih0b0luZGV4KGxlbmd0aCkpO1xuICAgIH07XG4gICAgdmFyIEFycmF5QnVmZmVyUHJvdG8gPSAkQXJyYXlCdWZmZXJbUFJPVE9UWVBFXSA9IEJhc2VCdWZmZXJbUFJPVE9UWVBFXTtcbiAgICBmb3IgKHZhciBrZXlzID0gZ09QTihCYXNlQnVmZmVyKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOykge1xuICAgICAgaWYgKCEoKGtleSA9IGtleXNbaisrXSkgaW4gJEFycmF5QnVmZmVyKSkgaGlkZSgkQXJyYXlCdWZmZXIsIGtleSwgQmFzZUJ1ZmZlcltrZXldKTtcbiAgICB9XG4gICAgaWYgKCFMSUJSQVJZKSBBcnJheUJ1ZmZlclByb3RvLmNvbnN0cnVjdG9yID0gJEFycmF5QnVmZmVyO1xuICB9XG4gIC8vIGlPUyBTYWZhcmkgNy54IGJ1Z1xuICB2YXIgdmlldyA9IG5ldyAkRGF0YVZpZXcobmV3ICRBcnJheUJ1ZmZlcigyKSk7XG4gIHZhciAkc2V0SW50OCA9ICREYXRhVmlld1tQUk9UT1RZUEVdLnNldEludDg7XG4gIHZpZXcuc2V0SW50OCgwLCAyMTQ3NDgzNjQ4KTtcbiAgdmlldy5zZXRJbnQ4KDEsIDIxNDc0ODM2NDkpO1xuICBpZiAodmlldy5nZXRJbnQ4KDApIHx8ICF2aWV3LmdldEludDgoMSkpIHJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgJHNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgICRzZXRJbnQ4LmNhbGwodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgIH1cbiAgfSwgdHJ1ZSk7XG59XG5zZXRUb1N0cmluZ1RhZygkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG5zZXRUb1N0cmluZ1RhZygkRGF0YVZpZXcsIERBVEFfVklFVyk7XG5oaWRlKCREYXRhVmlld1tQUk9UT1RZUEVdLCAkdHlwZWQuVklFVywgdHJ1ZSk7XG5leHBvcnRzW0FSUkFZX0JVRkZFUl0gPSAkQXJyYXlCdWZmZXI7XG5leHBvcnRzW0RBVEFfVklFV10gPSAkRGF0YVZpZXc7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciBUWVBFRCA9IHVpZCgndHlwZWRfYXJyYXknKTtcbnZhciBWSUVXID0gdWlkKCd2aWV3Jyk7XG52YXIgQUJWID0gISEoZ2xvYmFsLkFycmF5QnVmZmVyICYmIGdsb2JhbC5EYXRhVmlldyk7XG52YXIgQ09OU1RSID0gQUJWO1xudmFyIGkgPSAwO1xudmFyIGwgPSA5O1xudmFyIFR5cGVkO1xuXG52YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9ycyA9IChcbiAgJ0ludDhBcnJheSxVaW50OEFycmF5LFVpbnQ4Q2xhbXBlZEFycmF5LEludDE2QXJyYXksVWludDE2QXJyYXksSW50MzJBcnJheSxVaW50MzJBcnJheSxGbG9hdDMyQXJyYXksRmxvYXQ2NEFycmF5J1xuKS5zcGxpdCgnLCcpO1xuXG53aGlsZSAoaSA8IGwpIHtcbiAgaWYgKFR5cGVkID0gZ2xvYmFsW1R5cGVkQXJyYXlDb25zdHJ1Y3RvcnNbaSsrXV0pIHtcbiAgICBoaWRlKFR5cGVkLnByb3RvdHlwZSwgVFlQRUQsIHRydWUpO1xuICAgIGhpZGUoVHlwZWQucHJvdG90eXBlLCBWSUVXLCB0cnVlKTtcbiAgfSBlbHNlIENPTlNUUiA9IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQUJWOiBBQlYsXG4gIENPTlNUUjogQ09OU1RSLFxuICBUWVBFRDogVFlQRUQsXG4gIFZJRVc6IFZJRVdcbn07XG4iLCJ2YXIgaWQgPSAwO1xudmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFRZUEUpIHtcbiAgaWYgKCFpc09iamVjdChpdCkgfHwgaXQuX3QgIT09IFRZUEUpIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmIChuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKSBkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7IHZhbHVlOiB3a3NFeHQuZihuYW1lKSB9KTtcbn07XG4iLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTtcbiIsInZhciBzdG9yZSA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2w7XG52YXIgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjggQXJyYXkucHJvdG90eXBlLmZpbmQocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZmluZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg1KTtcbnZhciBLRVkgPSAnZmluZCc7XG52YXIgZm9yY2VkID0gdHJ1ZTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZiAoS0VZIGluIFtdKSBBcnJheSgxKVtLRVldKGZ1bmN0aW9uICgpIHsgZm9yY2VkID0gZmFsc2U7IH0pO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZDogZnVuY3Rpb24gZmluZChjYWxsYmFja2ZuIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqLykge1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoS0VZKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGZvckVhY2ggPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMCk7XG52YXIgU1RSSUNUID0gcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmZvckVhY2gsIHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFTVFJJQ1QsICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjEwIC8gMTUuNC40LjE4IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJGZvckVhY2godGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRpbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSk7XG52YXIgJG5hdGl2ZSA9IFtdLmluZGV4T2Y7XG52YXIgTkVHQVRJVkVfWkVSTyA9ICEhJG5hdGl2ZSAmJiAxIC8gWzFdLmluZGV4T2YoMSwgLTApIDwgMDtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoTkVHQVRJVkVfWkVSTyB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRuYXRpdmUpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTEgLyAxNS40LjQuMTQgQXJyYXkucHJvdG90eXBlLmluZGV4T2Yoc2VhcmNoRWxlbWVudCBbLCBmcm9tSW5kZXhdKVxuICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggPSAwICovKSB7XG4gICAgcmV0dXJuIE5FR0FUSVZFX1pFUk9cbiAgICAgIC8vIGNvbnZlcnQgLTAgdG8gKzBcbiAgICAgID8gJG5hdGl2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDBcbiAgICAgIDogJGluZGV4T2YodGhpcywgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBraW5kID0gdGhpcy5faztcbiAgdmFyIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgJHNvcnQgPSBbXS5zb3J0O1xudmFyIHRlc3QgPSBbMSwgMiwgM107XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gSUU4LVxuICB0ZXN0LnNvcnQodW5kZWZpbmVkKTtcbn0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIFY4IGJ1Z1xuICB0ZXN0LnNvcnQobnVsbCk7XG4gIC8vIE9sZCBXZWJLaXRcbn0pIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJHNvcnQpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMjUgQXJyYXkucHJvdG90eXBlLnNvcnQoY29tcGFyZWZuKVxuICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICAgIHJldHVybiBjb21wYXJlZm4gPT09IHVuZGVmaW5lZFxuICAgICAgPyAkc29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpKVxuICAgICAgOiAkc29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpLCBhRnVuY3Rpb24oY29tcGFyZWZuKSk7XG4gIH1cbn0pO1xuIiwidmFyIERhdGVQcm90byA9IERhdGUucHJvdG90eXBlO1xudmFyIElOVkFMSURfREFURSA9ICdJbnZhbGlkIERhdGUnO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgJHRvU3RyaW5nID0gRGF0ZVByb3RvW1RPX1NUUklOR107XG52YXIgZ2V0VGltZSA9IERhdGVQcm90by5nZXRUaW1lO1xuaWYgKG5ldyBEYXRlKE5hTikgKyAnJyAhPSBJTlZBTElEX0RBVEUpIHtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShEYXRlUHJvdG8sIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIHZhbHVlID0gZ2V0VGltZS5jYWxsKHRoaXMpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gJHRvU3RyaW5nLmNhbGwodGhpcykgOiBJTlZBTElEX0RBVEU7XG4gIH0pO1xufVxuIiwiLy8gMTkuMi4zLjIgLyAxNS4zLjQuNSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCh0aGlzQXJnLCBhcmdzLi4uKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdGdW5jdGlvbicsIHsgYmluZDogcmVxdWlyZSgnLi9fYmluZCcpIH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgTUFQID0gJ01hcCc7XG5cbi8vIDIzLjEgTWFwIE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKE1BUCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gTWFwKCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMS4zLjYgTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICB2YXIgZW50cnkgPSBzdHJvbmcuZ2V0RW50cnkodmFsaWRhdGUodGhpcywgTUFQKSwga2V5KTtcbiAgICByZXR1cm4gZW50cnkgJiYgZW50cnkudjtcbiAgfSxcbiAgLy8gMjMuMS4zLjkgTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHZhbGlkYXRlKHRoaXMsIE1BUCksIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nLCB0cnVlKTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBjcmVhdGU6IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKSB9KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHsgZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYgfSk7XG4iLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0IH0pO1xuIiwiLy8gMjYuMS4yIFJlZmxlY3QuY29uc3RydWN0KHRhcmdldCwgYXJndW1lbnRzTGlzdCBbLCBuZXdUYXJnZXRdKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4vX2JpbmQnKTtcbnZhciByQ29uc3RydWN0ID0gKHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3QgfHwge30pLmNvbnN0cnVjdDtcblxuLy8gTVMgRWRnZSBzdXBwb3J0cyBvbmx5IDIgYXJndW1lbnRzIGFuZCBhcmd1bWVudHNMaXN0IGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4vLyBGRiBOaWdodGx5IHNldHMgdGhpcmQgYXJndW1lbnQgYXMgYG5ldy50YXJnZXRgLCBidXQgZG9lcyBub3QgY3JlYXRlIGB0aGlzYCBmcm9tIGl0XG52YXIgTkVXX1RBUkdFVF9CVUcgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuICEockNvbnN0cnVjdChmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sIFtdLCBGKSBpbnN0YW5jZW9mIEYpO1xufSk7XG52YXIgQVJHU19CVUcgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICByQ29uc3RydWN0KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTkVXX1RBUkdFVF9CVUcgfHwgQVJHU19CVUcpLCAnUmVmbGVjdCcsIHtcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzIC8qICwgbmV3VGFyZ2V0ICovKSB7XG4gICAgYUZ1bmN0aW9uKFRhcmdldCk7XG4gICAgYW5PYmplY3QoYXJncyk7XG4gICAgdmFyIG5ld1RhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gVGFyZ2V0IDogYUZ1bmN0aW9uKGFyZ3VtZW50c1syXSk7XG4gICAgaWYgKEFSR1NfQlVHICYmICFORVdfVEFSR0VUX0JVRykgcmV0dXJuIHJDb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzLCBuZXdUYXJnZXQpO1xuICAgIGlmIChUYXJnZXQgPT0gbmV3VGFyZ2V0KSB7XG4gICAgICAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIG9wdGltaXphdGlvbiBmb3IgMC00IGFyZ3VtZW50c1xuICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgVGFyZ2V0KCk7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSk7XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgIGNhc2UgMzogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgIGNhc2UgNDogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICB9XG4gICAgICAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIGxvdCBvZiBhcmd1bWVudHMgY2FzZVxuICAgICAgdmFyICRhcmdzID0gW251bGxdO1xuICAgICAgJGFyZ3MucHVzaC5hcHBseSgkYXJncywgYXJncyk7XG4gICAgICByZXR1cm4gbmV3IChiaW5kLmFwcGx5KFRhcmdldCwgJGFyZ3MpKSgpO1xuICAgIH1cbiAgICAvLyB3aXRoIGFsdGVyZWQgbmV3VGFyZ2V0LCBub3Qgc3VwcG9ydCBidWlsdC1pbiBjb25zdHJ1Y3RvcnNcbiAgICB2YXIgcHJvdG8gPSBuZXdUYXJnZXQucHJvdG90eXBlO1xuICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZShpc09iamVjdChwcm90bykgPyBwcm90byA6IE9iamVjdC5wcm90b3R5cGUpO1xuICAgIHZhciByZXN1bHQgPSBGdW5jdGlvbi5hcHBseS5jYWxsKFRhcmdldCwgaW5zdGFuY2UsIGFyZ3MpO1xuICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogaW5zdGFuY2U7XG4gIH1cbn0pO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJyk7XG52YXIgJGZsYWdzID0gcmVxdWlyZSgnLi9fZmxhZ3MnKTtcbnZhciAkUmVnRXhwID0gZ2xvYmFsLlJlZ0V4cDtcbnZhciBCYXNlID0gJFJlZ0V4cDtcbnZhciBwcm90byA9ICRSZWdFeHAucHJvdG90eXBlO1xudmFyIHJlMSA9IC9hL2c7XG52YXIgcmUyID0gL2EvZztcbi8vIFwibmV3XCIgY3JlYXRlcyBhIG5ldyBvYmplY3QsIG9sZCB3ZWJraXQgYnVnZ3kgaGVyZVxudmFyIENPUlJFQ1RfTkVXID0gbmV3ICRSZWdFeHAocmUxKSAhPT0gcmUxO1xuXG5pZiAocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAoIUNPUlJFQ1RfTkVXIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZTJbcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyldID0gZmFsc2U7XG4gIC8vIFJlZ0V4cCBjb25zdHJ1Y3RvciBjYW4gYWx0ZXIgZmxhZ3MgYW5kIElzUmVnRXhwIHdvcmtzIGNvcnJlY3Qgd2l0aCBAQG1hdGNoXG4gIHJldHVybiAkUmVnRXhwKHJlMSkgIT0gcmUxIHx8ICRSZWdFeHAocmUyKSA9PSByZTIgfHwgJFJlZ0V4cChyZTEsICdpJykgIT0gJy9hL2knO1xufSkpKSB7XG4gICRSZWdFeHAgPSBmdW5jdGlvbiBSZWdFeHAocCwgZikge1xuICAgIHZhciB0aVJFID0gdGhpcyBpbnN0YW5jZW9mICRSZWdFeHA7XG4gICAgdmFyIHBpUkUgPSBpc1JlZ0V4cChwKTtcbiAgICB2YXIgZmlVID0gZiA9PT0gdW5kZWZpbmVkO1xuICAgIHJldHVybiAhdGlSRSAmJiBwaVJFICYmIHAuY29uc3RydWN0b3IgPT09ICRSZWdFeHAgJiYgZmlVID8gcFxuICAgICAgOiBpbmhlcml0SWZSZXF1aXJlZChDT1JSRUNUX05FV1xuICAgICAgICA/IG5ldyBCYXNlKHBpUkUgJiYgIWZpVSA/IHAuc291cmNlIDogcCwgZilcbiAgICAgICAgOiBCYXNlKChwaVJFID0gcCBpbnN0YW5jZW9mICRSZWdFeHApID8gcC5zb3VyY2UgOiBwLCBwaVJFICYmIGZpVSA/ICRmbGFncy5jYWxsKHApIDogZilcbiAgICAgICwgdGlSRSA/IHRoaXMgOiBwcm90bywgJFJlZ0V4cCk7XG4gIH07XG4gIHZhciBwcm94eSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBrZXkgaW4gJFJlZ0V4cCB8fCBkUCgkUmVnRXhwLCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQmFzZVtrZXldOyB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAoaXQpIHsgQmFzZVtrZXldID0gaXQ7IH1cbiAgICB9KTtcbiAgfTtcbiAgZm9yICh2YXIga2V5cyA9IGdPUE4oQmFzZSksIGkgPSAwOyBrZXlzLmxlbmd0aCA+IGk7KSBwcm94eShrZXlzW2krK10pO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICRSZWdFeHA7XG4gICRSZWdFeHAucHJvdG90eXBlID0gcHJvdG87XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoZ2xvYmFsLCAnUmVnRXhwJywgJFJlZ0V4cCk7XG59XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ1JlZ0V4cCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlZ2V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYycpO1xucmVxdWlyZSgnLi9fZXhwb3J0Jykoe1xuICB0YXJnZXQ6ICdSZWdFeHAnLFxuICBwcm90bzogdHJ1ZSxcbiAgZm9yY2VkOiByZWdleHBFeGVjICE9PSAvLi8uZXhlY1xufSwge1xuICBleGVjOiByZWdleHBFeGVjXG59KTtcbiIsIi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzKClcbmlmIChyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmIC8uL2cuZmxhZ3MgIT0gJ2cnKSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mKFJlZ0V4cC5wcm90b3R5cGUsICdmbGFncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IHJlcXVpcmUoJy4vX2ZsYWdzJylcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGFkdmFuY2VTdHJpbmdJbmRleCA9IHJlcXVpcmUoJy4vX2FkdmFuY2Utc3RyaW5nLWluZGV4Jyk7XG52YXIgcmVnRXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjLWFic3RyYWN0Jyk7XG5cbi8vIEBAbWF0Y2ggbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnbWF0Y2gnLCAxLCBmdW5jdGlvbiAoZGVmaW5lZCwgTUFUQ0gsICRtYXRjaCwgbWF5YmVDYWxsTmF0aXZlKSB7XG4gIHJldHVybiBbXG4gICAgLy8gYFN0cmluZy5wcm90b3R5cGUubWF0Y2hgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUubWF0Y2hcbiAgICBmdW5jdGlvbiBtYXRjaChyZWdleHApIHtcbiAgICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICAgIHZhciBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbTUFUQ0hdO1xuICAgICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbTUFUQ0hdKFN0cmluZyhPKSk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQG1hdGNoXG4gICAgZnVuY3Rpb24gKHJlZ2V4cCkge1xuICAgICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZSgkbWF0Y2gsIHJlZ2V4cCwgdGhpcyk7XG4gICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG4gICAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgICBpZiAoIXJ4Lmdsb2JhbCkgcmV0dXJuIHJlZ0V4cEV4ZWMocngsIFMpO1xuICAgICAgdmFyIGZ1bGxVbmljb2RlID0gcngudW5pY29kZTtcbiAgICAgIHJ4Lmxhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgQSA9IFtdO1xuICAgICAgdmFyIG4gPSAwO1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIHdoaWxlICgocmVzdWx0ID0gcmVnRXhwRXhlYyhyeCwgUykpICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBtYXRjaFN0ciA9IFN0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgICBBW25dID0gbWF0Y2hTdHI7XG4gICAgICAgIGlmIChtYXRjaFN0ciA9PT0gJycpIHJ4Lmxhc3RJbmRleCA9IGFkdmFuY2VTdHJpbmdJbmRleChTLCB0b0xlbmd0aChyeC5sYXN0SW5kZXgpLCBmdWxsVW5pY29kZSk7XG4gICAgICAgIG4rKztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuID09PSAwID8gbnVsbCA6IEE7XG4gICAgfVxuICBdO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gcmVxdWlyZSgnLi9fYWR2YW5jZS1zdHJpbmctaW5kZXgnKTtcbnZhciByZWdFeHBFeGVjID0gcmVxdWlyZSgnLi9fcmVnZXhwLWV4ZWMtYWJzdHJhY3QnKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFMgPSAvXFwkKFskJmAnXXxcXGRcXGQ/fDxbXj5dKj4pL2c7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQgPSAvXFwkKFskJmAnXXxcXGRcXGQ/KS9nO1xuXG52YXIgbWF5YmVUb1N0cmluZyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/IGl0IDogU3RyaW5nKGl0KTtcbn07XG5cbi8vIEBAcmVwbGFjZSBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdyZXBsYWNlJywgMiwgZnVuY3Rpb24gKGRlZmluZWQsIFJFUExBQ0UsICRyZXBsYWNlLCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgcmV0dXJuIFtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnJlcGxhY2VcbiAgICBmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICAgIHZhciBmbiA9IHNlYXJjaFZhbHVlID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlYXJjaFZhbHVlW1JFUExBQ0VdO1xuICAgICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBmbi5jYWxsKHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpXG4gICAgICAgIDogJHJlcGxhY2UuY2FsbChTdHJpbmcoTyksIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xuICAgIH0sXG4gICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHJlcGxhY2VcbiAgICBmdW5jdGlvbiAocmVnZXhwLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUoJHJlcGxhY2UsIHJlZ2V4cCwgdGhpcywgcmVwbGFjZVZhbHVlKTtcbiAgICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcblxuICAgICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcbiAgICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuICAgICAgdmFyIGZ1bmN0aW9uYWxSZXBsYWNlID0gdHlwZW9mIHJlcGxhY2VWYWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIGlmICghZnVuY3Rpb25hbFJlcGxhY2UpIHJlcGxhY2VWYWx1ZSA9IFN0cmluZyhyZXBsYWNlVmFsdWUpO1xuICAgICAgdmFyIGdsb2JhbCA9IHJ4Lmdsb2JhbDtcbiAgICAgIGlmIChnbG9iYWwpIHtcbiAgICAgICAgdmFyIGZ1bGxVbmljb2RlID0gcngudW5pY29kZTtcbiAgICAgICAgcngubGFzdEluZGV4ID0gMDtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVnRXhwRXhlYyhyeCwgUyk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIGJyZWFrO1xuICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgaWYgKCFnbG9iYWwpIGJyZWFrO1xuICAgICAgICB2YXIgbWF0Y2hTdHIgPSBTdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgaWYgKG1hdGNoU3RyID09PSAnJykgcngubGFzdEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHRvTGVuZ3RoKHJ4Lmxhc3RJbmRleCksIGZ1bGxVbmljb2RlKTtcbiAgICAgIH1cbiAgICAgIHZhciBhY2N1bXVsYXRlZFJlc3VsdCA9ICcnO1xuICAgICAgdmFyIG5leHRTb3VyY2VQb3NpdGlvbiA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0c1tpXTtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBTdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gbWF4KG1pbih0b0ludGVnZXIocmVzdWx0LmluZGV4KSwgUy5sZW5ndGgpLCAwKTtcbiAgICAgICAgdmFyIGNhcHR1cmVzID0gW107XG4gICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgZXF1aXZhbGVudCB0b1xuICAgICAgICAvLyAgIGNhcHR1cmVzID0gcmVzdWx0LnNsaWNlKDEpLm1hcChtYXliZVRvU3RyaW5nKVxuICAgICAgICAvLyBidXQgZm9yIHNvbWUgcmVhc29uIGBuYXRpdmVTbGljZS5jYWxsKHJlc3VsdCwgMSwgcmVzdWx0Lmxlbmd0aClgIChjYWxsZWQgaW5cbiAgICAgICAgLy8gdGhlIHNsaWNlIHBvbHlmaWxsIHdoZW4gc2xpY2luZyBuYXRpdmUgYXJyYXlzKSBcImRvZXNuJ3Qgd29ya1wiIGluIHNhZmFyaSA5IGFuZFxuICAgICAgICAvLyBjYXVzZXMgYSBjcmFzaCAoaHR0cHM6Ly9wYXN0ZWJpbi5jb20vTjIxUXplUUEpIHdoZW4gdHJ5aW5nIHRvIGRlYnVnIGl0LlxuICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHJlc3VsdC5sZW5ndGg7IGorKykgY2FwdHVyZXMucHVzaChtYXliZVRvU3RyaW5nKHJlc3VsdFtqXSkpO1xuICAgICAgICB2YXIgbmFtZWRDYXB0dXJlcyA9IHJlc3VsdC5ncm91cHM7XG4gICAgICAgIGlmIChmdW5jdGlvbmFsUmVwbGFjZSkge1xuICAgICAgICAgIHZhciByZXBsYWNlckFyZ3MgPSBbbWF0Y2hlZF0uY29uY2F0KGNhcHR1cmVzLCBwb3NpdGlvbiwgUyk7XG4gICAgICAgICAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkgcmVwbGFjZXJBcmdzLnB1c2gobmFtZWRDYXB0dXJlcyk7XG4gICAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gU3RyaW5nKHJlcGxhY2VWYWx1ZS5hcHBseSh1bmRlZmluZWQsIHJlcGxhY2VyQXJncykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcGxhY2VtZW50ID0gZ2V0U3Vic3RpdHV0aW9uKG1hdGNoZWQsIFMsIHBvc2l0aW9uLCBjYXB0dXJlcywgbmFtZWRDYXB0dXJlcywgcmVwbGFjZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24gPj0gbmV4dFNvdXJjZVBvc2l0aW9uKSB7XG4gICAgICAgICAgYWNjdW11bGF0ZWRSZXN1bHQgKz0gUy5zbGljZShuZXh0U291cmNlUG9zaXRpb24sIHBvc2l0aW9uKSArIHJlcGxhY2VtZW50O1xuICAgICAgICAgIG5leHRTb3VyY2VQb3NpdGlvbiA9IHBvc2l0aW9uICsgbWF0Y2hlZC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2N1bXVsYXRlZFJlc3VsdCArIFMuc2xpY2UobmV4dFNvdXJjZVBvc2l0aW9uKTtcbiAgICB9XG4gIF07XG5cbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1nZXRzdWJzdGl0dXRpb25cbiAgZnVuY3Rpb24gZ2V0U3Vic3RpdHV0aW9uKG1hdGNoZWQsIHN0ciwgcG9zaXRpb24sIGNhcHR1cmVzLCBuYW1lZENhcHR1cmVzLCByZXBsYWNlbWVudCkge1xuICAgIHZhciB0YWlsUG9zID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgICB2YXIgbSA9IGNhcHR1cmVzLmxlbmd0aDtcbiAgICB2YXIgc3ltYm9scyA9IFNVQlNUSVRVVElPTl9TWU1CT0xTX05PX05BTUVEO1xuICAgIGlmIChuYW1lZENhcHR1cmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG5hbWVkQ2FwdHVyZXMgPSB0b09iamVjdChuYW1lZENhcHR1cmVzKTtcbiAgICAgIHN5bWJvbHMgPSBTVUJTVElUVVRJT05fU1lNQk9MUztcbiAgICB9XG4gICAgcmV0dXJuICRyZXBsYWNlLmNhbGwocmVwbGFjZW1lbnQsIHN5bWJvbHMsIGZ1bmN0aW9uIChtYXRjaCwgY2gpIHtcbiAgICAgIHZhciBjYXB0dXJlO1xuICAgICAgc3dpdGNoIChjaC5jaGFyQXQoMCkpIHtcbiAgICAgICAgY2FzZSAnJCc6IHJldHVybiAnJCc7XG4gICAgICAgIGNhc2UgJyYnOiByZXR1cm4gbWF0Y2hlZDtcbiAgICAgICAgY2FzZSAnYCc6IHJldHVybiBzdHIuc2xpY2UoMCwgcG9zaXRpb24pO1xuICAgICAgICBjYXNlIFwiJ1wiOiByZXR1cm4gc3RyLnNsaWNlKHRhaWxQb3MpO1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICBjYXB0dXJlID0gbmFtZWRDYXB0dXJlc1tjaC5zbGljZSgxLCAtMSldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiAvLyBcXGRcXGQ/XG4gICAgICAgICAgdmFyIG4gPSArY2g7XG4gICAgICAgICAgaWYgKG4gPT09IDApIHJldHVybiBtYXRjaDtcbiAgICAgICAgICBpZiAobiA+IG0pIHtcbiAgICAgICAgICAgIHZhciBmID0gZmxvb3IobiAvIDEwKTtcbiAgICAgICAgICAgIGlmIChmID09PSAwKSByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgICBpZiAoZiA8PSBtKSByZXR1cm4gY2FwdHVyZXNbZiAtIDFdID09PSB1bmRlZmluZWQgPyBjaC5jaGFyQXQoMSkgOiBjYXB0dXJlc1tmIC0gMV0gKyBjaC5jaGFyQXQoMSk7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhcHR1cmUgPSBjYXB0dXJlc1tuIC0gMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FwdHVyZSA9PT0gdW5kZWZpbmVkID8gJycgOiBjYXB0dXJlO1xuICAgIH0pO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gcmVxdWlyZSgnLi9fYWR2YW5jZS1zdHJpbmctaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGNhbGxSZWdFeHBFeGVjID0gcmVxdWlyZSgnLi9fcmVnZXhwLWV4ZWMtYWJzdHJhY3QnKTtcbnZhciByZWdleHBFeGVjID0gcmVxdWlyZSgnLi9fcmVnZXhwLWV4ZWMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgJG1pbiA9IE1hdGgubWluO1xudmFyICRwdXNoID0gW10ucHVzaDtcbnZhciAkU1BMSVQgPSAnc3BsaXQnO1xudmFyIExFTkdUSCA9ICdsZW5ndGgnO1xudmFyIExBU1RfSU5ERVggPSAnbGFzdEluZGV4JztcbnZhciBNQVhfVUlOVDMyID0gMHhmZmZmZmZmZjtcblxuLy8gYmFiZWwtbWluaWZ5IHRyYW5zcGlsZXMgUmVnRXhwKCd4JywgJ3knKSAtPiAveC95IGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3JcbnZhciBTVVBQT1JUU19ZID0gIWZhaWxzKGZ1bmN0aW9uICgpIHsgUmVnRXhwKE1BWF9VSU5UMzIsICd5Jyk7IH0pO1xuXG4vLyBAQHNwbGl0IGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3NwbGl0JywgMiwgZnVuY3Rpb24gKGRlZmluZWQsIFNQTElULCAkc3BsaXQsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICB2YXIgaW50ZXJuYWxTcGxpdDtcbiAgaWYgKFxuICAgICdhYmJjJ1skU1BMSVRdKC8oYikqLylbMV0gPT0gJ2MnIHx8XG4gICAgJ3Rlc3QnWyRTUExJVF0oLyg/OikvLCAtMSlbTEVOR1RIXSAhPSA0IHx8XG4gICAgJ2FiJ1skU1BMSVRdKC8oPzphYikqLylbTEVOR1RIXSAhPSAyIHx8XG4gICAgJy4nWyRTUExJVF0oLyguPykoLj8pLylbTEVOR1RIXSAhPSA0IHx8XG4gICAgJy4nWyRTUExJVF0oLygpKCkvKVtMRU5HVEhdID4gMSB8fFxuICAgICcnWyRTUExJVF0oLy4/LylbTEVOR1RIXVxuICApIHtcbiAgICAvLyBiYXNlZCBvbiBlczUtc2hpbSBpbXBsZW1lbnRhdGlvbiwgbmVlZCB0byByZXdvcmsgaXRcbiAgICBpbnRlcm5hbFNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHZhciBzdHJpbmcgPSBTdHJpbmcodGhpcyk7XG4gICAgICBpZiAoc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDApIHJldHVybiBbXTtcbiAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICBpZiAoIWlzUmVnRXhwKHNlcGFyYXRvcikpIHJldHVybiAkc3BsaXQuY2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgdmFyIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IubXVsdGlsaW5lID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IudW5pY29kZSA/ICd1JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnN0aWNreSA/ICd5JyA6ICcnKTtcbiAgICAgIHZhciBsYXN0TGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBzcGxpdExpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9VSU5UMzIgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICB2YXIgc2VwYXJhdG9yQ29weSA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuICAgICAgdmFyIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGg7XG4gICAgICB3aGlsZSAobWF0Y2ggPSByZWdleHBFeGVjLmNhbGwoc2VwYXJhdG9yQ29weSwgc3RyaW5nKSkge1xuICAgICAgICBsYXN0SW5kZXggPSBzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdO1xuICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgIGlmIChtYXRjaFtMRU5HVEhdID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0cmluZ1tMRU5HVEhdKSAkcHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcbiAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF1bTEVOR1RIXTtcbiAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgIGlmIChvdXRwdXRbTEVOR1RIXSA+PSBzcGxpdExpbWl0KSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXSA9PT0gbWF0Y2guaW5kZXgpIHNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF0rKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgfVxuICAgICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0cmluZ1tMRU5HVEhdKSB7XG4gICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3JDb3B5LnRlc3QoJycpKSBvdXRwdXQucHVzaCgnJyk7XG4gICAgICB9IGVsc2Ugb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgIHJldHVybiBvdXRwdXRbTEVOR1RIXSA+IHNwbGl0TGltaXQgPyBvdXRwdXQuc2xpY2UoMCwgc3BsaXRMaW1pdCkgOiBvdXRwdXQ7XG4gICAgfTtcbiAgLy8gQ2hha3JhLCBWOFxuICB9IGVsc2UgaWYgKCcwJ1skU1BMSVRdKHVuZGVmaW5lZCwgMClbTEVOR1RIXSkge1xuICAgIGludGVybmFsU3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgcmV0dXJuIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwID8gW10gOiAkc3BsaXQuY2FsbCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGludGVybmFsU3BsaXQgPSAkc3BsaXQ7XG4gIH1cblxuICByZXR1cm4gW1xuICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLnNwbGl0YCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnNwbGl0XG4gICAgZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgICAgdmFyIHNwbGl0dGVyID0gc2VwYXJhdG9yID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlcGFyYXRvcltTUExJVF07XG4gICAgICByZXR1cm4gc3BsaXR0ZXIgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IHNwbGl0dGVyLmNhbGwoc2VwYXJhdG9yLCBPLCBsaW1pdClcbiAgICAgICAgOiBpbnRlcm5hbFNwbGl0LmNhbGwoU3RyaW5nKE8pLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9LFxuICAgIC8vIGBSZWdFeHAucHJvdG90eXBlW0BAc3BsaXRdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAc3BsaXRcbiAgICAvL1xuICAgIC8vIE5PVEU6IFRoaXMgY2Fubm90IGJlIHByb3Blcmx5IHBvbHlmaWxsZWQgaW4gZW5naW5lcyB0aGF0IGRvbid0IHN1cHBvcnRcbiAgICAvLyB0aGUgJ3knIGZsYWcuXG4gICAgZnVuY3Rpb24gKHJlZ2V4cCwgbGltaXQpIHtcbiAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUoaW50ZXJuYWxTcGxpdCwgcmVnZXhwLCB0aGlzLCBsaW1pdCwgaW50ZXJuYWxTcGxpdCAhPT0gJHNwbGl0KTtcbiAgICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcblxuICAgICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcbiAgICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuICAgICAgdmFyIEMgPSBzcGVjaWVzQ29uc3RydWN0b3IocngsIFJlZ0V4cCk7XG5cbiAgICAgIHZhciB1bmljb2RlTWF0Y2hpbmcgPSByeC51bmljb2RlO1xuICAgICAgdmFyIGZsYWdzID0gKHJ4Lmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJ4Lm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocngudW5pY29kZSA/ICd1JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoU1VQUE9SVFNfWSA/ICd5JyA6ICdnJyk7XG5cbiAgICAgIC8vIF4oPyArIHJ4ICsgKSBpcyBuZWVkZWQsIGluIGNvbWJpbmF0aW9uIHdpdGggc29tZSBTIHNsaWNpbmcsIHRvXG4gICAgICAvLyBzaW11bGF0ZSB0aGUgJ3knIGZsYWcuXG4gICAgICB2YXIgc3BsaXR0ZXIgPSBuZXcgQyhTVVBQT1JUU19ZID8gcnggOiAnXig/OicgKyByeC5zb3VyY2UgKyAnKScsIGZsYWdzKTtcbiAgICAgIHZhciBsaW0gPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gTUFYX1VJTlQzMiA6IGxpbWl0ID4+PiAwO1xuICAgICAgaWYgKGxpbSA9PT0gMCkgcmV0dXJuIFtdO1xuICAgICAgaWYgKFMubGVuZ3RoID09PSAwKSByZXR1cm4gY2FsbFJlZ0V4cEV4ZWMoc3BsaXR0ZXIsIFMpID09PSBudWxsID8gW1NdIDogW107XG4gICAgICB2YXIgcCA9IDA7XG4gICAgICB2YXIgcSA9IDA7XG4gICAgICB2YXIgQSA9IFtdO1xuICAgICAgd2hpbGUgKHEgPCBTLmxlbmd0aCkge1xuICAgICAgICBzcGxpdHRlci5sYXN0SW5kZXggPSBTVVBQT1JUU19ZID8gcSA6IDA7XG4gICAgICAgIHZhciB6ID0gY2FsbFJlZ0V4cEV4ZWMoc3BsaXR0ZXIsIFNVUFBPUlRTX1kgPyBTIDogUy5zbGljZShxKSk7XG4gICAgICAgIHZhciBlO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgeiA9PT0gbnVsbCB8fFxuICAgICAgICAgIChlID0gJG1pbih0b0xlbmd0aChzcGxpdHRlci5sYXN0SW5kZXggKyAoU1VQUE9SVFNfWSA/IDAgOiBxKSksIFMubGVuZ3RoKSkgPT09IHBcbiAgICAgICAgKSB7XG4gICAgICAgICAgcSA9IGFkdmFuY2VTdHJpbmdJbmRleChTLCBxLCB1bmljb2RlTWF0Y2hpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEEucHVzaChTLnNsaWNlKHAsIHEpKTtcbiAgICAgICAgICBpZiAoQS5sZW5ndGggPT09IGxpbSkgcmV0dXJuIEE7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gei5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIEEucHVzaCh6W2ldKTtcbiAgICAgICAgICAgIGlmIChBLmxlbmd0aCA9PT0gbGltKSByZXR1cm4gQTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcSA9IHAgPSBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBBLnB1c2goUy5zbGljZShwKSk7XG4gICAgICByZXR1cm4gQTtcbiAgICB9XG4gIF07XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnJlcXVpcmUoJy4vZXM2LnJlZ2V4cC5mbGFncycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgJGZsYWdzID0gcmVxdWlyZSgnLi9fZmxhZ3MnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciAkdG9TdHJpbmcgPSAvLi9bVE9fU1RSSU5HXTtcblxudmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmbikge1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKFJlZ0V4cC5wcm90b3R5cGUsIFRPX1NUUklORywgZm4sIHRydWUpO1xufTtcblxuLy8gMjEuMi41LjE0IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcoKVxuaWYgKHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkgeyByZXR1cm4gJHRvU3RyaW5nLmNhbGwoeyBzb3VyY2U6ICdhJywgZmxhZ3M6ICdiJyB9KSAhPSAnL2EvYic7IH0pKSB7XG4gIGRlZmluZShmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgUiA9IGFuT2JqZWN0KHRoaXMpO1xuICAgIHJldHVybiAnLycuY29uY2F0KFIuc291cmNlLCAnLycsXG4gICAgICAnZmxhZ3MnIGluIFIgPyBSLmZsYWdzIDogIURFU0NSSVBUT1JTICYmIFIgaW5zdGFuY2VvZiBSZWdFeHAgPyAkZmxhZ3MuY2FsbChSKSA6IHVuZGVmaW5lZCk7XG4gIH0pO1xuLy8gRkY0NC0gUmVnRXhwI3RvU3RyaW5nIGhhcyBhIHdyb25nIG5hbWVcbn0gZWxzZSBpZiAoJHRvU3RyaW5nLm5hbWUgIT0gVE9fU1RSSU5HKSB7XG4gIGRlZmluZShmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJHRvU3RyaW5nLmNhbGwodGhpcyk7XG4gIH0pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGluZGV4ID0gdGhpcy5faTtcbiAgdmFyIHBvaW50O1xuICBpZiAoaW5kZXggPj0gTy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgTUVUQSA9IHJlcXVpcmUoJy4vX21ldGEnKS5LRVk7XG52YXIgJGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIHdrc0RlZmluZSA9IHJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKTtcbnZhciBlbnVtS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIF9jcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZ09QTkV4dCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpO1xudmFyICRHT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciAkRFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QRCA9ICRHT1BELmY7XG52YXIgZFAgPSAkRFAuZjtcbnZhciBnT1BOID0gZ09QTkV4dC5mO1xudmFyICRTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyICRKU09OID0gZ2xvYmFsLkpTT047XG52YXIgX3N0cmluZ2lmeSA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBISURERU4gPSB3a3MoJ19oaWRkZW4nKTtcbnZhciBUT19QUklNSVRJVkUgPSB3a3MoJ3RvUHJpbWl0aXZlJyk7XG52YXIgaXNFbnVtID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpO1xudmFyIEFsbFN5bWJvbHMgPSBzaGFyZWQoJ3N5bWJvbHMnKTtcbnZhciBPUFN5bWJvbHMgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdFtQUk9UT1RZUEVdO1xudmFyIFVTRV9OQVRJVkUgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xudmFyIFFPYmplY3QgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX2NyZWF0ZShkUCh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkUCh0aGlzLCAnYScsIHsgdmFsdWU6IDcgfSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbiAoaXQsIGtleSwgRCkge1xuICB2YXIgcHJvdG9EZXNjID0gZ09QRChPYmplY3RQcm90bywga2V5KTtcbiAgaWYgKHByb3RvRGVzYykgZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZiAocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bykgZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHN5bS5fayA9IHRhZztcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciBpc1N5bWJvbCA9IFVTRV9OQVRJVkUgJiYgdHlwZW9mICRTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKSB7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8pICRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSkge1xuICAgIGlmICghRC5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoIWhhcyhpdCwgSElEREVOKSkgZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pIGl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwgeyBlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKSB9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKSB7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuICB2YXIga2V5O1xuICB3aGlsZSAobCA+IGkpICRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApIHtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpIHtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gIGl0ID0gdG9JT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmIChEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIEQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgdmFyIG5hbWVzID0gZ09QTih0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gIHZhciBJU19PUCA9IGl0ID09PSBPYmplY3RQcm90bztcbiAgdmFyIG5hbWVzID0gZ09QTihJU19PUCA/IE9QU3ltYm9scyA6IHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKSByZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmICghVVNFX05BVElWRSkge1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCkgdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzID09PSBPYmplY3RQcm90bykgJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYgKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYgKERFU0NSSVBUT1JTICYmIHNldHRlcikgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0IH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gICRHT1BELmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkRFAuZiA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmIChERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKSB7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBTeW1ib2w6ICRTeW1ib2wgfSk7XG5cbmZvciAodmFyIGVzNlN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaiA9IDA7IGVzNlN5bWJvbHMubGVuZ3RoID4gajspd2tzKGVzNlN5bWJvbHNbaisrXSk7XG5cbmZvciAodmFyIHdlbGxLbm93blN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBrID0gMDsgd2VsbEtub3duU3ltYm9scy5sZW5ndGggPiBrOykgd2tzRGVmaW5lKHdlbGxLbm93blN5bWJvbHNbaysrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XG4gICAgaWYgKCFpc1N5bWJvbChzeW0pKSB0aHJvdyBUeXBlRXJyb3Ioc3ltICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gICAgZm9yICh2YXIga2V5IGluIFN5bWJvbFJlZ2lzdHJ5KSBpZiAoU3ltYm9sUmVnaXN0cnlba2V5XSA9PT0gc3ltKSByZXR1cm4ga2V5O1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoeyBhOiBTIH0pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkge1xuICAgIHZhciBhcmdzID0gW2l0XTtcbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgICRyZXBsYWNlciA9IHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgICBpZiAoIWlzT2JqZWN0KHJlcGxhY2VyKSAmJiBpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgaWYgKCFpc0FycmF5KHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiAkcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykgdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnRmxvYXQzMicsIDQsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBGbG9hdDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdhc3luY0l0ZXJhdG9yJyk7XG4iLCJ2YXIgJGl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgSVRFUkFUT1IgPSB3a3MoJ2l0ZXJhdG9yJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHdrcygndG9TdHJpbmdUYWcnKTtcbnZhciBBcnJheVZhbHVlcyA9IEl0ZXJhdG9ycy5BcnJheTtcblxudmFyIERPTUl0ZXJhYmxlcyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiBmYWxzZSxcbiAgQ1NTVmFsdWVMaXN0OiBmYWxzZSxcbiAgQ2xpZW50UmVjdExpc3Q6IGZhbHNlLFxuICBET01SZWN0TGlzdDogZmFsc2UsXG4gIERPTVN0cmluZ0xpc3Q6IGZhbHNlLFxuICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiBmYWxzZSxcbiAgRmlsZUxpc3Q6IGZhbHNlLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogZmFsc2UsXG4gIEhUTUxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTEZvcm1FbGVtZW50OiBmYWxzZSxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IGZhbHNlLFxuICBNZWRpYUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBNaW1lVHlwZUFycmF5OiBmYWxzZSxcbiAgTmFtZWROb2RlTWFwOiBmYWxzZSxcbiAgTm9kZUxpc3Q6IHRydWUsXG4gIFBhaW50UmVxdWVzdExpc3Q6IGZhbHNlLFxuICBQbHVnaW46IGZhbHNlLFxuICBQbHVnaW5BcnJheTogZmFsc2UsXG4gIFNWR0xlbmd0aExpc3Q6IGZhbHNlLFxuICBTVkdOdW1iZXJMaXN0OiBmYWxzZSxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IGZhbHNlLFxuICBTVkdQb2ludExpc3Q6IGZhbHNlLFxuICBTVkdTdHJpbmdMaXN0OiBmYWxzZSxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogZmFsc2UsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IGZhbHNlLFxuICBTdHlsZVNoZWV0TGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIFRleHRUcmFja0N1ZUxpc3Q6IGZhbHNlLFxuICBUZXh0VHJhY2tMaXN0OiBmYWxzZSxcbiAgVG91Y2hMaXN0OiBmYWxzZVxufTtcblxuZm9yICh2YXIgY29sbGVjdGlvbnMgPSBnZXRLZXlzKERPTUl0ZXJhYmxlcyksIGkgPSAwOyBpIDwgY29sbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIE5BTUUgPSBjb2xsZWN0aW9uc1tpXTtcbiAgdmFyIGV4cGxpY2l0ID0gRE9NSXRlcmFibGVzW05BTUVdO1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIGtleTtcbiAgaWYgKHByb3RvKSB7XG4gICAgaWYgKCFwcm90b1tJVEVSQVRPUl0pIGhpZGUocHJvdG8sIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgaWYgKCFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gICAgSXRlcmF0b3JzW05BTUVdID0gQXJyYXlWYWx1ZXM7XG4gICAgaWYgKGV4cGxpY2l0KSBmb3IgKGtleSBpbiAkaXRlcmF0b3JzKSBpZiAoIXByb3RvW2tleV0pIHJlZGVmaW5lKHByb3RvLCBrZXksICRpdGVyYXRvcnNba2V5XSwgdHJ1ZSk7XG4gIH1cbn1cbiIsInR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkhsc1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJIbHNcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL2Rpc3QvXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvaGxzLmpzXCIpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoe1xuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBwcmVmaXggPSAnfic7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cbiAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRXZlbnRzKCkge31cblxuLy9cbi8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG4vLyBpbnN0YW5jZSBpbiB0aGlzIHdheSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkaXJlY3RseS5cbi8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG4vLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3Rcbi8vIG92ZXJyaWRkZW4gb3IgdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuLy9cbmlmIChPYmplY3QuY3JlYXRlKSB7XG4gIEV2ZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vXG4gIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG4gIC8vIHNvbWUgb2xkIGJyb3dzZXJzIGxpa2UgQW5kcm9pZCA0LCBpUGhvbmUgNS4xLCBPcGVyYSAxMSBhbmQgU2FmYXJpIDUuXG4gIC8vXG4gIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXykgcHJlZml4ID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IGVtaXR0ZXIsIG9uY2UpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0pIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIGVtaXR0ZXIuX2V2ZW50c0NvdW50Kys7XG4gIGVsc2UgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XS5mbikgZW1pdHRlci5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2UgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBbZW1pdHRlci5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuICByZXR1cm4gZW1pdHRlcjtcbn1cblxuLyoqXG4gKiBDbGVhciBldmVudCBieSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZ0IFRoZSBFdmVudCBuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXJFdmVudChlbWl0dGVyLCBldnQpIHtcbiAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApIGVtaXR0ZXIuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgZWxzZSBkZWxldGUgZW1pdHRlci5fZXZlbnRzW2V2dF07XG59XG5cbi8qKlxuICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICB2YXIgbmFtZXMgPSBbXVxuICAgICwgZXZlbnRzXG4gICAgLCBuYW1lO1xuXG4gIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIG5hbWVzO1xuXG4gIGZvciAobmFtZSBpbiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzKSkge1xuICAgIGlmIChoYXMuY2FsbChldmVudHMsIG5hbWUpKSBuYW1lcy5wdXNoKHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcbiAgfVxuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWhhbmRsZXJzKSByZXR1cm4gW107XG4gIGlmIChoYW5kbGVycy5mbikgcmV0dXJuIFtoYW5kbGVycy5mbl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG4gICAgZWVbaV0gPSBoYW5kbGVyc1tpXS5mbjtcbiAgfVxuXG4gIHJldHVybiBlZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIDA7XG4gIGlmIChsaXN0ZW5lcnMuZm4pIHJldHVybiAxO1xuICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZWxzZSBgZmFsc2VgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgYXJnc1xuICAgICwgaTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gICAgICAsIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IG1hdGNoIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IGhhdmUgdGhpcyBjb250ZXh0LlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgaWYgKCFmbikge1xuICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKFxuICAgICAgbGlzdGVuZXJzLmZuID09PSBmbiAmJlxuICAgICAgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKSAmJlxuICAgICAgKCFjb250ZXh0IHx8IGxpc3RlbmVycy5jb250ZXh0ID09PSBjb250ZXh0KVxuICAgICkge1xuICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFxuICAgICAgICBsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8XG4gICAgICAgIChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSkgfHxcbiAgICAgICAgKGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpXG4gICAgICApIHtcbiAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgICAvL1xuICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gICAgZWxzZSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQ7XG5cbiAgaWYgKGV2ZW50KSB7XG4gICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAodGhpcy5fZXZlbnRzW2V2dF0pIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgcHJlZml4LlxuLy9cbkV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuLy9cbi8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG4vL1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmlmICh0cnVlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL25vZGUtbGlicy1icm93c2VyL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL25vZGUtbGlicy1icm93c2VyL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy91cmwtdG9vbGtpdC9zcmMvdXJsLXRvb2xraXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3VybC10b29sa2l0L3NyYy91cmwtdG9vbGtpdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMxODA4XG5cbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbihmdW5jdGlvbihyb290KSB7IFxuLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuICB2YXIgVVJMX1JFR0VYID0gL14oKD86W2EtekEtWjAtOStcXC0uXSs6KT8pKFxcL1xcL1teXFwvPyNdKik/KCg/OlteXFwvXFw/I10qXFwvKSouKj8pPz8oOy4qPyk/KFxcPy4qPyk/KCMuKj8pPyQvO1xuICB2YXIgRklSU1RfU0VHTUVOVF9SRUdFWCA9IC9eKFteXFwvPyNdKikoLiopJC87XG4gIHZhciBTTEFTSF9ET1RfUkVHRVggPSAvKD86XFwvfF4pXFwuKD89XFwvKS9nO1xuICB2YXIgU0xBU0hfRE9UX0RPVF9SRUdFWCA9IC8oPzpcXC98XilcXC5cXC5cXC8oPyFcXC5cXC5cXC8pLio/KD89XFwvKS9nO1xuXG4gIHZhciBVUkxUb29sa2l0ID0geyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAvLyBJZiBvcHRzLmFsd2F5c05vcm1hbGl6ZSBpcyB0cnVlIHRoZW4gdGhlIHBhdGggd2lsbCBhbHdheXMgYmUgbm9ybWFsaXplZCBldmVuIHdoZW4gaXQgc3RhcnRzIHdpdGggLyBvciAvL1xuICAgIC8vIEUuZ1xuICAgIC8vIFdpdGggb3B0cy5hbHdheXNOb3JtYWxpemUgPSBmYWxzZSAoZGVmYXVsdCwgc3BlYyBjb21wbGlhbnQpXG4gICAgLy8gaHR0cDovL2EuY29tL2IvY2QgKyAvZS9mLy4uL2cgPT4gaHR0cDovL2EuY29tL2UvZi8uLi9nXG4gICAgLy8gV2l0aCBvcHRzLmFsd2F5c05vcm1hbGl6ZSA9IHRydWUgKG5vdCBzcGVjIGNvbXBsaWFudClcbiAgICAvLyBodHRwOi8vYS5jb20vYi9jZCArIC9lL2YvLi4vZyA9PiBodHRwOi8vYS5jb20vZS9nXG4gICAgYnVpbGRBYnNvbHV0ZVVSTDogZnVuY3Rpb24oYmFzZVVSTCwgcmVsYXRpdmVVUkwsIG9wdHMpIHtcbiAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgLy8gcmVtb3ZlIGFueSByZW1haW5pbmcgc3BhY2UgYW5kIENSTEZcbiAgICAgIGJhc2VVUkwgPSBiYXNlVVJMLnRyaW0oKTtcbiAgICAgIHJlbGF0aXZlVVJMID0gcmVsYXRpdmVVUkwudHJpbSgpO1xuICAgICAgaWYgKCFyZWxhdGl2ZVVSTCkge1xuICAgICAgICAvLyAyYSkgSWYgdGhlIGVtYmVkZGVkIFVSTCBpcyBlbnRpcmVseSBlbXB0eSwgaXQgaW5oZXJpdHMgdGhlXG4gICAgICAgIC8vIGVudGlyZSBiYXNlIFVSTCAoaS5lLiwgaXMgc2V0IGVxdWFsIHRvIHRoZSBiYXNlIFVSTClcbiAgICAgICAgLy8gYW5kIHdlIGFyZSBkb25lLlxuICAgICAgICBpZiAoIW9wdHMuYWx3YXlzTm9ybWFsaXplKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VVUkw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhc2VQYXJ0c0Zvck5vcm1hbGlzZSA9IFVSTFRvb2xraXQucGFyc2VVUkwoYmFzZVVSTCk7XG4gICAgICAgIGlmICghYmFzZVBhcnRzRm9yTm9ybWFsaXNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgYmFzZSBVUkwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgYmFzZVBhcnRzRm9yTm9ybWFsaXNlLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgoYmFzZVBhcnRzRm9yTm9ybWFsaXNlLnBhdGgpO1xuICAgICAgICByZXR1cm4gVVJMVG9vbGtpdC5idWlsZFVSTEZyb21QYXJ0cyhiYXNlUGFydHNGb3JOb3JtYWxpc2UpO1xuICAgICAgfVxuICAgICAgdmFyIHJlbGF0aXZlUGFydHMgPSBVUkxUb29sa2l0LnBhcnNlVVJMKHJlbGF0aXZlVVJMKTtcbiAgICAgIGlmICghcmVsYXRpdmVQYXJ0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSByZWxhdGl2ZSBVUkwuJyk7XG4gICAgICB9XG4gICAgICBpZiAocmVsYXRpdmVQYXJ0cy5zY2hlbWUpIHtcbiAgICAgICAgLy8gMmIpIElmIHRoZSBlbWJlZGRlZCBVUkwgc3RhcnRzIHdpdGggYSBzY2hlbWUgbmFtZSwgaXQgaXNcbiAgICAgICAgLy8gaW50ZXJwcmV0ZWQgYXMgYW4gYWJzb2x1dGUgVVJMIGFuZCB3ZSBhcmUgZG9uZS5cbiAgICAgICAgaWYgKCFvcHRzLmFsd2F5c05vcm1hbGl6ZSkge1xuICAgICAgICAgIHJldHVybiByZWxhdGl2ZVVSTDtcbiAgICAgICAgfVxuICAgICAgICByZWxhdGl2ZVBhcnRzLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgocmVsYXRpdmVQYXJ0cy5wYXRoKTtcbiAgICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMocmVsYXRpdmVQYXJ0cyk7XG4gICAgICB9XG4gICAgICB2YXIgYmFzZVBhcnRzID0gVVJMVG9vbGtpdC5wYXJzZVVSTChiYXNlVVJMKTtcbiAgICAgIGlmICghYmFzZVBhcnRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIGJhc2UgVVJMLicpO1xuICAgICAgfVxuICAgICAgaWYgKCFiYXNlUGFydHMubmV0TG9jICYmIGJhc2VQYXJ0cy5wYXRoICYmIGJhc2VQYXJ0cy5wYXRoWzBdICE9PSAnLycpIHtcbiAgICAgICAgLy8gSWYgbmV0TG9jIG1pc3NpbmcgYW5kIHBhdGggZG9lc24ndCBzdGFydCB3aXRoICcvJywgYXNzdW1lIGV2ZXJ0aGluZyBiZWZvcmUgdGhlIGZpcnN0ICcvJyBpcyB0aGUgbmV0TG9jXG4gICAgICAgIC8vIFRoaXMgY2F1c2VzICdleGFtcGxlLmNvbS9hJyB0byBiZSBoYW5kbGVkIGFzICcvL2V4YW1wbGUuY29tL2EnIGluc3RlYWQgb2YgJy9leGFtcGxlLmNvbS9hJ1xuICAgICAgICB2YXIgcGF0aFBhcnRzID0gRklSU1RfU0VHTUVOVF9SRUdFWC5leGVjKGJhc2VQYXJ0cy5wYXRoKTtcbiAgICAgICAgYmFzZVBhcnRzLm5ldExvYyA9IHBhdGhQYXJ0c1sxXTtcbiAgICAgICAgYmFzZVBhcnRzLnBhdGggPSBwYXRoUGFydHNbMl07XG4gICAgICB9XG4gICAgICBpZiAoYmFzZVBhcnRzLm5ldExvYyAmJiAhYmFzZVBhcnRzLnBhdGgpIHtcbiAgICAgICAgYmFzZVBhcnRzLnBhdGggPSAnLyc7XG4gICAgICB9XG4gICAgICB2YXIgYnVpbHRQYXJ0cyA9IHtcbiAgICAgICAgLy8gMmMpIE90aGVyd2lzZSwgdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgc2NoZW1lIG9mXG4gICAgICAgIC8vIHRoZSBiYXNlIFVSTC5cbiAgICAgICAgc2NoZW1lOiBiYXNlUGFydHMuc2NoZW1lLFxuICAgICAgICBuZXRMb2M6IHJlbGF0aXZlUGFydHMubmV0TG9jLFxuICAgICAgICBwYXRoOiBudWxsLFxuICAgICAgICBwYXJhbXM6IHJlbGF0aXZlUGFydHMucGFyYW1zLFxuICAgICAgICBxdWVyeTogcmVsYXRpdmVQYXJ0cy5xdWVyeSxcbiAgICAgICAgZnJhZ21lbnQ6IHJlbGF0aXZlUGFydHMuZnJhZ21lbnRcbiAgICAgIH07XG4gICAgICBpZiAoIXJlbGF0aXZlUGFydHMubmV0TG9jKSB7XG4gICAgICAgIC8vIDMpIElmIHRoZSBlbWJlZGRlZCBVUkwncyA8bmV0X2xvYz4gaXMgbm9uLWVtcHR5LCB3ZSBza2lwIHRvXG4gICAgICAgIC8vIFN0ZXAgNy4gIE90aGVyd2lzZSwgdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgPG5ldF9sb2M+XG4gICAgICAgIC8vIChpZiBhbnkpIG9mIHRoZSBiYXNlIFVSTC5cbiAgICAgICAgYnVpbHRQYXJ0cy5uZXRMb2MgPSBiYXNlUGFydHMubmV0TG9jO1xuICAgICAgICAvLyA0KSBJZiB0aGUgZW1iZWRkZWQgVVJMIHBhdGggaXMgcHJlY2VkZWQgYnkgYSBzbGFzaCBcIi9cIiwgdGhlXG4gICAgICAgIC8vIHBhdGggaXMgbm90IHJlbGF0aXZlIGFuZCB3ZSBza2lwIHRvIFN0ZXAgNy5cbiAgICAgICAgaWYgKHJlbGF0aXZlUGFydHMucGF0aFswXSAhPT0gJy8nKSB7XG4gICAgICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLnBhdGgpIHtcbiAgICAgICAgICAgIC8vIDUpIElmIHRoZSBlbWJlZGRlZCBVUkwgcGF0aCBpcyBlbXB0eSAoYW5kIG5vdCBwcmVjZWRlZCBieSBhXG4gICAgICAgICAgICAvLyBzbGFzaCksIHRoZW4gdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgYmFzZSBVUkwgcGF0aFxuICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gYmFzZVBhcnRzLnBhdGg7XG4gICAgICAgICAgICAvLyA1YSkgaWYgdGhlIGVtYmVkZGVkIFVSTCdzIDxwYXJhbXM+IGlzIG5vbi1lbXB0eSwgd2Ugc2tpcCB0b1xuICAgICAgICAgICAgLy8gc3RlcCA3OyBvdGhlcndpc2UsIGl0IGluaGVyaXRzIHRoZSA8cGFyYW1zPiBvZiB0aGUgYmFzZVxuICAgICAgICAgICAgLy8gVVJMIChpZiBhbnkpIGFuZFxuICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLnBhcmFtcykge1xuICAgICAgICAgICAgICBidWlsdFBhcnRzLnBhcmFtcyA9IGJhc2VQYXJ0cy5wYXJhbXM7XG4gICAgICAgICAgICAgIC8vIDViKSBpZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPHF1ZXJ5PiBpcyBub24tZW1wdHksIHdlIHNraXAgdG9cbiAgICAgICAgICAgICAgLy8gc3RlcCA3OyBvdGhlcndpc2UsIGl0IGluaGVyaXRzIHRoZSA8cXVlcnk+IG9mIHRoZSBiYXNlXG4gICAgICAgICAgICAgIC8vIFVSTCAoaWYgYW55KSBhbmQgd2Ugc2tpcCB0byBzdGVwIDcuXG4gICAgICAgICAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5xdWVyeSkge1xuICAgICAgICAgICAgICAgIGJ1aWx0UGFydHMucXVlcnkgPSBiYXNlUGFydHMucXVlcnk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gNikgVGhlIGxhc3Qgc2VnbWVudCBvZiB0aGUgYmFzZSBVUkwncyBwYXRoIChhbnl0aGluZ1xuICAgICAgICAgICAgLy8gZm9sbG93aW5nIHRoZSByaWdodG1vc3Qgc2xhc2ggXCIvXCIsIG9yIHRoZSBlbnRpcmUgcGF0aCBpZiBub1xuICAgICAgICAgICAgLy8gc2xhc2ggaXMgcHJlc2VudCkgaXMgcmVtb3ZlZCBhbmQgdGhlIGVtYmVkZGVkIFVSTCdzIHBhdGggaXNcbiAgICAgICAgICAgIC8vIGFwcGVuZGVkIGluIGl0cyBwbGFjZS5cbiAgICAgICAgICAgIHZhciBiYXNlVVJMUGF0aCA9IGJhc2VQYXJ0cy5wYXRoO1xuICAgICAgICAgICAgdmFyIG5ld1BhdGggPSBiYXNlVVJMUGF0aC5zdWJzdHJpbmcoMCwgYmFzZVVSTFBhdGgubGFzdEluZGV4T2YoJy8nKSArIDEpICsgcmVsYXRpdmVQYXJ0cy5wYXRoO1xuICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKG5ld1BhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGJ1aWx0UGFydHMucGF0aCA9PT0gbnVsbCkge1xuICAgICAgICBidWlsdFBhcnRzLnBhdGggPSBvcHRzLmFsd2F5c05vcm1hbGl6ZSA/IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChyZWxhdGl2ZVBhcnRzLnBhdGgpIDogcmVsYXRpdmVQYXJ0cy5wYXRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMoYnVpbHRQYXJ0cyk7XG4gICAgfSxcbiAgICBwYXJzZVVSTDogZnVuY3Rpb24odXJsKSB7XG4gICAgICB2YXIgcGFydHMgPSBVUkxfUkVHRVguZXhlYyh1cmwpO1xuICAgICAgaWYgKCFwYXJ0cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjaGVtZTogcGFydHNbMV0gfHwgJycsXG4gICAgICAgIG5ldExvYzogcGFydHNbMl0gfHwgJycsXG4gICAgICAgIHBhdGg6IHBhcnRzWzNdIHx8ICcnLFxuICAgICAgICBwYXJhbXM6IHBhcnRzWzRdIHx8ICcnLFxuICAgICAgICBxdWVyeTogcGFydHNbNV0gfHwgJycsXG4gICAgICAgIGZyYWdtZW50OiBwYXJ0c1s2XSB8fCAnJ1xuICAgICAgfTtcbiAgICB9LFxuICAgIG5vcm1hbGl6ZVBhdGg6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgb3BlcmF0aW9ucyBhcmVcbiAgICAgIC8vIHRoZW4gYXBwbGllZCwgaW4gb3JkZXIsIHRvIHRoZSBuZXcgcGF0aDpcbiAgICAgIC8vIDZhKSBBbGwgb2NjdXJyZW5jZXMgb2YgXCIuL1wiLCB3aGVyZSBcIi5cIiBpcyBhIGNvbXBsZXRlIHBhdGhcbiAgICAgIC8vIHNlZ21lbnQsIGFyZSByZW1vdmVkLlxuICAgICAgLy8gNmIpIElmIHRoZSBwYXRoIGVuZHMgd2l0aCBcIi5cIiBhcyBhIGNvbXBsZXRlIHBhdGggc2VnbWVudCxcbiAgICAgIC8vIHRoYXQgXCIuXCIgaXMgcmVtb3ZlZC5cbiAgICAgIHBhdGggPSBwYXRoLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJykucmVwbGFjZShTTEFTSF9ET1RfUkVHRVgsICcnKTtcbiAgICAgIC8vIDZjKSBBbGwgb2NjdXJyZW5jZXMgb2YgXCI8c2VnbWVudD4vLi4vXCIsIHdoZXJlIDxzZWdtZW50PiBpcyBhXG4gICAgICAvLyBjb21wbGV0ZSBwYXRoIHNlZ21lbnQgbm90IGVxdWFsIHRvIFwiLi5cIiwgYXJlIHJlbW92ZWQuXG4gICAgICAvLyBSZW1vdmFsIG9mIHRoZXNlIHBhdGggc2VnbWVudHMgaXMgcGVyZm9ybWVkIGl0ZXJhdGl2ZWx5LFxuICAgICAgLy8gcmVtb3ZpbmcgdGhlIGxlZnRtb3N0IG1hdGNoaW5nIHBhdHRlcm4gb24gZWFjaCBpdGVyYXRpb24sXG4gICAgICAvLyB1bnRpbCBubyBtYXRjaGluZyBwYXR0ZXJuIHJlbWFpbnMuXG4gICAgICAvLyA2ZCkgSWYgdGhlIHBhdGggZW5kcyB3aXRoIFwiPHNlZ21lbnQ+Ly4uXCIsIHdoZXJlIDxzZWdtZW50PiBpcyBhXG4gICAgICAvLyBjb21wbGV0ZSBwYXRoIHNlZ21lbnQgbm90IGVxdWFsIHRvIFwiLi5cIiwgdGhhdFxuICAgICAgLy8gXCI8c2VnbWVudD4vLi5cIiBpcyByZW1vdmVkLlxuICAgICAgd2hpbGUgKHBhdGgubGVuZ3RoICE9PSAocGF0aCA9IHBhdGgucmVwbGFjZShTTEFTSF9ET1RfRE9UX1JFR0VYLCAnJykpLmxlbmd0aCkge30gLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICByZXR1cm4gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpO1xuICAgIH0sXG4gICAgYnVpbGRVUkxGcm9tUGFydHM6IGZ1bmN0aW9uKHBhcnRzKSB7XG4gICAgICByZXR1cm4gcGFydHMuc2NoZW1lICsgcGFydHMubmV0TG9jICsgcGFydHMucGF0aCArIHBhcnRzLnBhcmFtcyArIHBhcnRzLnF1ZXJ5ICsgcGFydHMuZnJhZ21lbnQ7XG4gICAgfVxuICB9O1xuXG4vKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gIGlmKHRydWUpXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBVUkxUb29sa2l0O1xuICBlbHNlIHt9XG59KSh0aGlzKTtcbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvd2Vid29ya2lmeS13ZWJwYWNrL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy93ZWJ3b3JraWZ5LXdlYnBhY2svaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIHdlYnBhY2tCb290c3RyYXBGdW5jIChtb2R1bGVzKSB7XG4vKioqKioqLyAgLy8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gIHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovICAvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gIGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuLyoqKioqKi8gICAgLy8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyAgICBpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovICAgICAgcmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbi8qKioqKiovICAgIC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyAgICB2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyAgICAgIGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gICAgICBsOiBmYWxzZSxcbi8qKioqKiovICAgICAgZXhwb3J0czoge31cbi8qKioqKiovICAgIH07XG5cbi8qKioqKiovICAgIC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gICAgbW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbi8qKioqKiovICAgIC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovICAgIG1vZHVsZS5sID0gdHJ1ZTtcblxuLyoqKioqKi8gICAgLy8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovICB9XG5cbi8qKioqKiovICAvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbi8qKioqKiovICAvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbi8qKioqKiovICAvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4vKioqKioqLyAgLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyAgICBpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gICAgICAgIGdldDogZ2V0dGVyXG4vKioqKioqLyAgICAgIH0pO1xuLyoqKioqKi8gICAgfVxuLyoqKioqKi8gIH07XG5cbi8qKioqKiovICAvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovICB9O1xuXG4vKioqKioqLyAgLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovICBfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovICAgIHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gICAgICBmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gICAgICBmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gICAgcmV0dXJuIGdldHRlcjtcbi8qKioqKiovICB9O1xuXG4vKioqKioqLyAgLy8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4vKioqKioqLyAgLy8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovICBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9cIjtcblxuLyoqKioqKi8gIC8vIG9uIGVycm9yIGZ1bmN0aW9uIGZvciBhc3luYyBsb2FkaW5nXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5vZSA9IGZ1bmN0aW9uKGVycikgeyBjb25zb2xlLmVycm9yKGVycik7IHRocm93IGVycjsgfTtcblxuICB2YXIgZiA9IF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gRU5UUllfTU9EVUxFKVxuICByZXR1cm4gZi5kZWZhdWx0IHx8IGYgLy8gdHJ5IHRvIGNhbGwgZGVmYXVsdCBpZiBkZWZpbmVkIHRvIGFsc28gc3VwcG9ydCBiYWJlbCBlc21vZHVsZSBleHBvcnRzXG59XG5cbnZhciBtb2R1bGVOYW1lUmVxRXhwID0gJ1tcXFxcLnxcXFxcLXxcXFxcK3xcXFxcd3xcXC98QF0rJ1xudmFyIGRlcGVuZGVuY3lSZWdFeHAgPSAnXFxcXCgoXFwvXFxcXCouKj9cXFxcKlxcLyk/XFxzPy4qPygnICsgbW9kdWxlTmFtZVJlcUV4cCArICcpLio/XFxcXCknIC8vIGFkZGl0aW9uYWwgY2hhcnMgd2hlbiBvdXRwdXQucGF0aGluZm8gaXMgdHJ1ZVxuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNTkzNjYxLzEzMDQ0MlxuZnVuY3Rpb24gcXVvdGVSZWdFeHAgKHN0cikge1xuICByZXR1cm4gKHN0ciArICcnKS5yZXBsYWNlKC9bLj8qK14kW1xcXVxcXFwoKXt9fC1dL2csICdcXFxcJCYnKVxufVxuXG5mdW5jdGlvbiBpc051bWVyaWMobikge1xuICByZXR1cm4gIWlzTmFOKDEgKiBuKTsgLy8gMSAqIG4gY29udmVydHMgaW50ZWdlcnMsIGludGVnZXJzIGFzIHN0cmluZyAoXCIxMjNcIiksIDFlMyBhbmQgXCIxZTNcIiB0byBpbnRlZ2VycyBhbmQgc3RyaW5ncyB0byBOYU5cbn1cblxuZnVuY3Rpb24gZ2V0TW9kdWxlRGVwZW5kZW5jaWVzIChzb3VyY2VzLCBtb2R1bGUsIHF1ZXVlTmFtZSkge1xuICB2YXIgcmV0dmFsID0ge31cbiAgcmV0dmFsW3F1ZXVlTmFtZV0gPSBbXVxuXG4gIHZhciBmblN0cmluZyA9IG1vZHVsZS50b1N0cmluZygpXG4gIHZhciB3cmFwcGVyU2lnbmF0dXJlID0gZm5TdHJpbmcubWF0Y2goL15mdW5jdGlvblxccz9cXChcXHcrLFxccypcXHcrLFxccyooXFx3KylcXCkvKVxuICBpZiAoIXdyYXBwZXJTaWduYXR1cmUpIHJldHVybiByZXR2YWxcbiAgdmFyIHdlYnBhY2tSZXF1aXJlTmFtZSA9IHdyYXBwZXJTaWduYXR1cmVbMV1cblxuICAvLyBtYWluIGJ1bmRsZSBkZXBzXG4gIHZhciByZSA9IG5ldyBSZWdFeHAoJyhcXFxcXFxcXG58XFxcXFcpJyArIHF1b3RlUmVnRXhwKHdlYnBhY2tSZXF1aXJlTmFtZSkgKyBkZXBlbmRlbmN5UmVnRXhwLCAnZycpXG4gIHZhciBtYXRjaFxuICB3aGlsZSAoKG1hdGNoID0gcmUuZXhlYyhmblN0cmluZykpKSB7XG4gICAgaWYgKG1hdGNoWzNdID09PSAnZGxsLXJlZmVyZW5jZScpIGNvbnRpbnVlXG4gICAgcmV0dmFsW3F1ZXVlTmFtZV0ucHVzaChtYXRjaFszXSlcbiAgfVxuXG4gIC8vIGRsbCBkZXBzXG4gIHJlID0gbmV3IFJlZ0V4cCgnXFxcXCgnICsgcXVvdGVSZWdFeHAod2VicGFja1JlcXVpcmVOYW1lKSArICdcXFxcKFwiKGRsbC1yZWZlcmVuY2VcXFxccygnICsgbW9kdWxlTmFtZVJlcUV4cCArICcpKVwiXFxcXClcXFxcKScgKyBkZXBlbmRlbmN5UmVnRXhwLCAnZycpXG4gIHdoaWxlICgobWF0Y2ggPSByZS5leGVjKGZuU3RyaW5nKSkpIHtcbiAgICBpZiAoIXNvdXJjZXNbbWF0Y2hbMl1dKSB7XG4gICAgICByZXR2YWxbcXVldWVOYW1lXS5wdXNoKG1hdGNoWzFdKVxuICAgICAgc291cmNlc1ttYXRjaFsyXV0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKG1hdGNoWzFdKS5tXG4gICAgfVxuICAgIHJldHZhbFttYXRjaFsyXV0gPSByZXR2YWxbbWF0Y2hbMl1dIHx8IFtdXG4gICAgcmV0dmFsW21hdGNoWzJdXS5wdXNoKG1hdGNoWzRdKVxuICB9XG5cbiAgLy8gY29udmVydCAxZTMgYmFjayB0byAxMDAwIC0gdGhpcyBjYW4gYmUgaW1wb3J0YW50IGFmdGVyIHVnbGlmeS1qcyBjb252ZXJ0ZWQgMTAwMCB0byAxZTNcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZXR2YWwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJldHZhbFtrZXlzW2ldXS5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGlzTnVtZXJpYyhyZXR2YWxba2V5c1tpXV1bal0pKSB7XG4gICAgICAgIHJldHZhbFtrZXlzW2ldXVtqXSA9IDEgKiByZXR2YWxba2V5c1tpXV1bal07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldHZhbFxufVxuXG5mdW5jdGlvbiBoYXNWYWx1ZXNJblF1ZXVlcyAocXVldWVzKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMocXVldWVzKVxuICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGhhc1ZhbHVlcywga2V5KSB7XG4gICAgcmV0dXJuIGhhc1ZhbHVlcyB8fCBxdWV1ZXNba2V5XS5sZW5ndGggPiAwXG4gIH0sIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBnZXRSZXF1aXJlZE1vZHVsZXMgKHNvdXJjZXMsIG1vZHVsZUlkKSB7XG4gIHZhciBtb2R1bGVzUXVldWUgPSB7XG4gICAgbWFpbjogW21vZHVsZUlkXVxuICB9XG4gIHZhciByZXF1aXJlZE1vZHVsZXMgPSB7XG4gICAgbWFpbjogW11cbiAgfVxuICB2YXIgc2Vlbk1vZHVsZXMgPSB7XG4gICAgbWFpbjoge31cbiAgfVxuXG4gIHdoaWxlIChoYXNWYWx1ZXNJblF1ZXVlcyhtb2R1bGVzUXVldWUpKSB7XG4gICAgdmFyIHF1ZXVlcyA9IE9iamVjdC5rZXlzKG1vZHVsZXNRdWV1ZSlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHF1ZXVlTmFtZSA9IHF1ZXVlc1tpXVxuICAgICAgdmFyIHF1ZXVlID0gbW9kdWxlc1F1ZXVlW3F1ZXVlTmFtZV1cbiAgICAgIHZhciBtb2R1bGVUb0NoZWNrID0gcXVldWUucG9wKClcbiAgICAgIHNlZW5Nb2R1bGVzW3F1ZXVlTmFtZV0gPSBzZWVuTW9kdWxlc1txdWV1ZU5hbWVdIHx8IHt9XG4gICAgICBpZiAoc2Vlbk1vZHVsZXNbcXVldWVOYW1lXVttb2R1bGVUb0NoZWNrXSB8fCAhc291cmNlc1txdWV1ZU5hbWVdW21vZHVsZVRvQ2hlY2tdKSBjb250aW51ZVxuICAgICAgc2Vlbk1vZHVsZXNbcXVldWVOYW1lXVttb2R1bGVUb0NoZWNrXSA9IHRydWVcbiAgICAgIHJlcXVpcmVkTW9kdWxlc1txdWV1ZU5hbWVdID0gcmVxdWlyZWRNb2R1bGVzW3F1ZXVlTmFtZV0gfHwgW11cbiAgICAgIHJlcXVpcmVkTW9kdWxlc1txdWV1ZU5hbWVdLnB1c2gobW9kdWxlVG9DaGVjaylcbiAgICAgIHZhciBuZXdNb2R1bGVzID0gZ2V0TW9kdWxlRGVwZW5kZW5jaWVzKHNvdXJjZXMsIHNvdXJjZXNbcXVldWVOYW1lXVttb2R1bGVUb0NoZWNrXSwgcXVldWVOYW1lKVxuICAgICAgdmFyIG5ld01vZHVsZXNLZXlzID0gT2JqZWN0LmtleXMobmV3TW9kdWxlcylcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmV3TW9kdWxlc0tleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbW9kdWxlc1F1ZXVlW25ld01vZHVsZXNLZXlzW2pdXSA9IG1vZHVsZXNRdWV1ZVtuZXdNb2R1bGVzS2V5c1tqXV0gfHwgW11cbiAgICAgICAgbW9kdWxlc1F1ZXVlW25ld01vZHVsZXNLZXlzW2pdXSA9IG1vZHVsZXNRdWV1ZVtuZXdNb2R1bGVzS2V5c1tqXV0uY29uY2F0KG5ld01vZHVsZXNbbmV3TW9kdWxlc0tleXNbal1dKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXF1aXJlZE1vZHVsZXNcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobW9kdWxlSWQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIHNvdXJjZXMgPSB7XG4gICAgbWFpbjogX193ZWJwYWNrX3JlcXVpcmVfXy5tXG4gIH1cblxuICB2YXIgcmVxdWlyZWRNb2R1bGVzID0gb3B0aW9ucy5hbGwgPyB7IG1haW46IE9iamVjdC5rZXlzKHNvdXJjZXMubWFpbikgfSA6IGdldFJlcXVpcmVkTW9kdWxlcyhzb3VyY2VzLCBtb2R1bGVJZClcblxuICB2YXIgc3JjID0gJydcblxuICBPYmplY3Qua2V5cyhyZXF1aXJlZE1vZHVsZXMpLmZpbHRlcihmdW5jdGlvbiAobSkgeyByZXR1cm4gbSAhPT0gJ21haW4nIH0pLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgIHZhciBlbnRyeU1vZHVsZSA9IDBcbiAgICB3aGlsZSAocmVxdWlyZWRNb2R1bGVzW21vZHVsZV1bZW50cnlNb2R1bGVdKSB7XG4gICAgICBlbnRyeU1vZHVsZSsrXG4gICAgfVxuICAgIHJlcXVpcmVkTW9kdWxlc1ttb2R1bGVdLnB1c2goZW50cnlNb2R1bGUpXG4gICAgc291cmNlc1ttb2R1bGVdW2VudHJ5TW9kdWxlXSA9ICcoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7IG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXzsgfSknXG4gICAgc3JjID0gc3JjICsgJ3ZhciAnICsgbW9kdWxlICsgJyA9ICgnICsgd2VicGFja0Jvb3RzdHJhcEZ1bmMudG9TdHJpbmcoKS5yZXBsYWNlKCdFTlRSWV9NT0RVTEUnLCBKU09OLnN0cmluZ2lmeShlbnRyeU1vZHVsZSkpICsgJykoeycgKyByZXF1aXJlZE1vZHVsZXNbbW9kdWxlXS5tYXAoZnVuY3Rpb24gKGlkKSB7IHJldHVybiAnJyArIEpTT04uc3RyaW5naWZ5KGlkKSArICc6ICcgKyBzb3VyY2VzW21vZHVsZV1baWRdLnRvU3RyaW5nKCkgfSkuam9pbignLCcpICsgJ30pO1xcbidcbiAgfSlcblxuICBzcmMgPSBzcmMgKyAnbmV3ICgoJyArIHdlYnBhY2tCb290c3RyYXBGdW5jLnRvU3RyaW5nKCkucmVwbGFjZSgnRU5UUllfTU9EVUxFJywgSlNPTi5zdHJpbmdpZnkobW9kdWxlSWQpKSArICcpKHsnICsgcmVxdWlyZWRNb2R1bGVzLm1haW4ubWFwKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gJycgKyBKU09OLnN0cmluZ2lmeShpZCkgKyAnOiAnICsgc291cmNlcy5tYWluW2lkXS50b1N0cmluZygpIH0pLmpvaW4oJywnKSArICd9KSkoc2VsZik7J1xuXG4gIHZhciBibG9iID0gbmV3IHdpbmRvdy5CbG9iKFtzcmNdLCB7IHR5cGU6ICd0ZXh0L2phdmFzY3JpcHQnIH0pXG4gIGlmIChvcHRpb25zLmJhcmUpIHsgcmV0dXJuIGJsb2IgfVxuXG4gIHZhciBVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwgfHwgd2luZG93Lm1velVSTCB8fCB3aW5kb3cubXNVUkxcblxuICB2YXIgd29ya2VyVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKVxuICB2YXIgd29ya2VyID0gbmV3IHdpbmRvdy5Xb3JrZXIod29ya2VyVXJsKVxuICB3b3JrZXIub2JqZWN0VVJMID0gd29ya2VyVXJsXG5cbiAgcmV0dXJuIHdvcmtlclxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbmZpZy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29uZmlnLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBITFMgY29uZmlnXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBhYnJfY29udHJvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2Fici1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9hYnItY29udHJvbGxlci5qc1wiKTtcbnZhciBidWZmZXJfY29udHJvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2J1ZmZlci1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9idWZmZXItY29udHJvbGxlci5qc1wiKTtcbnZhciBjYXBfbGV2ZWxfY29udHJvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2NhcC1sZXZlbC1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9jYXAtbGV2ZWwtY29udHJvbGxlci5qc1wiKTtcbnZhciBmcHNfY29udHJvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2Zwcy1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9mcHMtY29udHJvbGxlci5qc1wiKTtcbnZhciB4aHJfbG9hZGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzL3hoci1sb2FkZXIgKi8gXCIuL3NyYy91dGlscy94aHItbG9hZGVyLmpzXCIpO1xuLy8gaW1wb3J0IEZldGNoTG9hZGVyIGZyb20gJy4vdXRpbHMvZmV0Y2gtbG9hZGVyJztcbnZhciBhdWRpb190cmFja19jb250cm9sbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvYXVkaW8tdHJhY2stY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvYXVkaW8tdHJhY2stY29udHJvbGxlci5qc1wiKTtcbnZhciBhdWRpb19zdHJlYW1fY29udHJvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2F1ZGlvLXN0cmVhbS1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9hdWRpby1zdHJlYW0tY29udHJvbGxlci5qc1wiKTtcbnZhciBDdWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscy9jdWVzICovIFwiLi9zcmMvdXRpbHMvY3Vlcy5qc1wiKTtcbnZhciB0aW1lbGluZV9jb250cm9sbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvdGltZWxpbmUtY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvdGltZWxpbmUtY29udHJvbGxlci5qc1wiKTtcbnZhciBzdWJ0aXRsZV90cmFja19jb250cm9sbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvc3VidGl0bGUtdHJhY2stY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvc3VidGl0bGUtdHJhY2stY29udHJvbGxlci5qc1wiKTtcbnZhciBzdWJ0aXRsZV9zdHJlYW1fY29udHJvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL3N1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9zdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlci5qc1wiKTtcbnZhciBlbWVfY29udHJvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2VtZS1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9lbWUtY29udHJvbGxlci5qc1wiKTtcbnZhciBtZWRpYWtleXNfaGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzL21lZGlha2V5cy1oZWxwZXIgKi8gXCIuL3NyYy91dGlscy9tZWRpYWtleXMtaGVscGVyLmpzXCIpO1xuZXhwb3J0cy5obHNEZWZhdWx0Q29uZmlnID0ge1xuICAgIGF1dG9TdGFydExvYWQ6IHRydWUsXG4gICAgc3RhcnRQb3NpdGlvbjogLTEsXG4gICAgZGVmYXVsdEF1ZGlvQ29kZWM6IHVuZGVmaW5lZCxcbiAgICBkZWJ1ZzogZmFsc2UsXG4gICAgY2FwTGV2ZWxPbkZQU0Ryb3A6IGZhbHNlLFxuICAgIGNhcExldmVsVG9QbGF5ZXJTaXplOiBmYWxzZSxcbiAgICBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZTogMSxcbiAgICBtYXhCdWZmZXJMZW5ndGg6IDMwLFxuICAgIG1heEJ1ZmZlclNpemU6IDYwICogMTAwMCAqIDEwMDAsXG4gICAgbWF4QnVmZmVySG9sZTogMC41LFxuICAgIGxvd0J1ZmZlcldhdGNoZG9nUGVyaW9kOiAwLjUsXG4gICAgaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kOiAzLFxuICAgIG51ZGdlT2Zmc2V0OiAwLjEsXG4gICAgbnVkZ2VNYXhSZXRyeTogMyxcbiAgICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlOiAwLjI1LFxuICAgIGxpdmVTeW5jRHVyYXRpb25Db3VudDogMyxcbiAgICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQ6IEluZmluaXR5LFxuICAgIGxpdmVTeW5jRHVyYXRpb246IHVuZGVmaW5lZCxcbiAgICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uOiB1bmRlZmluZWQsXG4gICAgbGl2ZUR1cmF0aW9uSW5maW5pdHk6IGZhbHNlLFxuICAgIGxpdmVCYWNrQnVmZmVyTGVuZ3RoOiBJbmZpbml0eSxcbiAgICBtYXhNYXhCdWZmZXJMZW5ndGg6IDYwMCxcbiAgICBlbmFibGVXb3JrZXI6IHRydWUsXG4gICAgZW5hYmxlU29mdHdhcmVBRVM6IHRydWUsXG4gICAgbWFuaWZlc3RMb2FkaW5nVGltZU91dDogMTAwMDAsXG4gICAgbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnk6IDEsXG4gICAgbWFuaWZlc3RMb2FkaW5nUmV0cnlEZWxheTogMTAwMCxcbiAgICBtYW5pZmVzdExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IDY0MDAwLFxuICAgIHN0YXJ0TGV2ZWw6IHVuZGVmaW5lZCxcbiAgICBsZXZlbExvYWRpbmdUaW1lT3V0OiAxMDAwMCxcbiAgICBsZXZlbExvYWRpbmdNYXhSZXRyeTogNCxcbiAgICBsZXZlbExvYWRpbmdSZXRyeURlbGF5OiAxMDAwLFxuICAgIGxldmVsTG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsXG4gICAgZnJhZ0xvYWRpbmdUaW1lT3V0OiAyMDAwMCxcbiAgICBmcmFnTG9hZGluZ01heFJldHJ5OiA2LFxuICAgIGZyYWdMb2FkaW5nUmV0cnlEZWxheTogMTAwMCxcbiAgICBmcmFnTG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsXG4gICAgc3RhcnRGcmFnUHJlZmV0Y2g6IGZhbHNlLFxuICAgIGZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kOiA1MDAwLFxuICAgIGZwc0Ryb3BwZWRNb25pdG9yaW5nVGhyZXNob2xkOiAwLjIsXG4gICAgYXBwZW5kRXJyb3JNYXhSZXRyeTogMyxcbiAgICBsb2FkZXI6IHhocl9sb2FkZXJfMS5kZWZhdWx0LFxuICAgIC8vIGxvYWRlcjogRmV0Y2hMb2FkZXIsXG4gICAgZkxvYWRlcjogdW5kZWZpbmVkLFxuICAgIHBMb2FkZXI6IHVuZGVmaW5lZCxcbiAgICB4aHJTZXR1cDogdW5kZWZpbmVkLFxuICAgIGxpY2Vuc2VYaHJTZXR1cDogdW5kZWZpbmVkLFxuICAgIC8vIGZldGNoU2V0dXA6IHVuZGVmaW5lZCxcbiAgICBhYnJDb250cm9sbGVyOiBhYnJfY29udHJvbGxlcl8xLmRlZmF1bHQsXG4gICAgYnVmZmVyQ29udHJvbGxlcjogYnVmZmVyX2NvbnRyb2xsZXJfMS5kZWZhdWx0LFxuICAgIGNhcExldmVsQ29udHJvbGxlcjogY2FwX2xldmVsX2NvbnRyb2xsZXJfMS5kZWZhdWx0LFxuICAgIGZwc0NvbnRyb2xsZXI6IGZwc19jb250cm9sbGVyXzEuZGVmYXVsdCxcbiAgICBzdHJldGNoU2hvcnRWaWRlb1RyYWNrOiBmYWxzZSxcbiAgICBtYXhBdWRpb0ZyYW1lc0RyaWZ0OiAxLFxuICAgIGZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHk6IHRydWUsXG4gICAgYWJyRXdtYUZhc3RMaXZlOiAzLFxuICAgIGFickV3bWFTbG93TGl2ZTogOSxcbiAgICBhYnJFd21hRmFzdFZvRDogMyxcbiAgICBhYnJFd21hU2xvd1ZvRDogOSxcbiAgICBhYnJFd21hRGVmYXVsdEVzdGltYXRlOiA1ZTUsXG4gICAgYWJyQmFuZFdpZHRoRmFjdG9yOiAwLjk1LFxuICAgIGFickJhbmRXaWR0aFVwRmFjdG9yOiAwLjcsXG4gICAgYWJyTWF4V2l0aFJlYWxCaXRyYXRlOiBmYWxzZSxcbiAgICBtYXhTdGFydmF0aW9uRGVsYXk6IDQsXG4gICAgbWF4TG9hZGluZ0RlbGF5OiA0LFxuICAgIG1pbkF1dG9CaXRyYXRlOiAwLFxuICAgIGVtZUVuYWJsZWQ6IGZhbHNlLFxuICAgIHdpZGV2aW5lTGljZW5zZVVybDogdW5kZWZpbmVkLFxuICAgIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmM6IG1lZGlha2V5c19oZWxwZXJfMS5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxufTtcbmlmICh0cnVlKSB7XG4gICAgZXhwb3J0cy5obHNEZWZhdWx0Q29uZmlnLnN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciA9IHN1YnRpdGxlX3N0cmVhbV9jb250cm9sbGVyXzEuU3VidGl0bGVTdHJlYW1Db250cm9sbGVyO1xuICAgIGV4cG9ydHMuaGxzRGVmYXVsdENvbmZpZy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHN1YnRpdGxlX3RyYWNrX2NvbnRyb2xsZXJfMS5kZWZhdWx0O1xuICAgIGV4cG9ydHMuaGxzRGVmYXVsdENvbmZpZy50aW1lbGluZUNvbnRyb2xsZXIgPSB0aW1lbGluZV9jb250cm9sbGVyXzEuZGVmYXVsdDtcbiAgICBleHBvcnRzLmhsc0RlZmF1bHRDb25maWcuY3VlSGFuZGxlciA9IEN1ZXM7IC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGV4cG9ydHMuaGxzRGVmYXVsdENvbmZpZy5lbmFibGVDRUE3MDhDYXB0aW9ucyA9IHRydWU7IC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGV4cG9ydHMuaGxzRGVmYXVsdENvbmZpZy5lbmFibGVXZWJWVFQgPSB0cnVlOyAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBleHBvcnRzLmhsc0RlZmF1bHRDb25maWcuY2FwdGlvbnNUZXh0VHJhY2sxTGFiZWwgPSAnRW5nbGlzaCc7IC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGV4cG9ydHMuaGxzRGVmYXVsdENvbmZpZy5jYXB0aW9uc1RleHRUcmFjazFMYW5ndWFnZUNvZGUgPSAnZW4nOyAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBleHBvcnRzLmhsc0RlZmF1bHRDb25maWcuY2FwdGlvbnNUZXh0VHJhY2syTGFiZWwgPSAnU3BhbmlzaCc7IC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGV4cG9ydHMuaGxzRGVmYXVsdENvbmZpZy5jYXB0aW9uc1RleHRUcmFjazJMYW5ndWFnZUNvZGUgPSAnZXMnOyAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbn1cbmlmICh0cnVlKSB7XG4gICAgZXhwb3J0cy5obHNEZWZhdWx0Q29uZmlnLmF1ZGlvU3RyZWFtQ29udHJvbGxlciA9IGF1ZGlvX3N0cmVhbV9jb250cm9sbGVyXzEuZGVmYXVsdDtcbiAgICBleHBvcnRzLmhsc0RlZmF1bHRDb25maWcuYXVkaW9UcmFja0NvbnRyb2xsZXIgPSBhdWRpb190cmFja19jb250cm9sbGVyXzEuZGVmYXVsdDtcbn1cbmlmICh0cnVlKSB7XG4gICAgZXhwb3J0cy5obHNEZWZhdWx0Q29uZmlnLmVtZUNvbnRyb2xsZXIgPSBlbWVfY29udHJvbGxlcl8xLmRlZmF1bHQ7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9hYnItY29udHJvbGxlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvYWJyLWNvbnRyb2xsZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihOdW1iZXIpIHtcbi8qXG4gKiBzaW1wbGUgQUJSIENvbnRyb2xsZXJcbiAqICAtIGNvbXB1dGUgbmV4dCBsZXZlbCBiYXNlZCBvbiBsYXN0IGZyYWdtZW50IGJ3IGhldXJpc3RpY3NcbiAqICAtIGltcGxlbWVudCBhbiBhYmFuZG9uIHJ1bGVzIHRyaWdnZXJlZCBpZiB3ZSBoYXZlIGxlc3MgdGhhbiAyIGZyYWcgYnVmZmVyZWQgYW5kIGlmIGNvbXB1dGVkIGJ3IHNob3dzIHRoYXQgd2UgcmlzayBidWZmZXIgc3RhbGxpbmdcbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMuanNcIik7XG52YXIgZXZlbnRfaGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnQtaGFuZGxlciAqLyBcIi4vc3JjL2V2ZW50LWhhbmRsZXIuanNcIik7XG52YXIgYnVmZmVyX2hlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvYnVmZmVyLWhlbHBlciAqLyBcIi4vc3JjL3V0aWxzL2J1ZmZlci1oZWxwZXIuanNcIik7XG52YXIgZXJyb3JzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMuanNcIik7XG52YXIgbG9nZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIuanNcIik7XG52YXIgZXdtYV9iYW5kd2lkdGhfZXN0aW1hdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9ld21hLWJhbmR3aWR0aC1lc3RpbWF0b3IgKi8gXCIuL3NyYy91dGlscy9ld21hLWJhbmR3aWR0aC1lc3RpbWF0b3IuanNcIik7XG52YXIgcGVyZm9ybWFuY2UgPSB3aW5kb3cucGVyZm9ybWFuY2U7XG52YXIgQWJyQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWJyQ29udHJvbGxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBYnJDb250cm9sbGVyKGhscykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBobHMsIGV2ZW50c18xLmRlZmF1bHQuRlJBR19MT0FESU5HLCBldmVudHNfMS5kZWZhdWx0LkZSQUdfTE9BREVELCBldmVudHNfMS5kZWZhdWx0LkZSQUdfQlVGRkVSRUQsIGV2ZW50c18xLmRlZmF1bHQuRVJST1IpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSAwO1xuICAgICAgICBfdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xO1xuICAgICAgICBfdGhpcy5obHMgPSBobHM7XG4gICAgICAgIF90aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX2J3RXN0aW1hdG9yID0gbnVsbDtcbiAgICAgICAgX3RoaXMub25DaGVjayA9IF90aGlzLl9hYmFuZG9uUnVsZXNDaGVjay5iaW5kKF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBYnJDb250cm9sbGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgZXZlbnRfaGFuZGxlcl8xLmRlZmF1bHQucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIEFickNvbnRyb2xsZXIucHJvdG90eXBlLm9uRnJhZ0xvYWRpbmcgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAgICAgaWYgKGZyYWcudHlwZSA9PT0gJ21haW4nKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudGltZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5vbkNoZWNrLCAxMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbGF6eSBpbml0IG9mIEJ3RXN0aW1hdG9yLCByYXRpb25hbGUgaXMgdGhhdCB3ZSB1c2UgZGlmZmVyZW50IHBhcmFtcyBmb3IgTGl2ZS9Wb0RcbiAgICAgICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gd2FpdCBmb3Igc3RyZWFtIG1hbmlmZXN0IC8gcGxheWxpc3QgdHlwZSB0byBpbnN0YW50aWF0ZSBpdC5cbiAgICAgICAgICAgIGlmICghdGhpcy5fYndFc3RpbWF0b3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGxzXzEgPSB0aGlzLmhscztcbiAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0gaGxzXzEuY29uZmlnO1xuICAgICAgICAgICAgICAgIHZhciBsZXZlbCA9IGZyYWcubGV2ZWw7XG4gICAgICAgICAgICAgICAgdmFyIGlzTGl2ZSA9IGhsc18xLmxldmVsc1tsZXZlbF0uZGV0YWlscy5saXZlO1xuICAgICAgICAgICAgICAgIHZhciBld21hRmFzdCA9IHZvaWQgMCwgZXdtYVNsb3cgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICBld21hRmFzdCA9IGNvbmZpZy5hYnJFd21hRmFzdExpdmU7XG4gICAgICAgICAgICAgICAgICAgIGV3bWFTbG93ID0gY29uZmlnLmFickV3bWFTbG93TGl2ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV3bWFGYXN0ID0gY29uZmlnLmFickV3bWFGYXN0Vm9EO1xuICAgICAgICAgICAgICAgICAgICBld21hU2xvdyA9IGNvbmZpZy5hYnJFd21hU2xvd1ZvRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fYndFc3RpbWF0b3IgPSBuZXcgZXdtYV9iYW5kd2lkdGhfZXN0aW1hdG9yXzEuZGVmYXVsdChobHNfMSwgZXdtYVNsb3csIGV3bWFGYXN0LCBjb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFickNvbnRyb2xsZXIucHJvdG90eXBlLl9hYmFuZG9uUnVsZXNDaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLypcbiAgICAgICAgICBtb25pdG9yIGZyYWdtZW50IHJldHJpZXZhbCB0aW1lLi4uXG4gICAgICAgICAgd2UgY29tcHV0ZSBleHBlY3RlZCB0aW1lIG9mIGFycml2YWwgb2YgdGhlIGNvbXBsZXRlIGZyYWdtZW50LlxuICAgICAgICAgIHdlIGNvbXBhcmUgaXQgdG8gZXhwZWN0ZWQgdGltZSBvZiBidWZmZXIgc3RhcnZhdGlvblxuICAgICAgICAqL1xuICAgICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICAgIHZhciB2aWRlbyA9IGhscy5tZWRpYTtcbiAgICAgICAgdmFyIGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9hZGVyID0gZnJhZy5sb2FkZXI7XG4gICAgICAgIHZhciBtaW5BdXRvTGV2ZWwgPSBobHMubWluQXV0b0xldmVsO1xuICAgICAgICAvLyBpZiBsb2FkZXIgaGFzIGJlZW4gZGVzdHJveWVkIG9yIGxvYWRpbmcgaGFzIGJlZW4gYWJvcnRlZCwgc3RvcCB0aW1lciBhbmQgcmV0dXJuXG4gICAgICAgIGlmICghbG9hZGVyIHx8IChsb2FkZXIuc3RhdHMgJiYgbG9hZGVyLnN0YXRzLmFib3J0ZWQpKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybignZnJhZyBsb2FkZXIgZGVzdHJveSBvciBhYm9ydGVkLCBkaXNhcm0gYWJhbmRvblJ1bGVzJyk7XG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgICAgIC8vIHJlc2V0IGZvcmNlZCBhdXRvIGxldmVsIHZhbHVlIHNvIHRoYXQgbmV4dCBsZXZlbCB3aWxsIGJlIHNlbGVjdGVkXG4gICAgICAgICAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXRzID0gbG9hZGVyLnN0YXRzO1xuICAgICAgICAvKiBvbmx5IG1vbml0b3IgZnJhZyByZXRyaWV2YWwgdGltZSBpZlxuICAgICAgICAodmlkZW8gbm90IHBhdXNlZCBPUiBmaXJzdCBmcmFnbWVudCBiZWluZyBsb2FkZWQocmVhZHkgc3RhdGUgPT09IEhBVkVfTk9USElORyA9IDApKSBBTkQgYXV0b3N3aXRjaGluZyBlbmFibGVkIEFORCBub3QgbG93ZXN0IGxldmVsICg9PiBtZWFucyB0aGF0IHdlIGhhdmUgc2V2ZXJhbCBsZXZlbHMpICovXG4gICAgICAgIGlmICh2aWRlbyAmJiBzdGF0cyAmJiAoKCF2aWRlby5wYXVzZWQgJiYgKHZpZGVvLnBsYXliYWNrUmF0ZSAhPT0gMCkpIHx8ICF2aWRlby5yZWFkeVN0YXRlKSAmJiBmcmFnLmF1dG9MZXZlbCAmJiBmcmFnLmxldmVsKSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdERlbGF5ID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGF0cy50cmVxdWVzdCwgcGxheWJhY2tSYXRlID0gTWF0aC5hYnModmlkZW8ucGxheWJhY2tSYXRlKTtcbiAgICAgICAgICAgIC8vIG1vbml0b3IgZnJhZ21lbnQgbG9hZCBwcm9ncmVzcyBhZnRlciBoYWxmIG9mIGV4cGVjdGVkIGZyYWdtZW50IGR1cmF0aW9uLHRvIHN0YWJpbGl6ZSBiaXRyYXRlXG4gICAgICAgICAgICBpZiAocmVxdWVzdERlbGF5ID4gKDUwMCAqIGZyYWcuZHVyYXRpb24gLyBwbGF5YmFja1JhdGUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxldmVscyA9IGhscy5sZXZlbHMsIGxvYWRSYXRlID0gTWF0aC5tYXgoMSwgc3RhdHMuYncgPyBzdGF0cy5idyAvIDggOiBzdGF0cy5sb2FkZWQgKiAxMDAwIC8gcmVxdWVzdERlbGF5KSwgLy8gYnl0ZS9zOyBhdCBsZWFzdCAxIGJ5dGUvcyB0byBhdm9pZCBkaXZpc2lvbiBieSB6ZXJvXG4gICAgICAgICAgICAgICAgLy8gY29tcHV0ZSBleHBlY3RlZCBmcmFnbWVudCBsZW5ndGggdXNpbmcgZnJhZyBkdXJhdGlvbiBhbmQgbGV2ZWwgYml0cmF0ZS4gYWxzbyBlbnN1cmUgdGhhdCBleHBlY3RlZCBsZW4gaXMgZ3RlIHRoYW4gYWxyZWFkeSBsb2FkZWQgc2l6ZVxuICAgICAgICAgICAgICAgIGxldmVsID0gbGV2ZWxzW2ZyYWcubGV2ZWxdLCBsZXZlbEJpdHJhdGUgPSBsZXZlbC5yZWFsQml0cmF0ZSA/IE1hdGgubWF4KGxldmVsLnJlYWxCaXRyYXRlLCBsZXZlbC5iaXRyYXRlKSA6IGxldmVsLmJpdHJhdGUsIGV4cGVjdGVkTGVuID0gc3RhdHMudG90YWwgPyBzdGF0cy50b3RhbCA6IE1hdGgubWF4KHN0YXRzLmxvYWRlZCwgTWF0aC5yb3VuZChmcmFnLmR1cmF0aW9uICogbGV2ZWxCaXRyYXRlIC8gOCkpLCBwb3MgPSB2aWRlby5jdXJyZW50VGltZSwgZnJhZ0xvYWRlZERlbGF5ID0gKGV4cGVjdGVkTGVuIC0gc3RhdHMubG9hZGVkKSAvIGxvYWRSYXRlLCBidWZmZXJTdGFydmF0aW9uRGVsYXkgPSAoYnVmZmVyX2hlbHBlcl8xLkJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKHZpZGVvLCBwb3MsIGhscy5jb25maWcubWF4QnVmZmVySG9sZSkuZW5kIC0gcG9zKSAvIHBsYXliYWNrUmF0ZTtcbiAgICAgICAgICAgICAgICAvLyBjb25zaWRlciBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gb25seSBpZiB3ZSBoYXZlIGxlc3MgdGhhbiAyIGZyYWcgYnVmZmVyZWQgQU5EXG4gICAgICAgICAgICAgICAgLy8gdGltZSB0byBmaW5pc2ggbG9hZGluZyBjdXJyZW50IGZyYWdtZW50IGlzIGJpZ2dlciB0aGFuIGJ1ZmZlciBzdGFydmF0aW9uIGRlbGF5XG4gICAgICAgICAgICAgICAgLy8gaWUgaWYgd2UgcmlzayBidWZmZXIgc3RhcnZhdGlvbiBpZiBidyBkb2VzIG5vdCBpbmNyZWFzZSBxdWlja2x5XG4gICAgICAgICAgICAgICAgaWYgKChidWZmZXJTdGFydmF0aW9uRGVsYXkgPCAoMiAqIGZyYWcuZHVyYXRpb24gLyBwbGF5YmFja1JhdGUpKSAmJiAoZnJhZ0xvYWRlZERlbGF5ID4gYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ID0gdm9pZCAwLCBuZXh0TG9hZExldmVsID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAvLyBsZXRzIGl0ZXJhdGUgdGhyb3VnaCBsb3dlciBsZXZlbCBhbmQgdHJ5IHRvIGZpbmQgdGhlIGJpZ2dlc3Qgb25lIHRoYXQgY291bGQgYXZvaWQgcmVidWZmZXJpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gd2Ugc3RhcnQgZnJvbSBjdXJyZW50IGxldmVsIC0gMSBhbmQgd2Ugc3RlcCBkb3duICwgdW50aWwgd2UgZmluZCBhIG1hdGNoaW5nIGxldmVsXG4gICAgICAgICAgICAgICAgICAgIGZvciAobmV4dExvYWRMZXZlbCA9IGZyYWcubGV2ZWwgLSAxOyBuZXh0TG9hZExldmVsID4gbWluQXV0b0xldmVsOyBuZXh0TG9hZExldmVsLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbXB1dGUgdGltZSB0byBsb2FkIG5leHQgZnJhZ21lbnQgYXQgbG93ZXIgbGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAuOCA6IGNvbnNpZGVyIG9ubHkgODAlIG9mIGN1cnJlbnQgYncgdG8gYmUgY29uc2VydmF0aXZlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyA4ID0gYml0cyBwZXIgYnl0ZSAoYnBzL0JwcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZXZlbE5leHRCaXRyYXRlID0gbGV2ZWxzW25leHRMb2FkTGV2ZWxdLnJlYWxCaXRyYXRlID8gTWF0aC5tYXgobGV2ZWxzW25leHRMb2FkTGV2ZWxdLnJlYWxCaXRyYXRlLCBsZXZlbHNbbmV4dExvYWRMZXZlbF0uYml0cmF0ZSkgOiBsZXZlbHNbbmV4dExvYWRMZXZlbF0uYml0cmF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA9IGZyYWcuZHVyYXRpb24gKiBsZXZlbE5leHRCaXRyYXRlIC8gKDggKiAwLjggKiBsb2FkUmF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5IDwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZm91bmQgYSBsb3dlciBsZXZlbCB0aGF0IGJlIHJlYnVmZmVyaW5nIGZyZWUgd2l0aCBjdXJyZW50IGVzdGltYXRlZCBidyAhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gaWYgaXQgdGFrZXMgbGVzcyB0aW1lIHRvIGxvYWQgbmV3IGZyYWdtZW50IGF0IGxvd2VzdCBsZXZlbCBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIGZpbmlzaGluZyBsb2FkaW5nIGN1cnJlbnQgb25lIC4uLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5IDwgZnJhZ0xvYWRlZERlbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybihcImxvYWRpbmcgdG9vIHNsb3csIGFib3J0IGZyYWdtZW50IGxvYWRpbmcgYW5kIHN3aXRjaCB0byBsZXZlbCBcIiArIG5leHRMb2FkTGV2ZWwgKyBcIjpmcmFnTG9hZGVkRGVsYXlbXCIgKyBuZXh0TG9hZExldmVsICsgXCJdPGZyYWdMb2FkZWREZWxheVtcIiArIChmcmFnLmxldmVsIC0gMSkgKyBcIl07YnVmZmVyU3RhcnZhdGlvbkRlbGF5OlwiICsgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5LnRvRml4ZWQoMSkgKyBcIjxcIiArIGZyYWdMb2FkZWREZWxheS50b0ZpeGVkKDEpICsgXCI6XCIgKyBidWZmZXJTdGFydmF0aW9uRGVsYXkudG9GaXhlZCgxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3JjZSBuZXh0IGxvYWQgbGV2ZWwgaW4gYXV0byBtb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBobHMubmV4dExvYWRMZXZlbCA9IG5leHRMb2FkTGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgYncgZXN0aW1hdGUgZm9yIHRoaXMgZnJhZ21lbnQgYmVmb3JlIGNhbmNlbGxpbmcgbG9hZCAodGhpcyB3aWxsIGhlbHAgcmVkdWNpbmcgdGhlIGJ3KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYndFc3RpbWF0b3Iuc2FtcGxlKHJlcXVlc3REZWxheSwgc3RhdHMubG9hZGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFib3J0IGZyYWdtZW50IGxvYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCBhYmFuZG9uIHJ1bGVzIHRpbWVyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVELCB7IGZyYWc6IGZyYWcsIHN0YXRzOiBzdGF0cyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQWJyQ29udHJvbGxlci5wcm90b3R5cGUub25GcmFnTG9hZGVkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgICAgIGlmIChmcmFnLnR5cGUgPT09ICdtYWluJyAmJiBOdW1iZXIuaXNGaW5pdGUoZnJhZy5zbikpIHtcbiAgICAgICAgICAgIC8vIHN0b3AgbW9uaXRvcmluZyBidyBvbmNlIGZyYWcgbG9hZGVkXG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgICAgIC8vIHN0b3JlIGxldmVsIGlkIGFmdGVyIHN1Y2Nlc3NmdWwgZnJhZ21lbnQgbG9hZFxuICAgICAgICAgICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gZnJhZy5sZXZlbDtcbiAgICAgICAgICAgIC8vIHJlc2V0IGZvcmNlZCBhdXRvIGxldmVsIHZhbHVlIHNvIHRoYXQgbmV4dCBsZXZlbCB3aWxsIGJlIHNlbGVjdGVkXG4gICAgICAgICAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG4gICAgICAgICAgICAvLyBjb21wdXRlIGxldmVsIGF2ZXJhZ2UgYml0cmF0ZVxuICAgICAgICAgICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5hYnJNYXhXaXRoUmVhbEJpdHJhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgICAgICAgICAgICAgdmFyIGxvYWRlZEJ5dGVzID0gKGxldmVsLmxvYWRlZCA/IGxldmVsLmxvYWRlZC5ieXRlcyA6IDApICsgZGF0YS5zdGF0cy5sb2FkZWQ7XG4gICAgICAgICAgICAgICAgdmFyIGxvYWRlZER1cmF0aW9uID0gKGxldmVsLmxvYWRlZCA/IGxldmVsLmxvYWRlZC5kdXJhdGlvbiA6IDApICsgZGF0YS5mcmFnLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIGxldmVsLmxvYWRlZCA9IHsgYnl0ZXM6IGxvYWRlZEJ5dGVzLCBkdXJhdGlvbjogbG9hZGVkRHVyYXRpb24gfTtcbiAgICAgICAgICAgICAgICBsZXZlbC5yZWFsQml0cmF0ZSA9IE1hdGgucm91bmQoOCAqIGxvYWRlZEJ5dGVzIC8gbG9hZGVkRHVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgZnJhZ21lbnQgaGFzIGJlZW4gbG9hZGVkIHRvIHBlcmZvcm0gYSBiaXRyYXRlIHRlc3QsXG4gICAgICAgICAgICBpZiAoZGF0YS5mcmFnLmJpdHJhdGVUZXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRzID0gZGF0YS5zdGF0cztcbiAgICAgICAgICAgICAgICBzdGF0cy50cGFyc2VkID0gc3RhdHMudGJ1ZmZlcmVkID0gc3RhdHMudGxvYWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkZyYWdCdWZmZXJlZChkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQWJyQ29udHJvbGxlci5wcm90b3R5cGUub25GcmFnQnVmZmVyZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgc3RhdHMgPSBkYXRhLnN0YXRzO1xuICAgICAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAgICAgLy8gb25seSB1cGRhdGUgc3RhdHMgb24gZmlyc3QgZnJhZyBidWZmZXJpbmdcbiAgICAgICAgLy8gaWYgc2FtZSBmcmFnIGlzIGxvYWRlZCBtdWx0aXBsZSB0aW1lcywgaXQgbWlnaHQgYmUgaW4gYnJvd3NlciBjYWNoZSwgYW5kIGxvYWRlZCBxdWlja2x5XG4gICAgICAgIC8vIGFuZCBsZWFkaW5nIHRvIHdyb25nIGJ3IGVzdGltYXRpb25cbiAgICAgICAgLy8gb24gYml0cmF0ZSB0ZXN0LCBhbHNvIG9ubHkgdXBkYXRlIHN0YXRzIG9uY2UgKGlmIHRsb2FkID0gdGJ1ZmZlcmVkID09IG9uIEZSQUdfTE9BREVEKVxuICAgICAgICBpZiAoc3RhdHMuYWJvcnRlZCAhPT0gdHJ1ZSAmJiBmcmFnLnR5cGUgPT09ICdtYWluJyAmJiBOdW1iZXIuaXNGaW5pdGUoZnJhZy5zbikgJiYgKCghZnJhZy5iaXRyYXRlVGVzdCB8fCBzdGF0cy50bG9hZCA9PT0gc3RhdHMudGJ1ZmZlcmVkKSkpIHtcbiAgICAgICAgICAgIC8vIHVzZSB0cGFyc2VkLXRyZXF1ZXN0IGluc3RlYWQgb2YgdGJ1ZmZlcmVkLXRyZXF1ZXN0IHRvIGNvbXB1dGUgZnJhZ0xvYWRpbmdQcm9jZXNzaW5nOyByYXRpb25hbGUgaXMgdGhhdCAgYnVmZmVyIGFwcGVuZGluZyBvbmx5IGhhcHBlbnMgb25jZSBtZWRpYSBpcyBhdHRhY2hlZFxuICAgICAgICAgICAgLy8gaW4gY2FzZSB3ZSB1c2UgY29uZmlnLnN0YXJ0RnJhZ1ByZWZldGNoIHdoaWxlIG1lZGlhIGlzIG5vdCBhdHRhY2hlZCB5ZXQsIGZyYWdtZW50IG1pZ2h0IGJlIHBhcnNlZCB3aGlsZSBtZWRpYSBub3QgYXR0YWNoZWQgeWV0LCBidXQgaXQgd2lsbCBvbmx5IGJlIGJ1ZmZlcmVkIG9uIG1lZGlhIGF0dGFjaGVkXG4gICAgICAgICAgICAvLyBhcyBhIGNvbnNlcXVlbmNlIGl0IGNvdWxkIGhhcHBlbiByZWFsbHkgbGF0ZSBpbiB0aGUgcHJvY2Vzcy4gbWVhbmluZyB0aGF0IGFwcGVuZGluZyBkdXJhdGlvbiBtaWdodCBhcHBlYXJzIGh1Z2UgLi4uIGxlYWRpbmcgdG8gdW5kZXJlc3RpbWF0ZWQgdGhyb3VnaHB1dCBlc3RpbWF0aW9uXG4gICAgICAgICAgICB2YXIgZnJhZ0xvYWRpbmdQcm9jZXNzaW5nTXMgPSBzdGF0cy50cGFyc2VkIC0gc3RhdHMudHJlcXVlc3Q7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwibGF0ZW5jeS9sb2FkaW5nL3BhcnNpbmcvYXBwZW5kL2ticHM6XCIgKyBNYXRoLnJvdW5kKHN0YXRzLnRmaXJzdCAtIHN0YXRzLnRyZXF1ZXN0KSArIFwiL1wiICsgTWF0aC5yb3VuZChzdGF0cy50bG9hZCAtIHN0YXRzLnRmaXJzdCkgKyBcIi9cIiArIE1hdGgucm91bmQoc3RhdHMudHBhcnNlZCAtIHN0YXRzLnRsb2FkKSArIFwiL1wiICsgTWF0aC5yb3VuZChzdGF0cy50YnVmZmVyZWQgLSBzdGF0cy50cGFyc2VkKSArIFwiL1wiICsgTWF0aC5yb3VuZCg4ICogc3RhdHMubG9hZGVkIC8gKHN0YXRzLnRidWZmZXJlZCAtIHN0YXRzLnRyZXF1ZXN0KSkpO1xuICAgICAgICAgICAgdGhpcy5fYndFc3RpbWF0b3Iuc2FtcGxlKGZyYWdMb2FkaW5nUHJvY2Vzc2luZ01zLCBzdGF0cy5sb2FkZWQpO1xuICAgICAgICAgICAgc3RhdHMuYndFc3RpbWF0ZSA9IHRoaXMuX2J3RXN0aW1hdG9yLmdldEVzdGltYXRlKCk7XG4gICAgICAgICAgICAvLyBpZiBmcmFnbWVudCBoYXMgYmVlbiBsb2FkZWQgdG8gcGVyZm9ybSBhIGJpdHJhdGUgdGVzdCwgKGhscy5zdGFydExldmVsID0gLTEpLCBzdG9yZSBiaXRyYXRlIHRlc3QgZGVsYXkgZHVyYXRpb25cbiAgICAgICAgICAgIGlmIChmcmFnLmJpdHJhdGVUZXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iaXRyYXRlVGVzdERlbGF5ID0gZnJhZ0xvYWRpbmdQcm9jZXNzaW5nTXMgLyAxMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iaXRyYXRlVGVzdERlbGF5ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQWJyQ29udHJvbGxlci5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIHN0b3AgdGltZXIgaW4gY2FzZSBvZiBmcmFnIGxvYWRpbmcgZXJyb3JcbiAgICAgICAgc3dpdGNoIChkYXRhLmRldGFpbHMpIHtcbiAgICAgICAgICAgIGNhc2UgZXJyb3JzXzEuRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUjpcbiAgICAgICAgICAgIGNhc2UgZXJyb3JzXzEuRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWJyQ29udHJvbGxlci5wcm90b3R5cGUuY2xlYXJUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJyQ29udHJvbGxlci5wcm90b3R5cGUsIFwibmV4dEF1dG9MZXZlbFwiLCB7XG4gICAgICAgIC8vIHJldHVybiBuZXh0IGF1dG8gbGV2ZWxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZm9yY2VkQXV0b0xldmVsID0gdGhpcy5fbmV4dEF1dG9MZXZlbDtcbiAgICAgICAgICAgIHZhciBid0VzdGltYXRvciA9IHRoaXMuX2J3RXN0aW1hdG9yO1xuICAgICAgICAgICAgLy8gaW4gY2FzZSBuZXh0IGF1dG8gbGV2ZWwgaGFzIGJlZW4gZm9yY2VkLCBhbmQgYncgbm90IGF2YWlsYWJsZSBvciBub3QgcmVsaWFibGUsIHJldHVybiBmb3JjZWQgdmFsdWVcbiAgICAgICAgICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xICYmICghYndFc3RpbWF0b3IgfHwgIWJ3RXN0aW1hdG9yLmNhbkVzdGltYXRlKCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcmNlZEF1dG9MZXZlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbXB1dGUgbmV4dCBsZXZlbCB1c2luZyBBQlIgbG9naWNcbiAgICAgICAgICAgIHZhciBuZXh0QUJSQXV0b0xldmVsID0gdGhpcy5fbmV4dEFCUkF1dG9MZXZlbDtcbiAgICAgICAgICAgIC8vIGlmIGZvcmNlZCBhdXRvIGxldmVsIGhhcyBiZWVuIGRlZmluZWQsIHVzZSBpdCB0byBjYXAgQUJSIGNvbXB1dGVkIHF1YWxpdHkgbGV2ZWxcbiAgICAgICAgICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbmV4dEFCUkF1dG9MZXZlbCA9IE1hdGgubWluKGZvcmNlZEF1dG9MZXZlbCwgbmV4dEFCUkF1dG9MZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV4dEFCUkF1dG9MZXZlbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV4dExldmVsKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gbmV4dExldmVsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJyQ29udHJvbGxlci5wcm90b3R5cGUsIFwiX25leHRBQlJBdXRvTGV2ZWxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBobHMgPSB0aGlzLmhscywgbWF4QXV0b0xldmVsID0gaGxzLm1heEF1dG9MZXZlbCwgbGV2ZWxzID0gaGxzLmxldmVscywgY29uZmlnID0gaGxzLmNvbmZpZywgbWluQXV0b0xldmVsID0gaGxzLm1pbkF1dG9MZXZlbDtcbiAgICAgICAgICAgIHZhciB2aWRlbyA9IGhscy5tZWRpYSwgY3VycmVudExldmVsID0gdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsLCBjdXJyZW50RnJhZ0R1cmF0aW9uID0gdGhpcy5mcmFnQ3VycmVudCA/IHRoaXMuZnJhZ0N1cnJlbnQuZHVyYXRpb24gOiAwLCBwb3MgPSAodmlkZW8gPyB2aWRlby5jdXJyZW50VGltZSA6IDApLCBcbiAgICAgICAgICAgIC8vIHBsYXliYWNrUmF0ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhlIHBsYXliYWNrIHJhdGU7IGlmIHZpZGVvLnBsYXliYWNrUmF0ZSBpcyAwLCB3ZSB1c2UgMSB0byBsb2FkIGFzXG4gICAgICAgICAgICAvLyBpZiB3ZSdyZSBwbGF5aW5nIGJhY2sgYXQgdGhlIG5vcm1hbCByYXRlLlxuICAgICAgICAgICAgcGxheWJhY2tSYXRlID0gKCh2aWRlbyAmJiAodmlkZW8ucGxheWJhY2tSYXRlICE9PSAwKSkgPyBNYXRoLmFicyh2aWRlby5wbGF5YmFja1JhdGUpIDogMS4wKSwgYXZnYncgPSB0aGlzLl9id0VzdGltYXRvciA/IHRoaXMuX2J3RXN0aW1hdG9yLmdldEVzdGltYXRlKCkgOiBjb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSwgXG4gICAgICAgICAgICAvLyBidWZmZXJTdGFydmF0aW9uRGVsYXkgaXMgdGhlIHdhbGwtY2xvY2sgdGltZSBsZWZ0IHVudGlsIHRoZSBwbGF5YmFjayBidWZmZXIgaXMgZXhoYXVzdGVkLlxuICAgICAgICAgICAgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID0gKGJ1ZmZlcl9oZWxwZXJfMS5CdWZmZXJIZWxwZXIuYnVmZmVySW5mbyh2aWRlbywgcG9zLCBjb25maWcubWF4QnVmZmVySG9sZSkuZW5kIC0gcG9zKSAvIHBsYXliYWNrUmF0ZTtcbiAgICAgICAgICAgIC8vIEZpcnN0LCBsb29rIHRvIHNlZSBpZiB3ZSBjYW4gZmluZCBhIGxldmVsIG1hdGNoaW5nIHdpdGggb3VyIGF2ZyBiYW5kd2lkdGggQU5EIHRoYXQgY291bGQgYWxzbyBndWFyYW50ZWUgbm8gcmVidWZmZXJpbmcgYXQgYWxsXG4gICAgICAgICAgICB2YXIgYmVzdExldmVsID0gdGhpcy5fZmluZEJlc3RMZXZlbChjdXJyZW50TGV2ZWwsIGN1cnJlbnRGcmFnRHVyYXRpb24sIGF2Z2J3LCBtaW5BdXRvTGV2ZWwsIG1heEF1dG9MZXZlbCwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5LCBjb25maWcuYWJyQmFuZFdpZHRoRmFjdG9yLCBjb25maWcuYWJyQmFuZFdpZHRoVXBGYWN0b3IsIGxldmVscyk7XG4gICAgICAgICAgICBpZiAoYmVzdExldmVsID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVzdExldmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLnRyYWNlKCdyZWJ1ZmZlcmluZyBleHBlY3RlZCB0byBoYXBwZW4sIGxldHMgdHJ5IHRvIGZpbmQgYSBxdWFsaXR5IGxldmVsIG1pbmltaXppbmcgdGhlIHJlYnVmZmVyaW5nJyk7XG4gICAgICAgICAgICAgICAgLy8gbm90IHBvc3NpYmxlIHRvIGdldCByaWQgb2YgcmVidWZmZXJpbmcgLi4uIGxldCdzIHRyeSB0byBmaW5kIGxldmVsIHRoYXQgd2lsbCBndWFyYW50ZWUgbGVzcyB0aGFuIG1heFN0YXJ2YXRpb25EZWxheSBvZiByZWJ1ZmZlcmluZ1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vIG1hdGNoaW5nIGxldmVsIGZvdW5kLCBsb2dpYyB3aWxsIHJldHVybiAwXG4gICAgICAgICAgICAgICAgdmFyIG1heFN0YXJ2YXRpb25EZWxheSA9IGN1cnJlbnRGcmFnRHVyYXRpb24gPyBNYXRoLm1pbihjdXJyZW50RnJhZ0R1cmF0aW9uLCBjb25maWcubWF4U3RhcnZhdGlvbkRlbGF5KSA6IGNvbmZpZy5tYXhTdGFydmF0aW9uRGVsYXksIGJ3RmFjdG9yID0gY29uZmlnLmFickJhbmRXaWR0aEZhY3RvciwgYndVcEZhY3RvciA9IGNvbmZpZy5hYnJCYW5kV2lkdGhVcEZhY3RvcjtcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluIGNhc2UgYnVmZmVyIGlzIGVtcHR5LCBsZXQncyBjaGVjayBpZiBwcmV2aW91cyBmcmFnbWVudCB3YXMgbG9hZGVkIHRvIHBlcmZvcm0gYSBiaXRyYXRlIHRlc3RcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpdHJhdGVUZXN0RGVsYXkgPSB0aGlzLmJpdHJhdGVUZXN0RGVsYXk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiaXRyYXRlVGVzdERlbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCBpcyB0aGUgY2FzZSwgdGhlbiB3ZSBuZWVkIHRvIGFkanVzdCBvdXIgbWF4IHN0YXJ2YXRpb24gZGVsYXkgdXNpbmcgbWF4TG9hZGluZ0RlbGF5IGNvbmZpZyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF4IHZpZGVvIGxvYWRpbmcgZGVsYXkgdXNlZCBpbiAgYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGF0IG1vZGUgQUJSIGNvbnRyb2xsZXIgd2lsbCBlbnN1cmUgdGhhdCB2aWRlbyBsb2FkaW5nIHRpbWUgKGllIHRoZSB0aW1lIHRvIGZldGNoIHRoZSBmaXJzdCBmcmFnbWVudCBhdCBsb3dlc3QgcXVhbGl0eSBsZXZlbCArXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdGltZSB0byBmZXRjaCB0aGUgZnJhZ21lbnQgYXQgdGhlIGFwcHJvcHJpYXRlIHF1YWxpdHkgbGV2ZWwgaXMgbGVzcyB0aGFuIGBgYG1heExvYWRpbmdEZWxheWBgYCApXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXAgbWF4TG9hZGluZ0RlbGF5IGFuZCBlbnN1cmUgaXQgaXMgbm90IGJpZ2dlciAndGhhbiBiaXRyYXRlIHRlc3QnIGZyYWcgZHVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhMb2FkaW5nRGVsYXkgPSBjdXJyZW50RnJhZ0R1cmF0aW9uID8gTWF0aC5taW4oY3VycmVudEZyYWdEdXJhdGlvbiwgY29uZmlnLm1heExvYWRpbmdEZWxheSkgOiBjb25maWcubWF4TG9hZGluZ0RlbGF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4U3RhcnZhdGlvbkRlbGF5ID0gbWF4TG9hZGluZ0RlbGF5IC0gYml0cmF0ZVRlc3REZWxheTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci50cmFjZShcImJpdHJhdGUgdGVzdCB0b29rIFwiICsgTWF0aC5yb3VuZCgxMDAwICogYml0cmF0ZVRlc3REZWxheSkgKyBcIm1zLCBzZXQgZmlyc3QgZnJhZ21lbnQgbWF4IGZldGNoRHVyYXRpb24gdG8gXCIgKyBNYXRoLnJvdW5kKDEwMDAgKiBtYXhTdGFydmF0aW9uRGVsYXkpICsgXCIgbXNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCB1c2UgY29uc2VydmF0aXZlIGZhY3RvciBvbiBiaXRyYXRlIHRlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ3RmFjdG9yID0gYndVcEZhY3RvciA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmVzdExldmVsID0gdGhpcy5fZmluZEJlc3RMZXZlbChjdXJyZW50TGV2ZWwsIGN1cnJlbnRGcmFnRHVyYXRpb24sIGF2Z2J3LCBtaW5BdXRvTGV2ZWwsIG1heEF1dG9MZXZlbCwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ICsgbWF4U3RhcnZhdGlvbkRlbGF5LCBid0ZhY3RvciwgYndVcEZhY3RvciwgbGV2ZWxzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoYmVzdExldmVsLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQWJyQ29udHJvbGxlci5wcm90b3R5cGUuX2ZpbmRCZXN0TGV2ZWwgPSBmdW5jdGlvbiAoY3VycmVudExldmVsLCBjdXJyZW50RnJhZ0R1cmF0aW9uLCBjdXJyZW50QncsIG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsLCBtYXhGZXRjaER1cmF0aW9uLCBid0ZhY3RvciwgYndVcEZhY3RvciwgbGV2ZWxzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBtYXhBdXRvTGV2ZWw7IGkgPj0gbWluQXV0b0xldmVsOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBsZXZlbEluZm8gPSBsZXZlbHNbaV07XG4gICAgICAgICAgICBpZiAoIWxldmVsSW5mbykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxldmVsRGV0YWlscyA9IGxldmVsSW5mby5kZXRhaWxzLCBhdmdEdXJhdGlvbiA9IGxldmVsRGV0YWlscyA/IGxldmVsRGV0YWlscy50b3RhbGR1cmF0aW9uIC8gbGV2ZWxEZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggOiBjdXJyZW50RnJhZ0R1cmF0aW9uLCBsaXZlID0gbGV2ZWxEZXRhaWxzID8gbGV2ZWxEZXRhaWxzLmxpdmUgOiBmYWxzZSwgYWRqdXN0ZWRidyA9IHZvaWQgMDtcbiAgICAgICAgICAgIC8vIGZvbGxvdyBhbGdvcml0aG0gY2FwdHVyZWQgZnJvbSBzdGFnZWZyaWdodCA6XG4gICAgICAgICAgICAvLyBodHRwczovL2FuZHJvaWQuZ29vZ2xlc291cmNlLmNvbS9wbGF0Zm9ybS9mcmFtZXdvcmtzL2F2LysvbWFzdGVyL21lZGlhL2xpYnN0YWdlZnJpZ2h0L2h0dHBsaXZlL0xpdmVTZXNzaW9uLmNwcFxuICAgICAgICAgICAgLy8gUGljayB0aGUgaGlnaGVzdCBiYW5kd2lkdGggc3RyZWFtIGJlbG93IG9yIGVxdWFsIHRvIGVzdGltYXRlZCBiYW5kd2lkdGguXG4gICAgICAgICAgICAvLyBjb25zaWRlciBvbmx5IDgwJSBvZiB0aGUgYXZhaWxhYmxlIGJhbmR3aWR0aCwgYnV0IGlmIHdlIGFyZSBzd2l0Y2hpbmcgdXAsXG4gICAgICAgICAgICAvLyBiZSBldmVuIG1vcmUgY29uc2VydmF0aXZlICg3MCUpIHRvIGF2b2lkIG92ZXJlc3RpbWF0aW5nIGFuZCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgLy8gc3dpdGNoaW5nIGJhY2suXG4gICAgICAgICAgICBpZiAoaSA8PSBjdXJyZW50TGV2ZWwpIHtcbiAgICAgICAgICAgICAgICBhZGp1c3RlZGJ3ID0gYndGYWN0b3IgKiBjdXJyZW50Qnc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGp1c3RlZGJ3ID0gYndVcEZhY3RvciAqIGN1cnJlbnRCdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiaXRyYXRlID0gbGV2ZWxzW2ldLnJlYWxCaXRyYXRlID8gTWF0aC5tYXgobGV2ZWxzW2ldLnJlYWxCaXRyYXRlLCBsZXZlbHNbaV0uYml0cmF0ZSkgOiBsZXZlbHNbaV0uYml0cmF0ZSwgZmV0Y2hEdXJhdGlvbiA9IGJpdHJhdGUgKiBhdmdEdXJhdGlvbiAvIGFkanVzdGVkYnc7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIudHJhY2UoXCJsZXZlbC9hZGp1c3RlZGJ3L2JpdHJhdGUvYXZnRHVyYXRpb24vbWF4RmV0Y2hEdXJhdGlvbi9mZXRjaER1cmF0aW9uOiBcIiArIGkgKyBcIi9cIiArIE1hdGgucm91bmQoYWRqdXN0ZWRidykgKyBcIi9cIiArIGJpdHJhdGUgKyBcIi9cIiArIGF2Z0R1cmF0aW9uICsgXCIvXCIgKyBtYXhGZXRjaER1cmF0aW9uICsgXCIvXCIgKyBmZXRjaER1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGlmIGFkanVzdGVkIGJ3IGlzIGdyZWF0ZXIgdGhhbiBsZXZlbCBiaXRyYXRlIEFORFxuICAgICAgICAgICAgaWYgKGFkanVzdGVkYncgPiBiaXRyYXRlICYmXG4gICAgICAgICAgICAgICAgLy8gZnJhZ21lbnQgZmV0Y2hEdXJhdGlvbiB1bmtub3duIE9SIGxpdmUgc3RyZWFtIE9SIGZyYWdtZW50IGZldGNoRHVyYXRpb24gbGVzcyB0aGFuIG1heCBhbGxvd2VkIGZldGNoIGR1cmF0aW9uLCB0aGVuIHRoaXMgbGV2ZWwgbWF0Y2hlc1xuICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IGFjY291bnQgZm9yIG1heCBGZXRjaCBEdXJhdGlvbiBmb3IgbGl2ZSBzdHJlYW1zLCB0aGlzIGlzIHRvIGF2b2lkIHN3aXRjaGluZyBkb3duIHdoZW4gbmVhciB0aGUgZWRnZSBvZiBsaXZlIHNsaWRpbmcgd2luZG93IC4uLlxuICAgICAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZSB0byBzdXBwb3J0IHN0YXJ0TGV2ZWwgPSAtMSAoYml0cmF0ZVRlc3QpIG9uIGxpdmUgc3RyZWFtcyA6IGluIHRoYXQgY2FzZSB3ZSBzaG91bGQgbm90IGV4aXQgbG9vcCBzbyB0aGF0IF9maW5kQmVzdExldmVsIHdpbGwgcmV0dXJuIC0xXG4gICAgICAgICAgICAgICAgKCFmZXRjaER1cmF0aW9uIHx8IChsaXZlICYmICF0aGlzLmJpdHJhdGVUZXN0RGVsYXkpIHx8IGZldGNoRHVyYXRpb24gPCBtYXhGZXRjaER1cmF0aW9uKSkge1xuICAgICAgICAgICAgICAgIC8vIGFzIHdlIGFyZSBsb29waW5nIGZyb20gaGlnaGVzdCB0byBsb3dlc3QsIHRoaXMgd2lsbCByZXR1cm4gdGhlIGJlc3QgYWNoaWV2YWJsZSBxdWFsaXR5IGxldmVsXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm90IGVub3VnaCB0aW1lIGJ1ZGdldCBldmVuIHdpdGggcXVhbGl0eSBsZXZlbCAwIC4uLiByZWJ1ZmZlcmluZyBtaWdodCBoYXBwZW5cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgcmV0dXJuIEFickNvbnRyb2xsZXI7XG59KGV2ZW50X2hhbmRsZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBBYnJDb250cm9sbGVyO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIuanNcIilbXCJOdW1iZXJcIl0pKVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2F1ZGlvLXN0cmVhbS1jb250cm9sbGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9hdWRpby1zdHJlYW0tY29udHJvbGxlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKE51bWJlcikge1xuLypcbiAqIEF1ZGlvIFN0cmVhbSBDb250cm9sbGVyXG4qL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYmluYXJ5X3NlYXJjaF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvYmluYXJ5LXNlYXJjaCAqLyBcIi4vc3JjL3V0aWxzL2JpbmFyeS1zZWFyY2guanNcIik7XG52YXIgYnVmZmVyX2hlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvYnVmZmVyLWhlbHBlciAqLyBcIi4vc3JjL3V0aWxzL2J1ZmZlci1oZWxwZXIuanNcIik7XG52YXIgZGVtdXhlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGVtdXgvZGVtdXhlciAqLyBcIi4vc3JjL2RlbXV4L2RlbXV4ZXIuanNcIik7XG52YXIgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMuanNcIik7XG52YXIgTGV2ZWxIZWxwZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xldmVsLWhlbHBlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvbGV2ZWwtaGVscGVyLmpzXCIpO1xudmFyIHRpbWVfcmFuZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy90aW1lLXJhbmdlcyAqLyBcIi4vc3JjL3V0aWxzL3RpbWUtcmFuZ2VzLmpzXCIpO1xudmFyIGVycm9yc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLmpzXCIpO1xudmFyIGxvZ2dlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLmpzXCIpO1xudmFyIGRpc2NvbnRpbnVpdGllc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvZGlzY29udGludWl0aWVzICovIFwiLi9zcmMvdXRpbHMvZGlzY29udGludWl0aWVzLmpzXCIpO1xudmFyIGZyYWdtZW50X3RyYWNrZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZnJhZ21lbnQtdHJhY2tlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtdHJhY2tlci5qc1wiKTtcbnZhciBmcmFnbWVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9hZGVyL2ZyYWdtZW50ICovIFwiLi9zcmMvbG9hZGVyL2ZyYWdtZW50LmpzXCIpO1xudmFyIGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYmFzZS1zdHJlYW0tY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvYmFzZS1zdHJlYW0tY29udHJvbGxlci5qc1wiKTtcbnZhciBwZXJmb3JtYW5jZSA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcbnZhciBUSUNLX0lOVEVSVkFMID0gMTAwOyAvLyBob3cgb2Z0ZW4gdG8gdGljayBpbiBtc1xudmFyIEF1ZGlvU3RyZWFtQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXVkaW9TdHJlYW1Db250cm9sbGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEF1ZGlvU3RyZWFtQ29udHJvbGxlcihobHMsIGZyYWdtZW50VHJhY2tlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBobHMsIGV2ZW50c18xLmRlZmF1bHQuTUVESUFfQVRUQUNIRUQsIGV2ZW50c18xLmRlZmF1bHQuTUVESUFfREVUQUNISU5HLCBldmVudHNfMS5kZWZhdWx0LkFVRElPX1RSQUNLU19VUERBVEVELCBldmVudHNfMS5kZWZhdWx0LkFVRElPX1RSQUNLX1NXSVRDSElORywgZXZlbnRzXzEuZGVmYXVsdC5BVURJT19UUkFDS19MT0FERUQsIGV2ZW50c18xLmRlZmF1bHQuS0VZX0xPQURFRCwgZXZlbnRzXzEuZGVmYXVsdC5GUkFHX0xPQURFRCwgZXZlbnRzXzEuZGVmYXVsdC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCBldmVudHNfMS5kZWZhdWx0LkZSQUdfUEFSU0lOR19EQVRBLCBldmVudHNfMS5kZWZhdWx0LkZSQUdfUEFSU0VELCBldmVudHNfMS5kZWZhdWx0LkVSUk9SLCBldmVudHNfMS5kZWZhdWx0LkJVRkZFUl9SRVNFVCwgZXZlbnRzXzEuZGVmYXVsdC5CVUZGRVJfQ1JFQVRFRCwgZXZlbnRzXzEuZGVmYXVsdC5CVUZGRVJfQVBQRU5ERUQsIGV2ZW50c18xLmRlZmF1bHQuQlVGRkVSX0ZMVVNIRUQsIGV2ZW50c18xLmRlZmF1bHQuSU5JVF9QVFNfRk9VTkQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmZyYWdtZW50VHJhY2tlciA9IGZyYWdtZW50VHJhY2tlcjtcbiAgICAgICAgX3RoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICAgICAgX3RoaXMuYXVkaW9Db2RlY1N3YXAgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX3N0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLlNUT1BQRUQ7XG4gICAgICAgIF90aGlzLmluaXRQVFMgPSBbXTtcbiAgICAgICAgX3RoaXMud2FpdGluZ0ZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgX3RoaXMudmlkZW9UcmFja0NDID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBdWRpb1N0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uSGFuZGxlckRlc3Ryb3lpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vbkhhbmRsZXJEZXN0cm95aW5nLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBBdWRpb1N0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uSGFuZGxlckRlc3Ryb3llZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5TVE9QUEVEO1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlciA9IG51bGw7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUub25IYW5kbGVyRGVzdHJveWVkLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICAvLyBTaWduYWwgdGhhdCB2aWRlbyBQVFMgd2FzIGZvdW5kXG4gICAgQXVkaW9TdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbkluaXRQdHNGb3VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBkZW11eGVySWQgPSBkYXRhLmlkLCBjYyA9IGRhdGEuZnJhZy5jYywgaW5pdFBUUyA9IGRhdGEuaW5pdFBUUztcbiAgICAgICAgaWYgKGRlbXV4ZXJJZCA9PT0gJ21haW4nKSB7XG4gICAgICAgICAgICAvLyBBbHdheXMgdXBkYXRlIHRoZSBuZXcgSU5JVCBQVFNcbiAgICAgICAgICAgIC8vIENhbiBjaGFuZ2UgZHVlIGxldmVsIHN3aXRjaFxuICAgICAgICAgICAgdGhpcy5pbml0UFRTW2NjXSA9IGluaXRQVFM7XG4gICAgICAgICAgICB0aGlzLnZpZGVvVHJhY2tDQyA9IGNjO1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIkluaXRQVFMgZm9yIGNjOiBcIiArIGNjICsgXCIgZm91bmQgZnJvbSB2aWRlbyB0cmFjazogXCIgKyBpbml0UFRTKTtcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSB3YWl0aW5nIHdlIG5lZWQgdG8gZGVtdXgvcmVtdXggdGhlIHdhaXRpbmcgZnJhZ1xuICAgICAgICAgICAgLy8gV2l0aCB0aGUgbmV3IGluaXRQVFNcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuV0FJVElOR19JTklUX1BUUykge1xuICAgICAgICAgICAgICAgIHRoaXMudGljaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBBdWRpb1N0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLnN0YXJ0TG9hZCA9IGZ1bmN0aW9uIChzdGFydFBvc2l0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYWNrcykge1xuICAgICAgICAgICAgdmFyIGxhc3RDdXJyZW50VGltZSA9IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgICAgICAgICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMKTtcbiAgICAgICAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG4gICAgICAgICAgICBpZiAobGFzdEN1cnJlbnRUaW1lID4gMCAmJiBzdGFydFBvc2l0aW9uID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJhdWRpbzpvdmVycmlkZSBzdGFydFBvc2l0aW9uIHdpdGggbGFzdEN1cnJlbnRUaW1lIEBcIiArIGxhc3RDdXJyZW50VGltZS50b0ZpeGVkKDMpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLklETEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHRoaXMuc3RhcnRQb3NpdGlvbiA/IHRoaXMuc3RhcnRQb3NpdGlvbiA6IHN0YXJ0UG9zaXRpb247XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5TVEFSVElORztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5TVE9QUEVEO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBdWRpb1N0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLnN0b3BMb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgICAgICBpZiAoZnJhZy5sb2FkZXIpIHtcbiAgICAgICAgICAgICAgICBmcmFnLmxvYWRlci5hYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmRlbXV4ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVtdXhlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuU1RPUFBFRDtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBdWRpb1N0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLCBcInN0YXRlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5leHRTdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IG5leHRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c1N0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiYXVkaW8gc3RyZWFtOlwiICsgcHJldmlvdXNTdGF0ZSArIFwiLT5cIiArIG5leHRTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEF1ZGlvU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuZG9UaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcG9zLCB0cmFjaywgdHJhY2tEZXRhaWxzLCBobHMgPSB0aGlzLmhscywgY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnYXVkaW9TdHJlYW06JyArIHRoaXMuc3RhdGUpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLkVSUk9SOlxuICAgICAgICAgICAgLy8gZG9uJ3QgZG8gYW55dGhpbmcgaW4gZXJyb3Igc3RhdGUgdG8gYXZvaWQgYnJlYWtpbmcgZnVydGhlciAuLi5cbiAgICAgICAgICAgIGNhc2UgYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLlBBVVNFRDpcbiAgICAgICAgICAgIC8vIGRvbid0IGRvIGFueXRoaW5nIGluIHBhdXNlZCBzdGF0ZSBlaXRoZXIgLi4uXG4gICAgICAgICAgICBjYXNlIGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5CVUZGRVJfRkxVU0hJTkc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5TVEFSVElORzpcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLldBSVRJTkdfVFJBQ0s7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuSURMRTpcbiAgICAgICAgICAgICAgICB2YXIgdHJhY2tzID0gdGhpcy50cmFja3M7XG4gICAgICAgICAgICAgICAgLy8gYXVkaW8gdHJhY2tzIG5vdCByZWNlaXZlZCA9PiBleGl0IGxvb3BcbiAgICAgICAgICAgICAgICBpZiAoIXRyYWNrcykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgdmlkZW8gbm90IGF0dGFjaGVkIEFORFxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGZyYWdtZW50IGFscmVhZHkgcmVxdWVzdGVkIE9SIHN0YXJ0IGZyYWcgcHJlZmV0Y2ggZGlzYWJsZVxuICAgICAgICAgICAgICAgIC8vIGV4aXQgbG9vcFxuICAgICAgICAgICAgICAgIC8vID0+IGlmIG1lZGlhIG5vdCBhdHRhY2hlZCBidXQgc3RhcnQgZnJhZyBwcmVmZXRjaCBpcyBlbmFibGVkIGFuZCBzdGFydCBmcmFnIG5vdCByZXF1ZXN0ZWQgeWV0LCB3ZSB3aWxsIG5vdCBleGl0IGxvb3BcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWVkaWEgJiZcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkIHx8ICFjb25maWcuc3RhcnRGcmFnUHJlZmV0Y2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkZXRlcm1pbmUgbmV4dCBjYW5kaWRhdGUgZnJhZ21lbnQgdG8gYmUgbG9hZGVkLCBiYXNlZCBvbiBjdXJyZW50IHBvc2l0aW9uIGFuZFxuICAgICAgICAgICAgICAgIC8vICBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBub3QgeWV0IGxvYWRlZCBhbnkgZnJhZ21lbnQsIHN0YXJ0IGxvYWRpbmcgZnJvbSBzdGFydCBwb3NpdGlvblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHRoaXMubWVkaWEuY3VycmVudFRpbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSB0aGlzLm5leHRMb2FkUG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhLCB2aWRlb0J1ZmZlciA9IHRoaXMudmlkZW9CdWZmZXIgPyB0aGlzLnZpZGVvQnVmZmVyIDogdGhpcy5tZWRpYSwgYnVmZmVySW5mbyA9IGJ1ZmZlcl9oZWxwZXJfMS5CdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSwgcG9zLCBjb25maWcubWF4QnVmZmVySG9sZSksIG1haW5CdWZmZXJJbmZvID0gYnVmZmVyX2hlbHBlcl8xLkJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKHZpZGVvQnVmZmVyLCBwb3MsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKSwgYnVmZmVyTGVuID0gYnVmZmVySW5mby5sZW4sIGJ1ZmZlckVuZF8xID0gYnVmZmVySW5mby5lbmQsIGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzLCBcbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgd2UgYnVmZmVyIGF0IGxlYXN0IGNvbmZpZy5tYXhCdWZmZXJMZW5ndGggKGRlZmF1bHQgMzBzKSBvciBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoIChkZWZhdWx0OiA2MDBzKVxuICAgICAgICAgICAgICAgIC8vIHdoaWNoZXZlciBpcyBzbWFsbGVyLlxuICAgICAgICAgICAgICAgIC8vIG9uY2Ugd2UgcmVhY2ggdGhhdCB0aHJlc2hvbGQsIGRvbid0IGJ1ZmZlciBtb3JlIHRoYW4gdmlkZW8gKG1haW5CdWZmZXJJbmZvLmxlbilcbiAgICAgICAgICAgICAgICBtYXhDb25maWdCdWZmZXIgPSBNYXRoLm1pbihjb25maWcubWF4QnVmZmVyTGVuZ3RoLCBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoKSwgbWF4QnVmTGVuID0gTWF0aC5tYXgobWF4Q29uZmlnQnVmZmVyLCBtYWluQnVmZmVySW5mby5sZW4pLCBhdWRpb1N3aXRjaCA9IHRoaXMuYXVkaW9Td2l0Y2gsIHRyYWNrSWQgPSB0aGlzLnRyYWNrSWQ7XG4gICAgICAgICAgICAgICAgLy8gaWYgYnVmZmVyIGxlbmd0aCBpcyBsZXNzIHRoYW4gbWF4QnVmTGVuIHRyeSB0byBsb2FkIGEgbmV3IGZyYWdtZW50XG4gICAgICAgICAgICAgICAgaWYgKChidWZmZXJMZW4gPCBtYXhCdWZMZW4gfHwgYXVkaW9Td2l0Y2gpICYmIHRyYWNrSWQgPCB0cmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrRGV0YWlscyA9IHRyYWNrc1t0cmFja0lkXS5kZXRhaWxzO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0cmFjayBpbmZvIG5vdCByZXRyaWV2ZWQgeWV0LCBzd2l0Y2ggc3RhdGUgYW5kIHdhaXQgZm9yIHRyYWNrIHJldHJpZXZhbFxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRyYWNrRGV0YWlscyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuV0FJVElOR19UUkFDSztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghYXVkaW9Td2l0Y2ggJiYgdGhpcy5fc3RyZWFtRW5kZWQoYnVmZmVySW5mbywgdHJhY2tEZXRhaWxzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkJVRkZFUl9FT1MsIHsgdHlwZTogJ2F1ZGlvJyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuRU5ERUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCBmcmFnbWVudCBpbmRleCwgY29udGlndW91cyB3aXRoIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50cyA9IHRyYWNrRGV0YWlscy5mcmFnbWVudHMsIGZyYWdMZW4gPSBmcmFnbWVudHMubGVuZ3RoLCBzdGFydCA9IGZyYWdtZW50c1swXS5zdGFydCwgZW5kID0gZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXS5zdGFydCArIGZyYWdtZW50c1tmcmFnTGVuIC0gMV0uZHVyYXRpb24sIGZyYWcgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gc3dpdGNoaW5nIGF1ZGlvIHRyYWNrLCByZWxvYWQgYXVkaW8gYXMgY2xvc2UgYXMgcG9zc2libGUgdG8gY3VycmVudFRpbWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF1ZGlvU3dpdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2tEZXRhaWxzLmxpdmUgJiYgIXRyYWNrRGV0YWlscy5QVFNLbm93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ3N3aXRjaGluZyBhdWRpb3RyYWNrLCBsaXZlIHN0cmVhbSwgdW5rbm93biBQVFMsbG9hZCBmaXJzdCBmcmFnbWVudCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckVuZF8xID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckVuZF8xID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGN1cnJlbnRUaW1lIChwb3MpIGlzIGxlc3MgdGhhbiBhbHQgYXVkaW8gcGxheWxpc3Qgc3RhcnQgdGltZSwgaXQgbWVhbnMgdGhhdCBhbHQgYXVkaW8gaXMgYWhlYWQgb2YgY3VycmVudFRpbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2tEZXRhaWxzLlBUU0tub3duICYmIHBvcyA8IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGV2ZXJ5dGhpbmcgaXMgYnVmZmVyZWQgZnJvbSBwb3MgdG8gc3RhcnQgb3IgaWYgYXVkaW8gYnVmZmVyIHVwZnJvbnQsIGxldCdzIHNlZWsgdG8gc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlckluZm8uZW5kID4gc3RhcnQgfHwgYnVmZmVySW5mby5uZXh0U3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ2FsdCBhdWRpbyB0cmFjayBhaGVhZCBvZiBtYWluIHRyYWNrLCBzZWVrIHRvIHN0YXJ0IG9mIGFsdCBhdWRpbyB0cmFjaycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZWRpYS5jdXJyZW50VGltZSA9IHN0YXJ0ICsgMC4wNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2tEZXRhaWxzLmluaXRTZWdtZW50ICYmICF0cmFja0RldGFpbHMuaW5pdFNlZ21lbnQuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyA9IHRyYWNrRGV0YWlscy5pbml0U2VnbWVudDtcbiAgICAgICAgICAgICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJyYWNlLXN0eWxlXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGJ1ZmZlckVuZCBiZWZvcmUgc3RhcnQgb2YgcGxheWxpc3QsIGxvYWQgZmlyc3QgZnJhZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYnVmZmVyRW5kXzEgPD0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcgPSBmcmFnbWVudHNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52aWRlb1RyYWNrQ0MgIT09IG51bGwgJiYgZnJhZy5jYyAhPT0gdGhpcy52aWRlb1RyYWNrQ0MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgd2UgZmluZCBhIGZyYWdtZW50IHdoaWNoIG1hdGNoZXMgdGhlIGNvbnRpbnVpdHkgb2YgdGhlIHZpZGVvIHRyYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyA9IGRpc2NvbnRpbnVpdGllc18xLmZpbmRGcmFnV2l0aENDKGZyYWdtZW50cywgdGhpcy52aWRlb1RyYWNrQ0MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrRGV0YWlscy5saXZlICYmIGZyYWcubG9hZElkeCAmJiBmcmFnLmxvYWRJZHggPT09IHRoaXMuZnJhZ0xvYWRJZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBqdXN0IGxvYWRlZCB0aGlzIGZpcnN0IGZyYWdtZW50LCBhbmQgd2UgYXJlIHN0aWxsIGxhZ2dpbmcgYmVoaW5kIHRoZSBzdGFydCBvZiB0aGUgbGl2ZSBwbGF5bGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCdzIGZvcmNlIHNlZWsgdG8gc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dEJ1ZmZlcmVkID0gYnVmZmVySW5mby5uZXh0U3RhcnQgPyBidWZmZXJJbmZvLm5leHRTdGFydCA6IHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJubyBhbHQgYXVkaW8gYXZhaWxhYmxlIEBjdXJyZW50VGltZTpcIiArIHRoaXMubWVkaWEuY3VycmVudFRpbWUgKyBcIiwgc2Vla2luZyBAXCIgKyAobmV4dEJ1ZmZlcmVkICsgMC4wNSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWVkaWEuY3VycmVudFRpbWUgPSBuZXh0QnVmZmVyZWQgKyAwLjA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZEZyYWcgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZV8xID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhZ05leHQgPSBmcmFnUHJldmlvdXMgPyBmcmFnbWVudHNbZnJhZ1ByZXZpb3VzLnNuIC0gZnJhZ21lbnRzWzBdLnNuICsgMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0ID0gZnVuY3Rpb24gKGNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mZnNldCBzaG91bGQgYmUgd2l0aGluIGZyYWdtZW50IGJvdW5kYXJ5IC0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRvIGNvcGUgd2l0aCBzaXR1YXRpb25zIGxpa2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBidWZmZXJFbmQgPSA5Ljk5MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZyYWdbw5hdIDogWzAsMTBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJhZ1sxXSA6IFsxMCwyMF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBidWZmZXJFbmQgaXMgd2l0aGluIGZyYWdbMF0gcmFuZ2UgLi4uIGFsdGhvdWdoIHdoYXQgd2UgYXJlIGV4cGVjdGluZyBpcyB0byByZXR1cm4gZnJhZ1sxXSBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgIGZyYWcgc3RhcnQgICAgICAgICAgICAgICBmcmFnIHN0YXJ0K2R1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgIDwtLS0+ICAgICAgICAgICAgICAgICAgICAgICAgIDwtLS0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIC4uLi0tLS0tLS0tPjwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT48LS0tLS0tLS0tLi4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzIGZyYWcgICAgICAgICBtYXRjaGluZyBmcmFnbWVudCAgICAgICAgIG5leHQgZnJhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICByZXR1cm4gLTEgICAgICAgICAgICAgcmV0dXJuIDAgICAgICAgICAgICAgICAgIHJldHVybiAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZyhgbGV2ZWwvc24vc3RhcnQvZW5kL2J1ZkVuZDoke2xldmVsfS8ke2NhbmRpZGF0ZS5zbn0vJHtjYW5kaWRhdGUuc3RhcnR9LyR7KGNhbmRpZGF0ZS5zdGFydCtjYW5kaWRhdGUuZHVyYXRpb24pfS8ke2J1ZmZlckVuZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGxvb2t1cCB0b2xlcmFuY2UgdG8gYmUgc21hbGwgZW5vdWdoIHRvIGRldGVjdCB0aGUgY3VycmVudCBzZWdtZW50IC0gZW5zdXJlcyB3ZSBkb24ndCBza2lwIG92ZXIgdmVyeSBzbWFsbCBzZWdtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPSBNYXRoLm1pbihtYXhGcmFnTG9va1VwVG9sZXJhbmNlXzEsIGNhbmRpZGF0ZS5kdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjYW5kaWRhdGUuc3RhcnQgKyBjYW5kaWRhdGUuZHVyYXRpb24gLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UpIDw9IGJ1ZmZlckVuZF8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjYW5kaWRhdGUuc3RhcnQgLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPiBidWZmZXJFbmRfMSAmJiBjYW5kaWRhdGUuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSB3aWxsIGhhdmUgbmVnYXRpdmUgdmFsdWUgdGhlbiBkb24ndCByZXR1cm4gLTEgZm9yIGZpcnN0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyRW5kXzEgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyRW5kXzEgPiBlbmQgLSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZV8xID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJlZmVyIHRoZSBuZXh0IGZyYWdtZW50IGlmIGl0J3Mgd2l0aGluIHRvbGVyYW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnTmV4dCAmJiAhZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KGZyYWdOZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZEZyYWcgPSBmcmFnTmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kRnJhZyA9IGJpbmFyeV9zZWFyY2hfMS5kZWZhdWx0LnNlYXJjaChmcmFnbWVudHMsIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVhY2ggZW5kIG9mIHBsYXlsaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRGcmFnID0gZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZEZyYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnID0gZm91bmRGcmFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZm91bmRGcmFnLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ2ZpbmQgU04gbWF0Y2hpbmcgd2l0aCBwb3M6JyArICBidWZmZXJFbmQgKyAnOicgKyBmcmFnLnNuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZ1ByZXZpb3VzICYmIGZyYWcubGV2ZWwgPT09IGZyYWdQcmV2aW91cy5sZXZlbCAmJiBmcmFnLnNuID09PSBmcmFnUHJldmlvdXMuc24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWcuc24gPCB0cmFja0RldGFpbHMuZW5kU04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcgPSBmcmFnbWVudHNbZnJhZy5zbiArIDEgLSB0cmFja0RldGFpbHMuc3RhcnRTTl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiU04ganVzdCBsb2FkZWQsIGxvYWQgbmV4dCBvbmU6IFwiICsgZnJhZy5zbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZygnICAgICAgbG9hZGluZyBmcmFnICcgKyBpICsnLHBvcy9idWZFbmQ6JyArIHBvcy50b0ZpeGVkKDMpICsgJy8nICsgYnVmZmVyRW5kLnRvRml4ZWQoMykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWcuZW5jcnlwdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIkxvYWRpbmcga2V5IGZvciBcIiArIGZyYWcuc24gKyBcIiBvZiBbXCIgKyB0cmFja0RldGFpbHMuc3RhcnRTTiArIFwiICxcIiArIHRyYWNrRGV0YWlscy5lbmRTTiArIFwiXSx0cmFjayBcIiArIHRyYWNrSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuS0VZX0xPQURJTkc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5LRVlfTE9BRElORywgeyBmcmFnOiBmcmFnIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIkxvYWRpbmcgXCIgKyBmcmFnLnNuICsgXCIsIGNjOiBcIiArIGZyYWcuY2MgKyBcIiBvZiBbXCIgKyB0cmFja0RldGFpbHMuc3RhcnRTTiArIFwiICxcIiArIHRyYWNrRGV0YWlscy5lbmRTTiArIFwiXSx0cmFjayBcIiArIHRyYWNrSWQgKyBcIiwgY3VycmVudFRpbWU6XCIgKyBwb3MgKyBcIixidWZmZXJFbmQ6XCIgKyBidWZmZXJFbmRfMS50b0ZpeGVkKDMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGxvYWQgaWYgZnJhZ21lbnQgaXMgbm90IGxvYWRlZCBvciBpZiBpbiBhdWRpbyBzd2l0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBmb3JjZSBhIGZyYWcgbG9hZGluZyBpbiBhdWRpbyBzd2l0Y2ggYXMgZnJhZ21lbnQgdHJhY2tlciBtaWdodCBub3QgaGF2ZSBldmljdGVkIHByZXZpb3VzIGZyYWdzIGluIGNhc2Ugb2YgcXVpY2sgYXVkaW8gc3dpdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF1ZGlvU3dpdGNoIHx8IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpID09PSBmcmFnbWVudF90cmFja2VyXzEuRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShmcmFnLnNuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gZnJhZy5zdGFydCArIGZyYWcuZHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5GUkFHX0xPQURJTkcsIHsgZnJhZzogZnJhZyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5GUkFHX0xPQURJTkc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuV0FJVElOR19UUkFDSzpcbiAgICAgICAgICAgICAgICB0cmFjayA9IHRoaXMudHJhY2tzW3RoaXMudHJhY2tJZF07XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgcGxheWxpc3QgaXMgYWxyZWFkeSBsb2FkZWRcbiAgICAgICAgICAgICAgICBpZiAodHJhY2sgJiYgdHJhY2suZGV0YWlscykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLklETEU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6XG4gICAgICAgICAgICAgICAgdmFyIG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgICAgIHZhciByZXRyeURhdGUgPSB0aGlzLnJldHJ5RGF0ZTtcbiAgICAgICAgICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICAgICAgICAgICAgdmFyIGlzU2Vla2luZyA9IG1lZGlhICYmIG1lZGlhLnNlZWtpbmc7XG4gICAgICAgICAgICAgICAgLy8gaWYgY3VycmVudCB0aW1lIGlzIGd0IHRoYW4gcmV0cnlEYXRlLCBvciBpZiBtZWRpYSBzZWVraW5nIGxldCdzIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIHJldHJ5IGxvYWRpbmdcbiAgICAgICAgICAgICAgICBpZiAoIXJldHJ5RGF0ZSB8fCAobm93ID49IHJldHJ5RGF0ZSkgfHwgaXNTZWVraW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ2F1ZGlvU3RyZWFtQ29udHJvbGxlcjogcmV0cnlEYXRlIHJlYWNoZWQsIHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5JRExFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLldBSVRJTkdfSU5JVF9QVFM6XG4gICAgICAgICAgICAgICAgdmFyIHZpZGVvVHJhY2tDQyA9IHRoaXMudmlkZW9UcmFja0NDO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluaXRQVFNbdmlkZW9UcmFja0NDXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgd2UgZG9uJ3QgZ2V0IHN0dWNrIGluIHRoZSBXQUlUSU5HX0lOSVRfUFRTIHN0YXRlIGlmIHRoZSB3YWl0aW5nIGZyYWcgQ0MgZG9lc24ndCBtYXRjaCBhbnkgaW5pdFBUU1xuICAgICAgICAgICAgICAgIHZhciB3YWl0aW5nRnJhZyA9IHRoaXMud2FpdGluZ0ZyYWdtZW50O1xuICAgICAgICAgICAgICAgIGlmICh3YWl0aW5nRnJhZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2FpdGluZ0ZyYWdDQyA9IHdhaXRpbmdGcmFnLmZyYWcuY2M7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aWRlb1RyYWNrQ0MgIT09IHdhaXRpbmdGcmFnQ0MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrID0gdGhpcy50cmFja3NbdGhpcy50cmFja0lkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFjay5kZXRhaWxzICYmIHRyYWNrLmRldGFpbHMubGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKFwiV2FpdGluZyBmcmFnbWVudCBDQyAoXCIgKyB3YWl0aW5nRnJhZ0NDICsgXCIpIGRvZXMgbm90IG1hdGNoIHZpZGVvIHRyYWNrIENDIChcIiArIHZpZGVvVHJhY2tDQyArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndhaXRpbmdGcmFnbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5JRExFO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5GUkFHX0xPQURJTkc7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRnJhZ0xvYWRlZCh0aGlzLndhaXRpbmdGcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndhaXRpbmdGcmFnbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuSURMRTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5TVE9QUEVEOlxuICAgICAgICAgICAgY2FzZSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuRlJBR19MT0FESU5HOlxuICAgICAgICAgICAgY2FzZSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuUEFSU0lORzpcbiAgICAgICAgICAgIGNhc2UgYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLlBBUlNFRDpcbiAgICAgICAgICAgIGNhc2UgYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLkVOREVEOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXVkaW9TdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbk1lZGlhQXR0YWNoZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IGRhdGEubWVkaWE7XG4gICAgICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub25NZWRpYVNlZWtpbmcuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbnZlbmRlZCA9IHRoaXMub25NZWRpYUVuZGVkLmJpbmQodGhpcyk7XG4gICAgICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgICAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgIGlmICh0aGlzLnRyYWNrcyAmJiBjb25maWcuYXV0b1N0YXJ0TG9hZCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydExvYWQoY29uZmlnLnN0YXJ0UG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBdWRpb1N0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uTWVkaWFEZXRhY2hpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICAgIGlmIChtZWRpYSAmJiBtZWRpYS5lbmRlZCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnTVNFIGRldGFjaGluZyBhbmQgdmlkZW8gZW5kZWQsIHJlc2V0IHN0YXJ0UG9zaXRpb24nKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyByZW1vdmUgdmlkZW8gbGlzdGVuZXJzXG4gICAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMub252c2Vla2luZyk7XG4gICAgICAgICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xuICAgICAgICAgICAgdGhpcy5vbnZzZWVraW5nID0gdGhpcy5vbnZzZWVrZWQgPSB0aGlzLm9udmVuZGVkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMudmlkZW9CdWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICB9O1xuICAgIEF1ZGlvU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25BdWRpb1RyYWNrc1VwZGF0ZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdhdWRpbyB0cmFja3MgdXBkYXRlZCcpO1xuICAgICAgICB0aGlzLnRyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3M7XG4gICAgfTtcbiAgICBBdWRpb1N0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uQXVkaW9UcmFja1N3aXRjaGluZyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIGlmIGFueSBVUkwgZm91bmQgb24gbmV3IGF1ZGlvIHRyYWNrLCBpdCBpcyBhbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tcbiAgICAgICAgdmFyIGFsdEF1ZGlvID0gISFkYXRhLnVybDtcbiAgICAgICAgdGhpcy50cmFja0lkID0gZGF0YS5pZDtcbiAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuUEFVU0VEO1xuICAgICAgICB0aGlzLndhaXRpbmdGcmFnbWVudCA9IG51bGw7XG4gICAgICAgIC8vIGRlc3Ryb3kgdXNlbGVzcyBkZW11eGVyIHdoZW4gc3dpdGNoaW5nIGF1ZGlvIHRvIG1haW5cbiAgICAgICAgaWYgKCFhbHRBdWRpbykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVtdXhlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVtdXhlci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZW11eGVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHN3aXRjaGluZyB0byBhdWRpbyB0cmFjaywgc3RhcnQgdGltZXIgaWYgbm90IGFscmVhZHkgc3RhcnRlZFxuICAgICAgICAgICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzaG91bGQgd2Ugc3dpdGNoIHRyYWNrcyA/XG4gICAgICAgIGlmIChhbHRBdWRpbykge1xuICAgICAgICAgICAgdGhpcy5hdWRpb1N3aXRjaCA9IHRydWU7XG4gICAgICAgICAgICAvLyBtYWluIGF1ZGlvIHRyYWNrIGFyZSBoYW5kbGVkIGJ5IHN0cmVhbS1jb250cm9sbGVyLCBqdXN0IGRvIHNvbWV0aGluZyBpZiBzd2l0Y2hpbmcgdG8gYWx0IGF1ZGlvIHRyYWNrXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLklETEU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgfTtcbiAgICBBdWRpb1N0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uQXVkaW9UcmFja0xvYWRlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBuZXdEZXRhaWxzID0gZGF0YS5kZXRhaWxzLCB0cmFja0lkID0gZGF0YS5pZCwgdHJhY2sgPSB0aGlzLnRyYWNrc1t0cmFja0lkXSwgZHVyYXRpb24gPSBuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb24sIHNsaWRpbmcgPSAwO1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwidHJhY2sgXCIgKyB0cmFja0lkICsgXCIgbG9hZGVkIFtcIiArIG5ld0RldGFpbHMuc3RhcnRTTiArIFwiLFwiICsgbmV3RGV0YWlscy5lbmRTTiArIFwiXSxkdXJhdGlvbjpcIiArIGR1cmF0aW9uKTtcbiAgICAgICAgaWYgKG5ld0RldGFpbHMubGl2ZSkge1xuICAgICAgICAgICAgdmFyIGN1ckRldGFpbHMgPSB0cmFjay5kZXRhaWxzO1xuICAgICAgICAgICAgaWYgKGN1ckRldGFpbHMgJiYgbmV3RGV0YWlscy5mcmFnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGFscmVhZHkgaGF2ZSBkZXRhaWxzIGZvciB0aGF0IGxldmVsLCBtZXJnZSB0aGVtXG4gICAgICAgICAgICAgICAgTGV2ZWxIZWxwZXIubWVyZ2VEZXRhaWxzKGN1ckRldGFpbHMsIG5ld0RldGFpbHMpO1xuICAgICAgICAgICAgICAgIHNsaWRpbmcgPSBuZXdEZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICAgICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICAgICAgLy8gdGhpcy5saXZlU3luY1Bvc2l0aW9uID0gdGhpcy5jb21wdXRlTGl2ZVBvc2l0aW9uKHNsaWRpbmcsIGN1ckRldGFpbHMpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdEZXRhaWxzLlBUU0tub3duKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJsaXZlIGF1ZGlvIHBsYXlsaXN0IHNsaWRpbmc6XCIgKyBzbGlkaW5nLnRvRml4ZWQoMykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnbGl2ZSBhdWRpbyBwbGF5bGlzdCAtIG91dGRhdGVkIFBUUywgdW5rbm93biBzbGlkaW5nJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ2xpdmUgYXVkaW8gcGxheWxpc3QgLSBmaXJzdCBsb2FkLCB1bmtub3duIHNsaWRpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld0RldGFpbHMuUFRTS25vd24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cmFjay5kZXRhaWxzID0gbmV3RGV0YWlscztcbiAgICAgICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvblxuICAgICAgICBpZiAoIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkKSB7XG4gICAgICAgICAgICAvLyBjb21wdXRlIHN0YXJ0IHBvc2l0aW9uIGlmIHNldCB0byAtMS4gdXNlIGl0IHN0cmFpZ2h0IGF3YXkgaWYgdmFsdWUgaXMgZGVmaW5lZFxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBmaXJzdCwgY2hlY2sgaWYgc3RhcnQgdGltZSBvZmZzZXQgaGFzIGJlZW4gc2V0IGluIHBsYXlsaXN0LCBpZiB5ZXMsIHVzZSB0aGlzIHZhbHVlXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0VGltZU9mZnNldCA9IG5ld0RldGFpbHMuc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoc3RhcnRUaW1lT2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwic3RhcnQgdGltZSBvZmZzZXQgZm91bmQgaW4gcGxheWxpc3QsIGFkanVzdCBzdGFydFBvc2l0aW9uIHRvIFwiICsgc3RhcnRUaW1lT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgLy8gb25seSBzd2l0Y2ggYmF0Y2sgdG8gSURMRSBzdGF0ZSBpZiB3ZSB3ZXJlIHdhaXRpbmcgZm9yIHRyYWNrIHRvIHN0YXJ0IGRvd25sb2FkaW5nIGEgbmV3IGZyYWdtZW50XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuV0FJVElOR19UUkFDSykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5JRExFO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgfTtcbiAgICBBdWRpb1N0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uS2V5TG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLktFWV9MT0FESU5HKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLklETEU7XG4gICAgICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXVkaW9TdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbkZyYWdMb2FkZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50LCBmcmFnTG9hZGVkID0gZGF0YS5mcmFnO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLkZSQUdfTE9BRElORyAmJlxuICAgICAgICAgICAgZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgICAgIGZyYWdMb2FkZWQudHlwZSA9PT0gJ2F1ZGlvJyAmJlxuICAgICAgICAgICAgZnJhZ0xvYWRlZC5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcbiAgICAgICAgICAgIGZyYWdMb2FkZWQuc24gPT09IGZyYWdDdXJyZW50LnNuKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2sgPSB0aGlzLnRyYWNrc1t0aGlzLnRyYWNrSWRdLCBkZXRhaWxzID0gdHJhY2suZGV0YWlscywgZHVyYXRpb24gPSBkZXRhaWxzLnRvdGFsZHVyYXRpb24sIHRyYWNrSWQgPSBmcmFnQ3VycmVudC5sZXZlbCwgc24gPSBmcmFnQ3VycmVudC5zbiwgY2MgPSBmcmFnQ3VycmVudC5jYywgYXVkaW9Db2RlYyA9IHRoaXMuY29uZmlnLmRlZmF1bHRBdWRpb0NvZGVjIHx8IHRyYWNrLmF1ZGlvQ29kZWMgfHwgJ21wNGEuNDAuMicsIHN0YXRzID0gdGhpcy5zdGF0cyA9IGRhdGEuc3RhdHM7XG4gICAgICAgICAgICBpZiAoc24gPT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLklETEU7XG4gICAgICAgICAgICAgICAgc3RhdHMudHBhcnNlZCA9IHN0YXRzLnRidWZmZXJlZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgICAgIGRldGFpbHMuaW5pdFNlZ21lbnQuZGF0YSA9IGRhdGEucGF5bG9hZDtcbiAgICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRlJBR19CVUZGRVJFRCwgeyBzdGF0czogc3RhdHMsIGZyYWc6IGZyYWdDdXJyZW50LCBpZDogJ2F1ZGlvJyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuUEFSU0lORztcbiAgICAgICAgICAgICAgICAvLyB0cmFuc211eCB0aGUgTVBFRy1UUyBkYXRhIHRvIElTTy1CTUZGIHNlZ21lbnRzXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kZW11eGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVtdXhlciA9IG5ldyBkZW11eGVyXzEuZGVmYXVsdCh0aGlzLmhscywgJ2F1ZGlvJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgdmlkZW8gaW5pdFBUU1xuICAgICAgICAgICAgICAgIC8vIElmIG5vdCB3ZSBuZWVkIHRvIHdhaXQgZm9yIGl0XG4gICAgICAgICAgICAgICAgdmFyIGluaXRQVFMgPSB0aGlzLmluaXRQVFNbY2NdO1xuICAgICAgICAgICAgICAgIHZhciBpbml0U2VnbWVudERhdGEgPSBkZXRhaWxzLmluaXRTZWdtZW50ID8gZGV0YWlscy5pbml0U2VnbWVudC5kYXRhIDogW107XG4gICAgICAgICAgICAgICAgaWYgKGRldGFpbHMuaW5pdFNlZ21lbnQgfHwgaW5pdFBUUyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJEZW11eGluZyBcIiArIHNuICsgXCIgb2YgW1wiICsgZGV0YWlscy5zdGFydFNOICsgXCIgLFwiICsgZGV0YWlscy5lbmRTTiArIFwiXSx0cmFjayBcIiArIHRyYWNrSWQpO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aW1lIE9mZnNldCBpcyBhY2N1cmF0ZSBpZiBsZXZlbCBQVFMgaXMga25vd24sIG9yIGlmIHBsYXlsaXN0IGlzIG5vdCBzbGlkaW5nIChub3QgbGl2ZSlcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjY3VyYXRlVGltZU9mZnNldCA9IGZhbHNlOyAvLyBkZXRhaWxzLlBUU0tub3duIHx8ICFkZXRhaWxzLmxpdmU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVtdXhlci5wdXNoKGRhdGEucGF5bG9hZCwgaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCBudWxsLCBmcmFnQ3VycmVudCwgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgaW5pdFBUUyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwidW5rbm93biB2aWRlbyBQVFMgZm9yIGNvbnRpbnVpdHkgY291bnRlciBcIiArIGNjICsgXCIsIHdhaXRpbmcgZm9yIHZpZGVvIFBUUyBiZWZvcmUgZGVtdXhpbmcgYXVkaW8gZnJhZyBcIiArIHNuICsgXCIgb2YgW1wiICsgZGV0YWlscy5zdGFydFNOICsgXCIgLFwiICsgZGV0YWlscy5lbmRTTiArIFwiXSx0cmFjayBcIiArIHRyYWNrSWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndhaXRpbmdGcmFnbWVudCA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuV0FJVElOR19JTklUX1BUUztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcbiAgICB9O1xuICAgIEF1ZGlvU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25GcmFnUGFyc2luZ0luaXRTZWdtZW50ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgICAgdmFyIGZyYWdOZXcgPSBkYXRhLmZyYWc7XG4gICAgICAgIGlmIChmcmFnQ3VycmVudCAmJlxuICAgICAgICAgICAgZGF0YS5pZCA9PT0gJ2F1ZGlvJyAmJlxuICAgICAgICAgICAgZnJhZ05ldy5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiZcbiAgICAgICAgICAgIGZyYWdOZXcubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuUEFSU0lORykge1xuICAgICAgICAgICAgdmFyIHRyYWNrcyA9IGRhdGEudHJhY2tzLCB0cmFjayA9IHZvaWQgMDtcbiAgICAgICAgICAgIC8vIGRlbGV0ZSBhbnkgdmlkZW8gdHJhY2sgZm91bmQgb24gYXVkaW8gZGVtdXhlclxuICAgICAgICAgICAgaWYgKHRyYWNrcy52aWRlbykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0cmFja3MudmlkZW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpbmNsdWRlIGxldmVsQ29kZWMgaW4gYXVkaW8gYW5kIHZpZGVvIHRyYWNrc1xuICAgICAgICAgICAgdHJhY2sgPSB0cmFja3MuYXVkaW87XG4gICAgICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgICAgICB0cmFjay5sZXZlbENvZGVjID0gdHJhY2suY29kZWM7XG4gICAgICAgICAgICAgICAgdHJhY2suaWQgPSBkYXRhLmlkO1xuICAgICAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5CVUZGRVJfQ09ERUNTLCB0cmFja3MpO1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJhdWRpbyB0cmFjazphdWRpbyxjb250YWluZXI6XCIgKyB0cmFjay5jb250YWluZXIgKyBcIixjb2RlY3NbbGV2ZWwvcGFyc2VkXT1bXCIgKyB0cmFjay5sZXZlbENvZGVjICsgXCIvXCIgKyB0cmFjay5jb2RlYyArIFwiXVwiKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5pdFNlZ21lbnQgPSB0cmFjay5pbml0U2VnbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoaW5pdFNlZ21lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFwcGVuZE9iaiA9IHsgdHlwZTogJ2F1ZGlvJywgZGF0YTogaW5pdFNlZ21lbnQsIHBhcmVudDogJ2F1ZGlvJywgY29udGVudDogJ2luaXRTZWdtZW50JyB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdWRpb1N3aXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nRGF0YSA9IFthcHBlbmRPYmpdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcm0gcGVuZGluZyBCdWZmZXJpbmcgZmxhZyBiZWZvcmUgYXBwZW5kaW5nIGEgc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5CVUZGRVJfQVBQRU5ESU5HLCBhcHBlbmRPYmopO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICAgICAgICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQXVkaW9TdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbkZyYWdQYXJzaW5nRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAgIHZhciBmcmFnTmV3ID0gZGF0YS5mcmFnO1xuICAgICAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgICAgIGRhdGEuaWQgPT09ICdhdWRpbycgJiZcbiAgICAgICAgICAgIGRhdGEudHlwZSA9PT0gJ2F1ZGlvJyAmJlxuICAgICAgICAgICAgZnJhZ05ldy5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiZcbiAgICAgICAgICAgIGZyYWdOZXcubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuUEFSU0lORykge1xuICAgICAgICAgICAgdmFyIHRyYWNrSWQgPSB0aGlzLnRyYWNrSWQsIHRyYWNrID0gdGhpcy50cmFja3NbdHJhY2tJZF0sIGhsc18xID0gdGhpcy5obHM7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShkYXRhLmVuZFBUUykpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmVuZFBUUyA9IGRhdGEuc3RhcnRQVFMgKyBmcmFnQ3VycmVudC5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICBkYXRhLmVuZERUUyA9IGRhdGEuc3RhcnREVFMgKyBmcmFnQ3VycmVudC5kdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyYWdDdXJyZW50LmFkZEVsZW1lbnRhcnlTdHJlYW0oZnJhZ21lbnRfMS5kZWZhdWx0LkVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTyk7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwicGFyc2VkIFwiICsgZGF0YS50eXBlICsgXCIsUFRTOltcIiArIGRhdGEuc3RhcnRQVFMudG9GaXhlZCgzKSArIFwiLFwiICsgZGF0YS5lbmRQVFMudG9GaXhlZCgzKSArIFwiXSxEVFM6W1wiICsgZGF0YS5zdGFydERUUy50b0ZpeGVkKDMpICsgXCIvXCIgKyBkYXRhLmVuZERUUy50b0ZpeGVkKDMpICsgXCJdLG5iOlwiICsgZGF0YS5uYik7XG4gICAgICAgICAgICBMZXZlbEhlbHBlci51cGRhdGVGcmFnUFRTRFRTKHRyYWNrLmRldGFpbHMsIGZyYWdDdXJyZW50LCBkYXRhLnN0YXJ0UFRTLCBkYXRhLmVuZFBUUyk7XG4gICAgICAgICAgICB2YXIgYXVkaW9Td2l0Y2ggPSB0aGlzLmF1ZGlvU3dpdGNoLCBtZWRpYSA9IHRoaXMubWVkaWEsIGFwcGVuZE9uQnVmZmVyRmx1c2ggPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIE9ubHkgZmx1c2ggYXVkaW8gZnJvbSBvbGQgYXVkaW8gdHJhY2tzIHdoZW4gUFRTIGlzIGtub3duIG9uIG5ldyBhdWRpbyB0cmFja1xuICAgICAgICAgICAgaWYgKGF1ZGlvU3dpdGNoICYmIG1lZGlhKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ3N3aXRjaGluZyBhdWRpbyB0cmFjayA6IGN1cnJlbnRUaW1lOicgKyBjdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VGltZSA+PSBkYXRhLnN0YXJ0UFRTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdzd2l0Y2hpbmcgYXVkaW8gdHJhY2sgOiBmbHVzaGluZyBhbGwgYXVkaW8nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuQlVGRkVSX0ZMVVNISU5HO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGxzXzEudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkJVRkZFUl9GTFVTSElORywgeyBzdGFydE9mZnNldDogMCwgZW5kT2Zmc2V0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIHR5cGU6ICdhdWRpbycgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRPbkJ1ZmZlckZsdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExldHMgYW5ub3VuY2UgdGhhdCB0aGUgaW5pdGlhbCBhdWRpbyB0cmFjayBzd2l0Y2ggZmx1c2ggb2NjdXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9Td2l0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhsc18xLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5BVURJT19UUkFDS19TV0lUQ0hFRCwgeyBpZDogdHJhY2tJZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGV0cyBhbm5vdW5jZSB0aGF0IHRoZSBpbml0aWFsIGF1ZGlvIHRyYWNrIHN3aXRjaCBmbHVzaCBvY2N1clxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvU3dpdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGhsc18xLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5BVURJT19UUkFDS19TV0lUQ0hFRCwgeyBpZDogdHJhY2tJZCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGVuZGluZ0RhdGFfMSA9IHRoaXMucGVuZGluZ0RhdGE7XG4gICAgICAgICAgICBpZiAoIXBlbmRpbmdEYXRhXzEpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybignQXBwYXJlbnRseSBhdHRlbXB0IHRvIGVucXVldWUgbWVkaWEgcGF5bG9hZCB3aXRob3V0IGNvZGVjIGluaXRpYWxpemF0aW9uIGRhdGEgdXBmcm9udCcpO1xuICAgICAgICAgICAgICAgIGhsc18xLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBlcnJvcnNfMS5FcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBudWxsLCBmYXRhbDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuYXVkaW9Td2l0Y2gpIHtcbiAgICAgICAgICAgICAgICBbZGF0YS5kYXRhMSwgZGF0YS5kYXRhMl0uZm9yRWFjaChmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0RhdGFfMS5wdXNoKHsgdHlwZTogZGF0YS50eXBlLCBkYXRhOiBidWZmZXIsIHBhcmVudDogJ2F1ZGlvJywgY29udGVudDogJ2RhdGEnIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFhcHBlbmRPbkJ1ZmZlckZsdXNoICYmIHBlbmRpbmdEYXRhXzEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdEYXRhXzEuZm9yRWFjaChmdW5jdGlvbiAoYXBwZW5kT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGFwcGVuZCBpbiBQQVJTSU5HIHN0YXRlIChyYXRpb25hbGUgaXMgdGhhdCBhbiBhcHBlbmRpbmcgZXJyb3IgY291bGQgaGFwcGVuIHN5bmNocm9ub3VzbHkgb24gZmlyc3Qgc2VnbWVudCBhcHBlbmRpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UgaXQgaXMgdXNlbGVzcyB0byBhcHBlbmQgZm9sbG93aW5nIHNlZ21lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUgPT09IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5QQVJTSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJtIHBlbmRpbmcgQnVmZmVyaW5nIGZsYWcgYmVmb3JlIGFwcGVuZGluZyBhIHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkJVRkZFUl9BUFBFTkRJTkcsIGFwcGVuZE9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdEYXRhID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICAgICAgICAgIHRoaXMudGljaygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBdWRpb1N0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uRnJhZ1BhcnNlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAgIHZhciBmcmFnTmV3ID0gZGF0YS5mcmFnO1xuICAgICAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgICAgIGRhdGEuaWQgPT09ICdhdWRpbycgJiZcbiAgICAgICAgICAgIGZyYWdOZXcuc24gPT09IGZyYWdDdXJyZW50LnNuICYmXG4gICAgICAgICAgICBmcmFnTmV3LmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLlBBUlNJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHMudHBhcnNlZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5QQVJTRUQ7XG4gICAgICAgICAgICB0aGlzLl9jaGVja0FwcGVuZGVkUGFyc2VkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF1ZGlvU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25CdWZmZXJSZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gcmVzZXQgcmVmZXJlbmNlIHRvIHNvdXJjZWJ1ZmZlcnNcbiAgICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMudmlkZW9CdWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgfTtcbiAgICBBdWRpb1N0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uQnVmZmVyQ3JlYXRlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBhdWRpb1RyYWNrID0gZGF0YS50cmFja3MuYXVkaW87XG4gICAgICAgIGlmIChhdWRpb1RyYWNrKSB7XG4gICAgICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID0gYXVkaW9UcmFjay5idWZmZXI7XG4gICAgICAgICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS50cmFja3MudmlkZW8pIHtcbiAgICAgICAgICAgIHRoaXMudmlkZW9CdWZmZXIgPSBkYXRhLnRyYWNrcy52aWRlby5idWZmZXI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF1ZGlvU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25CdWZmZXJBcHBlbmRlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLnBhcmVudCA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLlBBUlNJTkcgfHwgc3RhdGUgPT09IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5QQVJTRUQpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBhbGwgYnVmZmVycyBoYXZlIGJlZW4gYXBwZW5kZWRcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSAoZGF0YS5wZW5kaW5nID4gMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tBcHBlbmRlZFBhcnNlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBBdWRpb1N0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLl9jaGVja0FwcGVuZGVkUGFyc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuUEFSU0VEICYmICghdGhpcy5hcHBlbmRlZCB8fCAhdGhpcy5wZW5kaW5nQnVmZmVyaW5nKSkge1xuICAgICAgICAgICAgdmFyIGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50LCBzdGF0cyA9IHRoaXMuc3RhdHMsIGhsc18yID0gdGhpcy5obHM7XG4gICAgICAgICAgICBpZiAoZnJhZykge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICAgICAgICAgICAgICBzdGF0cy50YnVmZmVyZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgICAgICBobHNfMi50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRlJBR19CVUZGRVJFRCwgeyBzdGF0czogc3RhdHMsIGZyYWc6IGZyYWcsIGlkOiAnYXVkaW8nIH0pO1xuICAgICAgICAgICAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYTtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiYXVkaW8gYnVmZmVyZWQgOiBcIiArIHRpbWVfcmFuZ2VzXzEuZGVmYXVsdC50b1N0cmluZyhtZWRpYS5idWZmZXJlZCkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF1ZGlvU3dpdGNoICYmIHRoaXMuYXBwZW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdWRpb1N3aXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBobHNfMi50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuQVVESU9fVFJBQ0tfU1dJVENIRUQsIHsgaWQ6IHRoaXMudHJhY2tJZCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5JRExFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF1ZGlvU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnO1xuICAgICAgICAvLyBkb24ndCBoYW5kbGUgZnJhZyBlcnJvciBub3QgcmVsYXRlZCB0byBhdWRpbyBmcmFnbWVudFxuICAgICAgICBpZiAoZnJhZyAmJiBmcmFnLnR5cGUgIT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgICAgICAgICAgY2FzZSBlcnJvcnNfMS5FcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgICAgICAgY2FzZSBlcnJvcnNfMS5FcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICAgICAgICAgICAgdmFyIGZyYWdfMSA9IGRhdGEuZnJhZztcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBoYW5kbGUgZnJhZyBlcnJvciBub3QgcmVsYXRlZCB0byBhdWRpbyBmcmFnbWVudFxuICAgICAgICAgICAgICAgIGlmIChmcmFnXzEgJiYgZnJhZ18xLnR5cGUgIT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZGF0YS5mYXRhbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9hZEVycm9yID0gdGhpcy5mcmFnTG9hZEVycm9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9hZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkRXJyb3IrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRFcnJvciA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9hZEVycm9yIDw9IGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSBsb2FkRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBleHBvbmVudGlhbCBiYWNrb2ZmIGNhcHBlZCB0byBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWxheSA9IE1hdGgubWluKE1hdGgucG93KDIsIGxvYWRFcnJvciAtIDEpICogY29uZmlnLmZyYWdMb2FkaW5nUmV0cnlEZWxheSwgY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKFwiQXVkaW9TdHJlYW1Db250cm9sbGVyOiBmcmFnIGxvYWRpbmcgZmFpbGVkLCByZXRyeSBpbiBcIiArIGRlbGF5ICsgXCIgbXNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJldHJ5RGF0ZSA9IHBlcmZvcm1hbmNlLm5vdygpICsgZGVsYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXRyeSBsb2FkaW5nIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmVycm9yKFwiQXVkaW9TdHJlYW1Db250cm9sbGVyOiBcIiArIGRhdGEuZGV0YWlscyArIFwiIHJlYWNoZXMgbWF4IHJldHJ5LCByZWRpc3BhdGNoIGFzIGZhdGFsIC4uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN3aXRjaCBlcnJvciB0byBmYXRhbFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5mYXRhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLkVSUk9SO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBlcnJvcnNfMS5FcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9FUlJPUjpcbiAgICAgICAgICAgIGNhc2UgZXJyb3JzXzEuRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfVElNRU9VVDpcbiAgICAgICAgICAgIGNhc2UgZXJyb3JzXzEuRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgICAgICAgICAgY2FzZSBlcnJvcnNfMS5FcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICAgICAgICAgICAgICAvLyAgd2hlbiBpbiBFUlJPUiBzdGF0ZSwgZG9uJ3Qgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZSBpbiBjYXNlIGEgbm9uLWZhdGFsIGVycm9yIGlzIHJlY2VpdmVkXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5FUlJPUikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBmYXRhbCBlcnJvciwgc3RvcCBwcm9jZXNzaW5nLCBvdGhlcndpc2UgbW92ZSB0byBJRExFIHRvIHJldHJ5IGxvYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGRhdGEuZmF0YWwgPyBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuRVJST1IgOiBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuSURMRTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oXCJBdWRpb1N0cmVhbUNvbnRyb2xsZXI6IFwiICsgZGF0YS5kZXRhaWxzICsgXCIgd2hpbGUgbG9hZGluZyBmcmFnLCBub3cgc3dpdGNoaW5nIHRvIFwiICsgdGhpcy5zdGF0ZSArIFwiIHN0YXRlIC4uLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGVycm9yc18xLkVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjpcbiAgICAgICAgICAgICAgICAvLyBpZiBpbiBhcHBlbmRpbmcgc3RhdGVcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5wYXJlbnQgPT09ICdhdWRpbycgJiYgKHRoaXMuc3RhdGUgPT09IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5QQVJTSU5HIHx8IHRoaXMuc3RhdGUgPT09IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5QQVJTRUQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIsIGN1cnJlbnRUaW1lID0gdGhpcy5tZWRpYS5jdXJyZW50VGltZSwgbWVkaWFCdWZmZXJlZCA9IG1lZGlhICYmIGJ1ZmZlcl9oZWxwZXJfMS5CdWZmZXJIZWxwZXIuaXNCdWZmZXJlZChtZWRpYSwgY3VycmVudFRpbWUpICYmIGJ1ZmZlcl9oZWxwZXJfMS5CdWZmZXJIZWxwZXIuaXNCdWZmZXJlZChtZWRpYSwgY3VycmVudFRpbWUgKyAwLjUpO1xuICAgICAgICAgICAgICAgICAgICAvLyByZWR1Y2UgbWF4IGJ1ZiBsZW4gaWYgY3VycmVudCBwb3NpdGlvbiBpcyBidWZmZXJlZFxuICAgICAgICAgICAgICAgICAgICBpZiAobWVkaWFCdWZmZXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggPj0gY29uZmlnLm1heEJ1ZmZlckxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCBhcyBpdCBtaWdodCBiZSB0b28gaGlnaC4gd2UgZG8gdGhpcyB0byBhdm9pZCBsb29wIGZsdXNoaW5nIC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggLz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybihcIkF1ZGlvU3RyZWFtQ29udHJvbGxlcjogcmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIHRvIFwiICsgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCArIFwic1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuSURMRTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgcG9zaXRpb24gaXMgbm90IGJ1ZmZlcmVkLCBidXQgYnJvd3NlciBpcyBzdGlsbCBjb21wbGFpbmluZyBhYm91dCBidWZmZXIgZnVsbCBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBoYXBwZW5zIG9uIElFL0VkZ2UsIHJlZmVyIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL3B1bGwvNzA4XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UgZmx1c2ggdGhlIHdob2xlIGF1ZGlvIGJ1ZmZlciB0byByZWNvdmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybignQXVkaW9TdHJlYW1Db250cm9sbGVyOiBidWZmZXIgZnVsbCBlcnJvciBhbHNvIG1lZGlhLmN1cnJlbnRUaW1lIGlzIG5vdCBidWZmZXJlZCwgZmx1c2ggYXVkaW8gYnVmZmVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZsdXNoIGV2ZXJ5dGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuQlVGRkVSX0ZMVVNISU5HO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkJVRkZFUl9GTFVTSElORywgeyBzdGFydE9mZnNldDogMCwgZW5kT2Zmc2V0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIHR5cGU6ICdhdWRpbycgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBdWRpb1N0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uQnVmZmVyRmx1c2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHBlbmRpbmdEYXRhID0gdGhpcy5wZW5kaW5nRGF0YTtcbiAgICAgICAgaWYgKHBlbmRpbmdEYXRhICYmIHBlbmRpbmdEYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnQXVkaW9TdHJlYW1Db250cm9sbGVyOiBhcHBlbmRpbmcgcGVuZGluZyBhdWRpbyBkYXRhIGFmdGVyIGJ1ZmZlciBmbHVzaGVkJyk7XG4gICAgICAgICAgICBwZW5kaW5nRGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChhcHBlbmRPYmopIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkJVRkZFUl9BUFBFTkRJTkcsIGFwcGVuZE9iaik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nRGF0YSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5QQVJTRUQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBtb3ZlIHRvIElETEUgb25jZSBmbHVzaCBjb21wbGV0ZS4gdGhpcyBzaG91bGQgdHJpZ2dlciBuZXcgZnJhZ21lbnQgbG9hZGluZ1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5JRExFO1xuICAgICAgICAgICAgLy8gcmVzZXQgcmVmZXJlbmNlIHRvIGZyYWdcbiAgICAgICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMudGljaygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQXVkaW9TdHJlYW1Db250cm9sbGVyO1xufShiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQXVkaW9TdHJlYW1Db250cm9sbGVyO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIuanNcIilbXCJOdW1iZXJcIl0pKVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2F1ZGlvLXRyYWNrLWNvbnRyb2xsZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvYXVkaW8tdHJhY2stY29udHJvbGxlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLmpzXCIpO1xudmFyIHRhc2tfbG9vcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdGFzay1sb29wICovIFwiLi9zcmMvdGFzay1sb29wLmpzXCIpO1xudmFyIGxvZ2dlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLmpzXCIpO1xudmFyIGVycm9yc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLmpzXCIpO1xuLyoqXG4gKiBAY2xhc3MgQXVkaW9UcmFja0NvbnRyb2xsZXJcbiAqIEBpbXBsZW1lbnRzIHtFdmVudEhhbmRsZXJ9XG4gKlxuICogSGFuZGxlcyBtYWluIG1hbmlmZXN0IGFuZCBhdWRpby10cmFjayBtZXRhZGF0YSBsb2FkZWQsXG4gKiBvd25zIGFuZCBleHBvc2VzIHRoZSBzZWxlY3RhYmxlIGF1ZGlvLXRyYWNrcyBkYXRhLW1vZGVscy5cbiAqXG4gKiBFeHBvc2VzIGludGVybmFsIGludGVyZmFjZSB0byBzZWxlY3QgYXZhaWxhYmxlIGF1ZGlvLXRyYWNrcy5cbiAqXG4gKiBIYW5kbGVzIGVycm9ycyBvbiBsb2FkaW5nIGF1ZGlvLXRyYWNrIHBsYXlsaXN0cy4gTWFuYWdlcyBmYWxsYmFjayBtZWNoYW5pc21cbiAqIHdpdGggcmVkdW5kYW50cyB0cmFja3MgKGdyb3VwLUlEcykuXG4gKlxuICogSGFuZGxlcyBsZXZlbC1sb2FkaW5nIGFuZCBncm91cC1JRCBzd2l0Y2hlcyBmb3IgdmlkZW8gKGZhbGxiYWNrIG9uIHZpZGVvIGxldmVscyksXG4gKiBhbmQgZXZlbnR1YWxseSBhZGFwdHMgdGhlIGF1ZGlvLXRyYWNrIGdyb3VwLUlEIHRvIG1hdGNoLlxuICpcbiAqIEBmaXJlcyBBVURJT19UUkFDS19MT0FESU5HXG4gKiBAZmlyZXMgQVVESU9fVFJBQ0tfU1dJVENISU5HXG4gKiBAZmlyZXMgQVVESU9fVFJBQ0tTX1VQREFURURcbiAqIEBmaXJlcyBFUlJPUlxuICpcbiAqL1xudmFyIEF1ZGlvVHJhY2tDb250cm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBdWRpb1RyYWNrQ29udHJvbGxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBdWRpb1RyYWNrQ29udHJvbGxlcihobHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaGxzLCBldmVudHNfMS5kZWZhdWx0Lk1BTklGRVNUX0xPQURJTkcsIGV2ZW50c18xLmRlZmF1bHQuTUFOSUZFU1RfUEFSU0VELCBldmVudHNfMS5kZWZhdWx0LkFVRElPX1RSQUNLX0xPQURFRCwgZXZlbnRzXzEuZGVmYXVsdC5BVURJT19UUkFDS19TV0lUQ0hFRCwgZXZlbnRzXzEuZGVmYXVsdC5MRVZFTF9MT0FERUQsIGV2ZW50c18xLmRlZmF1bHQuRVJST1IpIHx8IHRoaXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBDdXJyZW50bHkgc2VsZWN0ZWQgaW5kZXggaW4gYHRyYWNrc2BcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSB0cmFja0lkXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fdHJhY2tJZCA9IC0xO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogSWYgc2hvdWxkIHNlbGVjdCB0cmFja3MgYWNjb3JkaW5nIHRvIGRlZmF1bHQgdHJhY2sgYXR0cmlidXRlXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IF9zZWxlY3REZWZhdWx0VHJhY2tcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9zZWxlY3REZWZhdWx0VHJhY2sgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBBbGwgdHJhY2tzIGF2YWlsYWJsZVxuICAgICAgICAgKiBAbWVtYmVyIHtBdWRpb1RyYWNrW119XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy50cmFja3MgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogTGlzdCBvZiBibGFja2xpc3RlZCBhdWRpbyB0cmFjayBJRHMgKHRoYXQgaGF2ZSBjYXVzZWQgZmFpbHVyZSlcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyW119XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy50cmFja0lkQmxhY2tsaXN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogVGhlIGN1cnJlbnRseSBydW5uaW5nIGdyb3VwIElEIGZvciBhdWRpb1xuICAgICAgICAgKiAod2UgZ3JhYiB0aGlzIG9uIG1hbmlmZXN0LXBhcnNlZCBhbmQgbmV3IGxldmVsLWxvYWRlZClcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuYXVkaW9Hcm91cElkID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldCBhdWRpbyB0cmFja3Mgb24gbmV3IG1hbmlmZXN0IGxvYWRpbmcuXG4gICAgICovXG4gICAgQXVkaW9UcmFja0NvbnRyb2xsZXIucHJvdG90eXBlLm9uTWFuaWZlc3RMb2FkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLl90cmFja0lkID0gLTE7XG4gICAgICAgIHRoaXMuX3NlbGVjdERlZmF1bHRUcmFjayA9IHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdG9yZSB0cmFja3MgZGF0YSBmcm9tIG1hbmlmZXN0IHBhcnNlZCBkYXRhLlxuICAgICAqXG4gICAgICogVHJpZ2dlciBBVURJT19UUkFDS1NfVVBEQVRFRCBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YVxuICAgICAqL1xuICAgIEF1ZGlvVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZS5vbk1hbmlmZXN0UGFyc2VkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHRyYWNrcyA9IHRoaXMudHJhY2tzID0gZGF0YS5hdWRpb1RyYWNrcyB8fCBbXTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkFVRElPX1RSQUNLU19VUERBVEVELCB7IGF1ZGlvVHJhY2tzOiB0cmFja3MgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdG9yZSB0cmFjayBkZXRhaWxzIG9mIGxvYWRlZCB0cmFjayBpbiBvdXIgZGF0YS1tb2RlbC5cbiAgICAgKlxuICAgICAqIFNldC11cCBtZXRhZGF0YSB1cGRhdGUgaW50ZXJ2YWwgdGFzayBmb3IgbGl2ZS1tb2RlIHN0cmVhbXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge30gZGF0YVxuICAgICAqL1xuICAgIEF1ZGlvVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZS5vbkF1ZGlvVHJhY2tMb2FkZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5pZCA+PSB0aGlzLnRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKCdJbnZhbGlkIGF1ZGlvIHRyYWNrIGlkOicsIGRhdGEuaWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJhdWRpb1RyYWNrIFwiICsgZGF0YS5pZCArIFwiIGxvYWRlZFwiKTtcbiAgICAgICAgdGhpcy50cmFja3NbZGF0YS5pZF0uZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICAgICAgLy8gY2hlY2sgaWYgY3VycmVudCBwbGF5bGlzdCBpcyBhIGxpdmUgcGxheWxpc3RcbiAgICAgICAgLy8gYW5kIGlmIHdlIGhhdmUgYWxyZWFkeSBvdXIgcmVsb2FkIGludGVydmFsIHNldHVwXG4gICAgICAgIGlmIChkYXRhLmRldGFpbHMubGl2ZSAmJiAhdGhpcy5oYXNJbnRlcnZhbCgpKSB7XG4gICAgICAgICAgICAvLyBpZiBsaXZlIHBsYXlsaXN0IHdlIHdpbGwgaGF2ZSB0byByZWxvYWQgaXQgcGVyaW9kaWNhbGx5XG4gICAgICAgICAgICAvLyBzZXQgcmVsb2FkIHBlcmlvZCB0byBwbGF5bGlzdCB0YXJnZXQgZHVyYXRpb25cbiAgICAgICAgICAgIHZhciB1cGRhdGVQZXJpb2RNcyA9IGRhdGEuZGV0YWlscy50YXJnZXRkdXJhdGlvbiAqIDEwMDA7XG4gICAgICAgICAgICB0aGlzLnNldEludGVydmFsKHVwZGF0ZVBlcmlvZE1zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGEuZGV0YWlscy5saXZlICYmIHRoaXMuaGFzSW50ZXJ2YWwoKSkge1xuICAgICAgICAgICAgLy8gcGxheWxpc3QgaXMgbm90IGxpdmUgYW5kIHRpbWVyIGlzIHNjaGVkdWxlZDogY2FuY2VsIGl0XG4gICAgICAgICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBpbnRlcm5hbCBncm91cCBJRCB0byBhbnkgYXVkaW8tdHJhY2sgd2UgbWF5IGhhdmUgc2V0IG1hbnVhbGx5XG4gICAgICogb3IgYmVjYXVzZSBvZiBhIGZhaWx1cmUtaGFuZGxpbmcgZmFsbGJhY2suXG4gICAgICpcbiAgICAgKiBRdWFsaXR5LWxldmVscyBzaG91bGQgdXBkYXRlIHRvIHRoYXQgZ3JvdXAgSUQgaW4gdGhpcyBjYXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBkYXRhXG4gICAgICovXG4gICAgQXVkaW9UcmFja0NvbnRyb2xsZXIucHJvdG90eXBlLm9uQXVkaW9UcmFja1N3aXRjaGVkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGF1ZGlvR3JvdXBJZCA9IHRoaXMudHJhY2tzW2RhdGEuaWRdLmdyb3VwSWQ7XG4gICAgICAgIGlmIChhdWRpb0dyb3VwSWQgJiYgKHRoaXMuYXVkaW9Hcm91cElkICE9PSBhdWRpb0dyb3VwSWQpKSB7XG4gICAgICAgICAgICB0aGlzLmF1ZGlvR3JvdXBJZCA9IGF1ZGlvR3JvdXBJZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hlbiBhIGxldmVsIGdldHMgbG9hZGVkLCBpZiBpdCBoYXMgcmVkdW5kYW50IGF1ZGlvR3JvdXBJZHMgKGluIHRoZSBzYW1lIG9yZGluYWxpdHkgYXMgaXQncyByZWR1bmRhbnQgVVJMcylcbiAgICAgKiB3ZSBhcmUgc2V0dGluZyBvdXIgYXVkaW8tZ3JvdXAgSUQgaW50ZXJuYWxseSB0byB0aGUgb25lIHNldCwgaWYgaXQgaXMgZGlmZmVyZW50IGZyb20gdGhlIGdyb3VwIElEIGN1cnJlbnRseSBzZXQuXG4gICAgICpcbiAgICAgKiBJZiBncm91cC1JRCBnb3QgdXBkYXRlLCB3ZSByZS1zZWxlY3QgdGhlIGFwcHJvcHJpYXRlIGF1ZGlvLXRyYWNrIHdpdGggdGhpcyBncm91cC1JRCBtYXRjaGluZyB0aGUgY3VycmVudGx5XG4gICAgICogc2VsZWN0ZWQgb25lIChiYXNlZCBvbiBOQU1FIHByb3BlcnR5KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YVxuICAgICAqL1xuICAgIEF1ZGlvVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZS5vbkxldmVsTG9hZGVkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgLy8gRklYTUU6IGNyYXNoZXMgYmVjYXVzZSBjdXJyZW50TGV2ZWwgaXMgdW5kZWZpbmVkXG4gICAgICAgIC8vIGNvbnN0IGxldmVsSW5mbyA9IHRoaXMuaGxzLmxldmVsc1t0aGlzLmhscy5jdXJyZW50TGV2ZWxdO1xuICAgICAgICB2YXIgbGV2ZWxJbmZvID0gdGhpcy5obHMubGV2ZWxzW2RhdGEubGV2ZWxdO1xuICAgICAgICBpZiAoIWxldmVsSW5mby5hdWRpb0dyb3VwSWRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF1ZGlvR3JvdXBJZCA9IGxldmVsSW5mby5hdWRpb0dyb3VwSWRzW2xldmVsSW5mby51cmxJZF07XG4gICAgICAgIGlmICh0aGlzLmF1ZGlvR3JvdXBJZCAhPT0gYXVkaW9Hcm91cElkKSB7XG4gICAgICAgICAgICB0aGlzLmF1ZGlvR3JvdXBJZCA9IGF1ZGlvR3JvdXBJZDtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdEluaXRpYWxBdWRpb1RyYWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBuZXR3b3JrIGVycm9ycyBsb2FkaW5nIGF1ZGlvIHRyYWNrIG1hbmlmZXN0c1xuICAgICAqIGFuZCBhbHNvIHBhdXNpbmcgb24gYW55IG5ldHdvayBlcnJvcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Vycm9yRXZlbnREYXRhfSBkYXRhXG4gICAgICovXG4gICAgQXVkaW9UcmFja0NvbnRyb2xsZXIucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAvLyBPbmx5IGhhbmRsZSBuZXR3b3JrIGVycm9yc1xuICAgICAgICBpZiAoZGF0YS50eXBlICE9PSBlcnJvcnNfMS5FcnJvclR5cGVzLk5FVFdPUktfRVJST1IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBmYXRhbCBuZXR3b3JrIGVycm9yLCBjYW5jZWwgdXBkYXRlIHRhc2tcbiAgICAgICAgaWYgKGRhdGEuZmF0YWwpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vdCBhbiBhdWRpby10cmFjayBsb2FkaW5nIGVycm9yIGRvbid0IGhhbmRsZSBmdXJ0aGVyXG4gICAgICAgIGlmIChkYXRhLmRldGFpbHMgIT09IGVycm9yc18xLkVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oJ05ldHdvcmsgZmFpbHVyZSBvbiBhdWRpby10cmFjayBpZDonLCBkYXRhLmNvbnRleHQuaWQpO1xuICAgICAgICB0aGlzLl9oYW5kbGVMb2FkRXJyb3IoKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBdWRpb1RyYWNrQ29udHJvbGxlci5wcm90b3R5cGUsIFwiYXVkaW9UcmFja3NcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0F1ZGlvVHJhY2tbXX0gQXVkaW8tdHJhY2sgbGlzdCB3ZSBvd25cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXVkaW9UcmFja0NvbnRyb2xsZXIucHJvdG90eXBlLCBcImF1ZGlvVHJhY2tcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn0gSW5kZXggaW50byBhdWRpby10cmFja3MgbGlzdCBvZiBjdXJyZW50bHkgc2VsZWN0ZWQgdHJhY2suXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFja0lkO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2VsZWN0IGN1cnJlbnQgdHJhY2sgYnkgaW5kZXhcbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0lkKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRBdWRpb1RyYWNrKG5ld0lkKTtcbiAgICAgICAgICAgIC8vIElmIGF1ZGlvIHRyYWNrIGlzIHNlbGVjdGVkIGZyb20gQVBJIHRoZW4gZG9uJ3QgY2hvb3NlIGZyb20gdGhlIG1hbmlmZXN0IGRlZmF1bHQgdHJhY2tcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdERlZmF1bHRUcmFjayA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdJZFxuICAgICAqL1xuICAgIEF1ZGlvVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZS5fc2V0QXVkaW9UcmFjayA9IGZ1bmN0aW9uIChuZXdJZCkge1xuICAgICAgICAvLyBub29wIG9uIHNhbWUgYXVkaW8gdHJhY2sgaWQgYXMgYWxyZWFkeSBzZXRcbiAgICAgICAgaWYgKHRoaXMuX3RyYWNrSWQgPT09IG5ld0lkICYmIHRoaXMudHJhY2tzW3RoaXMuX3RyYWNrSWRdLmRldGFpbHMpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5kZWJ1ZygnU2FtZSBpZCBhcyBjdXJyZW50IGF1ZGlvLXRyYWNrIHBhc3NlZCwgYW5kIHRyYWNrIGRldGFpbHMgYXZhaWxhYmxlIC0+IG5vLW9wJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgaWYgbGV2ZWwgaWR4IGlzIHZhbGlkXG4gICAgICAgIGlmIChuZXdJZCA8IDAgfHwgbmV3SWQgPj0gdGhpcy50cmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybignSW52YWxpZCBpZCBwYXNzZWQgdG8gYXVkaW8tdHJhY2sgY29udHJvbGxlcicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdWRpb1RyYWNrID0gdGhpcy50cmFja3NbbmV3SWRdO1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiTm93IHN3aXRjaGluZyB0byBhdWRpby10cmFjayBpbmRleCBcIiArIG5ld0lkKTtcbiAgICAgICAgLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XG4gICAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICAgICAgICB0aGlzLl90cmFja0lkID0gbmV3SWQ7XG4gICAgICAgIHZhciB1cmwgPSBhdWRpb1RyYWNrLnVybCwgdHlwZSA9IGF1ZGlvVHJhY2sudHlwZSwgaWQgPSBhdWRpb1RyYWNrLmlkO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuQVVESU9fVFJBQ0tfU1dJVENISU5HLCB7IGlkOiBpZCwgdHlwZTogdHlwZSwgdXJsOiB1cmwgfSk7XG4gICAgICAgIHRoaXMuX2xvYWRUcmFja0RldGFpbHNJZk5lZWRlZChhdWRpb1RyYWNrKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIEF1ZGlvVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZS5kb1RpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVRyYWNrKHRoaXMuX3RyYWNrSWQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VsZWN0IGluaXRpYWwgdHJhY2tcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEF1ZGlvVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZS5fc2VsZWN0SW5pdGlhbEF1ZGlvVHJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0cmFja3MgPSB0aGlzLnRyYWNrcztcbiAgICAgICAgaWYgKCF0cmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnRBdWRpb1RyYWNrID0gdGhpcy50cmFja3NbdGhpcy5fdHJhY2tJZF07XG4gICAgICAgIHZhciBuYW1lID0gbnVsbDtcbiAgICAgICAgaWYgKGN1cnJlbnRBdWRpb1RyYWNrKSB7XG4gICAgICAgICAgICBuYW1lID0gY3VycmVudEF1ZGlvVHJhY2submFtZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmUtc2VsZWN0IGRlZmF1bHQgdHJhY2tzIGlmIHRoZXJlIGFyZSBhbnlcbiAgICAgICAgaWYgKHRoaXMuX3NlbGVjdERlZmF1bHRUcmFjaykge1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRUcmFja3MgPSB0cmFja3MuZmlsdGVyKGZ1bmN0aW9uICh0cmFjaykgeyByZXR1cm4gdHJhY2suZGVmYXVsdDsgfSk7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdFRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0cmFja3MgPSBkZWZhdWx0VHJhY2tzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oJ05vIGRlZmF1bHQgYXVkaW8gdHJhY2tzIGRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdHJhY2tGb3VuZCA9IGZhbHNlO1xuICAgICAgICB2YXIgdHJhdmVyc2VUcmFja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBTZWxlY3QgdHJhY2sgd2l0aCByaWdodCBncm91cCBJRFxuICAgICAgICAgICAgdHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIG1hdGNoIHRoZSAocHJlLSlzZWxlY3RlZCBncm91cCBJRFxuICAgICAgICAgICAgICAgIC8vIGFuZCB0aGUgTkFNRSBvZiB0aGUgY3VycmVudCB0cmFjay5cbiAgICAgICAgICAgICAgICBpZiAoKCFfdGhpcy5hdWRpb0dyb3VwSWQgfHwgdHJhY2suZ3JvdXBJZCA9PT0gX3RoaXMuYXVkaW9Hcm91cElkKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIW5hbWUgfHwgbmFtZSA9PT0gdHJhY2submFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgcHJldmlvdXMgdHJhY2sgdHJ5IHRvIHN0YXkgd2l0aCB0aGUgc2FtZSBgTkFNRWAuXG4gICAgICAgICAgICAgICAgICAgIC8vIEl0IHNob3VsZCBiZSB1bmlxdWUgYWNyb3NzIHRyYWNrcyBvZiBzYW1lIGdyb3VwLCBhbmQgY29uc2lzdGVudCB0aHJvdWdoIHJlZHVuZGFudCB0cmFjayBncm91cHMuXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXRBdWRpb1RyYWNrKHRyYWNrLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRyYXZlcnNlVHJhY2tzKCk7XG4gICAgICAgIGlmICghdHJhY2tGb3VuZCkge1xuICAgICAgICAgICAgbmFtZSA9IG51bGw7XG4gICAgICAgICAgICB0cmF2ZXJzZVRyYWNrcygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdHJhY2tGb3VuZCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmVycm9yKFwiTm8gdHJhY2sgZm91bmQgZm9yIHJ1bm5pbmcgYXVkaW8gZ3JvdXAtSUQ6IFwiICsgdGhpcy5hdWRpb0dyb3VwSWQpO1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkVSUk9SLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogZXJyb3JzXzEuRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBlcnJvcnNfMS5FcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9FUlJPUixcbiAgICAgICAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBdWRpb1RyYWNrfSBhdWRpb1RyYWNrXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgQXVkaW9UcmFja0NvbnRyb2xsZXIucHJvdG90eXBlLl9uZWVkc1RyYWNrTG9hZGluZyA9IGZ1bmN0aW9uIChhdWRpb1RyYWNrKSB7XG4gICAgICAgIHZhciBkZXRhaWxzID0gYXVkaW9UcmFjay5kZXRhaWxzLCB1cmwgPSBhdWRpb1RyYWNrLnVybDtcbiAgICAgICAgaWYgKCFkZXRhaWxzIHx8IGRldGFpbHMubGl2ZSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgZmFjZSBhbiBhdWRpbyB0cmFjayBlbWJlZGRlZCBpbiBtYWluIHBsYXlsaXN0IChhdWRpbyB0cmFjayB3aXRob3V0IFVSSSBhdHRyaWJ1dGUpXG4gICAgICAgICAgICByZXR1cm4gISF1cmw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0F1ZGlvVHJhY2t9IGF1ZGlvVHJhY2tcbiAgICAgKi9cbiAgICBBdWRpb1RyYWNrQ29udHJvbGxlci5wcm90b3R5cGUuX2xvYWRUcmFja0RldGFpbHNJZk5lZWRlZCA9IGZ1bmN0aW9uIChhdWRpb1RyYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLl9uZWVkc1RyYWNrTG9hZGluZyhhdWRpb1RyYWNrKSkge1xuICAgICAgICAgICAgdmFyIHVybCA9IGF1ZGlvVHJhY2sudXJsLCBpZCA9IGF1ZGlvVHJhY2suaWQ7XG4gICAgICAgICAgICAvLyB0cmFjayBub3QgcmV0cmlldmVkIHlldCwgb3IgbGl2ZSBwbGF5bGlzdCB3ZSBuZWVkIHRvIChyZSlsb2FkIGl0XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwibG9hZGluZyBhdWRpby10cmFjayBwbGF5bGlzdCBmb3IgaWQ6IFwiICsgaWQpO1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkFVRElPX1RSQUNLX0xPQURJTkcsIHsgdXJsOiB1cmwsIGlkOiBpZCB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3SWRcbiAgICAgKi9cbiAgICBBdWRpb1RyYWNrQ29udHJvbGxlci5wcm90b3R5cGUuX3VwZGF0ZVRyYWNrID0gZnVuY3Rpb24gKG5ld0lkKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIGxldmVsIGlkeCBpcyB2YWxpZFxuICAgICAgICBpZiAobmV3SWQgPCAwIHx8IG5ld0lkID49IHRoaXMudHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuICAgICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICAgICAgdGhpcy5fdHJhY2tJZCA9IG5ld0lkO1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwidHJ5aW5nIHRvIHVwZGF0ZSBhdWRpby10cmFjayBcIiArIG5ld0lkKTtcbiAgICAgICAgdmFyIGF1ZGlvVHJhY2sgPSB0aGlzLnRyYWNrc1tuZXdJZF07XG4gICAgICAgIHRoaXMuX2xvYWRUcmFja0RldGFpbHNJZk5lZWRlZChhdWRpb1RyYWNrKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQXVkaW9UcmFja0NvbnRyb2xsZXIucHJvdG90eXBlLl9oYW5kbGVMb2FkRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEZpcnN0LCBsZXQncyBibGFjayBsaXN0IGN1cnJlbnQgdHJhY2sgaWRcbiAgICAgICAgdGhpcy50cmFja0lkQmxhY2tsaXN0W3RoaXMuX3RyYWNrSWRdID0gdHJ1ZTtcbiAgICAgICAgLy8gTGV0J3MgdHJ5IHRvIGZhbGwgYmFjayBvbiBhIGZ1bmN0aW9uYWwgYXVkaW8tdHJhY2sgd2l0aCB0aGUgc2FtZSBncm91cCBJRFxuICAgICAgICB2YXIgcHJldmlvdXNJZCA9IHRoaXMuX3RyYWNrSWQ7XG4gICAgICAgIHZhciBfYSA9IHRoaXMudHJhY2tzW3ByZXZpb3VzSWRdLCBuYW1lID0gX2EubmFtZSwgbGFuZ3VhZ2UgPSBfYS5sYW5ndWFnZSwgZ3JvdXBJZCA9IF9hLmdyb3VwSWQ7XG4gICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKFwiTG9hZGluZyBmYWlsZWQgb24gYXVkaW8gdHJhY2sgaWQ6IFwiICsgcHJldmlvdXNJZCArIFwiLCBncm91cC1pZDogXCIgKyBncm91cElkICsgXCIsIG5hbWUvbGFuZ3VhZ2U6IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgLyBcXFwiXCIgKyBsYW5ndWFnZSArIFwiXFxcIlwiKTtcbiAgICAgICAgLy8gRmluZCBhIG5vbi1ibGFja2xpc3RlZCB0cmFjayBJRCB3aXRoIHRoZSBzYW1lIE5BTUVcbiAgICAgICAgLy8gQXQgbGVhc3QgYSB0cmFjayB0aGF0IGlzIG5vdCBibGFja2xpc3RlZCwgdGh1cyBvbiBhbm90aGVyIGdyb3VwLUlELlxuICAgICAgICB2YXIgbmV3SWQgPSBwcmV2aW91c0lkO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50cmFja0lkQmxhY2tsaXN0W2ldKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV3VHJhY2sgPSB0aGlzLnRyYWNrc1tpXTtcbiAgICAgICAgICAgIGlmIChuZXdUcmFjay5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgbmV3SWQgPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdJZCA9PT0gcHJldmlvdXNJZCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oXCJObyBmYWxsYmFjayBhdWRpby10cmFjayBmb3VuZCBmb3IgbmFtZS9sYW5ndWFnZTogXFxcIlwiICsgbmFtZSArIFwiXFxcIiAvIFxcXCJcIiArIGxhbmd1YWdlICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ0F0dGVtcHRpbmcgYXVkaW8tdHJhY2sgZmFsbGJhY2sgaWQ6JywgbmV3SWQsICdncm91cC1pZDonLCB0aGlzLnRyYWNrc1tuZXdJZF0uZ3JvdXBJZCk7XG4gICAgICAgIHRoaXMuX3NldEF1ZGlvVHJhY2sobmV3SWQpO1xuICAgIH07XG4gICAgcmV0dXJuIEF1ZGlvVHJhY2tDb250cm9sbGVyO1xufSh0YXNrX2xvb3BfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBBdWRpb1RyYWNrQ29udHJvbGxlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2Jhc2Utc3RyZWFtLWNvbnRyb2xsZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvYmFzZS1zdHJlYW0tY29udHJvbGxlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oTnVtYmVyKSB7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0YXNrX2xvb3BfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3Rhc2stbG9vcCAqLyBcIi4vc3JjL3Rhc2stbG9vcC5qc1wiKTtcbnZhciBmcmFnbWVudF90cmFja2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZyYWdtZW50LXRyYWNrZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2ZyYWdtZW50LXRyYWNrZXIuanNcIik7XG52YXIgYnVmZmVyX2hlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvYnVmZmVyLWhlbHBlciAqLyBcIi4vc3JjL3V0aWxzL2J1ZmZlci1oZWxwZXIuanNcIik7XG52YXIgbG9nZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIuanNcIik7XG5leHBvcnRzLlN0YXRlID0ge1xuICAgIFNUT1BQRUQ6ICdTVE9QUEVEJyxcbiAgICBTVEFSVElORzogJ1NUQVJUSU5HJyxcbiAgICBJRExFOiAnSURMRScsXG4gICAgUEFVU0VEOiAnUEFVU0VEJyxcbiAgICBLRVlfTE9BRElORzogJ0tFWV9MT0FESU5HJyxcbiAgICBGUkFHX0xPQURJTkc6ICdGUkFHX0xPQURJTkcnLFxuICAgIEZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOiAnRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlknLFxuICAgIFdBSVRJTkdfVFJBQ0s6ICdXQUlUSU5HX1RSQUNLJyxcbiAgICBQQVJTSU5HOiAnUEFSU0lORycsXG4gICAgUEFSU0VEOiAnUEFSU0VEJyxcbiAgICBCVUZGRVJfRkxVU0hJTkc6ICdCVUZGRVJfRkxVU0hJTkcnLFxuICAgIEVOREVEOiAnRU5ERUQnLFxuICAgIEVSUk9SOiAnRVJST1InLFxuICAgIFdBSVRJTkdfSU5JVF9QVFM6ICdXQUlUSU5HX0lOSVRfUFRTJyxcbiAgICBXQUlUSU5HX0xFVkVMOiAnV0FJVElOR19MRVZFTCdcbn07XG52YXIgQmFzZVN0cmVhbUNvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJhc2VTdHJlYW1Db250cm9sbGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJhc2VTdHJlYW1Db250cm9sbGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEJhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5kb1RpY2sgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLl9zdHJlYW1FbmRlZCA9IGZ1bmN0aW9uIChidWZmZXJJbmZvLCBsZXZlbERldGFpbHMpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgZnJhZ0N1cnJlbnQgPSBfYS5mcmFnQ3VycmVudCwgZnJhZ21lbnRUcmFja2VyID0gX2EuZnJhZ21lbnRUcmFja2VyO1xuICAgICAgICAvLyB3ZSBqdXN0IGdvdCBkb25lIGxvYWRpbmcgdGhlIGZpbmFsIGZyYWdtZW50IGFuZCB0aGVyZSBpcyBubyBvdGhlciBidWZmZXJlZCByYW5nZSBhZnRlciAuLi5cbiAgICAgICAgLy8gcmF0aW9uYWxlIGlzIHRoYXQgaW4gY2FzZSB0aGVyZSBhcmUgYW55IGJ1ZmZlcmVkIHJhbmdlcyBhZnRlciwgaXQgbWVhbnMgdGhhdCB0aGVyZSBhcmUgdW5idWZmZXJlZCBwb3J0aW9uIGluIGJldHdlZW5cbiAgICAgICAgLy8gc28gd2Ugc2hvdWxkIG5vdCBzd2l0Y2ggdG8gRU5ERUQgaW4gdGhhdCBjYXNlLCB0byBiZSBhYmxlIHRvIGJ1ZmZlciB0aGVtXG4gICAgICAgIC8vIGRvbnQgc3dpdGNoIHRvIEVOREVEIGlmIHdlIG5lZWQgdG8gYmFja3RyYWNrIGxhc3QgZnJhZ21lbnRcbiAgICAgICAgaWYgKCFsZXZlbERldGFpbHMubGl2ZSAmJiBmcmFnQ3VycmVudCAmJiAhZnJhZ0N1cnJlbnQuYmFja3RyYWNrZWQgJiYgZnJhZ0N1cnJlbnQuc24gPT09IGxldmVsRGV0YWlscy5lbmRTTiAmJiAhYnVmZmVySW5mby5uZXh0U3RhcnQpIHtcbiAgICAgICAgICAgIHZhciBmcmFnU3RhdGUgPSBmcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZ0N1cnJlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZyYWdTdGF0ZSA9PT0gZnJhZ21lbnRfdHJhY2tlcl8xLkZyYWdtZW50U3RhdGUuUEFSVElBTCB8fCBmcmFnU3RhdGUgPT09IGZyYWdtZW50X3RyYWNrZXJfMS5GcmFnbWVudFN0YXRlLk9LO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEJhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbk1lZGlhU2Vla2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgY29uZmlnID0gX2EuY29uZmlnLCBtZWRpYSA9IF9hLm1lZGlhLCBtZWRpYUJ1ZmZlciA9IF9hLm1lZGlhQnVmZmVyLCBzdGF0ZSA9IF9hLnN0YXRlO1xuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBtZWRpYSA/IG1lZGlhLmN1cnJlbnRUaW1lIDogbnVsbDtcbiAgICAgICAgdmFyIGJ1ZmZlckluZm8gPSBidWZmZXJfaGVscGVyXzEuQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWFCdWZmZXIgfHwgbWVkaWEsIGN1cnJlbnRUaW1lLCB0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcbiAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShjdXJyZW50VGltZSkpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJtZWRpYSBzZWVraW5nIHRvIFwiICsgY3VycmVudFRpbWUudG9GaXhlZCgzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlID09PSBleHBvcnRzLlN0YXRlLkZSQUdfTE9BRElORykge1xuICAgICAgICAgICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGFyZSBzZWVraW5nIHRvIGEgdW5idWZmZXJlZCBhcmVhIEFORCBpZiBmcmFnIGxvYWRpbmcgaXMgaW4gcHJvZ3Jlc3NcbiAgICAgICAgICAgIGlmIChidWZmZXJJbmZvLmxlbiA9PT0gMCAmJiBmcmFnQ3VycmVudCkge1xuICAgICAgICAgICAgICAgIHZhciB0b2xlcmFuY2UgPSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTtcbiAgICAgICAgICAgICAgICB2YXIgZnJhZ1N0YXJ0T2Zmc2V0ID0gZnJhZ0N1cnJlbnQuc3RhcnQgLSB0b2xlcmFuY2U7XG4gICAgICAgICAgICAgICAgdmFyIGZyYWdFbmRPZmZzZXQgPSBmcmFnQ3VycmVudC5zdGFydCArIGZyYWdDdXJyZW50LmR1cmF0aW9uICsgdG9sZXJhbmNlO1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIHNlZWsgcG9zaXRpb24gd2lsbCBiZSBvdXQgb2YgY3VycmVudGx5IGxvYWRlZCBmcmFnIHJhbmdlIDogaWYgb3V0IGNhbmNlbCBmcmFnIGxvYWQsIGlmIGluLCBkb24ndCBkbyBhbnl0aGluZ1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VGltZSA8IGZyYWdTdGFydE9mZnNldCB8fCBjdXJyZW50VGltZSA+IGZyYWdFbmRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnc2Vla2luZyBvdXRzaWRlIG9mIGJ1ZmZlciB3aGlsZSBmcmFnbWVudCBsb2FkIGluIHByb2dyZXNzLCBjYW5jZWwgZnJhZ21lbnQgbG9hZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gbG9hZCBuZXcgZnJhZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGV4cG9ydHMuU3RhdGUuSURMRTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ3NlZWtpbmcgb3V0c2lkZSBvZiBidWZmZXIgYnV0IHdpdGhpbiBjdXJyZW50bHkgbG9hZGVkIGZyYWdtZW50IHJhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlID09PSBleHBvcnRzLlN0YXRlLkVOREVEKSB7XG4gICAgICAgICAgICAvLyBpZiBzZWVraW5nIHRvIHVuYnVmZmVyZWQgYXJlYSwgY2xlYW4gdXAgZnJhZ1ByZXZpb3VzXG4gICAgICAgICAgICBpZiAoYnVmZmVySW5mby5sZW4gPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byBjaGVjayBmb3IgcG90ZW50aWFsIG5ldyBmcmFnbWVudFxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGV4cG9ydHMuU3RhdGUuSURMRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW4gY2FzZSBzZWVraW5nIG9jY3VycyBhbHRob3VnaCBubyBtZWRpYSBidWZmZXJlZCwgYWRqdXN0IHN0YXJ0UG9zaXRpb24gYW5kIG5leHRMb2FkUG9zaXRpb24gdG8gc2VlayB0YXJnZXRcbiAgICAgICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb24gPSBjdXJyZW50VGltZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aWNrIHRvIHNwZWVkIHVwIHByb2Nlc3NpbmdcbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgfTtcbiAgICBCYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25NZWRpYUVuZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyByZXNldCBzdGFydFBvc2l0aW9uIGFuZCBsYXN0Q3VycmVudFRpbWUgdG8gcmVzdGFydCBwbGF5YmFjayBAIHN0cmVhbSBiZWdpbm5pbmdcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgIH07XG4gICAgcmV0dXJuIEJhc2VTdHJlYW1Db250cm9sbGVyO1xufSh0YXNrX2xvb3BfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBCYXNlU3RyZWFtQ29udHJvbGxlcjtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLmpzXCIpW1wiTnVtYmVyXCJdKSlcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9idWZmZXItY29udHJvbGxlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvYnVmZmVyLWNvbnRyb2xsZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihOdW1iZXIpIHtcbi8qXG4gKiBCdWZmZXIgQ29udHJvbGxlclxuKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLmpzXCIpO1xudmFyIGV2ZW50X2hhbmRsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50LWhhbmRsZXIgKi8gXCIuL3NyYy9ldmVudC1oYW5kbGVyLmpzXCIpO1xudmFyIGxvZ2dlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLmpzXCIpO1xudmFyIGVycm9yc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLmpzXCIpO1xudmFyIG1lZGlhc291cmNlX2hlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyICovIFwiLi9zcmMvdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyLmpzXCIpO1xudmFyIE1lZGlhU291cmNlID0gbWVkaWFzb3VyY2VfaGVscGVyXzEuZ2V0TWVkaWFTb3VyY2UoKTtcbnZhciBCdWZmZXJDb250cm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCdWZmZXJDb250cm9sbGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ1ZmZlckNvbnRyb2xsZXIoaGxzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGhscywgZXZlbnRzXzEuZGVmYXVsdC5NRURJQV9BVFRBQ0hJTkcsIGV2ZW50c18xLmRlZmF1bHQuTUVESUFfREVUQUNISU5HLCBldmVudHNfMS5kZWZhdWx0Lk1BTklGRVNUX1BBUlNFRCwgZXZlbnRzXzEuZGVmYXVsdC5CVUZGRVJfUkVTRVQsIGV2ZW50c18xLmRlZmF1bHQuQlVGRkVSX0FQUEVORElORywgZXZlbnRzXzEuZGVmYXVsdC5CVUZGRVJfQ09ERUNTLCBldmVudHNfMS5kZWZhdWx0LkJVRkZFUl9FT1MsIGV2ZW50c18xLmRlZmF1bHQuQlVGRkVSX0ZMVVNISU5HLCBldmVudHNfMS5kZWZhdWx0LkxFVkVMX1BUU19VUERBVEVELCBldmVudHNfMS5kZWZhdWx0LkxFVkVMX1VQREFURUQpIHx8IHRoaXM7XG4gICAgICAgIC8vIHRoZSB2YWx1ZSB0aGF0IHdlIGhhdmUgc2V0IG1lZGlhc291cmNlLmR1cmF0aW9uIHRvXG4gICAgICAgIC8vICh0aGUgYWN0dWFsIGR1cmF0aW9uIG1heSBiZSB0d2Vha2VkIHNsaWdobHkgYnkgdGhlIGJyb3dzZXIpXG4gICAgICAgIF90aGlzLl9tc0R1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgLy8gdGhlIHZhbHVlIHRoYXQgd2Ugd2FudCB0byBzZXQgbWVkaWFTb3VyY2UuZHVyYXRpb24gdG9cbiAgICAgICAgX3RoaXMuX2xldmVsRHVyYXRpb24gPSBudWxsO1xuICAgICAgICAvLyB0aGUgdGFyZ2V0IGR1cmF0aW9uIG9mIHRoZSBjdXJyZW50IG1lZGlhIHBsYXlsaXN0XG4gICAgICAgIF90aGlzLl9sZXZlbFRhcmdldER1cmF0aW9uID0gMTA7XG4gICAgICAgIC8vIGN1cnJlbnQgc3RyZWFtIHN0YXRlOiB0cnVlIC0gZm9yIGxpdmUgYnJvYWRjYXN0LCBmYWxzZSAtIGZvciBWb0QgY29udGVudFxuICAgICAgICBfdGhpcy5fbGl2ZSA9IG51bGw7XG4gICAgICAgIC8vIGNhY2hlIHRoZSBzZWxmIGdlbmVyYXRlZCBvYmplY3QgdXJsIHRvIGRldGVjdCBoaWphY2sgb2YgdmlkZW8gdGFnXG4gICAgICAgIF90aGlzLl9vYmplY3RVcmwgPSBudWxsO1xuICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIEJVRkZFUl9DT0RFQyBldmVudHMgcmVjZWl2ZWQgYmVmb3JlIGFueSBzb3VyY2VCdWZmZXJzIGFyZSBjcmVhdGVkXG4gICAgICAgIF90aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSAwO1xuICAgICAgICAvLyBTb3VyY2UgQnVmZmVyIGxpc3RlbmVyc1xuICAgICAgICBfdGhpcy5vbnNidWUgPSBfdGhpcy5vblNCVXBkYXRlRW5kLmJpbmQoX3RoaXMpO1xuICAgICAgICBfdGhpcy5vbnNiZSA9IF90aGlzLm9uU0JVcGRhdGVFcnJvci5iaW5kKF90aGlzKTtcbiAgICAgICAgX3RoaXMucGVuZGluZ1RyYWNrcyA9IHt9O1xuICAgICAgICBfdGhpcy50cmFja3MgPSB7fTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBCdWZmZXJDb250cm9sbGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBldmVudF9oYW5kbGVyXzEuZGVmYXVsdC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgQnVmZmVyQ29udHJvbGxlci5wcm90b3R5cGUub25MZXZlbFB0c1VwZGF0ZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgICAgICAgdmFyIGF1ZGlvVHJhY2sgPSB0aGlzLnRyYWNrcy5hdWRpbztcbiAgICAgICAgLy8gQWRqdXN0aW5nIGBTb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0YCAoZGVzaXJlZCBwb2ludCBpbiB0aGUgdGltZWxpbmUgd2hlcmUgdGhlIG5leHQgZnJhbWVzIHNob3VsZCBiZSBhcHBlbmRlZClcbiAgICAgICAgLy8gaW4gQ2hyb21lIGJyb3dzZXIgd2hlbiB3ZSBkZXRlY3QgTVBFRyBhdWRpbyBjb250YWluZXIgYW5kIHRpbWUgZGVsdGEgYmV0d2VlbiBsZXZlbCBQVFMgYW5kIGBTb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0YFxuICAgICAgICAvLyBpcyBncmVhdGVyIHRoYW4gMTAwbXMgKHRoaXMgaXMgZW5vdWdoIHRvIGhhbmRsZSBzZWVrIGZvciBWT0Qgb3IgbGV2ZWwgY2hhbmdlIGZvciBMSVZFIHZpZGVvcykuIEF0IHRoZSB0aW1lIG9mIGNoYW5nZSB3ZSBpc3N1ZVxuICAgICAgICAvLyBgU291cmNlQnVmZmVyLmFib3J0KClgIGFuZCBhZGp1c3RpbmcgYFNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXRgIGlmIGBTb3VyY2VCdWZmZXIudXBkYXRpbmdgIGlzIGZhbHNlIG9yIGF3YWl0aW5nIGB1cGRhdGVlbmRgXG4gICAgICAgIC8vIGV2ZW50IGlmIFNCIGlzIGluIHVwZGF0aW5nIHN0YXRlLlxuICAgICAgICAvLyBNb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzMzMiNpc3N1ZWNvbW1lbnQtMjU3OTg2NDg2XG4gICAgICAgIGlmICh0eXBlID09PSAnYXVkaW8nICYmIGF1ZGlvVHJhY2sgJiYgYXVkaW9UcmFjay5jb250YWluZXIgPT09ICdhdWRpby9tcGVnJykgeyAvLyBDaHJvbWUgYXVkaW8gbXAzIHRyYWNrXG4gICAgICAgICAgICB2YXIgYXVkaW9CdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlci5hdWRpbztcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IE1hdGguYWJzKGF1ZGlvQnVmZmVyLnRpbWVzdGFtcE9mZnNldCAtIGRhdGEuc3RhcnQpO1xuICAgICAgICAgICAgLy8gYWRqdXN0IHRpbWVzdGFtcCBvZmZzZXQgaWYgdGltZSBkZWx0YSBpcyBncmVhdGVyIHRoYW4gMTAwbXNcbiAgICAgICAgICAgIGlmIChkZWx0YSA+IDAuMSkge1xuICAgICAgICAgICAgICAgIHZhciB1cGRhdGluZyA9IGF1ZGlvQnVmZmVyLnVwZGF0aW5nO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvQnVmZmVyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oJ2NhbiBub3QgYWJvcnQgYXVkaW8gYnVmZmVyOiAnICsgZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF1cGRhdGluZykge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybignY2hhbmdlIG1wZWcgYXVkaW8gdGltZXN0YW1wIG9mZnNldCBmcm9tICcgKyBhdWRpb0J1ZmZlci50aW1lc3RhbXBPZmZzZXQgKyAnIHRvICcgKyBkYXRhLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgYXVkaW9CdWZmZXIudGltZXN0YW1wT2Zmc2V0ID0gZGF0YS5zdGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9UaW1lc3RhbXBPZmZzZXQgPSBkYXRhLnN0YXJ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQnVmZmVyQ29udHJvbGxlci5wcm90b3R5cGUub25NYW5pZmVzdFBhcnNlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIGluIGNhc2Ugb2YgYWx0IGF1ZGlvIDIgQlVGRkVSX0NPREVDUyBldmVudHMgd2lsbCBiZSB0cmlnZ2VyZWQsIG9uZSBwZXIgc3RyZWFtIGNvbnRyb2xsZXJcbiAgICAgICAgLy8gc291cmNlYnVmZmVycyB3aWxsIGJlIGNyZWF0ZWQgYWxsIGF0IG9uY2Ugd2hlbiB0aGUgZXhwZWN0ZWQgbmIgb2YgdHJhY2tzIHdpbGwgYmUgcmVhY2hlZFxuICAgICAgICAvLyBpbiBjYXNlIGFsdCBhdWRpbyBpcyBub3QgdXNlZCwgb25seSBvbmUgQlVGRkVSX0NPREVDIGV2ZW50IHdpbGwgYmUgZmlyZWQgZnJvbSBtYWluIHN0cmVhbSBjb250cm9sbGVyXG4gICAgICAgIC8vIGl0IHdpbGwgY29udGFpbiB0aGUgZXhwZWN0ZWQgbmIgb2Ygc291cmNlIGJ1ZmZlcnMsIG5vIG5lZWQgdG8gY29tcHV0ZSBpdFxuICAgICAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSBkYXRhLmFsdEF1ZGlvID8gMiA6IDE7XG4gICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2codGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkICsgXCIgYnVmZmVyQ29kZWMgZXZlbnQocykgZXhwZWN0ZWRcIik7XG4gICAgfTtcbiAgICBCdWZmZXJDb250cm9sbGVyLnByb3RvdHlwZS5vbk1lZGlhQXR0YWNoaW5nID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICAgICAgLy8gc2V0dXAgdGhlIG1lZGlhIHNvdXJjZVxuICAgICAgICAgICAgdmFyIG1zID0gdGhpcy5tZWRpYVNvdXJjZSA9IG5ldyBNZWRpYVNvdXJjZSgpO1xuICAgICAgICAgICAgLy8gTWVkaWEgU291cmNlIGxpc3RlbmVyc1xuICAgICAgICAgICAgdGhpcy5vbm1zbyA9IHRoaXMub25NZWRpYVNvdXJjZU9wZW4uYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub25tc2UgPSB0aGlzLm9uTWVkaWFTb3VyY2VFbmRlZC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vbm1zYyA9IHRoaXMub25NZWRpYVNvdXJjZUNsb3NlLmJpbmQodGhpcyk7XG4gICAgICAgICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5vbm1zbyk7XG4gICAgICAgICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VlbmRlZCcsIHRoaXMub25tc2UpO1xuICAgICAgICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlY2xvc2UnLCB0aGlzLm9ubXNjKTtcbiAgICAgICAgICAgIC8vIGxpbmsgdmlkZW8gYW5kIG1lZGlhIFNvdXJjZVxuICAgICAgICAgICAgbWVkaWEuc3JjID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwobXMpO1xuICAgICAgICAgICAgLy8gY2FjaGUgdGhlIGxvY2FsbHkgZ2VuZXJhdGVkIG9iamVjdCB1cmxcbiAgICAgICAgICAgIHRoaXMuX29iamVjdFVybCA9IG1lZGlhLnNyYztcbiAgICAgICAgfVxuICAgIH07XG4gICAgQnVmZmVyQ29udHJvbGxlci5wcm90b3R5cGUub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnbWVkaWEgc291cmNlIGRldGFjaGluZycpO1xuICAgICAgICB2YXIgbXMgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgICAgICBpZiAobXMpIHtcbiAgICAgICAgICAgIGlmIChtcy5yZWFkeVN0YXRlID09PSAnb3BlbicpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbmRPZlN0cmVhbSBjb3VsZCB0cmlnZ2VyIGV4Y2VwdGlvbiBpZiBhbnkgc291cmNlYnVmZmVyIGlzIGluIHVwZGF0aW5nIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IHJlYWxseSBjYXJlIGFib3V0IGNoZWNraW5nIHNvdXJjZWJ1ZmZlciBzdGF0ZSBoZXJlLFxuICAgICAgICAgICAgICAgICAgICAvLyBhcyB3ZSBhcmUgYW55d2F5IGRldGFjaGluZyB0aGUgTWVkaWFTb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgLy8gbGV0J3MganVzdCBhdm9pZCB0aGlzIGV4Y2VwdGlvbiB0byBwcm9wYWdhdGVcbiAgICAgICAgICAgICAgICAgICAgbXMuZW5kT2ZTdHJlYW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybihcIm9uTWVkaWFEZXRhY2hpbmc6XCIgKyBlcnIubWVzc2FnZSArIFwiIHdoaWxlIGNhbGxpbmcgZW5kT2ZTdHJlYW1cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMub25tc28pO1xuICAgICAgICAgICAgbXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlZW5kZWQnLCB0aGlzLm9ubXNlKTtcbiAgICAgICAgICAgIG1zLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZWNsb3NlJywgdGhpcy5vbm1zYyk7XG4gICAgICAgICAgICAvLyBEZXRhY2ggcHJvcGVybHkgdGhlIE1lZGlhU291cmNlIGZyb20gdGhlIEhUTUxNZWRpYUVsZW1lbnQgYXNcbiAgICAgICAgICAgIC8vIHN1Z2dlc3RlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vdzNjL21lZGlhLXNvdXJjZS9pc3N1ZXMvNTMuXG4gICAgICAgICAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKHRoaXMuX29iamVjdFVybCk7XG4gICAgICAgICAgICAgICAgLy8gY2xlYW4gdXAgdmlkZW8gdGFnIHNyYyBvbmx5IGlmIGl0J3Mgb3VyIG93biB1cmwuIHNvbWUgZXh0ZXJuYWwgbGlicmFyaWVzIG1pZ2h0XG4gICAgICAgICAgICAgICAgLy8gaGlqYWNrIHRoZSB2aWRlbyB0YWcgYW5kIGNoYW5nZSBpdHMgJ3NyYycgd2l0aG91dCBkZXN0cm95aW5nIHRoZSBIbHMgaW5zdGFuY2UgZmlyc3RcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tZWRpYS5zcmMgPT09IHRoaXMuX29iamVjdFVybCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lZGlhLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVkaWEubG9hZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oJ21lZGlhLnNyYyB3YXMgY2hhbmdlZCBieSBhIHRoaXJkIHBhcnR5IC0gc2tpcCBjbGVhbnVwJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tZWRpYVNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX29iamVjdFVybCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdUcmFja3MgPSB7fTtcbiAgICAgICAgICAgIHRoaXMudHJhY2tzID0ge307XG4gICAgICAgICAgICB0aGlzLnNvdXJjZUJ1ZmZlciA9IHt9O1xuICAgICAgICAgICAgdGhpcy5mbHVzaFJhbmdlID0gW107XG4gICAgICAgICAgICB0aGlzLnNlZ21lbnRzID0gW107XG4gICAgICAgICAgICB0aGlzLmFwcGVuZGVkID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9ubXNvID0gdGhpcy5vbm1zZSA9IHRoaXMub25tc2MgPSBudWxsO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuTUVESUFfREVUQUNIRUQpO1xuICAgIH07XG4gICAgQnVmZmVyQ29udHJvbGxlci5wcm90b3R5cGUub25NZWRpYVNvdXJjZU9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ21lZGlhIHNvdXJjZSBvcGVuZWQnKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0Lk1FRElBX0FUVEFDSEVELCB7IG1lZGlhOiB0aGlzLm1lZGlhIH0pO1xuICAgICAgICB2YXIgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgICAgICBpZiAobWVkaWFTb3VyY2UpIHtcbiAgICAgICAgICAgIC8vIG9uY2UgcmVjZWl2ZWQsIGRvbid0IGxpc3RlbiBhbnltb3JlIHRvIHNvdXJjZW9wZW4gZXZlbnRcbiAgICAgICAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLm9ubXNvKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrUGVuZGluZ1RyYWNrcygpO1xuICAgIH07XG4gICAgQnVmZmVyQ29udHJvbGxlci5wcm90b3R5cGUuY2hlY2tQZW5kaW5nVHJhY2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBidWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkID0gX2EuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCwgcGVuZGluZ1RyYWNrcyA9IF9hLnBlbmRpbmdUcmFja3M7XG4gICAgICAgIC8vIENoZWNrIGlmIHdlJ3ZlIHJlY2VpdmVkIGFsbCBvZiB0aGUgZXhwZWN0ZWQgYnVmZmVyQ29kZWMgZXZlbnRzLiBXaGVuIG5vbmUgcmVtYWluLCBjcmVhdGUgYWxsIHRoZSBzb3VyY2VCdWZmZXJzIGF0IG9uY2UuXG4gICAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgdGhlIE1TRSBzcGVjIGFsbG93cyBpbXBsZW1lbnRhdGlvbnMgdG8gdGhyb3cgUXVvdGFFeGNlZWRlZEVycm9ycyBpZiBjcmVhdGluZyBuZXcgc291cmNlQnVmZmVycyBhZnRlclxuICAgICAgICAvLyBkYXRhIGhhcyBiZWVuIGFwcGVuZGVkIHRvIGV4aXN0aW5nIG9uZXMuXG4gICAgICAgIC8vIDIgdHJhY2tzIGlzIHRoZSBtYXggKG9uZSBmb3IgYXVkaW8sIG9uZSBmb3IgdmlkZW8pLiBJZiB3ZSd2ZSByZWFjaCB0aGlzIG1heCBnbyBhaGVhZCBhbmQgY3JlYXRlIHRoZSBidWZmZXJzLlxuICAgICAgICB2YXIgcGVuZGluZ1RyYWNrc0NvdW50ID0gT2JqZWN0LmtleXMocGVuZGluZ1RyYWNrcykubGVuZ3RoO1xuICAgICAgICBpZiAoKHBlbmRpbmdUcmFja3NDb3VudCAmJiAhYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCkgfHwgcGVuZGluZ1RyYWNrc0NvdW50ID09PSAyKSB7XG4gICAgICAgICAgICAvLyBvaywgbGV0J3MgY3JlYXRlIHRoZW0gbm93ICFcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlU291cmNlQnVmZmVycyhwZW5kaW5nVHJhY2tzKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1RyYWNrcyA9IHt9O1xuICAgICAgICAgICAgLy8gYXBwZW5kIGFueSBwZW5kaW5nIHNlZ21lbnRzIG5vdyAhXG4gICAgICAgICAgICB0aGlzLmRvQXBwZW5kaW5nKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJ1ZmZlckNvbnRyb2xsZXIucHJvdG90eXBlLm9uTWVkaWFTb3VyY2VDbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnbWVkaWEgc291cmNlIGNsb3NlZCcpO1xuICAgIH07XG4gICAgQnVmZmVyQ29udHJvbGxlci5wcm90b3R5cGUub25NZWRpYVNvdXJjZUVuZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdtZWRpYSBzb3VyY2UgZW5kZWQnKTtcbiAgICB9O1xuICAgIEJ1ZmZlckNvbnRyb2xsZXIucHJvdG90eXBlLm9uU0JVcGRhdGVFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHVwZGF0ZSB0aW1lc3RhbXBPZmZzZXRcbiAgICAgICAgaWYgKHRoaXMuYXVkaW9UaW1lc3RhbXBPZmZzZXQpIHtcbiAgICAgICAgICAgIHZhciBhdWRpb0J1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyLmF1ZGlvO1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oXCJjaGFuZ2UgbXBlZyBhdWRpbyB0aW1lc3RhbXAgb2Zmc2V0IGZyb20gXCIgKyBhdWRpb0J1ZmZlci50aW1lc3RhbXBPZmZzZXQgKyBcIiB0byBcIiArIHRoaXMuYXVkaW9UaW1lc3RhbXBPZmZzZXQpO1xuICAgICAgICAgICAgYXVkaW9CdWZmZXIudGltZXN0YW1wT2Zmc2V0ID0gdGhpcy5hdWRpb1RpbWVzdGFtcE9mZnNldDtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmF1ZGlvVGltZXN0YW1wT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9uZWVkc0ZsdXNoKSB7XG4gICAgICAgICAgICB0aGlzLmRvRmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbmVlZHNFb3MpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tFb3MoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIC8vIGNvdW50IG5iIG9mIHBlbmRpbmcgc2VnbWVudHMgd2FpdGluZyBmb3IgYXBwZW5kaW5nIG9uIHRoaXMgc291cmNlYnVmZmVyXG4gICAgICAgIHZhciBwZW5kaW5nID0gdGhpcy5zZWdtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGNvdW50ZXIsIHNlZ21lbnQpIHsgcmV0dXJuIChzZWdtZW50LnBhcmVudCA9PT0gcGFyZW50KSA/IGNvdW50ZXIgKyAxIDogY291bnRlcjsgfSwgMCk7XG4gICAgICAgIC8vIHRoaXMuc291cmNlQnVmZmVyIGlzIGJldHRlciB0byB1c2UgdGhhbiBtZWRpYS5idWZmZXJlZCBhcyBpdCBpcyBjbG9zZXIgdG8gdGhlIFBUUyBkYXRhIGZyb20gdGhlIGZyYWdtZW50c1xuICAgICAgICB2YXIgdGltZVJhbmdlcyA9IHt9O1xuICAgICAgICB2YXIgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgICAgIGZvciAodmFyIHN0cmVhbVR5cGUgaW4gc291cmNlQnVmZmVyKSB7XG4gICAgICAgICAgICB0aW1lUmFuZ2VzW3N0cmVhbVR5cGVdID0gc291cmNlQnVmZmVyW3N0cmVhbVR5cGVdLmJ1ZmZlcmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5CVUZGRVJfQVBQRU5ERUQsIHsgcGFyZW50OiBwYXJlbnQsIHBlbmRpbmc6IHBlbmRpbmcsIHRpbWVSYW5nZXM6IHRpbWVSYW5nZXMgfSk7XG4gICAgICAgIC8vIGRvbid0IGFwcGVuZCBpbiBmbHVzaGluZyBtb2RlXG4gICAgICAgIGlmICghdGhpcy5fbmVlZHNGbHVzaCkge1xuICAgICAgICAgICAgdGhpcy5kb0FwcGVuZGluZygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24oKTtcbiAgICAgICAgLy8gYXBwZW5kaW5nIGdvZXMgZmlyc3RcbiAgICAgICAgaWYgKHBlbmRpbmcgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hMaXZlQmFja0J1ZmZlcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCdWZmZXJDb250cm9sbGVyLnByb3RvdHlwZS5vblNCVXBkYXRlRXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmVycm9yKCdzb3VyY2VCdWZmZXIgZXJyb3I6JywgZXZlbnQpO1xuICAgICAgICAvLyBhY2NvcmRpbmcgdG8gaHR0cDovL3d3dy53My5vcmcvVFIvbWVkaWEtc291cmNlLyNzb3VyY2VidWZmZXItYXBwZW5kLWVycm9yXG4gICAgICAgIC8vIHRoaXMgZXJyb3IgbWlnaHQgbm90IGFsd2F5cyBiZSBmYXRhbCAoaXQgaXMgZmF0YWwgaWYgZGVjb2RlIGVycm9yIGlzIHNldCwgaW4gdGhhdCBjYXNlXG4gICAgICAgIC8vIGl0IHdpbGwgYmUgZm9sbG93ZWQgYnkgYSBtZWRpYUVsZW1lbnQgZXJyb3IgLi4uKVxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogZXJyb3JzXzEuRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogZXJyb3JzXzEuRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRJTkdfRVJST1IsIGZhdGFsOiBmYWxzZSB9KTtcbiAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0byBkbyBtb3JlIHRoYW4gdGhhdCwgYXMgYWNjb3JkaW4gdG8gdGhlIHNwZWMsIHVwZGF0ZWVuZCB3aWxsIGJlIGZpcmVkIGp1c3QgYWZ0ZXJcbiAgICB9O1xuICAgIEJ1ZmZlckNvbnRyb2xsZXIucHJvdG90eXBlLm9uQnVmZmVyUmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcbiAgICAgICAgZm9yICh2YXIgdHlwZSBpbiBzb3VyY2VCdWZmZXIpIHtcbiAgICAgICAgICAgIHZhciBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZWRpYVNvdXJjZS5yZW1vdmVTb3VyY2VCdWZmZXIoc2IpO1xuICAgICAgICAgICAgICAgIHNiLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VwZGF0ZWVuZCcsIHRoaXMub25zYnVlKTtcbiAgICAgICAgICAgICAgICBzYi5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMub25zYmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc291cmNlQnVmZmVyID0ge307XG4gICAgICAgIHRoaXMuZmx1c2hSYW5nZSA9IFtdO1xuICAgICAgICB0aGlzLnNlZ21lbnRzID0gW107XG4gICAgICAgIHRoaXMuYXBwZW5kZWQgPSAwO1xuICAgIH07XG4gICAgQnVmZmVyQ29udHJvbGxlci5wcm90b3R5cGUub25CdWZmZXJDb2RlY3MgPSBmdW5jdGlvbiAodHJhY2tzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIGlmIHNvdXJjZSBidWZmZXIocykgbm90IGNyZWF0ZWQgeWV0LCBhcHBlbmRlZCBidWZmZXIgdHJhY2tzIGluIHRoaXMucGVuZGluZ1RyYWNrc1xuICAgICAgICAvLyBpZiBzb3VyY2VidWZmZXJzIGFscmVhZHkgY3JlYXRlZCwgZG8gbm90aGluZyAuLi5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuc291cmNlQnVmZmVyKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3Qua2V5cyh0cmFja3MpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrTmFtZSkge1xuICAgICAgICAgICAgX3RoaXMucGVuZGluZ1RyYWNrc1t0cmFja05hbWVdID0gdHJhY2tzW3RyYWNrTmFtZV07XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgICAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSBNYXRoLm1heCh0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgLSAxLCAwKTtcbiAgICAgICAgaWYgKG1lZGlhU291cmNlICYmIG1lZGlhU291cmNlLnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgICAgICAgdGhpcy5jaGVja1BlbmRpbmdUcmFja3MoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQnVmZmVyQ29udHJvbGxlci5wcm90b3R5cGUuY3JlYXRlU291cmNlQnVmZmVycyA9IGZ1bmN0aW9uICh0cmFja3MpIHtcbiAgICAgICAgdmFyIHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyLCBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2U7XG4gICAgICAgIGZvciAodmFyIHRyYWNrTmFtZSBpbiB0cmFja3MpIHtcbiAgICAgICAgICAgIGlmICghc291cmNlQnVmZmVyW3RyYWNrTmFtZV0pIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhY2sgPSB0cmFja3NbdHJhY2tOYW1lXTtcbiAgICAgICAgICAgICAgICAvLyB1c2UgbGV2ZWxDb2RlYyBhcyBmaXJzdCBwcmlvcml0eVxuICAgICAgICAgICAgICAgIHZhciBjb2RlYyA9IHRyYWNrLmxldmVsQ29kZWMgfHwgdHJhY2suY29kZWM7XG4gICAgICAgICAgICAgICAgdmFyIG1pbWVUeXBlID0gdHJhY2suY29udGFpbmVyICsgXCI7Y29kZWNzPVwiICsgY29kZWM7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcImNyZWF0aW5nIHNvdXJjZUJ1ZmZlcihcIiArIG1pbWVUeXBlICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzYiA9IHNvdXJjZUJ1ZmZlclt0cmFja05hbWVdID0gbWVkaWFTb3VyY2UuYWRkU291cmNlQnVmZmVyKG1pbWVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgc2IuYWRkRXZlbnRMaXN0ZW5lcigndXBkYXRlZW5kJywgdGhpcy5vbnNidWUpO1xuICAgICAgICAgICAgICAgICAgICBzYi5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMub25zYmUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNrc1t0cmFja05hbWVdID0geyBjb2RlYzogY29kZWMsIGNvbnRhaW5lcjogdHJhY2suY29udGFpbmVyIH07XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLmJ1ZmZlciA9IHNiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5lcnJvcihcImVycm9yIHdoaWxlIHRyeWluZyB0byBhZGQgc291cmNlQnVmZmVyOlwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogZXJyb3JzXzEuRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogZXJyb3JzXzEuRXJyb3JEZXRhaWxzLkJVRkZFUl9BRERfQ09ERUNfRVJST1IsIGZhdGFsOiBmYWxzZSwgZXJyOiBlcnIsIG1pbWVUeXBlOiBtaW1lVHlwZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkJVRkZFUl9DUkVBVEVELCB7IHRyYWNrczogdHJhY2tzIH0pO1xuICAgIH07XG4gICAgQnVmZmVyQ29udHJvbGxlci5wcm90b3R5cGUub25CdWZmZXJBcHBlbmRpbmcgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoIXRoaXMuX25lZWRzRmx1c2gpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZWdtZW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VnbWVudHMgPSBbZGF0YV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlZ21lbnRzLnB1c2goZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRvQXBwZW5kaW5nKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJ1ZmZlckNvbnRyb2xsZXIucHJvdG90eXBlLm9uQnVmZmVyQXBwZW5kRmFpbCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5lcnJvcignc291cmNlQnVmZmVyIGVycm9yOicsIGRhdGEuZXZlbnQpO1xuICAgICAgICAvLyBhY2NvcmRpbmcgdG8gaHR0cDovL3d3dy53My5vcmcvVFIvbWVkaWEtc291cmNlLyNzb3VyY2VidWZmZXItYXBwZW5kLWVycm9yXG4gICAgICAgIC8vIHRoaXMgZXJyb3IgbWlnaHQgbm90IGFsd2F5cyBiZSBmYXRhbCAoaXQgaXMgZmF0YWwgaWYgZGVjb2RlIGVycm9yIGlzIHNldCwgaW4gdGhhdCBjYXNlXG4gICAgICAgIC8vIGl0IHdpbGwgYmUgZm9sbG93ZWQgYnkgYSBtZWRpYUVsZW1lbnQgZXJyb3IgLi4uKVxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogZXJyb3JzXzEuRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogZXJyb3JzXzEuRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRJTkdfRVJST1IsIGZhdGFsOiBmYWxzZSB9KTtcbiAgICB9O1xuICAgIC8vIG9uIEJVRkZFUl9FT1MgbWFyayBtYXRjaGluZyBzb3VyY2VidWZmZXIocykgYXMgZW5kZWQgYW5kIHRyaWdnZXIgY2hlY2tFb3MoKVxuICAgIEJ1ZmZlckNvbnRyb2xsZXIucHJvdG90eXBlLm9uQnVmZmVyRW9zID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHNiID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgICAgIHZhciBkYXRhVHlwZSA9IGRhdGEudHlwZTtcbiAgICAgICAgZm9yICh2YXIgdHlwZSBpbiBzYikge1xuICAgICAgICAgICAgaWYgKCFkYXRhVHlwZSB8fCB0eXBlID09PSBkYXRhVHlwZSkge1xuICAgICAgICAgICAgICAgIGlmICghc2JbdHlwZV0uZW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2JbdHlwZV0uZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKHR5cGUgKyBcIiBzb3VyY2VCdWZmZXIgbm93IEVPU1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja0VvcygpO1xuICAgIH07XG4gICAgLy8gaWYgYWxsIHNvdXJjZSBidWZmZXJzIGFyZSBtYXJrZWQgYXMgZW5kZWQsIHNpZ25hbCBlbmRPZlN0cmVhbSgpIHRvIE1lZGlhU291cmNlLlxuICAgIEJ1ZmZlckNvbnRyb2xsZXIucHJvdG90eXBlLmNoZWNrRW9zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2IgPSB0aGlzLnNvdXJjZUJ1ZmZlciwgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgICAgICBpZiAoIW1lZGlhU291cmNlIHx8IG1lZGlhU291cmNlLnJlYWR5U3RhdGUgIT09ICdvcGVuJykge1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNFb3MgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciB0eXBlIGluIHNiKSB7XG4gICAgICAgICAgICB2YXIgc2JvYmogPSBzYlt0eXBlXTtcbiAgICAgICAgICAgIGlmICghc2JvYmouZW5kZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2JvYmoudXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc0VvcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ2FsbCBtZWRpYSBkYXRhIGFyZSBhdmFpbGFibGUsIHNpZ25hbCBlbmRPZlN0cmVhbSgpIHRvIE1lZGlhU291cmNlIGFuZCBzdG9wIGxvYWRpbmcgZnJhZ21lbnQnKTtcbiAgICAgICAgLy8gTm90aWZ5IHRoZSBtZWRpYSBlbGVtZW50IHRoYXQgaXQgbm93IGhhcyBhbGwgb2YgdGhlIG1lZGlhIGRhdGFcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKCdleGNlcHRpb24gd2hpbGUgY2FsbGluZyBtZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbmVlZHNFb3MgPSBmYWxzZTtcbiAgICB9O1xuICAgIEJ1ZmZlckNvbnRyb2xsZXIucHJvdG90eXBlLm9uQnVmZmVyRmx1c2hpbmcgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLmZsdXNoUmFuZ2UucHVzaCh7IHN0YXJ0OiBkYXRhLnN0YXJ0T2Zmc2V0LCBlbmQ6IGRhdGEuZW5kT2Zmc2V0LCB0eXBlOiBkYXRhLnR5cGUgfSk7XG4gICAgICAgIC8vIGF0dGVtcHQgZmx1c2ggaW1tZWRpYXRlbHlcbiAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlckNvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLmRvRmx1c2goKTtcbiAgICB9O1xuICAgIEJ1ZmZlckNvbnRyb2xsZXIucHJvdG90eXBlLmZsdXNoTGl2ZUJhY2tCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGNsZWFyIGJhY2sgYnVmZmVyIGZvciBsaXZlIG9ubHlcbiAgICAgICAgaWYgKCF0aGlzLl9saXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpdmVCYWNrQnVmZmVyTGVuZ3RoID0gdGhpcy5obHMuY29uZmlnLmxpdmVCYWNrQnVmZmVyTGVuZ3RoO1xuICAgICAgICBpZiAoIWlzRmluaXRlKGxpdmVCYWNrQnVmZmVyTGVuZ3RoKSB8fCBsaXZlQmFja0J1ZmZlckxlbmd0aCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lO1xuICAgICAgICB2YXIgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgICAgIHZhciBidWZmZXJUeXBlcyA9IE9iamVjdC5rZXlzKHNvdXJjZUJ1ZmZlcik7XG4gICAgICAgIHZhciB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24gPSBjdXJyZW50VGltZSAtIE1hdGgubWF4KGxpdmVCYWNrQnVmZmVyTGVuZ3RoLCB0aGlzLl9sZXZlbFRhcmdldER1cmF0aW9uKTtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSBidWZmZXJUeXBlcy5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICAgICAgICB2YXIgYnVmZmVyVHlwZSA9IGJ1ZmZlclR5cGVzW2luZGV4XSwgYnVmZmVyZWQgPSBzb3VyY2VCdWZmZXJbYnVmZmVyVHlwZV0uYnVmZmVyZWQ7XG4gICAgICAgICAgICAvLyB3aGVuIHRhcmdldCBidWZmZXIgc3RhcnQgZXhjZWVkcyBhY3R1YWwgYnVmZmVyIHN0YXJ0XG4gICAgICAgICAgICBpZiAoYnVmZmVyZWQubGVuZ3RoID4gMCAmJiB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24gPiBidWZmZXJlZC5zdGFydCgwKSkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBidWZmZXIgdXAgdW50aWwgY3VycmVudCB0aW1lIG1pbnVzIG1pbmltdW0gYmFjayBidWZmZXIgbGVuZ3RoIChyZW1vdmluZyBidWZmZXIgdG9vIGNsb3NlIHRvIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAvLyB0aW1lIHdpbGwgbGVhZCB0byBwbGF5YmFjayBmcmVlemluZylcbiAgICAgICAgICAgICAgICAvLyBjcmVkaXRzIGZvciBsZXZlbCB0YXJnZXQgZHVyYXRpb24gLSBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy9odHRwLXN0cmVhbWluZy9ibG9iLzMxMzI5MzNiNmFhOTlkZGVmYWIyOWMxMDQ0NzYyNGVmZDZmZDZlNTIvc3JjL3NlZ21lbnQtbG9hZGVyLmpzI0w5MVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQnVmZmVyUmFuZ2UoYnVmZmVyVHlwZSwgc291cmNlQnVmZmVyW2J1ZmZlclR5cGVdLCAwLCB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBCdWZmZXJDb250cm9sbGVyLnByb3RvdHlwZS5vbkxldmVsVXBkYXRlZCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgZGV0YWlscyA9IF9hLmRldGFpbHM7XG4gICAgICAgIGlmIChkZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9sZXZlbER1cmF0aW9uID0gZGV0YWlscy50b3RhbGR1cmF0aW9uICsgZGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLl9sZXZlbFRhcmdldER1cmF0aW9uID0gZGV0YWlscy5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gfHwgZGV0YWlscy50YXJnZXRkdXJhdGlvbiB8fCAxMDtcbiAgICAgICAgICAgIHRoaXMuX2xpdmUgPSBkZXRhaWxzLmxpdmU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBNZWRpYSBTb3VyY2UgZHVyYXRpb24gdG8gY3VycmVudCBsZXZlbCBkdXJhdGlvbiBvciBvdmVycmlkZSB0byBJbmZpbml0eSBpZiBjb25maWd1cmF0aW9uIHBhcmFtZXRlclxuICAgICAqICdsaXZlRHVyYXRpb25JbmZpbml0eWAgaXMgc2V0IHRvIGB0cnVlYFxuICAgICAqIE1vcmUgZGV0YWlsczogaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzM1NVxuICAgICAqL1xuICAgIEJ1ZmZlckNvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgICAgICB2YXIgZHVyYXRpb247XG4gICAgICAgIGlmICh0aGlzLl9sZXZlbER1cmF0aW9uID09PSBudWxsIHx8XG4gICAgICAgICAgICAhdGhpcy5tZWRpYSB8fFxuICAgICAgICAgICAgIXRoaXMubWVkaWFTb3VyY2UgfHxcbiAgICAgICAgICAgICF0aGlzLnNvdXJjZUJ1ZmZlciB8fFxuICAgICAgICAgICAgdGhpcy5tZWRpYS5yZWFkeVN0YXRlID09PSAwIHx8XG4gICAgICAgICAgICB0aGlzLm1lZGlhU291cmNlLnJlYWR5U3RhdGUgIT09ICdvcGVuJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHR5cGUgaW4gdGhpcy5zb3VyY2VCdWZmZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZUJ1ZmZlclt0eXBlXS51cGRhdGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIGNhbid0IHNldCBkdXJhdGlvbiB3aGlsc3QgYSBidWZmZXIgaXMgdXBkYXRpbmdcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZHVyYXRpb24gPSB0aGlzLm1lZGlhLmR1cmF0aW9uO1xuICAgICAgICAvLyBpbml0aWFsaXNlIHRvIHRoZSB2YWx1ZSB0aGF0IHRoZSBtZWRpYSBzb3VyY2UgaXMgcmVwb3J0aW5nXG4gICAgICAgIGlmICh0aGlzLl9tc0R1cmF0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9tc0R1cmF0aW9uID0gdGhpcy5tZWRpYVNvdXJjZS5kdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbGl2ZSA9PT0gdHJ1ZSAmJiBjb25maWcubGl2ZUR1cmF0aW9uSW5maW5pdHkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIE92ZXJyaWRlIGR1cmF0aW9uIHRvIEluZmluaXR5XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdNZWRpYSBTb3VyY2UgZHVyYXRpb24gaXMgc2V0IHRvIEluZmluaXR5Jyk7XG4gICAgICAgICAgICB0aGlzLl9tc0R1cmF0aW9uID0gdGhpcy5tZWRpYVNvdXJjZS5kdXJhdGlvbiA9IEluZmluaXR5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCh0aGlzLl9sZXZlbER1cmF0aW9uID4gdGhpcy5fbXNEdXJhdGlvbiAmJiB0aGlzLl9sZXZlbER1cmF0aW9uID4gZHVyYXRpb24pIHx8ICFOdW1iZXIuaXNGaW5pdGUoZHVyYXRpb24pKSB7XG4gICAgICAgICAgICAvLyBsZXZlbER1cmF0aW9uIHdhcyB0aGUgbGFzdCB2YWx1ZSB3ZSBzZXQuXG4gICAgICAgICAgICAvLyBub3QgdXNpbmcgbWVkaWFTb3VyY2UuZHVyYXRpb24gYXMgdGhlIGJyb3dzZXIgbWF5IHR3ZWFrIHRoaXMgdmFsdWVcbiAgICAgICAgICAgIC8vIG9ubHkgdXBkYXRlIE1lZGlhIFNvdXJjZSBkdXJhdGlvbiBpZiBpdHMgdmFsdWUgaW5jcmVhc2UsIHRoaXMgaXMgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIGZsdXNoaW5nIGFscmVhZHkgYnVmZmVyZWQgcG9ydGlvbiB3aGVuIHN3aXRjaGluZyBiZXR3ZWVuIHF1YWxpdHkgbGV2ZWxcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJVcGRhdGluZyBNZWRpYSBTb3VyY2UgZHVyYXRpb24gdG8gXCIgKyB0aGlzLl9sZXZlbER1cmF0aW9uLnRvRml4ZWQoMykpO1xuICAgICAgICAgICAgdGhpcy5fbXNEdXJhdGlvbiA9IHRoaXMubWVkaWFTb3VyY2UuZHVyYXRpb24gPSB0aGlzLl9sZXZlbER1cmF0aW9uO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCdWZmZXJDb250cm9sbGVyLnByb3RvdHlwZS5kb0ZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBsb29wIHRocm91Z2ggYWxsIGJ1ZmZlciByYW5nZXMgdG8gZmx1c2hcbiAgICAgICAgd2hpbGUgKHRoaXMuZmx1c2hSYW5nZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHRoaXMuZmx1c2hSYW5nZVswXTtcbiAgICAgICAgICAgIC8vIGZsdXNoQnVmZmVyIHdpbGwgYWJvcnQgYW55IGJ1ZmZlciBhcHBlbmQgaW4gcHJvZ3Jlc3MgYW5kIGZsdXNoIEF1ZGlvL1ZpZGVvIEJ1ZmZlclxuICAgICAgICAgICAgaWYgKHRoaXMuZmx1c2hCdWZmZXIocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCwgcmFuZ2UudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAvLyByYW5nZSBmbHVzaGVkLCByZW1vdmUgZnJvbSBmbHVzaCBhcnJheVxuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hSYW5nZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXJDb3VudGVyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRzRmx1c2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIGF2b2lkIGxvb3BpbmcsIHdhaXQgZm9yIFNCIHVwZGF0ZSBlbmQgdG8gcmV0cmlnZ2VyIGEgZmx1c2hcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmx1c2hSYW5nZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIGV2ZXJ5dGhpbmcgZmx1c2hlZFxuICAgICAgICAgICAgdGhpcy5fbmVlZHNGbHVzaCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gbGV0J3MgcmVjb21wdXRlIHRoaXMuYXBwZW5kZWQsIHdoaWNoIGlzIHVzZWQgdG8gYXZvaWQgZmx1c2ggbG9vcGluZ1xuICAgICAgICAgICAgdmFyIGFwcGVuZGVkID0gMDtcbiAgICAgICAgICAgIHZhciBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdHlwZSBpbiBzb3VyY2VCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwZW5kZWQgKz0gc291cmNlQnVmZmVyW3R5cGVdLmJ1ZmZlcmVkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBlcnJvciBjb3VsZCBiZSB0aHJvd24gd2hpbGUgYWNjZXNzaW5nIGJ1ZmZlcmVkLCBpbiBjYXNlIHNvdXJjZWJ1ZmZlciBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZnJvbSBNZWRpYVNvdXJjZVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgaGFybWVzcyBhdCB0aGlzIHN0YWdlLCBjYXRjaCB0aGlzIHRvIGF2b2lkIHJlcG9ydGluZyBhbiBpbnRlcm5hbCBleGNlcHRpb25cbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIuZXJyb3IoJ2Vycm9yIHdoaWxlIGFjY2Vzc2luZyBzb3VyY2VCdWZmZXIuYnVmZmVyZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXBwZW5kZWQgPSBhcHBlbmRlZDtcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5CVUZGRVJfRkxVU0hFRCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJ1ZmZlckNvbnRyb2xsZXIucHJvdG90eXBlLmRvQXBwZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBobHMgPSBfYS5obHMsIHNlZ21lbnRzID0gX2Euc2VnbWVudHMsIHNvdXJjZUJ1ZmZlciA9IF9hLnNvdXJjZUJ1ZmZlcjtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHNvdXJjZUJ1ZmZlcikubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tZWRpYS5lcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIuZXJyb3IoJ3RyeWluZyB0byBhcHBlbmQgYWx0aG91Z2ggYSBtZWRpYSBlcnJvciBvY2N1cmVkLCBmbHVzaCBzZWdtZW50IGFuZCBhYm9ydCcpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFwcGVuZGluZykge1xuICAgICAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coYHNiIGFwcGVuZGluZyBpbiBwcm9ncmVzc2ApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWdtZW50cyAmJiBzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBzZWdtZW50LnR5cGUsIHNiID0gc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2IudXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXNldCBzb3VyY2VCdWZmZXIgZW5kZWQgZmxhZyBiZWZvcmUgYXBwZW5kaW5nIHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYi5lbmRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coYGFwcGVuZGluZyAke3NlZ21lbnQuY29udGVudH0gJHt0eXBlfSBTQiwgc2l6ZToke3NlZ21lbnQuZGF0YS5sZW5ndGh9LCAke3NlZ21lbnQucGFyZW50fWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gc2VnbWVudC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2IuYXBwZW5kQnVmZmVyKHNlZ21lbnQuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRFcnJvciA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRlZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzLnVuc2hpZnQoc2VnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBjYXNlIHdlIGRvbid0IGhhdmUgYW55IHNvdXJjZSBidWZmZXIgbWF0Y2hpbmcgd2l0aCB0aGlzIHNlZ21lbnQgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IG1lYW5zIHRoYXQgTWVkaWFzb3VyY2UgZmFpbHMgdG8gY3JlYXRlIHNvdXJjZWJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlzY2FyZCB0aGlzIHNlZ21lbnQsIGFuZCB0cmlnZ2VyIHVwZGF0ZSBlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25TQlVwZGF0ZUVuZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gY2FzZSBhbnkgZXJyb3Igb2NjdXJlZCB3aGlsZSBhcHBlbmRpbmcsIHB1dCBiYWNrIHNlZ21lbnQgaW4gc2VnbWVudHMgdGFibGVcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmVycm9yKFwiZXJyb3Igd2hpbGUgdHJ5aW5nIHRvIGFwcGVuZCBidWZmZXI6XCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzLnVuc2hpZnQoc2VnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudF8xID0geyB0eXBlOiBlcnJvcnNfMS5FcnJvclR5cGVzLk1FRElBX0VSUk9SLCBwYXJlbnQ6IHNlZ21lbnQucGFyZW50IH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSAhPT0gMjIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFwcGVuZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRFcnJvcisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRFcnJvciA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudF8xLmRldGFpbHMgPSBlcnJvcnNfMS5FcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIHdpdGggVUhEIGNvbnRlbnQsIHdlIGNvdWxkIGdldCBsb29wIG9mIHF1b3RhIGV4Y2VlZGVkIGVycm9yIHVudGlsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyb3dzZXIgaXMgYWJsZSB0byBldmljdCBzb21lIGRhdGEgZnJvbSBzb3VyY2VidWZmZXIuIHJldHJ5aW5nIGhlbHAgcmVjb3ZlcmluZyB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXBwZW5kRXJyb3IgPiBobHMuY29uZmlnLmFwcGVuZEVycm9yTWF4UmV0cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiZmFpbCBcIiArIGhscy5jb25maWcuYXBwZW5kRXJyb3JNYXhSZXRyeSArIFwiIHRpbWVzIHRvIGFwcGVuZCBzZWdtZW50IGluIHNvdXJjZUJ1ZmZlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlZ21lbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRfMS5mYXRhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwgZXZlbnRfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudF8xLmZhdGFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwgZXZlbnRfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBRdW90YUV4Y2VlZGVkRXJyb3I6IGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZnJhc3RydWN0dXJlLmh0bWwjcXVvdGFleGNlZWRlZGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQncyBzdG9wIGFwcGVuZGluZyBhbnkgc2VnbWVudHMsIGFuZCByZXBvcnQgQlVGRkVSX0ZVTExfRVJST1IgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50XzEuZGV0YWlscyA9IGVycm9yc18xLkVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50XzEuZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIGV2ZW50XzEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKlxuICAgICAgZmx1c2ggc3BlY2lmaWVkIGJ1ZmZlcmVkIHJhbmdlLFxuICAgICAgcmV0dXJuIHRydWUgb25jZSByYW5nZSBoYXMgYmVlbiBmbHVzaGVkLlxuICAgICAgYXMgc291cmNlQnVmZmVyLnJlbW92ZSgpIGlzIGFzeW5jaHJvbm91cywgZmx1c2hCdWZmZXIgd2lsbCBiZSByZXRyaWdnZXJlZCBvbiBzb3VyY2VCdWZmZXIgdXBkYXRlIGVuZFxuICAgICovXG4gICAgQnVmZmVyQ29udHJvbGxlci5wcm90b3R5cGUuZmx1c2hCdWZmZXIgPSBmdW5jdGlvbiAoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgdHlwZUluKSB7XG4gICAgICAgIHZhciBzYjtcbiAgICAgICAgdmFyIHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoc291cmNlQnVmZmVyKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJmbHVzaEJ1ZmZlcixwb3Mvc3RhcnQvZW5kOiBcIiArIHRoaXMubWVkaWEuY3VycmVudFRpbWUudG9GaXhlZCgzKSArIFwiL1wiICsgc3RhcnRPZmZzZXQgKyBcIi9cIiArIGVuZE9mZnNldCk7XG4gICAgICAgICAgICAvLyBzYWZlZ3VhcmQgdG8gYXZvaWQgaW5maW5pdGUgbG9vcGluZyA6IGRvbid0IHRyeSB0byBmbHVzaCBtb3JlIHRoYW4gdGhlIG5iIG9mIGFwcGVuZGVkIHNlZ21lbnRzXG4gICAgICAgICAgICBpZiAodGhpcy5mbHVzaEJ1ZmZlckNvdW50ZXIgPCB0aGlzLmFwcGVuZGVkKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdHlwZSBpbiBzb3VyY2VCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgc291cmNlYnVmZmVyIHR5cGUgaXMgZGVmaW5lZCAodHlwZUluKTogaWYgeWVzLCBsZXQncyBvbmx5IGZsdXNoIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vLCBsZXQncyBmbHVzaCBhbGwgc291cmNlYnVmZmVyc1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZUluICYmIHR5cGUgIT09IHR5cGVJbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2IgPSBzb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGFyZSBnb2luZyB0byBmbHVzaCBidWZmZXIsIG1hcmsgc291cmNlIGJ1ZmZlciBhcyAnbm90IGVuZGVkJ1xuICAgICAgICAgICAgICAgICAgICBzYi5lbmRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNiLnVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZW1vdmVCdWZmZXJSYW5nZSh0eXBlLCBzYiwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoQnVmZmVyQ291bnRlcisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKCdjYW5ub3QgZmx1c2gsIHNiIHVwZGF0aW5nIGluIHByb2dyZXNzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybignYWJvcnQgZmx1c2hpbmcgdG9vIG1hbnkgcmV0cmllcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnYnVmZmVyIGZsdXNoZWQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBldmVyeXRoaW5nIGZsdXNoZWQgIVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZmlyc3QgYnVmZmVyZWQgcmFuZ2UgZnJvbSBwcm92aWRlZCBzb3VyY2UgYnVmZmVyIHRoYXQgbGllcyB3aXRoaW4gZ2l2ZW4gc3RhcnQgYW5kIGVuZCBvZmZzZXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGUgVHlwZSBvZiB0aGUgc291cmNlIGJ1ZmZlciwgbG9nZ2luZyBwdXJwb3NlcyBvbmx5LlxuICAgICAqIEBwYXJhbSBzYiBUYXJnZXQgU291cmNlQnVmZmVyIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSBzdGFydE9mZnNldFxuICAgICAqIEBwYXJhbSBlbmRPZmZzZXRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIHdoZW4gc291cmNlIGJ1ZmZlciByZW1vdmUgcmVxdWVzdGVkLlxuICAgICAqL1xuICAgIEJ1ZmZlckNvbnRyb2xsZXIucHJvdG90eXBlLnJlbW92ZUJ1ZmZlclJhbmdlID0gZnVuY3Rpb24gKHR5cGUsIHNiLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNiLmJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ1ZlN0YXJ0ID0gc2IuYnVmZmVyZWQuc3RhcnQoaSk7XG4gICAgICAgICAgICAgICAgdmFyIGJ1ZkVuZCA9IHNiLmJ1ZmZlcmVkLmVuZChpKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlU3RhcnQgPSBNYXRoLm1heChidWZTdGFydCwgc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHZhciByZW1vdmVFbmQgPSBNYXRoLm1pbihidWZFbmQsIGVuZE9mZnNldCk7XG4gICAgICAgICAgICAgICAgLyogc29tZXRpbWVzIHNvdXJjZWJ1ZmZlci5yZW1vdmUoKSBkb2VzIG5vdCBmbHVzaFxuICAgICAgICAgICAgICAgICAgdGhlIGV4YWN0IGV4cGVjdGVkIHRpbWUgcmFuZ2UuXG4gICAgICAgICAgICAgICAgICB0byBhdm9pZCByb3VuZGluZyBpc3N1ZXMvaW5maW5pdGUgbG9vcCxcbiAgICAgICAgICAgICAgICAgIG9ubHkgZmx1c2ggYnVmZmVyIHJhbmdlIG9mIGxlbmd0aCBncmVhdGVyIHRoYW4gNTAwbXMuXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5taW4ocmVtb3ZlRW5kLCBidWZFbmQpIC0gcmVtb3ZlU3RhcnQgPiAwLjUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcInNiIHJlbW92ZSBcIiArIHR5cGUgKyBcIiBbXCIgKyByZW1vdmVTdGFydCArIFwiLFwiICsgcmVtb3ZlRW5kICsgXCJdLCBvZiBbXCIgKyBidWZTdGFydCArIFwiLFwiICsgYnVmRW5kICsgXCJdLCBwb3M6XCIgKyB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgc2IucmVtb3ZlKHJlbW92ZVN0YXJ0LCByZW1vdmVFbmQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybigncmVtb3ZlQnVmZmVyUmFuZ2UgZmFpbGVkJywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBCdWZmZXJDb250cm9sbGVyO1xufShldmVudF9oYW5kbGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQnVmZmVyQ29udHJvbGxlcjtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLmpzXCIpW1wiTnVtYmVyXCJdKSlcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9jYXAtbGV2ZWwtY29udHJvbGxlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvY2FwLWxldmVsLWNvbnRyb2xsZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihOdW1iZXIpIHtcbi8qXG4gKiBjYXAgc3RyZWFtIGxldmVsIHRvIG1lZGlhIHNpemUgZGltZW5zaW9uIGNvbnRyb2xsZXJcbiovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy5qc1wiKTtcbnZhciBldmVudF9oYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudC1oYW5kbGVyICovIFwiLi9zcmMvZXZlbnQtaGFuZGxlci5qc1wiKTtcbnZhciBDYXBMZXZlbENvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENhcExldmVsQ29udHJvbGxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYXBMZXZlbENvbnRyb2xsZXIoaGxzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGhscywgZXZlbnRzXzEuZGVmYXVsdC5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLCBldmVudHNfMS5kZWZhdWx0Lk1FRElBX0FUVEFDSElORywgZXZlbnRzXzEuZGVmYXVsdC5NQU5JRkVTVF9QQVJTRUQsIGV2ZW50c18xLmRlZmF1bHQuQlVGRkVSX0NPREVDUywgZXZlbnRzXzEuZGVmYXVsdC5NRURJQV9ERVRBQ0hJTkcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIF90aGlzLmZpcnN0TGV2ZWwgPSBudWxsO1xuICAgICAgICBfdGhpcy5sZXZlbHMgPSBbXTtcbiAgICAgICAgX3RoaXMubWVkaWEgPSBudWxsO1xuICAgICAgICBfdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gW107XG4gICAgICAgIF90aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDYXBMZXZlbENvbnRyb2xsZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmhscy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUpIHtcbiAgICAgICAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fc3RvcENhcHBpbmcoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FwTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZS5vbkZwc0Ryb3BMZXZlbENhcHBpbmcgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAvLyBEb24ndCBhZGQgYSByZXN0cmljdGVkIGxldmVsIG1vcmUgdGhhbiBvbmNlXG4gICAgICAgIGlmIChDYXBMZXZlbENvbnRyb2xsZXIuaXNMZXZlbEFsbG93ZWQoZGF0YS5kcm9wcGVkTGV2ZWwsIHRoaXMucmVzdHJpY3RlZExldmVscykpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdHJpY3RlZExldmVscy5wdXNoKGRhdGEuZHJvcHBlZExldmVsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FwTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZS5vbk1lZGlhQXR0YWNoaW5nID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWEgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTFZpZGVvRWxlbWVudCA/IGRhdGEubWVkaWEgOiBudWxsO1xuICAgIH07XG4gICAgQ2FwTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZS5vbk1hbmlmZXN0UGFyc2VkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBbXTtcbiAgICAgICAgdGhpcy5sZXZlbHMgPSBkYXRhLmxldmVscztcbiAgICAgICAgdGhpcy5maXJzdExldmVsID0gZGF0YS5maXJzdExldmVsO1xuICAgICAgICBpZiAoaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSAmJiBkYXRhLnZpZGVvKSB7XG4gICAgICAgICAgICAvLyBTdGFydCBjYXBwaW5nIGltbWVkaWF0ZWx5IGlmIHRoZSBtYW5pZmVzdCBoYXMgc2lnbmFsZWQgdmlkZW8gY29kZWNzXG4gICAgICAgICAgICB0aGlzLl9zdGFydENhcHBpbmcoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gT25seSBhY3RpdmF0ZSBjYXBwaW5nIHdoZW4gcGxheWluZyBhIHZpZGVvIHN0cmVhbTsgb3RoZXJ3aXNlLCBtdWx0aS1iaXRyYXRlIGF1ZGlvLW9ubHkgc3RyZWFtcyB3aWxsIGJlIHJlc3RyaWN0ZWRcbiAgICAvLyB0byB0aGUgZmlyc3QgbGV2ZWxcbiAgICBDYXBMZXZlbENvbnRyb2xsZXIucHJvdG90eXBlLm9uQnVmZmVyQ29kZWNzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgICBpZiAoaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSAmJiBkYXRhLnZpZGVvKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgbWFuaWZlc3QgZGlkIG5vdCBzaWduYWwgYSB2aWRlbyBjb2RlYyBjYXBwaW5nIGhhcyBiZWVuIGRlZmVycmVkIHVudGlsIHdlJ3JlIGNlcnRhaW4gdmlkZW8gaXMgcHJlc2VudFxuICAgICAgICAgICAgdGhpcy5fc3RhcnRDYXBwaW5nKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhcExldmVsQ29udHJvbGxlci5wcm90b3R5cGUub25MZXZlbHNVcGRhdGVkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5sZXZlbHMgPSBkYXRhLmxldmVscztcbiAgICB9O1xuICAgIENhcExldmVsQ29udHJvbGxlci5wcm90b3R5cGUub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc3RvcENhcHBpbmcoKTtcbiAgICB9O1xuICAgIENhcExldmVsQ29udHJvbGxlci5wcm90b3R5cGUuZGV0ZWN0UGxheWVyU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgICAgICAgIHZhciBsZXZlbHNMZW5ndGggPSB0aGlzLmxldmVscyA/IHRoaXMubGV2ZWxzLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICBpZiAobGV2ZWxzTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhsc18xID0gdGhpcy5obHM7XG4gICAgICAgICAgICAgICAgaGxzXzEuYXV0b0xldmVsQ2FwcGluZyA9IHRoaXMuZ2V0TWF4TGV2ZWwobGV2ZWxzTGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgaWYgKGhsc18xLmF1dG9MZXZlbENhcHBpbmcgPiB0aGlzLmF1dG9MZXZlbENhcHBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgYXV0byBsZXZlbCBjYXBwaW5nIGhhcyBhIGhpZ2hlciB2YWx1ZSBmb3IgdGhlIHByZXZpb3VzIG9uZSwgZmx1c2ggdGhlIGJ1ZmZlciB1c2luZyBuZXh0TGV2ZWxTd2l0Y2hcbiAgICAgICAgICAgICAgICAgICAgLy8gdXN1YWxseSBoYXBwZW4gd2hlbiB0aGUgdXNlciBnbyB0byB0aGUgZnVsbHNjcmVlbiBtb2RlLlxuICAgICAgICAgICAgICAgICAgICBobHNfMS5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBobHNfMS5hdXRvTGV2ZWxDYXBwaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKlxuICAgICogcmV0dXJucyBsZXZlbCBzaG91bGQgYmUgdGhlIG9uZSB3aXRoIHRoZSBkaW1lbnNpb25zIGVxdWFsIG9yIGdyZWF0ZXIgdGhhbiB0aGUgbWVkaWEgKHBsYXllcikgZGltZW5zaW9ucyAoc28gdGhlIHZpZGVvIHdpbGwgYmUgZG93bnNjYWxlZClcbiAgICAqL1xuICAgIENhcExldmVsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0TWF4TGV2ZWwgPSBmdW5jdGlvbiAoY2FwTGV2ZWxJbmRleCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMubGV2ZWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbGlkTGV2ZWxzID0gdGhpcy5sZXZlbHMuZmlsdGVyKGZ1bmN0aW9uIChsZXZlbCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBDYXBMZXZlbENvbnRyb2xsZXIuaXNMZXZlbEFsbG93ZWQoaW5kZXgsIF90aGlzLnJlc3RyaWN0ZWRMZXZlbHMpICYmIGluZGV4IDw9IGNhcExldmVsSW5kZXg7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gQ2FwTGV2ZWxDb250cm9sbGVyLmdldE1heExldmVsQnlNZWRpYVNpemUodmFsaWRMZXZlbHMsIHRoaXMubWVkaWFXaWR0aCwgdGhpcy5tZWRpYUhlaWdodCk7XG4gICAgfTtcbiAgICBDYXBMZXZlbENvbnRyb2xsZXIucHJvdG90eXBlLl9zdGFydENhcHBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICAvLyBEb24ndCByZXNldCBjYXBwaW5nIGlmIHN0YXJ0ZWQgdHdpY2U7IHRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgbWFuaWZlc3Qgc2lnbmFscyBhIHZpZGVvIGNvZGVjXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICB0aGlzLmhscy5maXJzdExldmVsID0gdGhpcy5nZXRNYXhMZXZlbCh0aGlzLmZpcnN0TGV2ZWwpO1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5kZXRlY3RQbGF5ZXJTaXplLmJpbmQodGhpcyksIDEwMDApO1xuICAgICAgICB0aGlzLmRldGVjdFBsYXllclNpemUoKTtcbiAgICB9O1xuICAgIENhcExldmVsQ29udHJvbGxlci5wcm90b3R5cGUuX3N0b3BDYXBwaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBbXTtcbiAgICAgICAgdGhpcy5maXJzdExldmVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICAgICAgdGhpcy50aW1lciA9IGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhcExldmVsQ29udHJvbGxlci5wcm90b3R5cGUsIFwibWVkaWFXaWR0aFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHdpZHRoO1xuICAgICAgICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgICAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICAgICAgICAgIHdpZHRoID0gbWVkaWEud2lkdGggfHwgbWVkaWEuY2xpZW50V2lkdGggfHwgbWVkaWEub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgd2lkdGggKj0gQ2FwTGV2ZWxDb250cm9sbGVyLmNvbnRlbnRTY2FsZUZhY3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3aWR0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhcExldmVsQ29udHJvbGxlci5wcm90b3R5cGUsIFwibWVkaWFIZWlnaHRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBoZWlnaHQ7XG4gICAgICAgICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gbWVkaWEuaGVpZ2h0IHx8IG1lZGlhLmNsaWVudEhlaWdodCB8fCBtZWRpYS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ICo9IENhcExldmVsQ29udHJvbGxlci5jb250ZW50U2NhbGVGYWN0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGVpZ2h0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2FwTGV2ZWxDb250cm9sbGVyLCBcImNvbnRlbnRTY2FsZUZhY3RvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBpeGVsUmF0aW8gPSAxO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICByZXR1cm4gcGl4ZWxSYXRpbztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ2FwTGV2ZWxDb250cm9sbGVyLmlzTGV2ZWxBbGxvd2VkID0gZnVuY3Rpb24gKGxldmVsLCByZXN0cmljdGVkTGV2ZWxzKSB7XG4gICAgICAgIGlmIChyZXN0cmljdGVkTGV2ZWxzID09PSB2b2lkIDApIHsgcmVzdHJpY3RlZExldmVscyA9IFtdOyB9XG4gICAgICAgIHJldHVybiByZXN0cmljdGVkTGV2ZWxzLmluZGV4T2YobGV2ZWwpID09PSAtMTtcbiAgICB9O1xuICAgIENhcExldmVsQ29udHJvbGxlci5nZXRNYXhMZXZlbEJ5TWVkaWFTaXplID0gZnVuY3Rpb24gKGxldmVscywgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBpZiAoIWxldmVscyB8fCAobGV2ZWxzICYmICFsZXZlbHMubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIC8vIExldmVscyBjYW4gaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25zIGJ1dCBkaWZmZXJpbmcgYmFuZHdpZHRocyAtIHNpbmNlIGxldmVscyBhcmUgb3JkZXJlZCwgd2UgY2FuIGxvb2sgdG8gdGhlIG5leHRcbiAgICAgICAgLy8gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgd2UndmUgY2hvc2VuIHRoZSBncmVhdGVzdCBiYW5kd2lkdGggZm9yIHRoZSBtZWRpYSdzIGRpbWVuc2lvbnNcbiAgICAgICAgdmFyIGF0R3JlYXRlc3RCYW5kaXdkdGggPSBmdW5jdGlvbiAoY3VyTGV2ZWwsIG5leHRMZXZlbCkge1xuICAgICAgICAgICAgaWYgKCFuZXh0TGV2ZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJMZXZlbC53aWR0aCAhPT0gbmV4dExldmVsLndpZHRoIHx8IGN1ckxldmVsLmhlaWdodCAhPT0gbmV4dExldmVsLmhlaWdodDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSWYgd2UgcnVuIHRocm91Z2ggdGhlIGxvb3Agd2l0aG91dCBicmVha2luZywgdGhlIG1lZGlhJ3MgZGltZW5zaW9ucyBhcmUgZ3JlYXRlciB0aGFuIGV2ZXJ5IGxldmVsLCBzbyBkZWZhdWx0IHRvXG4gICAgICAgIC8vIHRoZSBtYXggbGV2ZWxcbiAgICAgICAgdmFyIG1heExldmVsSW5kZXggPSBsZXZlbHMubGVuZ3RoIC0gMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tpXTtcbiAgICAgICAgICAgIGlmICgobGV2ZWwud2lkdGggPj0gd2lkdGggfHwgbGV2ZWwuaGVpZ2h0ID49IGhlaWdodCkgJiYgYXRHcmVhdGVzdEJhbmRpd2R0aChsZXZlbCwgbGV2ZWxzW2kgKyAxXSkpIHtcbiAgICAgICAgICAgICAgICBtYXhMZXZlbEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4TGV2ZWxJbmRleDtcbiAgICB9O1xuICAgIHJldHVybiBDYXBMZXZlbENvbnRyb2xsZXI7XG59KGV2ZW50X2hhbmRsZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDYXBMZXZlbENvbnRyb2xsZXI7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci5qc1wiKVtcIk51bWJlclwiXSkpXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZW1lLWNvbnRyb2xsZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2VtZS1jb250cm9sbGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQGF1dGhvciBTdGVwaGFuIEhlc3NlIDxkaXNwYXJhdEBnbWFpbC5jb20+IHwgPHRjaGFrYWJhbUBnbWFpbC5jb20+XG4gKlxuICogRFJNIHN1cHBvcnQgZm9yIEhscy5qc1xuICovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBldmVudF9oYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudC1oYW5kbGVyICovIFwiLi9zcmMvZXZlbnQtaGFuZGxlci5qc1wiKTtcbnZhciBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy5qc1wiKTtcbnZhciBlcnJvcnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy5qc1wiKTtcbnZhciBsb2dnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci5qc1wiKTtcbnZhciBYTUxIdHRwUmVxdWVzdCA9IHdpbmRvdy5YTUxIdHRwUmVxdWVzdDtcbnZhciBNQVhfTElDRU5TRV9SRVFVRVNUX0ZBSUxVUkVTID0gMztcbi8qKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTmF2aWdhdG9yL3JlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc1xuICovXG52YXIgS2V5U3lzdGVtcyA9IHtcbiAgICBXSURFVklORTogJ2NvbS53aWRldmluZS5hbHBoYScsXG4gICAgUExBWVJFQURZOiAnY29tLm1pY3Jvc29mdC5wbGF5cmVhZHknXG59O1xuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYXVkaW9Db2RlY3MgTGlzdCBvZiByZXF1aXJlZCBhdWRpbyBjb2RlY3MgdG8gc3VwcG9ydFxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB2aWRlb0NvZGVjcyBMaXN0IG9mIHJlcXVpcmVkIHZpZGVvIGNvZGVjcyB0byBzdXBwb3J0XG4gKiBAcGFyYW0ge29iamVjdH0gZHJtU3lzdGVtT3B0aW9ucyBPcHRpb25hbCBwYXJhbWV0ZXJzL3JlcXVpcmVtZW50cyBmb3IgdGhlIGtleS1zeXN0ZW1cbiAqIEByZXR1cm5zIHtBcnJheTxNZWRpYVN5c3RlbUNvbmZpZ3VyYXRpb24+fSBBbiBhcnJheSBvZiBzdXBwb3J0ZWQgY29uZmlndXJhdGlvbnNcbiAqL1xudmFyIGNyZWF0ZVdpZGV2aW5lTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyA9IGZ1bmN0aW9uIChhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MsIGRybVN5c3RlbU9wdGlvbnMpIHtcbiAgICB2YXIgYmFzZUNvbmZpZyA9IHtcbiAgICAgICAgLy8gaW5pdERhdGFUeXBlczogWydrZXlpZHMnLCAnbXA0J10sXG4gICAgICAgIC8vIGxhYmVsOiBcIlwiLFxuICAgICAgICAvLyBwZXJzaXN0ZW50U3RhdGU6IFwibm90LWFsbG93ZWRcIiwgLy8gb3IgXCJyZXF1aXJlZFwiID9cbiAgICAgICAgLy8gZGlzdGluY3RpdmVJZGVudGlmaWVyOiBcIm5vdC1hbGxvd2VkXCIsIC8vIG9yIFwicmVxdWlyZWRcIiA/XG4gICAgICAgIC8vIHNlc3Npb25UeXBlczogWyd0ZW1wb3JhcnknXSxcbiAgICAgICAgdmlkZW9DYXBhYmlsaXRpZXM6IFtcbiAgICAgICAgLy8geyBjb250ZW50VHlwZTogJ3ZpZGVvL21wNDsgY29kZWNzPVwiYXZjMS40MkUwMUVcIicgfVxuICAgICAgICBdXG4gICAgfTtcbiAgICB2aWRlb0NvZGVjcy5mb3JFYWNoKGZ1bmN0aW9uIChjb2RlYykge1xuICAgICAgICBiYXNlQ29uZmlnLnZpZGVvQ2FwYWJpbGl0aWVzLnB1c2goe1xuICAgICAgICAgICAgY29udGVudFR5cGU6IFwidmlkZW8vbXA0OyBjb2RlY3M9XFxcIlwiICsgY29kZWMgKyBcIlxcXCJcIlxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gW1xuICAgICAgICBiYXNlQ29uZmlnXG4gICAgXTtcbn07XG4vKipcbiAqIFRoZSBpZGVhIGhlcmUgaXMgdG8gaGFuZGxlIGtleS1zeXN0ZW0gKGFuZCB0aGVpciByZXNwZWN0aXZlIHBsYXRmb3Jtcykgc3BlY2lmaWMgY29uZmlndXJhdGlvbiBkaWZmZXJlbmNlc1xuICogaW4gb3JkZXIgdG8gd29yayB3aXRoIHRoZSBsb2NhbCByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgbWV0aG9kLlxuICpcbiAqIFdlIGNhbiBhbHNvIHJ1bGUtb3V0IHBsYXRmb3JtLXJlbGF0ZWQga2V5LXN5c3RlbSBzdXBwb3J0IGF0IHRoaXMgcG9pbnQgYnkgdGhyb3dpbmcgYW4gZXJyb3Igb3IgcmV0dXJuaW5nIG51bGwuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleVN5c3RlbSBJZGVudGlmaWVyIGZvciB0aGUga2V5LXN5c3RlbSwgc2VlIGBLZXlTeXN0ZW1zYCBlbnVtXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGF1ZGlvQ29kZWNzIExpc3Qgb2YgcmVxdWlyZWQgYXVkaW8gY29kZWNzIHRvIHN1cHBvcnRcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gdmlkZW9Db2RlY3MgTGlzdCBvZiByZXF1aXJlZCB2aWRlbyBjb2RlY3MgdG8gc3VwcG9ydFxuICogQHJldHVybnMge0FycmF5PE1lZGlhU3lzdGVtQ29uZmlndXJhdGlvbj4gfCBudWxsfSBBIG5vbi1lbXB0eSBBcnJheSBvZiBNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb24gb2JqZWN0cyBvciBgbnVsbGBcbiAqL1xudmFyIGdldFN1cHBvcnRlZE1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbnMgPSBmdW5jdGlvbiAoa2V5U3lzdGVtLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MpIHtcbiAgICBzd2l0Y2ggKGtleVN5c3RlbSkge1xuICAgICAgICBjYXNlIEtleVN5c3RlbXMuV0lERVZJTkU6XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlV2lkZXZpbmVNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zKGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignVW5rbm93biBrZXktc3lzdGVtOiAnICsga2V5U3lzdGVtKTtcbiAgICB9XG59O1xuLyoqXG4gKiBDb250cm9sbGVyIHRvIGRlYWwgd2l0aCBlbmNyeXB0ZWQgbWVkaWEgZXh0ZW5zaW9ucyAoRU1FKVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRW5jcnlwdGVkX01lZGlhX0V4dGVuc2lvbnNfQVBJXG4gKlxuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEVNRUNvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVNRUNvbnRyb2xsZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICAgKiBAY29uc3RydWN0c1xuICAgICAgICogQHBhcmFtIHtIbHN9IGhscyBPdXIgSGxzLmpzIGluc3RhbmNlXG4gICAgICAgKi9cbiAgICBmdW5jdGlvbiBFTUVDb250cm9sbGVyKGhscykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBobHMsIGV2ZW50c18xLmRlZmF1bHQuTUVESUFfQVRUQUNIRUQsIGV2ZW50c18xLmRlZmF1bHQuTUFOSUZFU1RfUEFSU0VEKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fd2lkZXZpbmVMaWNlbnNlVXJsID0gaGxzLmNvbmZpZy53aWRldmluZUxpY2Vuc2VVcmw7XG4gICAgICAgIF90aGlzLl9saWNlbnNlWGhyU2V0dXAgPSBobHMuY29uZmlnLmxpY2Vuc2VYaHJTZXR1cDtcbiAgICAgICAgX3RoaXMuX2VtZUVuYWJsZWQgPSBobHMuY29uZmlnLmVtZUVuYWJsZWQ7XG4gICAgICAgIF90aGlzLl9yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgPSBobHMuY29uZmlnLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmM7XG4gICAgICAgIF90aGlzLl9tZWRpYUtleXNMaXN0ID0gW107XG4gICAgICAgIF90aGlzLl9tZWRpYSA9IG51bGw7XG4gICAgICAgIF90aGlzLl9oYXNTZXRNZWRpYUtleXMgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX2lzTWVkaWFFbmNyeXB0ZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5U3lzdGVtIElkZW50aWZpZXIgZm9yIHRoZSBrZXktc3lzdGVtLCBzZWUgYEtleVN5c3RlbXNgIGVudW1cbiAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IExpY2Vuc2Ugc2VydmVyIFVSTCBmb3Iga2V5LXN5c3RlbSAoaWYgYW55IGNvbmZpZ3VyZWQsIG90aGVyd2lzZSBjYXVzZXMgZXJyb3IpXG4gICAgICAgKi9cbiAgICBFTUVDb250cm9sbGVyLnByb3RvdHlwZS5nZXRMaWNlbnNlU2VydmVyVXJsID0gZnVuY3Rpb24gKGtleVN5c3RlbSkge1xuICAgICAgICB2YXIgdXJsO1xuICAgICAgICBzd2l0Y2ggKGtleVN5c3RlbSkge1xuICAgICAgICAgICAgY2FzZSBLZXlTeXN0ZW1zLldJREVWSU5FOlxuICAgICAgICAgICAgICAgIHVybCA9IHRoaXMuX3dpZGV2aW5lTGljZW5zZVVybDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdXJsID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXVybCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmVycm9yKFwiTm8gbGljZW5zZSBzZXJ2ZXIgVVJMIGNvbmZpZ3VyZWQgZm9yIGtleS1zeXN0ZW0gXFxcIlwiICsga2V5U3lzdGVtICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkVSUk9SLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogZXJyb3JzXzEuRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGVycm9yc18xLkVycm9yRGV0YWlscy5LRVlfU1lTVEVNX0xJQ0VOU0VfUkVRVUVTVF9GQUlMRUQsXG4gICAgICAgICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgICAqIFJlcXVlc3RzIGFjY2VzcyBvYmplY3QgYW5kIGFkZHMgaXQgdG8gb3VyIGxpc3QgdXBvbiBzdWNjZXNzXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVN5c3RlbSBTeXN0ZW0gSUQgKHNlZSBgS2V5U3lzdGVtc2ApXG4gICAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGF1ZGlvQ29kZWNzIExpc3Qgb2YgcmVxdWlyZWQgYXVkaW8gY29kZWNzIHRvIHN1cHBvcnRcbiAgICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gdmlkZW9Db2RlY3MgTGlzdCBvZiByZXF1aXJlZCB2aWRlbyBjb2RlY3MgdG8gc3VwcG9ydFxuICAgICAgICovXG4gICAgRU1FQ29udHJvbGxlci5wcm90b3R5cGUuX2F0dGVtcHRLZXlTeXN0ZW1BY2Nlc3MgPSBmdW5jdGlvbiAoa2V5U3lzdGVtLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MpIHtcbiAgICAgICAgLy8gVE9ETzogYWRkIG90aGVyIERSTSBcIm9wdGlvbnNcIlxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbWVkaWFLZXlTeXN0ZW1Db25maWdzID0gZ2V0U3VwcG9ydGVkTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyhrZXlTeXN0ZW0sIGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcyk7XG4gICAgICAgIGlmICghbWVkaWFLZXlTeXN0ZW1Db25maWdzKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybignQ2FuIG5vdCBjcmVhdGUgY29uZmlnIGZvciBrZXktc3lzdGVtIChtYXliZSBiZWNhdXNlIHBsYXRmb3JtIGlzIG5vdCBzdXBwb3J0ZWQpOicsIGtleVN5c3RlbSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnUmVxdWVzdGluZyBlbmNyeXB0ZWQgbWVkaWEga2V5LXN5c3RlbSBhY2Nlc3MnKTtcbiAgICAgICAgLy8gZXhwZWN0aW5nIGludGVyZmFjZSBsaWtlIHdpbmRvdy5uYXZpZ2F0b3IucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzXG4gICAgICAgIHRoaXMucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzKGtleVN5c3RlbSwgbWVkaWFLZXlTeXN0ZW1Db25maWdzKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG1lZGlhS2V5U3lzdGVtQWNjZXNzKSB7XG4gICAgICAgICAgICBfdGhpcy5fb25NZWRpYUtleVN5c3RlbUFjY2Vzc09idGFpbmVkKGtleVN5c3RlbSwgbWVkaWFLZXlTeXN0ZW1BY2Nlc3MpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBvYnRhaW4ga2V5LXN5c3RlbSBcXFwiXCIgKyBrZXlTeXN0ZW0gKyBcIlxcXCIgYWNjZXNzOlwiLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFTUVDb250cm9sbGVyLnByb3RvdHlwZSwgXCJyZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgZnVuY3Rpb24gY29uZmlndXJlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICAgKiBIYW5kbGVzIG9idGFpbmluZyBhY2Nlc3MgdG8gYSBrZXktc3lzdGVtXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVN5c3RlbVxuICAgICAgICogQHBhcmFtIHtNZWRpYUtleVN5c3RlbUFjY2Vzc30gbWVkaWFLZXlTeXN0ZW1BY2Nlc3MgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhS2V5U3lzdGVtQWNjZXNzXG4gICAgICAgKi9cbiAgICBFTUVDb250cm9sbGVyLnByb3RvdHlwZS5fb25NZWRpYUtleVN5c3RlbUFjY2Vzc09idGFpbmVkID0gZnVuY3Rpb24gKGtleVN5c3RlbSwgbWVkaWFLZXlTeXN0ZW1BY2Nlc3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIkFjY2VzcyBmb3Iga2V5LXN5c3RlbSBcXFwiXCIgKyBrZXlTeXN0ZW0gKyBcIlxcXCIgb2J0YWluZWRcIik7XG4gICAgICAgIHZhciBtZWRpYUtleXNMaXN0SXRlbSA9IHtcbiAgICAgICAgICAgIG1lZGlhS2V5czogbnVsbCxcbiAgICAgICAgICAgIG1lZGlhS2V5c1Nlc3Npb246IG51bGwsXG4gICAgICAgICAgICBtZWRpYUtleXNTZXNzaW9uSW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgbWVkaWFLZXlTeXN0ZW1BY2Nlc3M6IG1lZGlhS2V5U3lzdGVtQWNjZXNzLFxuICAgICAgICAgICAgbWVkaWFLZXlTeXN0ZW1Eb21haW46IGtleVN5c3RlbVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9tZWRpYUtleXNMaXN0LnB1c2gobWVkaWFLZXlzTGlzdEl0ZW0pO1xuICAgICAgICBtZWRpYUtleVN5c3RlbUFjY2Vzcy5jcmVhdGVNZWRpYUtleXMoKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG1lZGlhS2V5cykge1xuICAgICAgICAgICAgbWVkaWFLZXlzTGlzdEl0ZW0ubWVkaWFLZXlzID0gbWVkaWFLZXlzO1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIk1lZGlhLWtleXMgY3JlYXRlZCBmb3Iga2V5LXN5c3RlbSBcXFwiXCIgKyBrZXlTeXN0ZW0gKyBcIlxcXCJcIik7XG4gICAgICAgICAgICBfdGhpcy5fb25NZWRpYUtleXNDcmVhdGVkKCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIG1lZGlhLWtleXM6JywgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgICAqIEhhbmRsZXMga2V5LWNyZWF0aW9uIChyZXByZXNlbnRzIGFjY2VzcyB0byBDRE0pLiBXZSBhcmUgZ29pbmcgdG8gY3JlYXRlIGtleS1zZXNzaW9ucyB1cG9uIHRoaXNcbiAgICAgICAqIGZvciBhbGwgZXhpc3Rpbmcga2V5cyB3aGVyZSBubyBzZXNzaW9uIGV4aXN0cyB5ZXQuXG4gICAgICAgKi9cbiAgICBFTUVDb250cm9sbGVyLnByb3RvdHlwZS5fb25NZWRpYUtleXNDcmVhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBjaGVjayBmb3IgYWxsIGtleS1saXN0IGl0ZW1zIGlmIGEgc2Vzc2lvbiBleGlzdHMsIG90aGVyd2lzZSwgY3JlYXRlIG9uZVxuICAgICAgICB0aGlzLl9tZWRpYUtleXNMaXN0LmZvckVhY2goZnVuY3Rpb24gKG1lZGlhS2V5c0xpc3RJdGVtKSB7XG4gICAgICAgICAgICBpZiAoIW1lZGlhS2V5c0xpc3RJdGVtLm1lZGlhS2V5c1Nlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBtZWRpYUtleXNMaXN0SXRlbS5tZWRpYUtleXNTZXNzaW9uID0gbWVkaWFLZXlzTGlzdEl0ZW0ubWVkaWFLZXlzLmNyZWF0ZVNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fb25OZXdNZWRpYUtleVNlc3Npb24obWVkaWFLZXlzTGlzdEl0ZW0ubWVkaWFLZXlzU2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsqfSBrZXlTZXNzaW9uXG4gICAgICAgKi9cbiAgICBFTUVDb250cm9sbGVyLnByb3RvdHlwZS5fb25OZXdNZWRpYUtleVNlc3Npb24gPSBmdW5jdGlvbiAoa2V5U2Vzc2lvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiTmV3IGtleS1zeXN0ZW0gc2Vzc2lvbiBcIiArIGtleVNlc3Npb24uc2Vzc2lvbklkKTtcbiAgICAgICAga2V5U2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBfdGhpcy5fb25LZXlTZXNzaW9uTWVzc2FnZShrZXlTZXNzaW9uLCBldmVudC5tZXNzYWdlKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgIH07XG4gICAgRU1FQ29udHJvbGxlci5wcm90b3R5cGUuX29uS2V5U2Vzc2lvbk1lc3NhZ2UgPSBmdW5jdGlvbiAoa2V5U2Vzc2lvbiwgbWVzc2FnZSkge1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdHb3QgRU1FIG1lc3NhZ2UgZXZlbnQsIGNyZWF0aW5nIGxpY2Vuc2UgcmVxdWVzdCcpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZShtZXNzYWdlLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnUmVjZWl2ZWQgbGljZW5zZSBkYXRhLCB1cGRhdGluZyBrZXktc2Vzc2lvbicpO1xuICAgICAgICAgICAga2V5U2Vzc2lvbi51cGRhdGUoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRU1FQ29udHJvbGxlci5wcm90b3R5cGUuX29uTWVkaWFFbmNyeXB0ZWQgPSBmdW5jdGlvbiAoaW5pdERhdGFUeXBlLCBpbml0RGF0YSkge1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiTWVkaWEgaXMgZW5jcnlwdGVkIHVzaW5nIFxcXCJcIiArIGluaXREYXRhVHlwZSArIFwiXFxcIiBpbml0IGRhdGEgdHlwZVwiKTtcbiAgICAgICAgdGhpcy5faXNNZWRpYUVuY3J5cHRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX21lZGlhRW5jcnlwdGlvbkluaXREYXRhVHlwZSA9IGluaXREYXRhVHlwZTtcbiAgICAgICAgdGhpcy5fbWVkaWFFbmNyeXB0aW9uSW5pdERhdGEgPSBpbml0RGF0YTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdFNldE1lZGlhS2V5cygpO1xuICAgICAgICB0aGlzLl9nZW5lcmF0ZVJlcXVlc3RXaXRoUHJlZmVycmVkS2V5U2Vzc2lvbigpO1xuICAgIH07XG4gICAgRU1FQ29udHJvbGxlci5wcm90b3R5cGUuX2F0dGVtcHRTZXRNZWRpYUtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5faGFzU2V0TWVkaWFLZXlzKSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogc2VlIGlmIHdlIGNhbi93YW50L25lZWQtdG8gcmVhbGx5IHRvIGRlYWwgd2l0aCBzZXZlcmFsIHBvdGVudGlhbCBrZXktc2Vzc2lvbnM/XG4gICAgICAgICAgICB2YXIga2V5c0xpc3RJdGVtID0gdGhpcy5fbWVkaWFLZXlzTGlzdFswXTtcbiAgICAgICAgICAgIGlmICgha2V5c0xpc3RJdGVtIHx8ICFrZXlzTGlzdEl0ZW0ubWVkaWFLZXlzKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmVycm9yKCdGYXRhbDogTWVkaWEgaXMgZW5jcnlwdGVkIGJ1dCBubyBDRE0gYWNjZXNzIG9yIG5vIGtleXMgaGF2ZSBiZWVuIG9idGFpbmVkIHlldCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBlcnJvcnNfMS5FcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGVycm9yc18xLkVycm9yRGV0YWlscy5LRVlfU1lTVEVNX05PX0tFWVMsXG4gICAgICAgICAgICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnU2V0dGluZyBrZXlzIGZvciBlbmNyeXB0ZWQgbWVkaWEnKTtcbiAgICAgICAgICAgIHRoaXMuX21lZGlhLnNldE1lZGlhS2V5cyhrZXlzTGlzdEl0ZW0ubWVkaWFLZXlzKTtcbiAgICAgICAgICAgIHRoaXMuX2hhc1NldE1lZGlhS2V5cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVNRUNvbnRyb2xsZXIucHJvdG90eXBlLl9nZW5lcmF0ZVJlcXVlc3RXaXRoUHJlZmVycmVkS2V5U2Vzc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gRklYTUU6IHNlZSBpZiB3ZSBjYW4vd2FudC9uZWVkLXRvIHJlYWxseSB0byBkZWFsIHdpdGggc2V2ZXJhbCBwb3RlbnRpYWwga2V5LXNlc3Npb25zP1xuICAgICAgICB2YXIga2V5c0xpc3RJdGVtID0gdGhpcy5fbWVkaWFLZXlzTGlzdFswXTtcbiAgICAgICAgaWYgKCFrZXlzTGlzdEl0ZW0pIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5lcnJvcignRmF0YWw6IE1lZGlhIGlzIGVuY3J5cHRlZCBidXQgbm90IGFueSBrZXktc3lzdGVtIGFjY2VzcyBoYXMgYmVlbiBvYnRhaW5lZCB5ZXQnKTtcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwge1xuICAgICAgICAgICAgICAgIHR5cGU6IGVycm9yc18xLkVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBlcnJvcnNfMS5FcnJvckRldGFpbHMuS0VZX1NZU1RFTV9OT19BQ0NFU1MsXG4gICAgICAgICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlzTGlzdEl0ZW0ubWVkaWFLZXlzU2Vzc2lvbkluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybignS2V5LVNlc3Npb24gYWxyZWFkeSBpbml0aWFsaXplZCBidXQgcmVxdWVzdGVkIGFnYWluJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleVNlc3Npb24gPSBrZXlzTGlzdEl0ZW0ubWVkaWFLZXlzU2Vzc2lvbjtcbiAgICAgICAgaWYgKCFrZXlTZXNzaW9uKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIuZXJyb3IoJ0ZhdGFsOiBNZWRpYSBpcyBlbmNyeXB0ZWQgYnV0IG5vIGtleS1zZXNzaW9uIGV4aXN0aW5nJyk7XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBlcnJvcnNfMS5FcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogZXJyb3JzXzEuRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTk9fU0VTU0lPTixcbiAgICAgICAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluaXREYXRhVHlwZSA9IHRoaXMuX21lZGlhRW5jcnlwdGlvbkluaXREYXRhVHlwZTtcbiAgICAgICAgdmFyIGluaXREYXRhID0gdGhpcy5fbWVkaWFFbmNyeXB0aW9uSW5pdERhdGE7XG4gICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJHZW5lcmF0aW5nIGtleS1zZXNzaW9uIHJlcXVlc3QgZm9yIFxcXCJcIiArIGluaXREYXRhVHlwZSArIFwiXFxcIiBpbml0IGRhdGEgdHlwZVwiKTtcbiAgICAgICAga2V5c0xpc3RJdGVtLm1lZGlhS2V5c1Nlc3Npb25Jbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIGtleVNlc3Npb24uZ2VuZXJhdGVSZXF1ZXN0KGluaXREYXRhVHlwZSwgaW5pdERhdGEpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIuZGVidWcoJ0tleS1zZXNzaW9uIGdlbmVyYXRpb24gc3VjY2VlZGVkJyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmVycm9yKCdFcnJvciBnZW5lcmF0aW5nIGtleS1zZXNzaW9uIHJlcXVlc3Q6JywgZXJyKTtcbiAgICAgICAgICAgIF90aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBlcnJvcnNfMS5FcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogZXJyb3JzXzEuRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTk9fU0VTU0lPTixcbiAgICAgICAgICAgICAgICBmYXRhbDogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBMaWNlbnNlIHNlcnZlciBVUkxcbiAgICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGtleU1lc3NhZ2UgTWVzc2FnZSBkYXRhIGlzc3VlZCBieSBrZXktc3lzdGVtXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgd2hlbiBYSFIgaGFzIHN1Y2NlZWRlZFxuICAgICAgICogQHJldHVybnMge1hNTEh0dHBSZXF1ZXN0fSBVbnNlbnQgKGJ1dCBvcGVuZWQgc3RhdGUpIFhIUiBvYmplY3RcbiAgICAgICAqL1xuICAgIEVNRUNvbnRyb2xsZXIucHJvdG90eXBlLl9jcmVhdGVMaWNlbnNlWGhyID0gZnVuY3Rpb24gKHVybCwga2V5TWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB2YXIgbGljZW5zZVhoclNldHVwID0gdGhpcy5fbGljZW5zZVhoclNldHVwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGxpY2Vuc2VYaHJTZXR1cCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGxpY2Vuc2VYaHJTZXR1cCh4aHIsIHVybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxldCdzIHRyeSB0byBvcGVuIGJlZm9yZSBydW5uaW5nIHNldHVwXG4gICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKCdQT1NUJywgdXJsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgbGljZW5zZVhoclNldHVwKHhociwgdXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBsaWNlbnNlWGhyU2V0dXAgZGlkIG5vdCB5ZXQgY2FsbCBvcGVuLCBsZXQncyBkbyBpdCBub3dcbiAgICAgICAgICAgIGlmICgheGhyLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgICAgICB4aHIub3BlbignUE9TVCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIElFMTEgdGhyb3dzIGFuIGV4Y2VwdGlvbiBvbiB4aHIub3BlbiBpZiBhdHRlbXB0aW5nIHRvIGFjY2VzcyBhbiBIVFRQIHJlc291cmNlIG92ZXIgSFRUUFNcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5lcnJvcignRXJyb3Igc2V0dGluZyB1cCBrZXktc3lzdGVtIGxpY2Vuc2UgWEhSJywgZSk7XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBlcnJvcnNfMS5FcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogZXJyb3JzXzEuRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTElDRU5TRV9SRVFVRVNUX0ZBSUxFRCxcbiAgICAgICAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPVxuICAgICAgICAgICAgdGhpcy5fb25MaWNlbnNlUmVxdWVzdFJlYWR5U3RhZ2VDaGFuZ2UuYmluZCh0aGlzLCB4aHIsIHVybCwga2V5TWVzc2FnZSwgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4geGhyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge1hNTEh0dHBSZXF1ZXN0fSB4aHJcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgTGljZW5zZSBzZXJ2ZXIgVVJMXG4gICAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBrZXlNZXNzYWdlIE1lc3NhZ2UgZGF0YSBpc3N1ZWQgYnkga2V5LXN5c3RlbVxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIHdoZW4gWEhSIGhhcyBzdWNjZWVkZWRcbiAgICAgICAqXG4gICAgICAgKi9cbiAgICBFTUVDb250cm9sbGVyLnByb3RvdHlwZS5fb25MaWNlbnNlUmVxdWVzdFJlYWR5U3RhZ2VDaGFuZ2UgPSBmdW5jdGlvbiAoeGhyLCB1cmwsIGtleU1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gICAgICAgIHN3aXRjaCAoeGhyLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnTGljZW5zZSByZXF1ZXN0IHN1Y2NlZWRlZCcpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh4aHIucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmVycm9yKFwiTGljZW5zZSBSZXF1ZXN0IFhIUiBmYWlsZWQgKFwiICsgdXJsICsgXCIpLiBTdGF0dXM6IFwiICsgeGhyLnN0YXR1cyArIFwiIChcIiArIHhoci5zdGF0dXNUZXh0ICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQgPD0gTUFYX0xJQ0VOU0VfUkVRVUVTVF9GQUlMVVJFUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dGVtcHRzTGVmdCA9IE1BWF9MSUNFTlNFX1JFUVVFU1RfRkFJTFVSRVMgLSB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybihcIlJldHJ5aW5nIGxpY2Vuc2UgcmVxdWVzdCwgXCIgKyBhdHRlbXB0c0xlZnQgKyBcIiBhdHRlbXB0cyBsZWZ0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVxdWVzdExpY2Vuc2Uoa2V5TWVzc2FnZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZXJyb3JzXzEuRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogZXJyb3JzXzEuRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTElDRU5TRV9SRVFVRVNUX0ZBSUxFRCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0ga2V5c0xpc3RJdGVtXG4gICAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBrZXlNZXNzYWdlXG4gICAgICAgKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IENoYWxsZW5nZSBkYXRhIHBvc3RlZCB0byBsaWNlbnNlIHNlcnZlclxuICAgICAgICovXG4gICAgRU1FQ29udHJvbGxlci5wcm90b3R5cGUuX2dlbmVyYXRlTGljZW5zZVJlcXVlc3RDaGFsbGVuZ2UgPSBmdW5jdGlvbiAoa2V5c0xpc3RJdGVtLCBrZXlNZXNzYWdlKSB7XG4gICAgICAgIHZhciBjaGFsbGVuZ2U7XG4gICAgICAgIGlmIChrZXlzTGlzdEl0ZW0ubWVkaWFLZXlTeXN0ZW1Eb21haW4gPT09IEtleVN5c3RlbXMuUExBWVJFQURZKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIuZXJyb3IoJ1BsYXlSZWFkeSBpcyBub3Qgc3VwcG9ydGVkICh5ZXQpJyk7XG4gICAgICAgICAgICAvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnRFZGdlL0RlbW9zL2Jsb2IvbWFzdGVyL2VtZS9zY3JpcHRzL2RlbW8uanNcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgIGlmICh0aGlzLmxpY2Vuc2VUeXBlICE9PSB0aGlzLkxJQ0VOU0VfVFlQRV9XSURFVklORSkge1xuICAgICAgICAgICAgICAgICAgLy8gRm9yIFBsYXlSZWFkeSBDRE1zLCB3ZSBuZWVkIHRvIGRpZyB0aGUgQ2hhbGxlbmdlIG91dCBvZiB0aGUgWE1MLlxuICAgICAgICAgICAgICAgICAgdmFyIGtleU1lc3NhZ2VYbWwgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQxNkFycmF5KGtleU1lc3NhZ2UpKSwgJ2FwcGxpY2F0aW9uL3htbCcpO1xuICAgICAgICAgICAgICAgICAgaWYgKGtleU1lc3NhZ2VYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0NoYWxsZW5nZScpWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhbGxlbmdlID0gYXRvYihrZXlNZXNzYWdlWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdDaGFsbGVuZ2UnKVswXS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93ICdDYW5ub3QgZmluZCA8Q2hhbGxlbmdlPiBpbiBrZXkgbWVzc2FnZSc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2YXIgaGVhZGVyTmFtZXMgPSBrZXlNZXNzYWdlWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCduYW1lJyk7XG4gICAgICAgICAgICAgICAgICB2YXIgaGVhZGVyVmFsdWVzID0ga2V5TWVzc2FnZVhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndmFsdWUnKTtcbiAgICAgICAgICAgICAgICAgIGlmIChoZWFkZXJOYW1lcy5sZW5ndGggIT09IGhlYWRlclZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnTWlzbWF0Y2hlZCBoZWFkZXIgPG5hbWU+Lzx2YWx1ZT4gcGFpciBpbiBrZXkgbWVzc2FnZSc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhlYWRlck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyTmFtZXNbaV0uY2hpbGROb2Rlc1swXS5ub2RlVmFsdWUsIGhlYWRlclZhbHVlc1tpXS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKi9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXlzTGlzdEl0ZW0ubWVkaWFLZXlTeXN0ZW1Eb21haW4gPT09IEtleVN5c3RlbXMuV0lERVZJTkUpIHtcbiAgICAgICAgICAgIC8vIEZvciBXaWRldmluZSBDRE1zLCB0aGUgY2hhbGxlbmdlIGlzIHRoZSBrZXlNZXNzYWdlLlxuICAgICAgICAgICAgY2hhbGxlbmdlID0ga2V5TWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5lcnJvcignVW5zdXBwb3J0ZWQga2V5LXN5c3RlbTonLCBrZXlzTGlzdEl0ZW0ubWVkaWFLZXlTeXN0ZW1Eb21haW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFsbGVuZ2U7XG4gICAgfTtcbiAgICBFTUVDb250cm9sbGVyLnByb3RvdHlwZS5fcmVxdWVzdExpY2Vuc2UgPSBmdW5jdGlvbiAoa2V5TWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnUmVxdWVzdGluZyBjb250ZW50IGxpY2Vuc2UgZm9yIGtleS1zeXN0ZW0nKTtcbiAgICAgICAgdmFyIGtleXNMaXN0SXRlbSA9IHRoaXMuX21lZGlhS2V5c0xpc3RbMF07XG4gICAgICAgIGlmICgha2V5c0xpc3RJdGVtKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIuZXJyb3IoJ0ZhdGFsIGVycm9yOiBNZWRpYSBpcyBlbmNyeXB0ZWQgYnV0IG5vIGtleS1zeXN0ZW0gYWNjZXNzIGhhcyBiZWVuIG9idGFpbmVkIHlldCcpO1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkVSUk9SLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogZXJyb3JzXzEuRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGVycm9yc18xLkVycm9yRGV0YWlscy5LRVlfU1lTVEVNX05PX0FDQ0VTUyxcbiAgICAgICAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVybCA9IHRoaXMuZ2V0TGljZW5zZVNlcnZlclVybChrZXlzTGlzdEl0ZW0ubWVkaWFLZXlTeXN0ZW1Eb21haW4pO1xuICAgICAgICB2YXIgeGhyID0gdGhpcy5fY3JlYXRlTGljZW5zZVhocih1cmwsIGtleU1lc3NhZ2UsIGNhbGxiYWNrKTtcbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIlNlbmRpbmcgbGljZW5zZSByZXF1ZXN0IHRvIFVSTDogXCIgKyB1cmwpO1xuICAgICAgICB4aHIuc2VuZCh0aGlzLl9nZW5lcmF0ZUxpY2Vuc2VSZXF1ZXN0Q2hhbGxlbmdlKGtleXNMaXN0SXRlbSwga2V5TWVzc2FnZSkpO1xuICAgIH07XG4gICAgRU1FQ29udHJvbGxlci5wcm90b3R5cGUub25NZWRpYUF0dGFjaGVkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLl9lbWVFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICAgICAgLy8ga2VlcCByZWZlcmVuY2Ugb2YgbWVkaWFcbiAgICAgICAgdGhpcy5fbWVkaWEgPSBtZWRpYTtcbiAgICAgICAgLy8gRklYTUU6IGFsc28gaGFuZGxlIGRldGFjaGluZyBtZWRpYSAhXG4gICAgICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ2VuY3J5cHRlZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBfdGhpcy5fb25NZWRpYUVuY3J5cHRlZChlLmluaXREYXRhVHlwZSwgZS5pbml0RGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRU1FQ29udHJvbGxlci5wcm90b3R5cGUub25NYW5pZmVzdFBhcnNlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICghdGhpcy5fZW1lRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdWRpb0NvZGVjcyA9IGRhdGEubGV2ZWxzLm1hcChmdW5jdGlvbiAobGV2ZWwpIHsgcmV0dXJuIGxldmVsLmF1ZGlvQ29kZWM7IH0pO1xuICAgICAgICB2YXIgdmlkZW9Db2RlY3MgPSBkYXRhLmxldmVscy5tYXAoZnVuY3Rpb24gKGxldmVsKSB7IHJldHVybiBsZXZlbC52aWRlb0NvZGVjOyB9KTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdEtleVN5c3RlbUFjY2VzcyhLZXlTeXN0ZW1zLldJREVWSU5FLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MpO1xuICAgIH07XG4gICAgcmV0dXJuIEVNRUNvbnRyb2xsZXI7XG59KGV2ZW50X2hhbmRsZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBFTUVDb250cm9sbGVyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZnBzLWNvbnRyb2xsZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2Zwcy1jb250cm9sbGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gKiBGUFMgQ29udHJvbGxlclxuKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLmpzXCIpO1xudmFyIGV2ZW50X2hhbmRsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50LWhhbmRsZXIgKi8gXCIuL3NyYy9ldmVudC1oYW5kbGVyLmpzXCIpO1xudmFyIGxvZ2dlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLmpzXCIpO1xudmFyIHBlcmZvcm1hbmNlID0gd2luZG93LnBlcmZvcm1hbmNlO1xudmFyIEZQU0NvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZQU0NvbnRyb2xsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRlBTQ29udHJvbGxlcihobHMpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGhscywgZXZlbnRzXzEuZGVmYXVsdC5NRURJQV9BVFRBQ0hJTkcpIHx8IHRoaXM7XG4gICAgfVxuICAgIEZQU0NvbnRyb2xsZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSA9IGZhbHNlO1xuICAgIH07XG4gICAgRlBTQ29udHJvbGxlci5wcm90b3R5cGUub25NZWRpYUF0dGFjaGluZyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgICAgIGlmIChjb25maWcuY2FwTGV2ZWxPbkZQU0Ryb3ApIHtcbiAgICAgICAgICAgIHZhciB2aWRlb18xID0gdGhpcy52aWRlbyA9IGRhdGEubWVkaWEgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTFZpZGVvRWxlbWVudCA/IGRhdGEubWVkaWEgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2aWRlb18xLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5jaGVja0ZQU0ludGVydmFsLmJpbmQodGhpcyksIGNvbmZpZy5mcHNEcm9wcGVkTW9uaXRvcmluZ1BlcmlvZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZQU0NvbnRyb2xsZXIucHJvdG90eXBlLmNoZWNrRlBTID0gZnVuY3Rpb24gKHZpZGVvLCBkZWNvZGVkRnJhbWVzLCBkcm9wcGVkRnJhbWVzKSB7XG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBpZiAoZGVjb2RlZEZyYW1lcykge1xuICAgICAgICAgICAgaWYgKHRoaXMubGFzdFRpbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFBlcmlvZCA9IGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0VGltZSwgY3VycmVudERyb3BwZWQgPSBkcm9wcGVkRnJhbWVzIC0gdGhpcy5sYXN0RHJvcHBlZEZyYW1lcywgY3VycmVudERlY29kZWQgPSBkZWNvZGVkRnJhbWVzIC0gdGhpcy5sYXN0RGVjb2RlZEZyYW1lcywgZHJvcHBlZEZQUyA9IDEwMDAgKiBjdXJyZW50RHJvcHBlZCAvIGN1cnJlbnRQZXJpb2QsIGhsc18xID0gdGhpcy5obHM7XG4gICAgICAgICAgICAgICAgaGxzXzEudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkZQU19EUk9QLCB7IGN1cnJlbnREcm9wcGVkOiBjdXJyZW50RHJvcHBlZCwgY3VycmVudERlY29kZWQ6IGN1cnJlbnREZWNvZGVkLCB0b3RhbERyb3BwZWRGcmFtZXM6IGRyb3BwZWRGcmFtZXMgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGRyb3BwZWRGUFMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ2NoZWNrRlBTIDogZHJvcHBlZEZQUy9kZWNvZGVkRlBTOicgKyBkcm9wcGVkRlBTLygxMDAwICogY3VycmVudERlY29kZWQgLyBjdXJyZW50UGVyaW9kKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RHJvcHBlZCA+IGhsc18xLmNvbmZpZy5mcHNEcm9wcGVkTW9uaXRvcmluZ1RocmVzaG9sZCAqIGN1cnJlbnREZWNvZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudExldmVsID0gaGxzXzEuY3VycmVudExldmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oJ2Ryb3AgRlBTIHJhdGlvIGdyZWF0ZXIgdGhhbiBtYXggYWxsb3dlZCB2YWx1ZSBmb3IgY3VycmVudExldmVsOiAnICsgY3VycmVudExldmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TGV2ZWwgPiAwICYmIChobHNfMS5hdXRvTGV2ZWxDYXBwaW5nID09PSAtMSB8fCBobHNfMS5hdXRvTGV2ZWxDYXBwaW5nID49IGN1cnJlbnRMZXZlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBjdXJyZW50TGV2ZWwgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhsc18xLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLCB7IGxldmVsOiBjdXJyZW50TGV2ZWwsIGRyb3BwZWRMZXZlbDogaGxzXzEuY3VycmVudExldmVsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhsc18xLmF1dG9MZXZlbENhcHBpbmcgPSBjdXJyZW50TGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGxzXzEuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGFzdFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgICAgICAgIHRoaXMubGFzdERyb3BwZWRGcmFtZXMgPSBkcm9wcGVkRnJhbWVzO1xuICAgICAgICAgICAgdGhpcy5sYXN0RGVjb2RlZEZyYW1lcyA9IGRlY29kZWRGcmFtZXM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZQU0NvbnRyb2xsZXIucHJvdG90eXBlLmNoZWNrRlBTSW50ZXJ2YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2aWRlbyA9IHRoaXMudmlkZW87XG4gICAgICAgIGlmICh2aWRlbykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSkge1xuICAgICAgICAgICAgICAgIHZhciB2aWRlb1BsYXliYWNrUXVhbGl0eSA9IHZpZGVvLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0ZQUyh2aWRlbywgdmlkZW9QbGF5YmFja1F1YWxpdHkudG90YWxWaWRlb0ZyYW1lcywgdmlkZW9QbGF5YmFja1F1YWxpdHkuZHJvcHBlZFZpZGVvRnJhbWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tGUFModmlkZW8sIHZpZGVvLndlYmtpdERlY29kZWRGcmFtZUNvdW50LCB2aWRlby53ZWJraXREcm9wcGVkRnJhbWVDb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBGUFNDb250cm9sbGVyO1xufShldmVudF9oYW5kbGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRlBTQ29udHJvbGxlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2ZyYWdtZW50LWZpbmRlcnMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtZmluZGVycy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oTnVtYmVyKSB7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYmluYXJ5X3NlYXJjaF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvYmluYXJ5LXNlYXJjaCAqLyBcIi4vc3JjL3V0aWxzL2JpbmFyeS1zZWFyY2guanNcIik7XG4vKipcbiAqIFJldHVybnMgZmlyc3QgZnJhZ21lbnQgd2hvc2UgZW5kUGR0IHZhbHVlIGV4Y2VlZHMgdGhlIGdpdmVuIFBEVC5cbiAqIEBwYXJhbSB7QXJyYXk8RnJhZ21lbnQ+fSBmcmFnbWVudHMgLSBUaGUgYXJyYXkgb2YgY2FuZGlkYXRlIGZyYWdtZW50c1xuICogQHBhcmFtIHtudW1iZXJ8bnVsbH0gW1BEVFZhbHVlID0gbnVsbF0gLSBUaGUgUERUIHZhbHVlIHdoaWNoIG11c3QgYmUgZXhjZWVkZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDBdIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0L2VuZCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICogQHJldHVybnMgeyp8bnVsbH0gZnJhZ21lbnQgLSBUaGUgYmVzdCBtYXRjaGluZyBmcmFnbWVudFxuICovXG5mdW5jdGlvbiBmaW5kRnJhZ21lbnRCeVBEVChmcmFnbWVudHMsIFBEVFZhbHVlLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGZyYWdtZW50cykgfHwgIWZyYWdtZW50cy5sZW5ndGggfHwgIU51bWJlci5pc0Zpbml0ZShQRFRWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIGlmIGxlc3MgdGhhbiBzdGFydFxuICAgIGlmIChQRFRWYWx1ZSA8IGZyYWdtZW50c1swXS5wcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChQRFRWYWx1ZSA+PSBmcmFnbWVudHNbZnJhZ21lbnRzLmxlbmd0aCAtIDFdLmVuZFByb2dyYW1EYXRlVGltZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IG1heEZyYWdMb29rVXBUb2xlcmFuY2UgfHwgMDtcbiAgICBmb3IgKHZhciBzZWcgPSAwOyBzZWcgPCBmcmFnbWVudHMubGVuZ3RoOyArK3NlZykge1xuICAgICAgICB2YXIgZnJhZyA9IGZyYWdtZW50c1tzZWddO1xuICAgICAgICBpZiAocGR0V2l0aGluVG9sZXJhbmNlVGVzdChQRFRWYWx1ZSwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgZnJhZykpIHtcbiAgICAgICAgICAgIHJldHVybiBmcmFnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0cy5maW5kRnJhZ21lbnRCeVBEVCA9IGZpbmRGcmFnbWVudEJ5UERUO1xuLyoqXG4gKiBGaW5kcyBhIGZyYWdtZW50IGJhc2VkIG9uIHRoZSBTTiBvZiB0aGUgcHJldmlvdXMgZnJhZ21lbnQ7IG9yIGJhc2VkIG9uIHRoZSBuZWVkcyBvZiB0aGUgY3VycmVudCBidWZmZXIuXG4gKiBUaGlzIG1ldGhvZCBjb21wZW5zYXRlcyBmb3Igc21hbGwgYnVmZmVyIGdhcHMgYnkgYXBwbHlpbmcgYSB0b2xlcmFuY2UgdG8gdGhlIHN0YXJ0IG9mIGFueSBjYW5kaWRhdGUgZnJhZ21lbnQsIHRodXNcbiAqIGJyZWFraW5nIGFueSB0cmFwcyB3aGljaCB3b3VsZCBjYXVzZSB0aGUgc2FtZSBmcmFnbWVudCB0byBiZSBjb250aW51b3VzbHkgc2VsZWN0ZWQgd2l0aGluIGEgc21hbGwgcmFuZ2UuXG4gKiBAcGFyYW0geyp9IGZyYWdQcmV2aW91cyAtIFRoZSBsYXN0IGZyYWcgc3VjY2Vzc2Z1bGx5IGFwcGVuZGVkXG4gKiBAcGFyYW0ge0FycmF5PEZyYWdtZW50Pn0gZnJhZ21lbnRzIC0gVGhlIGFycmF5IG9mIGNhbmRpZGF0ZSBmcmFnbWVudHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbYnVmZmVyRW5kID0gMF0gLSBUaGUgZW5kIG9mIHRoZSBjb250aWd1b3VzIGJ1ZmZlcmVkIHJhbmdlIHRoZSBwbGF5aGVhZCBpcyBjdXJyZW50bHkgd2l0aGluXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAtIFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGEgZnJhZ21lbnQncyBzdGFydC9lbmQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcbiAqIEByZXR1cm5zIHsqfSBmb3VuZEZyYWcgLSBUaGUgYmVzdCBtYXRjaGluZyBmcmFnbWVudFxuICovXG5mdW5jdGlvbiBmaW5kRnJhZ21lbnRCeVBUUyhmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgYnVmZmVyRW5kLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKSB7XG4gICAgaWYgKGJ1ZmZlckVuZCA9PT0gdm9pZCAwKSB7IGJ1ZmZlckVuZCA9IDA7IH1cbiAgICBpZiAobWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9PT0gdm9pZCAwKSB7IG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwOyB9XG4gICAgdmFyIGZyYWdOZXh0ID0gZnJhZ1ByZXZpb3VzID8gZnJhZ21lbnRzW2ZyYWdQcmV2aW91cy5zbiAtIGZyYWdtZW50c1swXS5zbiArIDFdIDogbnVsbDtcbiAgICAvLyBQcmVmZXIgdGhlIG5leHQgZnJhZ21lbnQgaWYgaXQncyB3aXRoaW4gdG9sZXJhbmNlXG4gICAgaWYgKGZyYWdOZXh0ICYmICFmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QoYnVmZmVyRW5kLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBmcmFnTmV4dCkpIHtcbiAgICAgICAgcmV0dXJuIGZyYWdOZXh0O1xuICAgIH1cbiAgICByZXR1cm4gYmluYXJ5X3NlYXJjaF8xLmRlZmF1bHQuc2VhcmNoKGZyYWdtZW50cywgZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0LmJpbmQobnVsbCwgYnVmZmVyRW5kLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKSk7XG59XG5leHBvcnRzLmZpbmRGcmFnbWVudEJ5UFRTID0gZmluZEZyYWdtZW50QnlQVFM7XG4vKipcbiAqIFRoZSB0ZXN0IGZ1bmN0aW9uIHVzZWQgYnkgdGhlIGZpbmRGcmFnbWVudEJ5U24ncyBCaW5hcnlTZWFyY2ggdG8gbG9vayBmb3IgdGhlIGJlc3QgbWF0Y2ggdG8gdGhlIGN1cnJlbnQgYnVmZmVyIGNvbmRpdGlvbnMuXG4gKiBAcGFyYW0geyp9IGNhbmRpZGF0ZSAtIFRoZSBmcmFnbWVudCB0byB0ZXN0XG4gKiBAcGFyYW0ge251bWJlcn0gW2J1ZmZlckVuZCA9IDBdIC0gVGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXJlZCByYW5nZSB0aGUgcGxheWhlYWQgaXMgY3VycmVudGx5IHdpdGhpblxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMF0gLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0gMCBpZiBpdCBtYXRjaGVzLCAxIGlmIHRvbyBsb3csIC0xIGlmIHRvbyBoaWdoXG4gKi9cbmZ1bmN0aW9uIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdChidWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGNhbmRpZGF0ZSkge1xuICAgIGlmIChidWZmZXJFbmQgPT09IHZvaWQgMCkgeyBidWZmZXJFbmQgPSAwOyB9XG4gICAgaWYgKG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPT09IHZvaWQgMCkgeyBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMDsgfVxuICAgIC8vIG9mZnNldCBzaG91bGQgYmUgd2l0aGluIGZyYWdtZW50IGJvdW5kYXJ5IC0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2VcbiAgICAvLyB0aGlzIGlzIHRvIGNvcGUgd2l0aCBzaXR1YXRpb25zIGxpa2VcbiAgICAvLyBidWZmZXJFbmQgPSA5Ljk5MVxuICAgIC8vIGZyYWdbw5hdIDogWzAsMTBdXG4gICAgLy8gZnJhZ1sxXSA6IFsxMCwyMF1cbiAgICAvLyBidWZmZXJFbmQgaXMgd2l0aGluIGZyYWdbMF0gcmFuZ2UgLi4uIGFsdGhvdWdoIHdoYXQgd2UgYXJlIGV4cGVjdGluZyBpcyB0byByZXR1cm4gZnJhZ1sxXSBoZXJlXG4gICAgLy8gICAgICAgICAgICAgIGZyYWcgc3RhcnQgICAgICAgICAgICAgICBmcmFnIHN0YXJ0K2R1cmF0aW9uXG4gICAgLy8gICAgICAgICAgICAgICAgICB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgLy8gICAgICAgICAgICAgIDwtLS0+ICAgICAgICAgICAgICAgICAgICAgICAgIDwtLS0+XG4gICAgLy8gIC4uLi0tLS0tLS0tPjwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT48LS0tLS0tLS0tLi4uLlxuICAgIC8vIHByZXZpb3VzIGZyYWcgICAgICAgICBtYXRjaGluZyBmcmFnbWVudCAgICAgICAgIG5leHQgZnJhZ1xuICAgIC8vICByZXR1cm4gLTEgICAgICAgICAgICAgcmV0dXJuIDAgICAgICAgICAgICAgICAgIHJldHVybiAxXG4gICAgLy8gbG9nZ2VyLmxvZyhgbGV2ZWwvc24vc3RhcnQvZW5kL2J1ZkVuZDoke2xldmVsfS8ke2NhbmRpZGF0ZS5zbn0vJHtjYW5kaWRhdGUuc3RhcnR9LyR7KGNhbmRpZGF0ZS5zdGFydCtjYW5kaWRhdGUuZHVyYXRpb24pfS8ke2J1ZmZlckVuZH1gKTtcbiAgICAvLyBTZXQgdGhlIGxvb2t1cCB0b2xlcmFuY2UgdG8gYmUgc21hbGwgZW5vdWdoIHRvIGRldGVjdCB0aGUgY3VycmVudCBzZWdtZW50IC0gZW5zdXJlcyB3ZSBkb24ndCBza2lwIG92ZXIgdmVyeSBzbWFsbCBzZWdtZW50c1xuICAgIHZhciBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPSBNYXRoLm1pbihtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBjYW5kaWRhdGUuZHVyYXRpb24gKyAoY2FuZGlkYXRlLmRlbHRhUFRTID8gY2FuZGlkYXRlLmRlbHRhUFRTIDogMCkpO1xuICAgIGlmIChjYW5kaWRhdGUuc3RhcnQgKyBjYW5kaWRhdGUuZHVyYXRpb24gLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPD0gYnVmZmVyRW5kKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIGlmIChjYW5kaWRhdGUuc3RhcnQgLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPiBidWZmZXJFbmQgJiYgY2FuZGlkYXRlLnN0YXJ0KSB7XG4gICAgICAgIC8vIGlmIG1heEZyYWdMb29rVXBUb2xlcmFuY2Ugd2lsbCBoYXZlIG5lZ2F0aXZlIHZhbHVlIHRoZW4gZG9uJ3QgcmV0dXJuIC0xIGZvciBmaXJzdCBlbGVtZW50XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5leHBvcnRzLmZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdCA9IGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdDtcbi8qKlxuICogVGhlIHRlc3QgZnVuY3Rpb24gdXNlZCBieSB0aGUgZmluZEZyYWdtZW50QnlQZHQncyBCaW5hcnlTZWFyY2ggdG8gbG9vayBmb3IgdGhlIGJlc3QgbWF0Y2ggdG8gdGhlIGN1cnJlbnQgYnVmZmVyIGNvbmRpdGlvbnMuXG4gKiBUaGlzIGZ1bmN0aW9uIHRlc3RzIHRoZSBjYW5kaWRhdGUncyBwcm9ncmFtIGRhdGUgdGltZSB2YWx1ZXMsIGFzIHJlcHJlc2VudGVkIGluIFVuaXggdGltZVxuICogQHBhcmFtIHsqfSBjYW5kaWRhdGUgLSBUaGUgZnJhZ21lbnQgdG8gdGVzdFxuICogQHBhcmFtIHtudW1iZXJ9IFtwZHRCdWZmZXJFbmQgPSAwXSAtIFRoZSBVbml4IHRpbWUgcmVwcmVzZW50aW5nIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYnVmZmVyZWQgcmFuZ2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDBdIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0IGNhbiBiZSB3aXRoaW4gaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCBjb250aWd1b3VzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBjb250aWd1b3VzLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gcGR0V2l0aGluVG9sZXJhbmNlVGVzdChwZHRCdWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGNhbmRpZGF0ZSkge1xuICAgIHZhciBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPSBNYXRoLm1pbihtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBjYW5kaWRhdGUuZHVyYXRpb24gKyAoY2FuZGlkYXRlLmRlbHRhUFRTID8gY2FuZGlkYXRlLmRlbHRhUFRTIDogMCkpICogMTAwMDtcbiAgICByZXR1cm4gY2FuZGlkYXRlLmVuZFByb2dyYW1EYXRlVGltZSAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA+IHBkdEJ1ZmZlckVuZDtcbn1cbmV4cG9ydHMucGR0V2l0aGluVG9sZXJhbmNlVGVzdCA9IHBkdFdpdGhpblRvbGVyYW5jZVRlc3Q7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci5qc1wiKVtcIk51bWJlclwiXSkpXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtdHJhY2tlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9mcmFnbWVudC10cmFja2VyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihOdW1iZXIpIHtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV2ZW50X2hhbmRsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50LWhhbmRsZXIgKi8gXCIuL3NyYy9ldmVudC1oYW5kbGVyLmpzXCIpO1xudmFyIGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLmpzXCIpO1xuZXhwb3J0cy5GcmFnbWVudFN0YXRlID0ge1xuICAgIE5PVF9MT0FERUQ6ICdOT1RfTE9BREVEJyxcbiAgICBBUFBFTkRJTkc6ICdBUFBFTkRJTkcnLFxuICAgIFBBUlRJQUw6ICdQQVJUSUFMJyxcbiAgICBPSzogJ09LJ1xufTtcbnZhciBGcmFnbWVudFRyYWNrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZyYWdtZW50VHJhY2tlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGcmFnbWVudFRyYWNrZXIoaGxzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGhscywgZXZlbnRzXzEuZGVmYXVsdC5CVUZGRVJfQVBQRU5ERUQsIGV2ZW50c18xLmRlZmF1bHQuRlJBR19CVUZGRVJFRCwgZXZlbnRzXzEuZGVmYXVsdC5GUkFHX0xPQURFRCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYnVmZmVyUGFkZGluZyA9IDAuMjtcbiAgICAgICAgX3RoaXMuZnJhZ21lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgX3RoaXMudGltZVJhbmdlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIF90aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRnJhZ21lbnRUcmFja2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMudGltZVJhbmdlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuY29uZmlnID0gbnVsbDtcbiAgICAgICAgZXZlbnRfaGFuZGxlcl8xLmRlZmF1bHQucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBGcmFnbWVudCB0aGF0IG1hdGNoIHRoZSBwb3NpdGlvbiBhbmQgbGV2ZWxUeXBlLlxuICAgICAqIElmIG5vdCBmb3VuZCBhbnkgRnJhZ21lbnQsIHJldHVybiBudWxsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtMZXZlbFR5cGV9IGxldmVsVHlwZVxuICAgICAqIEByZXR1cm5zIHtGcmFnbWVudHxudWxsfVxuICAgICAqL1xuICAgIEZyYWdtZW50VHJhY2tlci5wcm90b3R5cGUuZ2V0QnVmZmVyZWRGcmFnID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBsZXZlbFR5cGUpIHtcbiAgICAgICAgdmFyIGZyYWdtZW50cyA9IHRoaXMuZnJhZ21lbnRzO1xuICAgICAgICB2YXIgYnVmZmVyZWRGcmFncyA9IE9iamVjdC5rZXlzKGZyYWdtZW50cykuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBmcmFnbWVudEVudGl0eSA9IGZyYWdtZW50c1trZXldO1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50RW50aXR5LmJvZHkudHlwZSAhPT0gbGV2ZWxUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmcmFnbWVudEVudGl0eS5idWZmZXJlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmcmFnID0gZnJhZ21lbnRFbnRpdHkuYm9keTtcbiAgICAgICAgICAgIHJldHVybiBmcmFnLnN0YXJ0UFRTIDw9IHBvc2l0aW9uICYmIHBvc2l0aW9uIDw9IGZyYWcuZW5kUFRTO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGJ1ZmZlcmVkRnJhZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL3B1bGwvMTU0NSNkaXNjdXNzaW9uX3IxNjYyMjk1NjZcbiAgICAgICAgICAgIHZhciBidWZmZXJlZEZyYWdLZXkgPSBidWZmZXJlZEZyYWdzLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50c1tidWZmZXJlZEZyYWdLZXldLmJvZHk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBhcnRpYWwgZnJhZ21lbnRzIGVmZmVjdGVkIGJ5IGNvZGVkIGZyYW1lIGV2aWN0aW9uIHdpbGwgYmUgcmVtb3ZlZFxuICAgICAqIFRoZSBicm93c2VyIHdpbGwgdW5sb2FkIHBhcnRzIG9mIHRoZSBidWZmZXIgdG8gZnJlZSB1cCBtZW1vcnkgZm9yIG5ldyBidWZmZXIgZGF0YVxuICAgICAqIEZyYWdtZW50cyB3aWxsIG5lZWQgdG8gYmUgcmVsb2FkZWQgd2hlbiB0aGUgYnVmZmVyIGlzIGZyZWVkIHVwLCByZW1vdmluZyBwYXJ0aWFsIGZyYWdtZW50cyB3aWxsIGFsbG93IHRoZW0gdG8gcmVsb2FkKHNpbmNlIHRoZXJlIG1pZ2h0IGJlIHBhcnRzIHRoYXQgYXJlIHN0aWxsIHBsYXlhYmxlKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBlbGVtZW50YXJ5U3RyZWFtIFRoZSBlbGVtZW50YXJ5U3RyZWFtIG9mIG1lZGlhIHRoaXMgaXMgKGVnLiB2aWRlby9hdWRpbylcbiAgICAgKiBAcGFyYW0ge1RpbWVSYW5nZXN9IHRpbWVSYW5nZSBUaW1lUmFuZ2Ugb2JqZWN0IGZyb20gYSBzb3VyY2VCdWZmZXJcbiAgICAgKi9cbiAgICBGcmFnbWVudFRyYWNrZXIucHJvdG90eXBlLmRldGVjdEV2aWN0ZWRGcmFnbWVudHMgPSBmdW5jdGlvbiAoZWxlbWVudGFyeVN0cmVhbSwgdGltZVJhbmdlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBmcmFnbWVudFRpbWVzLCB0aW1lO1xuICAgICAgICAvLyBDaGVjayBpZiBhbnkgZmxhZ2dlZCBmcmFnbWVudHMgaGF2ZSBiZWVuIHVubG9hZGVkXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuZnJhZ21lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBmcmFnbWVudEVudGl0eSA9IF90aGlzLmZyYWdtZW50c1trZXldO1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVzRGF0YSA9IGZyYWdtZW50RW50aXR5LnJhbmdlW2VsZW1lbnRhcnlTdHJlYW1dO1xuICAgICAgICAgICAgICAgIGlmIChlc0RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRUaW1lcyA9IGVzRGF0YS50aW1lO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYWdtZW50VGltZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWUgPSBmcmFnbWVudFRpbWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzVGltZUJ1ZmZlcmVkKHRpbWUuc3RhcnRQVFMsIHRpbWUuZW5kUFRTLCB0aW1lUmFuZ2UpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVucmVnaXN0ZXIgcGFydGlhbCBmcmFnbWVudCBhcyBpdCBuZWVkcyB0byBsb2FkIGFnYWluIHRvIGJlIHJldXNlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZUZyYWdtZW50KGZyYWdtZW50RW50aXR5LmJvZHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZnJhZ21lbnQgcGFzc2VkIGluIGlzIGxvYWRlZCBpbiB0aGUgYnVmZmVyIHByb3Blcmx5XG4gICAgICogUGFydGlhbGx5IGxvYWRlZCBmcmFnbWVudHMgd2lsbCBiZSByZWdpc3RlcmVkIGFzIGEgcGFydGlhbCBmcmFnbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmcmFnbWVudCBDaGVjayB0aGUgZnJhZ21lbnQgYWdhaW5zdCBhbGwgc291cmNlQnVmZmVycyBsb2FkZWRcbiAgICAgKi9cbiAgICBGcmFnbWVudFRyYWNrZXIucHJvdG90eXBlLmRldGVjdFBhcnRpYWxGcmFnbWVudHMgPSBmdW5jdGlvbiAoZnJhZ21lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGZyYWdLZXkgPSB0aGlzLmdldEZyYWdtZW50S2V5KGZyYWdtZW50KTtcbiAgICAgICAgdmFyIGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gICAgICAgIGlmIChmcmFnbWVudEVudGl0eSkge1xuICAgICAgICAgICAgZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy50aW1lUmFuZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50YXJ5U3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyYWdtZW50Lmhhc0VsZW1lbnRhcnlTdHJlYW0oZWxlbWVudGFyeVN0cmVhbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVSYW5nZSA9IF90aGlzLnRpbWVSYW5nZXNbZWxlbWVudGFyeVN0cmVhbV07XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBtYWxmb3JtZWQgZnJhZ21lbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vIEdhcHMgbmVlZCB0byBiZSBjYWxjdWxhdGVkIGZvciBlYWNoIGVsZW1lbnRhcnlTdHJlYW1cbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRFbnRpdHkucmFuZ2VbZWxlbWVudGFyeVN0cmVhbV0gPSBfdGhpcy5nZXRCdWZmZXJlZFRpbWVzKGZyYWdtZW50LnN0YXJ0UFRTLCBmcmFnbWVudC5lbmRQVFMsIHRpbWVSYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZyYWdtZW50VHJhY2tlci5wcm90b3R5cGUuZ2V0QnVmZmVyZWRUaW1lcyA9IGZ1bmN0aW9uIChzdGFydFBUUywgZW5kUFRTLCB0aW1lUmFuZ2UpIHtcbiAgICAgICAgdmFyIGZyYWdtZW50VGltZXMgPSBbXTtcbiAgICAgICAgdmFyIHN0YXJ0VGltZSwgZW5kVGltZTtcbiAgICAgICAgdmFyIGZyYWdtZW50UGFydGlhbCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbWVSYW5nZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3RhcnRUaW1lID0gdGltZVJhbmdlLnN0YXJ0KGkpIC0gdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgICAgICAgZW5kVGltZSA9IHRpbWVSYW5nZS5lbmQoaSkgKyB0aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICAgICAgICBpZiAoc3RhcnRQVFMgPj0gc3RhcnRUaW1lICYmIGVuZFBUUyA8PSBlbmRUaW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gRnJhZ21lbnQgaXMgZW50aXJlbHkgY29udGFpbmVkIGluIGJ1ZmZlclxuICAgICAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgdGhlIG90aGVyIHRpbWVSYW5nZSB0aW1lcyBzaW5jZSBpdCdzIGNvbXBsZXRlbHkgcGxheWFibGVcbiAgICAgICAgICAgICAgICBmcmFnbWVudFRpbWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzdGFydFBUUzogTWF0aC5tYXgoc3RhcnRQVFMsIHRpbWVSYW5nZS5zdGFydChpKSksXG4gICAgICAgICAgICAgICAgICAgIGVuZFBUUzogTWF0aC5taW4oZW5kUFRTLCB0aW1lUmFuZ2UuZW5kKGkpKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnRQVFMgPCBlbmRUaW1lICYmIGVuZFBUUyA+IHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBpbnRlcnNlY3Rpb24gd2l0aCBidWZmZXJcbiAgICAgICAgICAgICAgICAvLyBHZXQgcGxheWFibGUgc2VjdGlvbnMgb2YgdGhlIGZyYWdtZW50XG4gICAgICAgICAgICAgICAgZnJhZ21lbnRUaW1lcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRQVFM6IE1hdGgubWF4KHN0YXJ0UFRTLCB0aW1lUmFuZ2Uuc3RhcnQoaSkpLFxuICAgICAgICAgICAgICAgICAgICBlbmRQVFM6IE1hdGgubWluKGVuZFBUUywgdGltZVJhbmdlLmVuZChpKSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmcmFnbWVudFBhcnRpYWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW5kUFRTIDw9IHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgdGhlIHJlc3Qgb2YgdGhlIHRpbWVSYW5nZSBhcyBpdCBpcyBpbiBvcmRlclxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0aW1lOiBmcmFnbWVudFRpbWVzLFxuICAgICAgICAgICAgcGFydGlhbDogZnJhZ21lbnRQYXJ0aWFsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBGcmFnbWVudFRyYWNrZXIucHJvdG90eXBlLmdldEZyYWdtZW50S2V5ID0gZnVuY3Rpb24gKGZyYWdtZW50KSB7XG4gICAgICAgIHJldHVybiBmcmFnbWVudC50eXBlICsgXCJfXCIgKyBmcmFnbWVudC5sZXZlbCArIFwiX1wiICsgZnJhZ21lbnQudXJsSWQgKyBcIl9cIiArIGZyYWdtZW50LnNuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGFydGlhbCBmcmFnbWVudCBmb3IgYSBjZXJ0YWluIHRpbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGltZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGZyYWdtZW50IFJldHVybnMgYSBwYXJ0aWFsIGZyYWdtZW50IGF0IGEgdGltZSBvciBudWxsIGlmIHRoZXJlIGlzIG5vIHBhcnRpYWwgZnJhZ21lbnRcbiAgICAgKi9cbiAgICBGcmFnbWVudFRyYWNrZXIucHJvdG90eXBlLmdldFBhcnRpYWxGcmFnbWVudCA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0aW1lUGFkZGluZywgc3RhcnRUaW1lLCBlbmRUaW1lO1xuICAgICAgICB2YXIgYmVzdEZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgdmFyIGJlc3RPdmVybGFwID0gMDtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5mcmFnbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIGZyYWdtZW50RW50aXR5ID0gX3RoaXMuZnJhZ21lbnRzW2tleV07XG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNQYXJ0aWFsKGZyYWdtZW50RW50aXR5KSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0VGltZSA9IGZyYWdtZW50RW50aXR5LmJvZHkuc3RhcnRQVFMgLSBfdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgICAgICAgICAgIGVuZFRpbWUgPSBmcmFnbWVudEVudGl0eS5ib2R5LmVuZFBUUyArIF90aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgPj0gc3RhcnRUaW1lICYmIHRpbWUgPD0gZW5kVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGZyYWdtZW50IHRoYXQgaGFzIHRoZSBtb3N0IHBhZGRpbmcgZnJvbSBzdGFydCBhbmQgZW5kIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgdGltZVBhZGRpbmcgPSBNYXRoLm1pbih0aW1lIC0gc3RhcnRUaW1lLCBlbmRUaW1lIC0gdGltZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZXN0T3ZlcmxhcCA8PSB0aW1lUGFkZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdEZyYWdtZW50ID0gZnJhZ21lbnRFbnRpdHkuYm9keTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RPdmVybGFwID0gdGltZVBhZGRpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYmVzdEZyYWdtZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZyYWdtZW50IFRoZSBmcmFnbWVudCB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFJldHVybnMgdGhlIGZyYWdtZW50IHN0YXRlIHdoZW4gYSBmcmFnbWVudCBuZXZlciBsb2FkZWQgb3IgaWYgaXQgcGFydGlhbGx5IGxvYWRlZFxuICAgICAqL1xuICAgIEZyYWdtZW50VHJhY2tlci5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoZnJhZ21lbnQpIHtcbiAgICAgICAgdmFyIGZyYWdLZXkgPSB0aGlzLmdldEZyYWdtZW50S2V5KGZyYWdtZW50KTtcbiAgICAgICAgdmFyIGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gICAgICAgIHZhciBzdGF0ZSA9IGV4cG9ydHMuRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEO1xuICAgICAgICBpZiAoZnJhZ21lbnRFbnRpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFmcmFnbWVudEVudGl0eS5idWZmZXJlZCkge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gZXhwb3J0cy5GcmFnbWVudFN0YXRlLkFQUEVORElORztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNQYXJ0aWFsKGZyYWdtZW50RW50aXR5KSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gZXhwb3J0cy5GcmFnbWVudFN0YXRlLlBBUlRJQUw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IGV4cG9ydHMuRnJhZ21lbnRTdGF0ZS5PSztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfTtcbiAgICBGcmFnbWVudFRyYWNrZXIucHJvdG90eXBlLmlzUGFydGlhbCA9IGZ1bmN0aW9uIChmcmFnbWVudEVudGl0eSkge1xuICAgICAgICByZXR1cm4gZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgPT09IHRydWUgJiZcbiAgICAgICAgICAgICgoZnJhZ21lbnRFbnRpdHkucmFuZ2UudmlkZW8gIT09IHVuZGVmaW5lZCAmJiBmcmFnbWVudEVudGl0eS5yYW5nZS52aWRlby5wYXJ0aWFsID09PSB0cnVlKSB8fFxuICAgICAgICAgICAgICAgIChmcmFnbWVudEVudGl0eS5yYW5nZS5hdWRpbyAhPT0gdW5kZWZpbmVkICYmIGZyYWdtZW50RW50aXR5LnJhbmdlLmF1ZGlvLnBhcnRpYWwgPT09IHRydWUpKTtcbiAgICB9O1xuICAgIEZyYWdtZW50VHJhY2tlci5wcm90b3R5cGUuaXNUaW1lQnVmZmVyZWQgPSBmdW5jdGlvbiAoc3RhcnRQVFMsIGVuZFBUUywgdGltZVJhbmdlKSB7XG4gICAgICAgIHZhciBzdGFydFRpbWUsIGVuZFRpbWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGltZVJhbmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdGFydFRpbWUgPSB0aW1lUmFuZ2Uuc3RhcnQoaSkgLSB0aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICAgICAgICBlbmRUaW1lID0gdGltZVJhbmdlLmVuZChpKSArIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgICAgICAgIGlmIChzdGFydFBUUyA+PSBzdGFydFRpbWUgJiYgZW5kUFRTIDw9IGVuZFRpbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmRQVFMgPD0gc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayB0aGUgcmVzdCBvZiB0aGUgdGltZVJhbmdlIGFzIGl0IGlzIGluIG9yZGVyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gYSBmcmFnbWVudCBsb2FkaW5nIGlzIGNvbXBsZXRlZFxuICAgICAqL1xuICAgIEZyYWdtZW50VHJhY2tlci5wcm90b3R5cGUub25GcmFnTG9hZGVkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGZyYWdtZW50ID0gZS5mcmFnO1xuICAgICAgICAvLyBkb24ndCB0cmFjayBpbml0c2VnbWVudCAoZm9yIHdoaWNoIHNuIGlzIG5vdCBhIG51bWJlcilcbiAgICAgICAgLy8gZG9uJ3QgdHJhY2sgZnJhZ3MgdXNlZCBmb3IgYml0cmF0ZVRlc3QsIHRoZXkncmUgaXJyZWxldmFudC5cbiAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShmcmFnbWVudC5zbikgJiYgIWZyYWdtZW50LmJpdHJhdGVUZXN0KSB7XG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50c1t0aGlzLmdldEZyYWdtZW50S2V5KGZyYWdtZW50KV0gPSB7XG4gICAgICAgICAgICAgICAgYm9keTogZnJhZ21lbnQsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICAgICAgYnVmZmVyZWQ6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBidWZmZXIgaXMgdXBkYXRlZFxuICAgICAqL1xuICAgIEZyYWdtZW50VHJhY2tlci5wcm90b3R5cGUub25CdWZmZXJBcHBlbmRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFN0b3JlIHRoZSBsYXRlc3QgdGltZVJhbmdlcyBsb2FkZWQgaW4gdGhlIGJ1ZmZlclxuICAgICAgICB0aGlzLnRpbWVSYW5nZXMgPSBlLnRpbWVSYW5nZXM7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMudGltZVJhbmdlcykuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudGFyeVN0cmVhbSkge1xuICAgICAgICAgICAgdmFyIHRpbWVSYW5nZSA9IF90aGlzLnRpbWVSYW5nZXNbZWxlbWVudGFyeVN0cmVhbV07XG4gICAgICAgICAgICBfdGhpcy5kZXRlY3RFdmljdGVkRnJhZ21lbnRzKGVsZW1lbnRhcnlTdHJlYW0sIHRpbWVSYW5nZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmlyZXMgYWZ0ZXIgYSBmcmFnbWVudCBoYXMgYmVlbiBsb2FkZWQgaW50byB0aGUgc291cmNlIGJ1ZmZlclxuICAgICAqL1xuICAgIEZyYWdtZW50VHJhY2tlci5wcm90b3R5cGUub25GcmFnQnVmZmVyZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLmRldGVjdFBhcnRpYWxGcmFnbWVudHMoZS5mcmFnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGlmIGZyYWdtZW50IHRyYWNrZXIgaGFzIHRoZSBmcmFnbWVudC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZnJhZ21lbnRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBGcmFnbWVudFRyYWNrZXIucHJvdG90eXBlLmhhc0ZyYWdtZW50ID0gZnVuY3Rpb24gKGZyYWdtZW50KSB7XG4gICAgICAgIHZhciBmcmFnS2V5ID0gdGhpcy5nZXRGcmFnbWVudEtleShmcmFnbWVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgZnJhZ21lbnQgZnJvbSBmcmFnbWVudCB0cmFja2VyIHVudGlsIGl0IGlzIGxvYWRlZCBhZ2FpblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmcmFnbWVudCBUaGUgZnJhZ21lbnQgdG8gcmVtb3ZlXG4gICAgICovXG4gICAgRnJhZ21lbnRUcmFja2VyLnByb3RvdHlwZS5yZW1vdmVGcmFnbWVudCA9IGZ1bmN0aW9uIChmcmFnbWVudCkge1xuICAgICAgICB2YXIgZnJhZ0tleSA9IHRoaXMuZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpO1xuICAgICAgICBkZWxldGUgdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGZyYWdtZW50cyBmcm9tIGZyYWdtZW50IHRyYWNrZXIuXG4gICAgICovXG4gICAgRnJhZ21lbnRUcmFja2VyLnByb3RvdHlwZS5yZW1vdmVBbGxGcmFnbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuICAgIHJldHVybiBGcmFnbWVudFRyYWNrZXI7XG59KGV2ZW50X2hhbmRsZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLkZyYWdtZW50VHJhY2tlciA9IEZyYWdtZW50VHJhY2tlcjtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLmpzXCIpW1wiTnVtYmVyXCJdKSlcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9nYXAtY29udHJvbGxlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvZ2FwLWNvbnRyb2xsZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGJ1ZmZlcl9oZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2J1ZmZlci1oZWxwZXIgKi8gXCIuL3NyYy91dGlscy9idWZmZXItaGVscGVyLmpzXCIpO1xudmFyIGVycm9yc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLmpzXCIpO1xudmFyIGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLmpzXCIpO1xudmFyIGxvZ2dlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLmpzXCIpO1xudmFyIHN0YWxsRGVib3VuY2VJbnRlcnZhbCA9IDEwMDA7XG52YXIganVtcFRocmVzaG9sZCA9IDAuNTsgLy8gdG9sZXJhbmNlIG5lZWRlZCBhcyBzb21lIGJyb3dzZXJzIHN0YWxscyBwbGF5YmFjayBiZWZvcmUgcmVhY2hpbmcgYnVmZmVyZWQgcmFuZ2UgZW5kXG52YXIgR2FwQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHYXBDb250cm9sbGVyKGNvbmZpZywgbWVkaWEsIGZyYWdtZW50VHJhY2tlciwgaGxzKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLm1lZGlhID0gbWVkaWE7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyID0gZnJhZ21lbnRUcmFja2VyO1xuICAgICAgICB0aGlzLmhscyA9IGhscztcbiAgICAgICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgcGxheWhlYWQgaXMgc3R1Y2sgd2l0aGluIGEgZ2FwLCBhbmQgaWYgc28sIGF0dGVtcHRzIHRvIGZyZWUgaXQuXG4gICAgICogQSBnYXAgaXMgYW4gdW5idWZmZXJlZCByYW5nZSBiZXR3ZWVuIHR3byBidWZmZXJlZCByYW5nZXMgKG9yIHRoZSBzdGFydCBhbmQgdGhlIGZpcnN0IGJ1ZmZlcmVkIHJhbmdlKS5cbiAgICAgKiBAcGFyYW0gbGFzdEN1cnJlbnRUaW1lXG4gICAgICogQHBhcmFtIGJ1ZmZlcmVkXG4gICAgICovXG4gICAgR2FwQ29udHJvbGxlci5wcm90b3R5cGUucG9sbCA9IGZ1bmN0aW9uIChsYXN0Q3VycmVudFRpbWUsIGJ1ZmZlcmVkKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGNvbmZpZyA9IF9hLmNvbmZpZywgbWVkaWEgPSBfYS5tZWRpYTtcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgICAgIHZhciB0bm93ID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBpZiAoY3VycmVudFRpbWUgIT09IGxhc3RDdXJyZW50VGltZSkge1xuICAgICAgICAgICAgLy8gVGhlIHBsYXloZWFkIGlzIG5vdyBtb3ZpbmcsIGJ1dCB3YXMgcHJldmlvdXNseSBzdGFsbGVkXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFsbFJlcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oXCJwbGF5YmFjayBub3Qgc3R1Y2sgYW55bW9yZSBAXCIgKyBjdXJyZW50VGltZSArIFwiLCBhZnRlciBcIiArIE1hdGgucm91bmQodG5vdyAtIHRoaXMuc3RhbGxlZCkgKyBcIm1zXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhbGxSZXBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubnVkZ2VSZXRyeSA9IDA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lZGlhLmVuZGVkIHx8ICFtZWRpYS5idWZmZXJlZC5sZW5ndGggfHwgbWVkaWEucmVhZHlTdGF0ZSA+IDIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVkaWEuc2Vla2luZyAmJiBidWZmZXJfaGVscGVyXzEuQnVmZmVySGVscGVyLmlzQnVmZmVyZWQobWVkaWEsIGN1cnJlbnRUaW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBwbGF5aGVhZCBpc24ndCBtb3ZpbmcgYnV0IGl0IHNob3VsZCBiZVxuICAgICAgICAvLyBBbGxvdyBzb21lIHNsYWNrIHRpbWUgdG8gZm9yIHNtYWxsIHN0YWxscyB0byByZXNvbHZlIHRoZW1zZWx2ZXNcbiAgICAgICAgdmFyIHN0YWxsZWREdXJhdGlvbiA9IHRub3cgLSB0aGlzLnN0YWxsZWQ7XG4gICAgICAgIHZhciBidWZmZXJJbmZvID0gYnVmZmVyX2hlbHBlcl8xLkJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhLCBjdXJyZW50VGltZSwgY29uZmlnLm1heEJ1ZmZlckhvbGUpO1xuICAgICAgICBpZiAoIXRoaXMuc3RhbGxlZCkge1xuICAgICAgICAgICAgdGhpcy5zdGFsbGVkID0gdG5vdztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGFsbGVkRHVyYXRpb24gPj0gc3RhbGxEZWJvdW5jZUludGVydmFsKSB7XG4gICAgICAgICAgICAvLyBSZXBvcnQgc3RhbGxpbmcgYWZ0ZXIgdHJ5aW5nIHRvIGZpeFxuICAgICAgICAgICAgdGhpcy5fcmVwb3J0U3RhbGwoYnVmZmVySW5mby5sZW4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyeUZpeEJ1ZmZlclN0YWxsKGJ1ZmZlckluZm8sIHN0YWxsZWREdXJhdGlvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRlY3RzIGFuZCBhdHRlbXB0cyB0byBmaXgga25vd24gYnVmZmVyIHN0YWxsaW5nIGlzc3Vlcy5cbiAgICAgKiBAcGFyYW0gYnVmZmVySW5mbyAtIFRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IGJ1ZmZlci5cbiAgICAgKiBAcGFyYW0gc3RhbGxlZER1cmF0aW9uIC0gVGhlIGFtb3VudCBvZiB0aW1lIEhscy5qcyBoYXMgYmVlbiBzdGFsbGluZyBmb3IuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBHYXBDb250cm9sbGVyLnByb3RvdHlwZS5fdHJ5Rml4QnVmZmVyU3RhbGwgPSBmdW5jdGlvbiAoYnVmZmVySW5mbywgc3RhbGxlZER1cmF0aW9uKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGNvbmZpZyA9IF9hLmNvbmZpZywgZnJhZ21lbnRUcmFja2VyID0gX2EuZnJhZ21lbnRUcmFja2VyLCBtZWRpYSA9IF9hLm1lZGlhO1xuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAgICAgdmFyIHBhcnRpYWwgPSBmcmFnbWVudFRyYWNrZXIuZ2V0UGFydGlhbEZyYWdtZW50KGN1cnJlbnRUaW1lKTtcbiAgICAgICAgaWYgKHBhcnRpYWwpIHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBza2lwIG92ZXIgdGhlIGJ1ZmZlciBob2xlIGNhdXNlZCBieSBhIHBhcnRpYWwgZnJhZ21lbnRcbiAgICAgICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzbid0IGxpbWl0ZWQgYnkgdGhlIHNpemUgb2YgdGhlIGdhcCBiZXR3ZWVuIGJ1ZmZlcmVkIHJhbmdlc1xuICAgICAgICAgICAgdGhpcy5fdHJ5U2tpcEJ1ZmZlckhvbGUocGFydGlhbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZmZlckluZm8ubGVuID4ganVtcFRocmVzaG9sZCAmJiBzdGFsbGVkRHVyYXRpb24gPiBjb25maWcuaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kICogMTAwMCkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIG51ZGdlIGN1cnJlbnRUaW1lIG92ZXIgYSBidWZmZXIgaG9sZSBpZiB3ZSd2ZSBiZWVuIHN0YWxsaW5nIGZvciB0aGUgY29uZmlndXJlZCBhbW91bnQgb2Ygc2Vjb25kc1xuICAgICAgICAgICAgLy8gV2Ugb25seSB0cnkgdG8ganVtcCB0aGUgaG9sZSBpZiBpdCdzIHVuZGVyIHRoZSBjb25maWd1cmVkIHNpemVcbiAgICAgICAgICAgIC8vIFJlc2V0IHN0YWxsZWQgc28gdG8gcmVhcm0gd2F0Y2hkb2cgdGltZXJcbiAgICAgICAgICAgIHRoaXMuc3RhbGxlZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl90cnlOdWRnZUJ1ZmZlcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyBhIEJVRkZFUl9TVEFMTEVEX0VSUk9SIGV2ZW50LCBidXQgb25seSBvbmNlIHBlciBzdGFsbCBwZXJpb2QuXG4gICAgICogQHBhcmFtIGJ1ZmZlckxlbiAtIFRoZSBwbGF5aGVhZCBkaXN0YW5jZSBmcm9tIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYnVmZmVyIHNlZ21lbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBHYXBDb250cm9sbGVyLnByb3RvdHlwZS5fcmVwb3J0U3RhbGwgPSBmdW5jdGlvbiAoYnVmZmVyTGVuKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGhscyA9IF9hLmhscywgbWVkaWEgPSBfYS5tZWRpYSwgc3RhbGxSZXBvcnRlZCA9IF9hLnN0YWxsUmVwb3J0ZWQ7XG4gICAgICAgIGlmICghc3RhbGxSZXBvcnRlZCkge1xuICAgICAgICAgICAgLy8gUmVwb3J0IHN0YWxsZWQgZXJyb3Igb25jZVxuICAgICAgICAgICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKFwiUGxheWJhY2sgc3RhbGxpbmcgYXQgQFwiICsgbWVkaWEuY3VycmVudFRpbWUgKyBcIiBkdWUgdG8gbG93IGJ1ZmZlclwiKTtcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBlcnJvcnNfMS5FcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGVycm9yc18xLkVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUixcbiAgICAgICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgYnVmZmVyOiBidWZmZXJMZW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBmaXggYnVmZmVyIHN0YWxscyBieSBqdW1waW5nIG92ZXIga25vd24gZ2FwcyBjYXVzZWQgYnkgcGFydGlhbCBmcmFnbWVudHNcbiAgICAgKiBAcGFyYW0gcGFydGlhbCAtIFRoZSBwYXJ0aWFsIGZyYWdtZW50IGZvdW5kIGF0IHRoZSBjdXJyZW50IHRpbWUgKHdoZXJlIHBsYXliYWNrIGlzIHN0YWxsaW5nKS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEdhcENvbnRyb2xsZXIucHJvdG90eXBlLl90cnlTa2lwQnVmZmVySG9sZSA9IGZ1bmN0aW9uIChwYXJ0aWFsKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGhscyA9IF9hLmhscywgbWVkaWEgPSBfYS5tZWRpYTtcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgICAgIHZhciBsYXN0RW5kVGltZSA9IDA7XG4gICAgICAgIC8vIENoZWNrIGlmIGN1cnJlbnRUaW1lIGlzIGJldHdlZW4gdW5idWZmZXJlZCByZWdpb25zIG9mIHBhcnRpYWwgZnJhZ21lbnRzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVkaWEuYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdGFydFRpbWUgPSBtZWRpYS5idWZmZXJlZC5zdGFydChpKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGltZSA+PSBsYXN0RW5kVGltZSAmJiBjdXJyZW50VGltZSA8IHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gTWF0aC5tYXgoc3RhcnRUaW1lLCBtZWRpYS5jdXJyZW50VGltZSArIDAuMSk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oXCJza2lwcGluZyBob2xlLCBhZGp1c3RpbmcgY3VycmVudFRpbWUgZnJvbSBcIiArIGN1cnJlbnRUaW1lICsgXCIgdG8gXCIgKyBtZWRpYS5jdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkVSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGVycm9yc18xLkVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGVycm9yc18xLkVycm9yRGV0YWlscy5CVUZGRVJfU0VFS19PVkVSX0hPTEUsXG4gICAgICAgICAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBcImZyYWdtZW50IGxvYWRlZCB3aXRoIGJ1ZmZlciBob2xlcywgc2Vla2luZyBmcm9tIFwiICsgY3VycmVudFRpbWUgKyBcIiB0byBcIiArIG1lZGlhLmN1cnJlbnRUaW1lLFxuICAgICAgICAgICAgICAgICAgICBmcmFnOiBwYXJ0aWFsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEVuZFRpbWUgPSBtZWRpYS5idWZmZXJlZC5lbmQoaSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGZpeCBidWZmZXIgc3RhbGxzIGJ5IGFkdmFuY2luZyB0aGUgbWVkaWFFbGVtZW50J3MgY3VycmVudCB0aW1lIGJ5IGEgc21hbGwgYW1vdW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgR2FwQ29udHJvbGxlci5wcm90b3R5cGUuX3RyeU51ZGdlQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBjb25maWcgPSBfYS5jb25maWcsIGhscyA9IF9hLmhscywgbWVkaWEgPSBfYS5tZWRpYTtcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgICAgIHZhciBudWRnZVJldHJ5ID0gKHRoaXMubnVkZ2VSZXRyeSB8fCAwKSArIDE7XG4gICAgICAgIHRoaXMubnVkZ2VSZXRyeSA9IG51ZGdlUmV0cnk7XG4gICAgICAgIGlmIChudWRnZVJldHJ5IDwgY29uZmlnLm51ZGdlTWF4UmV0cnkpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRUaW1lID0gY3VycmVudFRpbWUgKyBudWRnZVJldHJ5ICogY29uZmlnLm51ZGdlT2Zmc2V0O1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcImFkanVzdCBjdXJyZW50VGltZSBmcm9tIFwiICsgY3VycmVudFRpbWUgKyBcIiB0byBcIiArIHRhcmdldFRpbWUpO1xuICAgICAgICAgICAgLy8gcGxheWJhY2sgc3RhbGxlZCBpbiBidWZmZXJlZCBhcmVhIC4uLiBsZXQncyBudWRnZSBjdXJyZW50VGltZSB0byB0cnkgdG8gb3ZlcmNvbWUgdGhpc1xuICAgICAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSB0YXJnZXRUaW1lO1xuICAgICAgICAgICAgaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwge1xuICAgICAgICAgICAgICAgIHR5cGU6IGVycm9yc18xLkVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogZXJyb3JzXzEuRXJyb3JEZXRhaWxzLkJVRkZFUl9OVURHRV9PTl9TVEFMTCxcbiAgICAgICAgICAgICAgICBmYXRhbDogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmVycm9yKFwic3RpbGwgc3R1Y2sgaW4gaGlnaCBidWZmZXIgQFwiICsgY3VycmVudFRpbWUgKyBcIiBhZnRlciBcIiArIGNvbmZpZy5udWRnZU1heFJldHJ5ICsgXCIsIHJhaXNlIGZhdGFsIGVycm9yXCIpO1xuICAgICAgICAgICAgaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwge1xuICAgICAgICAgICAgICAgIHR5cGU6IGVycm9yc18xLkVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogZXJyb3JzXzEuRXJyb3JEZXRhaWxzLkJVRkZFUl9TVEFMTEVEX0VSUk9SLFxuICAgICAgICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEdhcENvbnRyb2xsZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gR2FwQ29udHJvbGxlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2lkMy10cmFjay1jb250cm9sbGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9pZDMtdHJhY2stY29udHJvbGxlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKlxuICogaWQzIG1ldGFkYXRhIHRyYWNrIGNvbnRyb2xsZXJcbiovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy5qc1wiKTtcbnZhciBldmVudF9oYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudC1oYW5kbGVyICovIFwiLi9zcmMvZXZlbnQtaGFuZGxlci5qc1wiKTtcbnZhciBpZDNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L2lkMyAqLyBcIi4vc3JjL2RlbXV4L2lkMy5qc1wiKTtcbnZhciB0ZXh0dHJhY2tfdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL3RleHR0cmFjay11dGlscyAqLyBcIi4vc3JjL3V0aWxzL3RleHR0cmFjay11dGlscy5qc1wiKTtcbnZhciBJRDNUcmFja0NvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElEM1RyYWNrQ29udHJvbGxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJRDNUcmFja0NvbnRyb2xsZXIoaGxzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGhscywgZXZlbnRzXzEuZGVmYXVsdC5NRURJQV9BVFRBQ0hFRCwgZXZlbnRzXzEuZGVmYXVsdC5NRURJQV9ERVRBQ0hJTkcsIGV2ZW50c18xLmRlZmF1bHQuRlJBR19QQVJTSU5HX01FVEFEQVRBKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pZDNUcmFjayA9IHVuZGVmaW5lZDtcbiAgICAgICAgX3RoaXMubWVkaWEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSUQzVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBldmVudF9oYW5kbGVyXzEuZGVmYXVsdC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgLy8gQWRkIElEMyBtZXRhdGFkYXRhIHRleHQgdHJhY2suXG4gICAgSUQzVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZS5vbk1lZGlhQXR0YWNoZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICAgICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElEM1RyYWNrQ29udHJvbGxlci5wcm90b3R5cGUub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGV4dHRyYWNrX3V0aWxzXzEuY2xlYXJDdXJyZW50Q3Vlcyh0aGlzLmlkM1RyYWNrKTtcbiAgICAgICAgdGhpcy5pZDNUcmFjayA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tZWRpYSA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIElEM1RyYWNrQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0SUQzVHJhY2sgPSBmdW5jdGlvbiAodGV4dFRyYWNrcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0ZXh0VHJhY2sgPSB0ZXh0VHJhY2tzW2ldO1xuICAgICAgICAgICAgaWYgKHRleHRUcmFjay5raW5kID09PSAnbWV0YWRhdGEnICYmIHRleHRUcmFjay5sYWJlbCA9PT0gJ2lkMycpIHtcbiAgICAgICAgICAgICAgICAvLyBzZW5kICdhZGR0cmFjaycgd2hlbiByZXVzaW5nIHRoZSB0ZXh0VHJhY2sgZm9yIG1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIC8vIHNhbWUgYXMgd2hhdCB3ZSBkbyBmb3IgY2FwdGlvbnNcbiAgICAgICAgICAgICAgICB0ZXh0dHJhY2tfdXRpbHNfMS5zZW5kQWRkVHJhY2tFdmVudCh0ZXh0VHJhY2ssIHRoaXMubWVkaWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0VHJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWVkaWEuYWRkVGV4dFRyYWNrKCdtZXRhZGF0YScsICdpZDMnKTtcbiAgICB9O1xuICAgIElEM1RyYWNrQ29udHJvbGxlci5wcm90b3R5cGUub25GcmFnUGFyc2luZ01ldGFkYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGZyYWdtZW50ID0gZGF0YS5mcmFnO1xuICAgICAgICB2YXIgc2FtcGxlcyA9IGRhdGEuc2FtcGxlcztcbiAgICAgICAgLy8gY3JlYXRlIHRyYWNrIGR5bmFtaWNhbGx5XG4gICAgICAgIGlmICghdGhpcy5pZDNUcmFjaykge1xuICAgICAgICAgICAgdGhpcy5pZDNUcmFjayA9IHRoaXMuZ2V0SUQzVHJhY2sodGhpcy5tZWRpYS50ZXh0VHJhY2tzKTtcbiAgICAgICAgICAgIHRoaXMuaWQzVHJhY2subW9kZSA9ICdoaWRkZW4nO1xuICAgICAgICB9XG4gICAgICAgIC8vIEF0dGVtcHQgdG8gcmVjcmVhdGUgU2FmYXJpIGZ1bmN0aW9uYWxpdHkgYnkgY3JlYXRpbmdcbiAgICAgICAgLy8gV2ViS2l0RGF0YUN1ZSBvYmplY3RzIHdoZW4gYXZhaWxhYmxlIGFuZCBzdG9yZSB0aGUgZGVjb2RlZFxuICAgICAgICAvLyBJRDMgZGF0YSBpbiB0aGUgdmFsdWUgcHJvcGVydHkgb2YgdGhlIGN1ZVxuICAgICAgICB2YXIgQ3VlID0gd2luZG93LldlYktpdERhdGFDdWUgfHwgd2luZG93LlZUVEN1ZSB8fCB3aW5kb3cuVGV4dFRyYWNrQ3VlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmcmFtZXNfMSA9IGlkM18xLmRlZmF1bHQuZ2V0SUQzRnJhbWVzKHNhbXBsZXNbaV0uZGF0YSk7XG4gICAgICAgICAgICBpZiAoZnJhbWVzXzEpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRUaW1lID0gc2FtcGxlc1tpXS5wdHM7XG4gICAgICAgICAgICAgICAgdmFyIGVuZFRpbWUgPSBpIDwgc2FtcGxlcy5sZW5ndGggLSAxID8gc2FtcGxlc1tpICsgMV0ucHRzIDogZnJhZ21lbnQuZW5kUFRTO1xuICAgICAgICAgICAgICAgIC8vIEdpdmUgYSBzbGlnaHQgYnVtcCB0byB0aGUgZW5kVGltZSBpZiBpdCdzIGVxdWFsIHRvIHN0YXJ0VGltZSB0byBhdm9pZCBhIFN5bnRheEVycm9yIGluIElFXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0VGltZSA9PT0gZW5kVGltZSkge1xuICAgICAgICAgICAgICAgICAgICBlbmRUaW1lICs9IDAuMDAwMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmcmFtZXNfMS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBmcmFtZXNfMVtqXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIGRvZXNuJ3QgcHV0IHRoZSB0aW1lc3RhbXAgZnJhbWUgaW4gdGhlIFRleHRUcmFja1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlkM18xLmRlZmF1bHQuaXNUaW1lU3RhbXBGcmFtZShmcmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdWUgPSBuZXcgQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VlLnZhbHVlID0gZnJhbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlkM1RyYWNrLmFkZEN1ZShjdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSUQzVHJhY2tDb250cm9sbGVyO1xufShldmVudF9oYW5kbGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSUQzVHJhY2tDb250cm9sbGVyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvbGV2ZWwtY29udHJvbGxlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9sZXZlbC1jb250cm9sbGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLypcbiAqIExldmVsIENvbnRyb2xsZXJcbiovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy5qc1wiKTtcbnZhciBldmVudF9oYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudC1oYW5kbGVyICovIFwiLi9zcmMvZXZlbnQtaGFuZGxlci5qc1wiKTtcbnZhciBsb2dnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci5qc1wiKTtcbnZhciBlcnJvcnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy5qc1wiKTtcbnZhciBjb2RlY3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2NvZGVjcyAqLyBcIi4vc3JjL3V0aWxzL2NvZGVjcy5qc1wiKTtcbnZhciBsZXZlbF9oZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGV2ZWwtaGVscGVyICovIFwiLi9zcmMvY29udHJvbGxlci9sZXZlbC1oZWxwZXIuanNcIik7XG52YXIgcGVyZm9ybWFuY2UgPSB3aW5kb3cucGVyZm9ybWFuY2U7XG52YXIgY2hyb21lT3JGaXJlZm94O1xudmFyIExldmVsQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGV2ZWxDb250cm9sbGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExldmVsQ29udHJvbGxlcihobHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaGxzLCBldmVudHNfMS5kZWZhdWx0Lk1BTklGRVNUX0xPQURFRCwgZXZlbnRzXzEuZGVmYXVsdC5MRVZFTF9MT0FERUQsIGV2ZW50c18xLmRlZmF1bHQuQVVESU9fVFJBQ0tfU1dJVENIRUQsIGV2ZW50c18xLmRlZmF1bHQuRlJBR19MT0FERUQsIGV2ZW50c18xLmRlZmF1bHQuRVJST1IpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNhbmxvYWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuY3VycmVudExldmVsSW5kZXggPSBudWxsO1xuICAgICAgICBfdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gLTE7XG4gICAgICAgIF90aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgY2hyb21lT3JGaXJlZm94ID0gL2Nocm9tZXxmaXJlZm94Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZS5vbkhhbmRsZXJEZXN0cm95aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gLTE7XG4gICAgfTtcbiAgICBMZXZlbENvbnRyb2xsZXIucHJvdG90eXBlLmNsZWFyVGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZS5zdGFydExvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XG4gICAgICAgIHRoaXMuY2FubG9hZCA9IHRydWU7XG4gICAgICAgIHRoaXMubGV2ZWxSZXRyeUNvdW50ID0gMDtcbiAgICAgICAgLy8gY2xlYW4gdXAgbGl2ZSBsZXZlbCBkZXRhaWxzIHRvIGZvcmNlIHJlbG9hZCB0aGVtLCBhbmQgcmVzZXQgbG9hZCBlcnJvcnNcbiAgICAgICAgaWYgKGxldmVscykge1xuICAgICAgICAgICAgbGV2ZWxzLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwubG9hZEVycm9yID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgbGV2ZWxEZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWxEZXRhaWxzICYmIGxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldmVsLmRldGFpbHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3BlZWQgdXAgbGl2ZSBwbGF5bGlzdCByZWZyZXNoIGlmIHRpbWVyIGV4aXN0c1xuICAgICAgICBpZiAodGhpcy50aW1lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5sb2FkTGV2ZWwoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZS5zdG9wTG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jYW5sb2FkID0gZmFsc2U7XG4gICAgfTtcbiAgICBMZXZlbENvbnRyb2xsZXIucHJvdG90eXBlLm9uTWFuaWZlc3RMb2FkZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgbGV2ZWxzID0gW107XG4gICAgICAgIHZhciBhdWRpb1RyYWNrcyA9IFtdO1xuICAgICAgICB2YXIgYml0cmF0ZVN0YXJ0O1xuICAgICAgICB2YXIgbGV2ZWxTZXQgPSB7fTtcbiAgICAgICAgdmFyIGxldmVsRnJvbVNldCA9IG51bGw7XG4gICAgICAgIHZhciB2aWRlb0NvZGVjRm91bmQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGF1ZGlvQ29kZWNGb3VuZCA9IGZhbHNlO1xuICAgICAgICAvLyByZWdyb3VwIHJlZHVuZGFudCBsZXZlbHMgdG9nZXRoZXJcbiAgICAgICAgZGF0YS5sZXZlbHMuZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gbGV2ZWwuYXR0cnM7XG4gICAgICAgICAgICBsZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgdmlkZW9Db2RlY0ZvdW5kID0gdmlkZW9Db2RlY0ZvdW5kIHx8ICEhbGV2ZWwudmlkZW9Db2RlYztcbiAgICAgICAgICAgIGF1ZGlvQ29kZWNGb3VuZCA9IGF1ZGlvQ29kZWNGb3VuZCB8fCAhIWxldmVsLmF1ZGlvQ29kZWM7XG4gICAgICAgICAgICAvLyBlcmFzZSBhdWRpbyBjb2RlYyBpbmZvIGlmIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBtcDRhLjQwLjM0LlxuICAgICAgICAgICAgLy8gZGVtdXhlciB3aWxsIGF1dG9kZXRlY3QgY29kZWMgYW5kIGZhbGxiYWNrIHRvIG1wZWcvYXVkaW9cbiAgICAgICAgICAgIGlmIChjaHJvbWVPckZpcmVmb3ggJiYgbGV2ZWwuYXVkaW9Db2RlYyAmJiBsZXZlbC5hdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuMzQnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsZXZlbC5hdWRpb0NvZGVjID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV2ZWxGcm9tU2V0ID0gbGV2ZWxTZXRbbGV2ZWwuYml0cmF0ZV07IC8vIEZJWE1FOiB3ZSB3b3VsZCBhbHNvIGhhdmUgdG8gbWF0Y2ggdGhlIHJlc29sdXRpb24gaGVyZVxuICAgICAgICAgICAgaWYgKCFsZXZlbEZyb21TZXQpIHtcbiAgICAgICAgICAgICAgICBsZXZlbC51cmwgPSBbbGV2ZWwudXJsXTtcbiAgICAgICAgICAgICAgICBsZXZlbC51cmxJZCA9IDA7XG4gICAgICAgICAgICAgICAgbGV2ZWxTZXRbbGV2ZWwuYml0cmF0ZV0gPSBsZXZlbDtcbiAgICAgICAgICAgICAgICBsZXZlbHMucHVzaChsZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXZlbEZyb21TZXQudXJsLnB1c2gobGV2ZWwudXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuQVVESU8pIHtcbiAgICAgICAgICAgICAgICAgICAgYXVkaW9Db2RlY0ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWxfaGVscGVyXzEuYWRkR3JvdXBJZChsZXZlbEZyb21TZXQgfHwgbGV2ZWwsICdhdWRpbycsIGF0dHJpYnV0ZXMuQVVESU8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlcy5TVUJUSVRMRVMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWxfaGVscGVyXzEuYWRkR3JvdXBJZChsZXZlbEZyb21TZXQgfHwgbGV2ZWwsICd0ZXh0JywgYXR0cmlidXRlcy5TVUJUSVRMRVMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHJlbW92ZSBhdWRpby1vbmx5IGxldmVsIGlmIHdlIGFsc28gaGF2ZSBsZXZlbHMgd2l0aCBhdWRpbyt2aWRlbyBjb2RlY3Mgc2lnbmFsbGVkXG4gICAgICAgIGlmICh2aWRlb0NvZGVjRm91bmQgJiYgYXVkaW9Db2RlY0ZvdW5kKSB7XG4gICAgICAgICAgICBsZXZlbHMgPSBsZXZlbHMuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciB2aWRlb0NvZGVjID0gX2EudmlkZW9Db2RlYztcbiAgICAgICAgICAgICAgICByZXR1cm4gISF2aWRlb0NvZGVjO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb25seSBrZWVwIGxldmVscyB3aXRoIHN1cHBvcnRlZCBhdWRpby92aWRlbyBjb2RlY3NcbiAgICAgICAgbGV2ZWxzID0gbGV2ZWxzLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBhdWRpb0NvZGVjID0gX2EuYXVkaW9Db2RlYywgdmlkZW9Db2RlYyA9IF9hLnZpZGVvQ29kZWM7XG4gICAgICAgICAgICByZXR1cm4gKCFhdWRpb0NvZGVjIHx8IGNvZGVjc18xLmlzQ29kZWNTdXBwb3J0ZWRJbk1wNChhdWRpb0NvZGVjLCAnYXVkaW8nKSkgJiYgKCF2aWRlb0NvZGVjIHx8IGNvZGVjc18xLmlzQ29kZWNTdXBwb3J0ZWRJbk1wNCh2aWRlb0NvZGVjLCAndmlkZW8nKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGF0YS5hdWRpb1RyYWNrcykge1xuICAgICAgICAgICAgYXVkaW9UcmFja3MgPSBkYXRhLmF1ZGlvVHJhY2tzLmZpbHRlcihmdW5jdGlvbiAodHJhY2spIHsgcmV0dXJuICF0cmFjay5hdWRpb0NvZGVjIHx8IGNvZGVjc18xLmlzQ29kZWNTdXBwb3J0ZWRJbk1wNCh0cmFjay5hdWRpb0NvZGVjLCAnYXVkaW8nKTsgfSk7XG4gICAgICAgICAgICAvLyBSZWFzc2lnbiBpZCdzIGFmdGVyIGZpbHRlcmluZyBzaW5jZSB0aGV5J3JlIHVzZWQgYXMgYXJyYXkgaW5kaWNlc1xuICAgICAgICAgICAgYXVkaW9UcmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2ssIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdHJhY2suaWQgPSBpbmRleDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZXZlbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gc3RhcnQgYml0cmF0ZSBpcyB0aGUgZmlyc3QgYml0cmF0ZSBvZiB0aGUgbWFuaWZlc3RcbiAgICAgICAgICAgIGJpdHJhdGVTdGFydCA9IGxldmVsc1swXS5iaXRyYXRlO1xuICAgICAgICAgICAgLy8gc29ydCBsZXZlbCBvbiBiaXRyYXRlXG4gICAgICAgICAgICBsZXZlbHMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5iaXRyYXRlIC0gYi5iaXRyYXRlOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX2xldmVscyA9IGxldmVscztcbiAgICAgICAgICAgIC8vIGZpbmQgaW5kZXggb2YgZmlyc3QgbGV2ZWwgaW4gc29ydGVkIGxldmVsc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWxzW2ldLmJpdHJhdGUgPT09IGJpdHJhdGVTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maXJzdExldmVsID0gaTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIm1hbmlmZXN0IGxvYWRlZCxcIiArIGxldmVscy5sZW5ndGggKyBcIiBsZXZlbChzKSBmb3VuZCwgZmlyc3QgYml0cmF0ZTpcIiArIGJpdHJhdGVTdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEF1ZGlvIGlzIG9ubHkgYWx0ZXJuYXRlIGlmIG1hbmlmZXN0IGluY2x1ZGUgYSBVUkkgYWxvbmcgd2l0aCB0aGUgYXVkaW8gZ3JvdXAgdGFnXG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuTUFOSUZFU1RfUEFSU0VELCB7XG4gICAgICAgICAgICAgICAgbGV2ZWxzOiBsZXZlbHMsXG4gICAgICAgICAgICAgICAgYXVkaW9UcmFja3M6IGF1ZGlvVHJhY2tzLFxuICAgICAgICAgICAgICAgIGZpcnN0TGV2ZWw6IHRoaXMuX2ZpcnN0TGV2ZWwsXG4gICAgICAgICAgICAgICAgc3RhdHM6IGRhdGEuc3RhdHMsXG4gICAgICAgICAgICAgICAgYXVkaW86IGF1ZGlvQ29kZWNGb3VuZCxcbiAgICAgICAgICAgICAgICB2aWRlbzogdmlkZW9Db2RlY0ZvdW5kLFxuICAgICAgICAgICAgICAgIGFsdEF1ZGlvOiBhdWRpb1RyYWNrcy5zb21lKGZ1bmN0aW9uICh0KSB7IHJldHVybiAhIXQudXJsOyB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBlcnJvcnNfMS5FcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGVycm9yc18xLkVycm9yRGV0YWlscy5NQU5JRkVTVF9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SLFxuICAgICAgICAgICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICAgICAgICAgIHVybDogdGhpcy5obHMudXJsLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogJ25vIGxldmVsIHdpdGggY29tcGF0aWJsZSBjb2RlY3MgZm91bmQgaW4gbWFuaWZlc3QnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExldmVsQ29udHJvbGxlci5wcm90b3R5cGUsIFwibGV2ZWxzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGV2ZWxzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZSwgXCJsZXZlbFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudExldmVsSW5kZXg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0xldmVsKSB7XG4gICAgICAgICAgICB2YXIgbGV2ZWxzID0gdGhpcy5fbGV2ZWxzO1xuICAgICAgICAgICAgaWYgKGxldmVscykge1xuICAgICAgICAgICAgICAgIG5ld0xldmVsID0gTWF0aC5taW4obmV3TGV2ZWwsIGxldmVscy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50TGV2ZWxJbmRleCAhPT0gbmV3TGV2ZWwgfHwgIWxldmVsc1tuZXdMZXZlbF0uZGV0YWlscykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldExldmVsSW50ZXJuYWwobmV3TGV2ZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZS5zZXRMZXZlbEludGVybmFsID0gZnVuY3Rpb24gKG5ld0xldmVsKSB7XG4gICAgICAgIHZhciBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XG4gICAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgICAgLy8gY2hlY2sgaWYgbGV2ZWwgaWR4IGlzIHZhbGlkXG4gICAgICAgIGlmIChuZXdMZXZlbCA+PSAwICYmIG5ld0xldmVsIDwgbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRMZXZlbEluZGV4ICE9PSBuZXdMZXZlbCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJzd2l0Y2hpbmcgdG8gbGV2ZWwgXCIgKyBuZXdMZXZlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IG5ld0xldmVsO1xuICAgICAgICAgICAgICAgIHZhciBsZXZlbFByb3BlcnRpZXMgPSBsZXZlbHNbbmV3TGV2ZWxdO1xuICAgICAgICAgICAgICAgIGxldmVsUHJvcGVydGllcy5sZXZlbCA9IG5ld0xldmVsO1xuICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuTEVWRUxfU1dJVENISU5HLCBsZXZlbFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxldmVsID0gbGV2ZWxzW25ld0xldmVsXTtcbiAgICAgICAgICAgIHZhciBsZXZlbERldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBsb2FkIHBsYXlsaXN0IGZvciB0aGlzIGxldmVsXG4gICAgICAgICAgICBpZiAoIWxldmVsRGV0YWlscyB8fCBsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgICAgICAgICAgIC8vIGxldmVsIG5vdCByZXRyaWV2ZWQgeWV0LCBvciBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gKHJlKWxvYWQgaXRcbiAgICAgICAgICAgICAgICB2YXIgdXJsSWQgPSBsZXZlbC51cmxJZDtcbiAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkxFVkVMX0xPQURJTkcsIHsgdXJsOiBsZXZlbC51cmxbdXJsSWRdLCBsZXZlbDogbmV3TGV2ZWwsIGlkOiB1cmxJZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGludmFsaWQgbGV2ZWwgaWQgZ2l2ZW4sIHRyaWdnZXIgZXJyb3JcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBlcnJvcnNfMS5FcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGVycm9yc18xLkVycm9yRGV0YWlscy5MRVZFTF9TV0lUQ0hfRVJST1IsXG4gICAgICAgICAgICAgICAgbGV2ZWw6IG5ld0xldmVsLFxuICAgICAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZWFzb246ICdpbnZhbGlkIGxldmVsIGlkeCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZSwgXCJtYW51YWxMZXZlbFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFudWFsTGV2ZWxJbmRleDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3TGV2ZWwpIHtcbiAgICAgICAgICAgIHRoaXMubWFudWFsTGV2ZWxJbmRleCA9IG5ld0xldmVsO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXJ0TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdMZXZlbCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxldmVsID0gbmV3TGV2ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMZXZlbENvbnRyb2xsZXIucHJvdG90eXBlLCBcImZpcnN0TGV2ZWxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9maXJzdExldmVsO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdMZXZlbCkge1xuICAgICAgICAgICAgdGhpcy5fZmlyc3RMZXZlbCA9IG5ld0xldmVsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZSwgXCJzdGFydExldmVsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBobHMuc3RhcnRMZXZlbCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgY29uZmlnLnN0YXJ0TGV2ZWxcbiAgICAgICAgICAgIC8vIGlmIG5vbmUgb2YgdGhlc2UgdmFsdWVzIGFyZSBkZWZpbmVkLCBmYWxsYmFjayBvbiB0aGlzLl9maXJzdExldmVsIChmaXJzdCBxdWFsaXR5IGxldmVsIGFwcGVhcmluZyBpbiB2YXJpYW50IG1hbmlmZXN0KVxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXJ0TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBjb25maWdTdGFydExldmVsID0gdGhpcy5obHMuY29uZmlnLnN0YXJ0TGV2ZWw7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZ1N0YXJ0TGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlnU3RhcnRMZXZlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9maXJzdExldmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGFydExldmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdMZXZlbCkge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBMZXZlbENvbnRyb2xsZXIucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gZXJyb3JzXzEuRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxldmVsRXJyb3IgPSBmYWxzZSwgZnJhZ21lbnRFcnJvciA9IGZhbHNlO1xuICAgICAgICB2YXIgbGV2ZWxJbmRleDtcbiAgICAgICAgLy8gdHJ5IHRvIHJlY292ZXIgbm90IGZhdGFsIGVycm9yc1xuICAgICAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgICAgICAgICAgY2FzZSBlcnJvcnNfMS5FcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgICAgICAgY2FzZSBlcnJvcnNfMS5FcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICAgICAgICBjYXNlIGVycm9yc18xLkVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUjpcbiAgICAgICAgICAgIGNhc2UgZXJyb3JzXzEuRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAgICAgICAgICAgbGV2ZWxJbmRleCA9IGRhdGEuZnJhZy5sZXZlbDtcbiAgICAgICAgICAgICAgICBmcmFnbWVudEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZXJyb3JzXzEuRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I6XG4gICAgICAgICAgICBjYXNlIGVycm9yc18xLkVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ6XG4gICAgICAgICAgICAgICAgbGV2ZWxJbmRleCA9IGRhdGEuY29udGV4dC5sZXZlbDtcbiAgICAgICAgICAgICAgICBsZXZlbEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZXJyb3JzXzEuRXJyb3JEZXRhaWxzLlJFTVVYX0FMTE9DX0VSUk9SOlxuICAgICAgICAgICAgICAgIGxldmVsSW5kZXggPSBkYXRhLmxldmVsO1xuICAgICAgICAgICAgICAgIGxldmVsRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZXZlbEluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVjb3ZlckxldmVsKGRhdGEsIGxldmVsSW5kZXgsIGxldmVsRXJyb3IsIGZyYWdtZW50RXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTd2l0Y2ggdG8gYSByZWR1bmRhbnQgc3RyZWFtIGlmIGFueSBhdmFpbGFibGUuXG4gICAgICogSWYgcmVkdW5kYW50IHN0cmVhbSBpcyBub3QgYXZhaWxhYmxlLCBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gaWYgQUJSIG1vZGUgaXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlcnJvckV2ZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsSW5kZXggY3VycmVudCBsZXZlbCBpbmRleFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gbGV2ZWxFcnJvclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZnJhZ21lbnRFcnJvclxuICAgICAqL1xuICAgIC8vIEZJWE1FIEZpbmQgYSBiZXR0ZXIgYWJzdHJhY3Rpb24gd2hlcmUgZnJhZ21lbnQvbGV2ZWwgcmV0cnkgbWFuYWdlbWVudCBpcyB3ZWxsIGRlY291cGxlZFxuICAgIExldmVsQ29udHJvbGxlci5wcm90b3R5cGUucmVjb3ZlckxldmVsID0gZnVuY3Rpb24gKGVycm9yRXZlbnQsIGxldmVsSW5kZXgsIGxldmVsRXJyb3IsIGZyYWdtZW50RXJyb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICAgICAgdmFyIGVycm9yRGV0YWlscyA9IGVycm9yRXZlbnQuZGV0YWlscztcbiAgICAgICAgdmFyIGxldmVsID0gdGhpcy5fbGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgICAgICB2YXIgcmVkdW5kYW50TGV2ZWxzLCBkZWxheSwgbmV4dExldmVsO1xuICAgICAgICBsZXZlbC5sb2FkRXJyb3IrKztcbiAgICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IGZyYWdtZW50RXJyb3I7XG4gICAgICAgIGlmIChsZXZlbEVycm9yKSB7XG4gICAgICAgICAgICBpZiAoKHRoaXMubGV2ZWxSZXRyeUNvdW50ICsgMSkgPD0gY29uZmlnLmxldmVsTG9hZGluZ01heFJldHJ5KSB7XG4gICAgICAgICAgICAgICAgLy8gZXhwb25lbnRpYWwgYmFja29mZiBjYXBwZWQgdG8gbWF4IHJldHJ5IHRpbWVvdXRcbiAgICAgICAgICAgICAgICBkZWxheSA9IE1hdGgubWluKE1hdGgucG93KDIsIHRoaXMubGV2ZWxSZXRyeUNvdW50KSAqIGNvbmZpZy5sZXZlbExvYWRpbmdSZXRyeURlbGF5LCBjb25maWcubGV2ZWxMb2FkaW5nTWF4UmV0cnlUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAvLyBTY2hlZHVsZSBsZXZlbCByZWxvYWRcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5sb2FkTGV2ZWwoKTsgfSwgZGVsYXkpO1xuICAgICAgICAgICAgICAgIC8vIGJvb2xlYW4gdXNlZCB0byBpbmZvcm0gc3RyZWFtIGNvbnRyb2xsZXIgbm90IHRvIHN3aXRjaCBiYWNrIHRvIElETEUgb24gbm9uIGZhdGFsIGVycm9yXG4gICAgICAgICAgICAgICAgZXJyb3JFdmVudC5sZXZlbFJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmxldmVsUmV0cnlDb3VudCsrO1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKFwibGV2ZWwgY29udHJvbGxlciwgXCIgKyBlcnJvckRldGFpbHMgKyBcIiwgcmV0cnkgaW4gXCIgKyBkZWxheSArIFwiIG1zLCBjdXJyZW50IHJldHJ5IGNvdW50IGlzIFwiICsgdGhpcy5sZXZlbFJldHJ5Q291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmVycm9yKFwibGV2ZWwgY29udHJvbGxlciwgY2Fubm90IHJlY292ZXIgZnJvbSBcIiArIGVycm9yRGV0YWlscyArIFwiIGVycm9yXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudExldmVsSW5kZXggPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICAgICAgICAgIC8vIHN3aXRjaCBlcnJvciB0byBmYXRhbFxuICAgICAgICAgICAgICAgIGVycm9yRXZlbnQuZmF0YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgYW55IHJlZHVuZGFudCBzdHJlYW1zIGlmIGF2YWlsYWJsZSBmb3IgYm90aCBlcnJvcnM6IGxldmVsIGFuZCBmcmFnbWVudFxuICAgICAgICAvLyBJZiBsZXZlbC5sb2FkRXJyb3IgcmVhY2hlcyByZWR1bmRhbnRMZXZlbHMgaXQgbWVhbnMgdGhhdCB3ZSB0cmllZCB0aGVtIGFsbCwgbm8gaG9wZSAgPT4gbGV0J3Mgc3dpdGNoIGRvd25cbiAgICAgICAgaWYgKGxldmVsRXJyb3IgfHwgZnJhZ21lbnRFcnJvcikge1xuICAgICAgICAgICAgcmVkdW5kYW50TGV2ZWxzID0gbGV2ZWwudXJsLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChyZWR1bmRhbnRMZXZlbHMgPiAxICYmIGxldmVsLmxvYWRFcnJvciA8IHJlZHVuZGFudExldmVscykge1xuICAgICAgICAgICAgICAgIGxldmVsLnVybElkID0gKGxldmVsLnVybElkICsgMSkgJSByZWR1bmRhbnRMZXZlbHM7XG4gICAgICAgICAgICAgICAgbGV2ZWwuZGV0YWlscyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybihcImxldmVsIGNvbnRyb2xsZXIsIFwiICsgZXJyb3JEZXRhaWxzICsgXCIgZm9yIGxldmVsIFwiICsgbGV2ZWxJbmRleCArIFwiOiBzd2l0Y2hpbmcgdG8gcmVkdW5kYW50IFVSTC1pZCBcIiArIGxldmVsLnVybElkKTtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnQ3VycmVudCBhdWRpbyB0cmFjayBncm91cCBJRDonLCB0aGlzLmhscy5hdWRpb1RyYWNrc1t0aGlzLmhscy5hdWRpb1RyYWNrXS5ncm91cElkKTtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnTmV3IHZpZGVvIHF1YWxpdHkgbGV2ZWwgYXVkaW8gZ3JvdXAgaWQ6JywgbGV2ZWwuYXR0cnMuQVVESU8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU2VhcmNoIGZvciBhdmFpbGFibGUgbGV2ZWxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYW51YWxMZXZlbEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGxvd2VzdCBsZXZlbCBoYXMgYmVlbiByZWFjaGVkLCBsZXQncyBzdGFydCBodW50IGZyb20gdGhlIHRvcFxuICAgICAgICAgICAgICAgICAgICBuZXh0TGV2ZWwgPSAobGV2ZWxJbmRleCA9PT0gMCkgPyB0aGlzLl9sZXZlbHMubGVuZ3RoIC0gMSA6IGxldmVsSW5kZXggLSAxO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybihcImxldmVsIGNvbnRyb2xsZXIsIFwiICsgZXJyb3JEZXRhaWxzICsgXCI6IHN3aXRjaCB0byBcIiArIG5leHRMZXZlbCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWwgPSB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gbmV4dExldmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmcmFnbWVudEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IGZyYWdtZW50IHJldHJ5IGFzIGxvbmcgYXMgY29uZmlndXJhdGlvbiBhbGxvd3MuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc2V0IHRoaXMuX2xldmVsIHNvIHRoYXQgYW5vdGhlciBjYWxsIHRvIHNldCBsZXZlbCgpIHdpbGwgdHJpZ2dlciBhZ2FpbiBhIGZyYWcgbG9hZFxuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybihcImxldmVsIGNvbnRyb2xsZXIsIFwiICsgZXJyb3JEZXRhaWxzICsgXCI6IHJlbG9hZCBhIGZyYWdtZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIHJlc2V0IGVycm9ycyBvbiB0aGUgc3VjY2Vzc2Z1bCBsb2FkIG9mIGEgZnJhZ21lbnRcbiAgICBMZXZlbENvbnRyb2xsZXIucHJvdG90eXBlLm9uRnJhZ0xvYWRlZCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgZnJhZyA9IF9hLmZyYWc7XG4gICAgICAgIGlmIChmcmFnICE9PSB1bmRlZmluZWQgJiYgZnJhZy50eXBlID09PSAnbWFpbicpIHtcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IHRoaXMuX2xldmVsc1tmcmFnLmxldmVsXTtcbiAgICAgICAgICAgIGlmIChsZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5sZXZlbFJldHJ5Q291bnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBMZXZlbENvbnRyb2xsZXIucHJvdG90eXBlLm9uTGV2ZWxMb2FkZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbGV2ZWxJZCA9IGRhdGEubGV2ZWw7XG4gICAgICAgIC8vIG9ubHkgcHJvY2VzcyBsZXZlbCBsb2FkZWQgZXZlbnRzIG1hdGNoaW5nIHdpdGggZXhwZWN0ZWQgbGV2ZWxcbiAgICAgICAgaWYgKGxldmVsSWQgIT09IHRoaXMuY3VycmVudExldmVsSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VyTGV2ZWwgPSB0aGlzLl9sZXZlbHNbbGV2ZWxJZF07XG4gICAgICAgIC8vIHJlc2V0IGxldmVsIGxvYWQgZXJyb3IgY291bnRlciBvbiBzdWNjZXNzZnVsIGxldmVsIGxvYWRlZCBvbmx5IGlmIHRoZXJlIGlzIG5vIGlzc3VlcyB3aXRoIGZyYWdtZW50c1xuICAgICAgICBpZiAoIWN1ckxldmVsLmZyYWdtZW50RXJyb3IpIHtcbiAgICAgICAgICAgIGN1ckxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICAgICAgICB0aGlzLmxldmVsUmV0cnlDb3VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld0RldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgICAgIC8vIGlmIGN1cnJlbnQgcGxheWxpc3QgaXMgYSBsaXZlIHBsYXlsaXN0LCBhcm0gYSB0aW1lciB0byByZWxvYWQgaXRcbiAgICAgICAgaWYgKG5ld0RldGFpbHMubGl2ZSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldGR1cmF0aW9uTXMgPSAxMDAwICogKG5ld0RldGFpbHMuYXZlcmFnZXRhcmdldGR1cmF0aW9uID8gbmV3RGV0YWlscy5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gOiBuZXdEZXRhaWxzLnRhcmdldGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHZhciByZWxvYWRJbnRlcnZhbCA9IHRhcmdldGR1cmF0aW9uTXMsIGN1ckRldGFpbHMgPSBjdXJMZXZlbC5kZXRhaWxzO1xuICAgICAgICAgICAgaWYgKGN1ckRldGFpbHMgJiYgbmV3RGV0YWlscy5lbmRTTiA9PT0gY3VyRGV0YWlscy5lbmRTTikge1xuICAgICAgICAgICAgICAgIC8vIGZvbGxvdyBITFMgU3BlYywgSWYgdGhlIGNsaWVudCByZWxvYWRzIGEgUGxheWxpc3QgZmlsZSBhbmQgZmluZHMgdGhhdCBpdCBoYXMgbm90XG4gICAgICAgICAgICAgICAgLy8gY2hhbmdlZCB0aGVuIGl0IE1VU1Qgd2FpdCBmb3IgYSBwZXJpb2Qgb2Ygb25lLWhhbGYgdGhlIHRhcmdldFxuICAgICAgICAgICAgICAgIC8vIGR1cmF0aW9uIGJlZm9yZSByZXRyeWluZy5cbiAgICAgICAgICAgICAgICByZWxvYWRJbnRlcnZhbCAvPSAyO1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ3NhbWUgbGl2ZSBwbGF5bGlzdCwgcmVsb2FkIHR3aWNlIGZhc3RlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGVjcmVtZW50IHJlbG9hZEludGVydmFsIHdpdGggbGV2ZWwgbG9hZGluZyBkZWxheVxuICAgICAgICAgICAgcmVsb2FkSW50ZXJ2YWwgLT0gcGVyZm9ybWFuY2Uubm93KCkgLSBkYXRhLnN0YXRzLnRyZXF1ZXN0O1xuICAgICAgICAgICAgLy8gaW4gYW55IGNhc2UsIGRvbid0IHJlbG9hZCBtb3JlIHRoYW4gaGFsZiBvZiB0YXJnZXQgZHVyYXRpb25cbiAgICAgICAgICAgIHJlbG9hZEludGVydmFsID0gTWF0aC5tYXgodGFyZ2V0ZHVyYXRpb25NcyAvIDIsIE1hdGgucm91bmQocmVsb2FkSW50ZXJ2YWwpKTtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJsaXZlIHBsYXlsaXN0LCByZWxvYWQgaW4gXCIgKyBNYXRoLnJvdW5kKHJlbG9hZEludGVydmFsKSArIFwiIG1zXCIpO1xuICAgICAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMubG9hZExldmVsKCk7IH0sIHJlbG9hZEludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMZXZlbENvbnRyb2xsZXIucHJvdG90eXBlLm9uQXVkaW9UcmFja1N3aXRjaGVkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGF1ZGlvR3JvdXBJZCA9IHRoaXMuaGxzLmF1ZGlvVHJhY2tzW2RhdGEuaWRdLmdyb3VwSWQ7XG4gICAgICAgIHZhciBjdXJyZW50TGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbdGhpcy5jdXJyZW50TGV2ZWxJbmRleF07XG4gICAgICAgIGlmICghY3VycmVudExldmVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRMZXZlbC5hdWRpb0dyb3VwSWRzKSB7XG4gICAgICAgICAgICB2YXIgdXJsSWQgPSBjdXJyZW50TGV2ZWwuYXVkaW9Hcm91cElkcy5maW5kSW5kZXgoZnVuY3Rpb24gKGdyb3VwSWQpIHsgcmV0dXJuIGdyb3VwSWQgPT09IGF1ZGlvR3JvdXBJZDsgfSk7XG4gICAgICAgICAgICBpZiAodXJsSWQgIT09IGN1cnJlbnRMZXZlbC51cmxJZCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMZXZlbC51cmxJZCA9IHVybElkO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRMb2FkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExldmVsQ29udHJvbGxlci5wcm90b3R5cGUubG9hZExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIuZGVidWcoJ2NhbGwgdG8gbG9hZExldmVsJyk7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRMZXZlbEluZGV4ICE9PSBudWxsICYmIHRoaXMuY2FubG9hZCkge1xuICAgICAgICAgICAgdmFyIGxldmVsT2JqZWN0ID0gdGhpcy5fbGV2ZWxzW3RoaXMuY3VycmVudExldmVsSW5kZXhdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbE9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICBsZXZlbE9iamVjdC51cmwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBsZXZlbCA9IHRoaXMuY3VycmVudExldmVsSW5kZXg7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gbGV2ZWxPYmplY3QudXJsSWQ7XG4gICAgICAgICAgICAgICAgdmFyIHVybCA9IGxldmVsT2JqZWN0LnVybFtpZF07XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIkF0dGVtcHQgbG9hZGluZyBsZXZlbCBpbmRleCBcIiArIGxldmVsICsgXCIgd2l0aCBVUkwtaWQgXCIgKyBpZCk7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0N1cnJlbnQgYXVkaW8gdHJhY2sgZ3JvdXAgSUQ6JywgdGhpcy5obHMuYXVkaW9UcmFja3NbdGhpcy5obHMuYXVkaW9UcmFja10uZ3JvdXBJZCk7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ05ldyB2aWRlbyBxdWFsaXR5IGxldmVsIGF1ZGlvIGdyb3VwIGlkOicsIGxldmVsT2JqZWN0LmF0dHJzLkFVRElPLCBsZXZlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkxFVkVMX0xPQURJTkcsIHsgdXJsOiB1cmwsIGxldmVsOiBsZXZlbCwgaWQ6IGlkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZSwgXCJuZXh0TG9hZExldmVsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYW51YWxMZXZlbEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hbnVhbExldmVsSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5obHMubmV4dEF1dG9MZXZlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV4dExldmVsKSB7XG4gICAgICAgICAgICB0aGlzLmxldmVsID0gbmV4dExldmVsO1xuICAgICAgICAgICAgaWYgKHRoaXMubWFudWFsTGV2ZWxJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhscy5uZXh0QXV0b0xldmVsID0gbmV4dExldmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gTGV2ZWxDb250cm9sbGVyO1xufShldmVudF9oYW5kbGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTGV2ZWxDb250cm9sbGVyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvbGV2ZWwtaGVscGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvbGV2ZWwtaGVscGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKE51bWJlcikge1xuLyoqXG4gKiBAbW9kdWxlIExldmVsSGVscGVyXG4gKlxuICogUHJvdmlkaW5nIG1ldGhvZHMgZGVhbGluZyB3aXRoIHBsYXlsaXN0IHNsaWRpbmcgYW5kIGRyaWZ0XG4gKlxuICogVE9ETzogQ3JlYXRlIGFuIGFjdHVhbCBgTGV2ZWxgIGNsYXNzL21vZGVsIHRoYXQgZGVhbHMgd2l0aCBhbGwgdGhpcyBsb2dpYyBpbiBhbiBvYmplY3Qtb3JpZW50ZWQtbWFubmVyLlxuICpcbiAqICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbG9nZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIuanNcIik7XG5mdW5jdGlvbiBhZGRHcm91cElkKGxldmVsLCB0eXBlLCBpZCkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdhdWRpbyc6XG4gICAgICAgICAgICBpZiAoIWxldmVsLmF1ZGlvR3JvdXBJZHMpIHtcbiAgICAgICAgICAgICAgICBsZXZlbC5hdWRpb0dyb3VwSWRzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXZlbC5hdWRpb0dyb3VwSWRzLnB1c2goaWQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgaWYgKCFsZXZlbC50ZXh0R3JvdXBJZHMpIHtcbiAgICAgICAgICAgICAgICBsZXZlbC50ZXh0R3JvdXBJZHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldmVsLnRleHRHcm91cElkcy5wdXNoKGlkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbmV4cG9ydHMuYWRkR3JvdXBJZCA9IGFkZEdyb3VwSWQ7XG5mdW5jdGlvbiB1cGRhdGVQVFMoZnJhZ21lbnRzLCBmcm9tSWR4LCB0b0lkeCkge1xuICAgIHZhciBmcmFnRnJvbSA9IGZyYWdtZW50c1tmcm9tSWR4XSwgZnJhZ1RvID0gZnJhZ21lbnRzW3RvSWR4XSwgZnJhZ1RvUFRTID0gZnJhZ1RvLnN0YXJ0UFRTO1xuICAgIC8vIGlmIHdlIGtub3cgc3RhcnRQVFNbdG9JZHhdXG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShmcmFnVG9QVFMpKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBmcmFnbWVudCBkdXJhdGlvbi5cbiAgICAgICAgLy8gaXQgaGVscHMgdG8gZml4IGRyaWZ0cyBiZXR3ZWVuIHBsYXlsaXN0IHJlcG9ydGVkIGR1cmF0aW9uIGFuZCBmcmFnbWVudCByZWFsIGR1cmF0aW9uXG4gICAgICAgIGlmICh0b0lkeCA+IGZyb21JZHgpIHtcbiAgICAgICAgICAgIGZyYWdGcm9tLmR1cmF0aW9uID0gZnJhZ1RvUFRTIC0gZnJhZ0Zyb20uc3RhcnQ7XG4gICAgICAgICAgICBpZiAoZnJhZ0Zyb20uZHVyYXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oXCJuZWdhdGl2ZSBkdXJhdGlvbiBjb21wdXRlZCBmb3IgZnJhZyBcIiArIGZyYWdGcm9tLnNuICsgXCIsbGV2ZWwgXCIgKyBmcmFnRnJvbS5sZXZlbCArIFwiLCB0aGVyZSBzaG91bGQgYmUgc29tZSBkdXJhdGlvbiBkcmlmdCBiZXR3ZWVuIHBsYXlsaXN0IGFuZCBmcmFnbWVudCFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcmFnVG8uZHVyYXRpb24gPSBmcmFnRnJvbS5zdGFydCAtIGZyYWdUb1BUUztcbiAgICAgICAgICAgIGlmIChmcmFnVG8uZHVyYXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oXCJuZWdhdGl2ZSBkdXJhdGlvbiBjb21wdXRlZCBmb3IgZnJhZyBcIiArIGZyYWdUby5zbiArIFwiLGxldmVsIFwiICsgZnJhZ1RvLmxldmVsICsgXCIsIHRoZXJlIHNob3VsZCBiZSBzb21lIGR1cmF0aW9uIGRyaWZ0IGJldHdlZW4gcGxheWxpc3QgYW5kIGZyYWdtZW50IVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gd2UgZG9udCBrbm93IHN0YXJ0UFRTW3RvSWR4XVxuICAgICAgICBpZiAodG9JZHggPiBmcm9tSWR4KSB7XG4gICAgICAgICAgICBmcmFnVG8uc3RhcnQgPSBmcmFnRnJvbS5zdGFydCArIGZyYWdGcm9tLmR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnJhZ1RvLnN0YXJ0ID0gTWF0aC5tYXgoZnJhZ0Zyb20uc3RhcnQgLSBmcmFnVG8uZHVyYXRpb24sIDApO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy51cGRhdGVQVFMgPSB1cGRhdGVQVFM7XG5mdW5jdGlvbiB1cGRhdGVGcmFnUFRTRFRTKGRldGFpbHMsIGZyYWcsIHN0YXJ0UFRTLCBlbmRQVFMsIHN0YXJ0RFRTLCBlbmREVFMpIHtcbiAgICAvLyB1cGRhdGUgZnJhZyBQVFMvRFRTXG4gICAgdmFyIG1heFN0YXJ0UFRTID0gc3RhcnRQVFM7XG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShmcmFnLnN0YXJ0UFRTKSkge1xuICAgICAgICAvLyBkZWx0YSBQVFMgYmV0d2VlbiBhdWRpbyBhbmQgdmlkZW9cbiAgICAgICAgdmFyIGRlbHRhUFRTID0gTWF0aC5hYnMoZnJhZy5zdGFydFBUUyAtIHN0YXJ0UFRTKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZnJhZy5kZWx0YVBUUykpIHtcbiAgICAgICAgICAgIGZyYWcuZGVsdGFQVFMgPSBkZWx0YVBUUztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyYWcuZGVsdGFQVFMgPSBNYXRoLm1heChkZWx0YVBUUywgZnJhZy5kZWx0YVBUUyk7XG4gICAgICAgIH1cbiAgICAgICAgbWF4U3RhcnRQVFMgPSBNYXRoLm1heChzdGFydFBUUywgZnJhZy5zdGFydFBUUyk7XG4gICAgICAgIHN0YXJ0UFRTID0gTWF0aC5taW4oc3RhcnRQVFMsIGZyYWcuc3RhcnRQVFMpO1xuICAgICAgICBlbmRQVFMgPSBNYXRoLm1heChlbmRQVFMsIGZyYWcuZW5kUFRTKTtcbiAgICAgICAgc3RhcnREVFMgPSBNYXRoLm1pbihzdGFydERUUywgZnJhZy5zdGFydERUUyk7XG4gICAgICAgIGVuZERUUyA9IE1hdGgubWF4KGVuZERUUywgZnJhZy5lbmREVFMpO1xuICAgIH1cbiAgICB2YXIgZHJpZnQgPSBzdGFydFBUUyAtIGZyYWcuc3RhcnQ7XG4gICAgZnJhZy5zdGFydCA9IGZyYWcuc3RhcnRQVFMgPSBzdGFydFBUUztcbiAgICBmcmFnLm1heFN0YXJ0UFRTID0gbWF4U3RhcnRQVFM7XG4gICAgZnJhZy5lbmRQVFMgPSBlbmRQVFM7XG4gICAgZnJhZy5zdGFydERUUyA9IHN0YXJ0RFRTO1xuICAgIGZyYWcuZW5kRFRTID0gZW5kRFRTO1xuICAgIGZyYWcuZHVyYXRpb24gPSBlbmRQVFMgLSBzdGFydFBUUztcbiAgICB2YXIgc24gPSBmcmFnLnNuO1xuICAgIC8vIGV4aXQgaWYgc24gb3V0IG9mIHJhbmdlXG4gICAgaWYgKCFkZXRhaWxzIHx8IHNuIDwgZGV0YWlscy5zdGFydFNOIHx8IHNuID4gZGV0YWlscy5lbmRTTikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgdmFyIGZyYWdJZHgsIGZyYWdtZW50cywgaTtcbiAgICBmcmFnSWR4ID0gc24gLSBkZXRhaWxzLnN0YXJ0U047XG4gICAgZnJhZ21lbnRzID0gZGV0YWlscy5mcmFnbWVudHM7XG4gICAgLy8gdXBkYXRlIGZyYWcgcmVmZXJlbmNlIGluIGZyYWdtZW50cyBhcnJheVxuICAgIC8vIHJhdGlvbmFsZSBpcyB0aGF0IGZyYWdtZW50cyBhcnJheSBtaWdodCBub3QgY29udGFpbiB0aGlzIGZyYWcgb2JqZWN0LlxuICAgIC8vIHRoaXMgd2lsbCBoYXBwZW4gaWYgcGxheWxpc3QgaGFzIGJlZW4gcmVmcmVzaGVkIGJldHdlZW4gZnJhZyBsb2FkaW5nIGFuZCBjYWxsIHRvIHVwZGF0ZUZyYWdQVFNEVFMoKVxuICAgIC8vIGlmIHdlIGRvbid0IHVwZGF0ZSBmcmFnLCB3ZSB3b24ndCBiZSBhYmxlIHRvIHByb3BhZ2F0ZSBQVFMgaW5mbyBvbiB0aGUgcGxheWxpc3RcbiAgICAvLyByZXN1bHRpbmcgaW4gaW52YWxpZCBzbGlkaW5nIGNvbXB1dGF0aW9uXG4gICAgZnJhZ21lbnRzW2ZyYWdJZHhdID0gZnJhZztcbiAgICAvLyBhZGp1c3QgZnJhZ21lbnQgUFRTL2R1cmF0aW9uIGZyb20gc2VxbnVtLTEgdG8gZnJhZyAwXG4gICAgZm9yIChpID0gZnJhZ0lkeDsgaSA+IDA7IGktLSkge1xuICAgICAgICB1cGRhdGVQVFMoZnJhZ21lbnRzLCBpLCBpIC0gMSk7XG4gICAgfVxuICAgIC8vIGFkanVzdCBmcmFnbWVudCBQVFMvZHVyYXRpb24gZnJvbSBzZXFudW0gdG8gbGFzdCBmcmFnXG4gICAgZm9yIChpID0gZnJhZ0lkeDsgaSA8IGZyYWdtZW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgdXBkYXRlUFRTKGZyYWdtZW50cywgaSwgaSArIDEpO1xuICAgIH1cbiAgICBkZXRhaWxzLlBUU0tub3duID0gdHJ1ZTtcbiAgICByZXR1cm4gZHJpZnQ7XG59XG5leHBvcnRzLnVwZGF0ZUZyYWdQVFNEVFMgPSB1cGRhdGVGcmFnUFRTRFRTO1xuZnVuY3Rpb24gbWVyZ2VEZXRhaWxzKG9sZERldGFpbHMsIG5ld0RldGFpbHMpIHtcbiAgICB2YXIgc3RhcnQgPSBNYXRoLm1heChvbGREZXRhaWxzLnN0YXJ0U04sIG5ld0RldGFpbHMuc3RhcnRTTikgLSBuZXdEZXRhaWxzLnN0YXJ0U04sIGVuZCA9IE1hdGgubWluKG9sZERldGFpbHMuZW5kU04sIG5ld0RldGFpbHMuZW5kU04pIC0gbmV3RGV0YWlscy5zdGFydFNOLCBkZWx0YSA9IG5ld0RldGFpbHMuc3RhcnRTTiAtIG9sZERldGFpbHMuc3RhcnRTTiwgb2xkZnJhZ21lbnRzID0gb2xkRGV0YWlscy5mcmFnbWVudHMsIG5ld2ZyYWdtZW50cyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzLCBjY09mZnNldCA9IDAsIFBUU0ZyYWc7XG4gICAgLy8gcG90ZW50aWFsbHkgcmV0cmlldmUgY2FjaGVkIGluaXRzZWdtZW50XG4gICAgaWYgKG5ld0RldGFpbHMuaW5pdFNlZ21lbnQgJiYgb2xkRGV0YWlscy5pbml0U2VnbWVudCkge1xuICAgICAgICBuZXdEZXRhaWxzLmluaXRTZWdtZW50ID0gb2xkRGV0YWlscy5pbml0U2VnbWVudDtcbiAgICB9XG4gICAgLy8gY2hlY2sgaWYgb2xkL25ldyBwbGF5bGlzdHMgaGF2ZSBmcmFnbWVudHMgaW4gY29tbW9uXG4gICAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgICAgIG5ld0RldGFpbHMuUFRTS25vd24gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBsb29wIHRocm91Z2ggb3ZlcmxhcHBpbmcgU04gYW5kIHVwZGF0ZSBzdGFydFBUUyAsIGNjLCBhbmQgZHVyYXRpb24gaWYgYW55IGZvdW5kXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgIHZhciBvbGRGcmFnID0gb2xkZnJhZ21lbnRzW2RlbHRhICsgaV0sIG5ld0ZyYWcgPSBuZXdmcmFnbWVudHNbaV07XG4gICAgICAgIGlmIChuZXdGcmFnICYmIG9sZEZyYWcpIHtcbiAgICAgICAgICAgIGNjT2Zmc2V0ID0gb2xkRnJhZy5jYyAtIG5ld0ZyYWcuY2M7XG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKG9sZEZyYWcuc3RhcnRQVFMpKSB7XG4gICAgICAgICAgICAgICAgbmV3RnJhZy5zdGFydCA9IG5ld0ZyYWcuc3RhcnRQVFMgPSBvbGRGcmFnLnN0YXJ0UFRTO1xuICAgICAgICAgICAgICAgIG5ld0ZyYWcuZW5kUFRTID0gb2xkRnJhZy5lbmRQVFM7XG4gICAgICAgICAgICAgICAgbmV3RnJhZy5kdXJhdGlvbiA9IG9sZEZyYWcuZHVyYXRpb247XG4gICAgICAgICAgICAgICAgbmV3RnJhZy5iYWNrdHJhY2tlZCA9IG9sZEZyYWcuYmFja3RyYWNrZWQ7XG4gICAgICAgICAgICAgICAgbmV3RnJhZy5kcm9wcGVkID0gb2xkRnJhZy5kcm9wcGVkO1xuICAgICAgICAgICAgICAgIFBUU0ZyYWcgPSBuZXdGcmFnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjY09mZnNldCkge1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdkaXNjb250aW51aXR5IHNsaWRpbmcgZnJvbSBwbGF5bGlzdCwgdGFrZSBkcmlmdCBpbnRvIGFjY291bnQnKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5ld2ZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmV3ZnJhZ21lbnRzW2ldLmNjICs9IGNjT2Zmc2V0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGlmIGF0IGxlYXN0IG9uZSBmcmFnbWVudCBjb250YWlucyBQVFMgaW5mbywgcmVjb21wdXRlIFBUUyBpbmZvcm1hdGlvbiBmb3IgYWxsIGZyYWdtZW50c1xuICAgIGlmIChQVFNGcmFnKSB7XG4gICAgICAgIHVwZGF0ZUZyYWdQVFNEVFMobmV3RGV0YWlscywgUFRTRnJhZywgUFRTRnJhZy5zdGFydFBUUywgUFRTRnJhZy5lbmRQVFMsIFBUU0ZyYWcuc3RhcnREVFMsIFBUU0ZyYWcuZW5kRFRTKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IGRlbHRhIGlzIHdpdGhpbiBvbGRmcmFnbWVudHMgcmFuZ2VcbiAgICAgICAgLy8gYWxzbyBhZGp1c3Qgc2xpZGluZyBpbiBjYXNlIGRlbHRhIGlzIDAgKHdlIGNvdWxkIGhhdmUgb2xkPVs1MC02MF0gYW5kIG5ldz1vbGQ9WzUwLTYxXSlcbiAgICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGFsc28gbmVlZCB0byBhZGp1c3Qgc3RhcnQgb2Zmc2V0IG9mIGFsbCBmcmFnbWVudHNcbiAgICAgICAgaWYgKGRlbHRhID49IDAgJiYgZGVsdGEgPCBvbGRmcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBhZGp1c3Qgc3RhcnQgYnkgc2xpZGluZyBvZmZzZXRcbiAgICAgICAgICAgIHZhciBzbGlkaW5nID0gb2xkZnJhZ21lbnRzW2RlbHRhXS5zdGFydDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuZXdmcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBuZXdmcmFnbWVudHNbaV0uc3RhcnQgKz0gc2xpZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiB3ZSBhcmUgaGVyZSwgaXQgbWVhbnMgd2UgaGF2ZSBmcmFnbWVudHMgb3ZlcmxhcHBpbmcgYmV0d2VlblxuICAgIC8vIG9sZCBhbmQgbmV3IGxldmVsLiByZWxpYWJsZSBQVFMgaW5mbyBpcyB0aHVzIHJlbHlpbmcgb24gb2xkIGxldmVsXG4gICAgbmV3RGV0YWlscy5QVFNLbm93biA9IG9sZERldGFpbHMuUFRTS25vd247XG59XG5leHBvcnRzLm1lcmdlRGV0YWlscyA9IG1lcmdlRGV0YWlscztcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLmpzXCIpW1wiTnVtYmVyXCJdKSlcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9zdHJlYW0tY29udHJvbGxlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvc3RyZWFtLWNvbnRyb2xsZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihOdW1iZXIpIHtcbi8qXG4gKiBTdHJlYW0gQ29udHJvbGxlclxuKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGJpbmFyeV9zZWFyY2hfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2JpbmFyeS1zZWFyY2ggKi8gXCIuL3NyYy91dGlscy9iaW5hcnktc2VhcmNoLmpzXCIpO1xudmFyIGJ1ZmZlcl9oZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2J1ZmZlci1oZWxwZXIgKi8gXCIuL3NyYy91dGlscy9idWZmZXItaGVscGVyLmpzXCIpO1xudmFyIGRlbXV4ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L2RlbXV4ZXIgKi8gXCIuL3NyYy9kZW11eC9kZW11eGVyLmpzXCIpO1xudmFyIGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLmpzXCIpO1xudmFyIGZyYWdtZW50X3RyYWNrZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZnJhZ21lbnQtdHJhY2tlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtdHJhY2tlci5qc1wiKTtcbnZhciBmcmFnbWVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9hZGVyL2ZyYWdtZW50ICovIFwiLi9zcmMvbG9hZGVyL2ZyYWdtZW50LmpzXCIpO1xudmFyIHBsYXlsaXN0X2xvYWRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9hZGVyL3BsYXlsaXN0LWxvYWRlciAqLyBcIi4vc3JjL2xvYWRlci9wbGF5bGlzdC1sb2FkZXIuanNcIik7XG52YXIgTGV2ZWxIZWxwZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xldmVsLWhlbHBlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvbGV2ZWwtaGVscGVyLmpzXCIpO1xudmFyIHRpbWVfcmFuZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy90aW1lLXJhbmdlcyAqLyBcIi4vc3JjL3V0aWxzL3RpbWUtcmFuZ2VzLmpzXCIpO1xudmFyIGVycm9yc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLmpzXCIpO1xudmFyIGxvZ2dlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLmpzXCIpO1xudmFyIGRpc2NvbnRpbnVpdGllc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvZGlzY29udGludWl0aWVzICovIFwiLi9zcmMvdXRpbHMvZGlzY29udGludWl0aWVzLmpzXCIpO1xudmFyIGZyYWdtZW50X2ZpbmRlcnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZnJhZ21lbnQtZmluZGVycyAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtZmluZGVycy5qc1wiKTtcbnZhciBnYXBfY29udHJvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nYXAtY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZ2FwLWNvbnRyb2xsZXIuanNcIik7XG52YXIgYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9iYXNlLXN0cmVhbS1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9iYXNlLXN0cmVhbS1jb250cm9sbGVyLmpzXCIpO1xudmFyIFRJQ0tfSU5URVJWQUwgPSAxMDA7IC8vIGhvdyBvZnRlbiB0byB0aWNrIGluIG1zXG52YXIgU3RyZWFtQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3RyZWFtQ29udHJvbGxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdHJlYW1Db250cm9sbGVyKGhscywgZnJhZ21lbnRUcmFja2VyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGhscywgZXZlbnRzXzEuZGVmYXVsdC5NRURJQV9BVFRBQ0hFRCwgZXZlbnRzXzEuZGVmYXVsdC5NRURJQV9ERVRBQ0hJTkcsIGV2ZW50c18xLmRlZmF1bHQuTUFOSUZFU1RfTE9BRElORywgZXZlbnRzXzEuZGVmYXVsdC5NQU5JRkVTVF9QQVJTRUQsIGV2ZW50c18xLmRlZmF1bHQuTEVWRUxfTE9BREVELCBldmVudHNfMS5kZWZhdWx0LktFWV9MT0FERUQsIGV2ZW50c18xLmRlZmF1bHQuRlJBR19MT0FERUQsIGV2ZW50c18xLmRlZmF1bHQuRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVELCBldmVudHNfMS5kZWZhdWx0LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIGV2ZW50c18xLmRlZmF1bHQuRlJBR19QQVJTSU5HX0RBVEEsIGV2ZW50c18xLmRlZmF1bHQuRlJBR19QQVJTRUQsIGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIGV2ZW50c18xLmRlZmF1bHQuQVVESU9fVFJBQ0tfU1dJVENISU5HLCBldmVudHNfMS5kZWZhdWx0LkFVRElPX1RSQUNLX1NXSVRDSEVELCBldmVudHNfMS5kZWZhdWx0LkJVRkZFUl9DUkVBVEVELCBldmVudHNfMS5kZWZhdWx0LkJVRkZFUl9BUFBFTkRFRCwgZXZlbnRzXzEuZGVmYXVsdC5CVUZGRVJfRkxVU0hFRCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZnJhZ21lbnRUcmFja2VyID0gZnJhZ21lbnRUcmFja2VyO1xuICAgICAgICBfdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgICAgICBfdGhpcy5hdWRpb0NvZGVjU3dhcCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5fc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuU1RPUFBFRDtcbiAgICAgICAgX3RoaXMuc3RhbGxSZXBvcnRlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5nYXBDb250cm9sbGVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbkhhbmRsZXJEZXN0cm95aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUub25IYW5kbGVyRGVzdHJveWluZy5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25IYW5kbGVyRGVzdHJveWVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLlNUT1BQRUQ7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyID0gbnVsbDtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vbkhhbmRsZXJEZXN0cm95ZWQuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLnN0YXJ0TG9hZCA9IGZ1bmN0aW9uIChzdGFydFBvc2l0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmxldmVscykge1xuICAgICAgICAgICAgdmFyIGxhc3RDdXJyZW50VGltZSA9IHRoaXMubGFzdEN1cnJlbnRUaW1lLCBobHNfMSA9IHRoaXMuaGxzO1xuICAgICAgICAgICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgICAgICAgICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMKTtcbiAgICAgICAgICAgIHRoaXMubGV2ZWwgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGxvYWQgbGV2ZWxcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRMZXZlbCA9IGhsc18xLnN0YXJ0TGV2ZWw7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0TGV2ZWwgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIC0xIDogZ3Vlc3Mgc3RhcnQgTGV2ZWwgYnkgZG9pbmcgYSBiaXRyYXRlIHRlc3QgYnkgbG9hZGluZyBmaXJzdCBmcmFnbWVudCBvZiBsb3dlc3QgcXVhbGl0eSBsZXZlbFxuICAgICAgICAgICAgICAgICAgICBzdGFydExldmVsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iaXRyYXRlVGVzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHNldCBuZXcgbGV2ZWwgdG8gcGxheWxpc3QgbG9hZGVyIDogdGhpcyB3aWxsIHRyaWdnZXIgc3RhcnQgbGV2ZWwgbG9hZFxuICAgICAgICAgICAgICAgIC8vIGhscy5uZXh0TG9hZExldmVsIHJlbWFpbnMgdW50aWwgaXQgaXMgc2V0IHRvIGEgbmV3IHZhbHVlIG9yIHVudGlsIGEgbmV3IGZyYWcgaXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZFxuICAgICAgICAgICAgICAgIHRoaXMubGV2ZWwgPSBobHNfMS5uZXh0TG9hZExldmVsID0gc3RhcnRMZXZlbDtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBzdGFydFBvc2l0aW9uIHVuZGVmaW5lZCBidXQgbGFzdEN1cnJlbnRUaW1lIHNldCwgc2V0IHN0YXJ0UG9zaXRpb24gdG8gbGFzdCBjdXJyZW50VGltZVxuICAgICAgICAgICAgaWYgKGxhc3RDdXJyZW50VGltZSA+IDAgJiYgc3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwib3ZlcnJpZGUgc3RhcnRQb3NpdGlvbiB3aXRoIGxhc3RDdXJyZW50VGltZSBAXCIgKyBsYXN0Q3VycmVudFRpbWUudG9GaXhlZCgzKSk7XG4gICAgICAgICAgICAgICAgc3RhcnRQb3NpdGlvbiA9IGxhc3RDdXJyZW50VGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuSURMRTtcbiAgICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgICAgIHRoaXMudGljaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mb3JjZVN0YXJ0TG9hZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLlNUT1BQRUQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLnN0b3BMb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgICAgICBpZiAoZnJhZy5sb2FkZXIpIHtcbiAgICAgICAgICAgICAgICBmcmFnLmxvYWRlci5hYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmRlbXV4ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVtdXhlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLlNUT1BQRUQ7XG4gICAgICAgIHRoaXMuZm9yY2VTdGFydExvYWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmRvVGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5CVUZGRVJfRkxVU0hJTkc6XG4gICAgICAgICAgICAgICAgLy8gaW4gYnVmZmVyIGZsdXNoaW5nIHN0YXRlLCByZXNldCBmcmFnTG9hZEVycm9yIGNvdW50ZXJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuSURMRTpcbiAgICAgICAgICAgICAgICB0aGlzLl9kb1RpY2tJZGxlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5XQUlUSU5HX0xFVkVMOlxuICAgICAgICAgICAgICAgIHZhciBsZXZlbCA9IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxdO1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHBsYXlsaXN0IGlzIGFscmVhZHkgbG9hZGVkXG4gICAgICAgICAgICAgICAgaWYgKGxldmVsICYmIGxldmVsLmRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5JRExFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOlxuICAgICAgICAgICAgICAgIHZhciBub3cgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICAgICAgdmFyIHJldHJ5RGF0ZSA9IHRoaXMucmV0cnlEYXRlO1xuICAgICAgICAgICAgICAgIC8vIGlmIGN1cnJlbnQgdGltZSBpcyBndCB0aGFuIHJldHJ5RGF0ZSwgb3IgaWYgbWVkaWEgc2Vla2luZyBsZXQncyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byByZXRyeSBsb2FkaW5nXG4gICAgICAgICAgICAgICAgaWYgKCFyZXRyeURhdGUgfHwgKG5vdyA+PSByZXRyeURhdGUpIHx8ICh0aGlzLm1lZGlhICYmIHRoaXMubWVkaWEuc2Vla2luZykpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnbWVkaWFDb250cm9sbGVyOiByZXRyeURhdGUgcmVhY2hlZCwgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZScpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLklETEU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuRVJST1I6XG4gICAgICAgICAgICBjYXNlIGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5TVE9QUEVEOlxuICAgICAgICAgICAgY2FzZSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuRlJBR19MT0FESU5HOlxuICAgICAgICAgICAgY2FzZSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuUEFSU0lORzpcbiAgICAgICAgICAgIGNhc2UgYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLlBBUlNFRDpcbiAgICAgICAgICAgIGNhc2UgYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLkVOREVEOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBidWZmZXJcbiAgICAgICAgdGhpcy5fY2hlY2tCdWZmZXIoKTtcbiAgICAgICAgLy8gY2hlY2svdXBkYXRlIGN1cnJlbnQgZnJhZ21lbnRcbiAgICAgICAgdGhpcy5fY2hlY2tGcmFnbWVudENoYW5nZWQoKTtcbiAgICB9O1xuICAgIC8vIElyb25pY2FsbHkgdGhlIFwiaWRsZVwiIHN0YXRlIGlzIHRoZSBvbiB3ZSBkbyB0aGUgbW9zdCBsb2dpYyBpbiBpdCBzZWVtcyAuLi4uXG4gICAgLy8gTk9URTogTWF5YmUgd2UgY291bGQgcmF0aGVyIHNjaGVkdWxlIGEgY2hlY2sgZm9yIGJ1ZmZlciBsZW5ndGggYWZ0ZXIgaGFsZiBvZiB0aGUgY3VycmVudGx5XG4gICAgLy8gICAgICAgcGxheWVkIHNlZ21lbnQsIG9yIG9uIHBhdXNlL3BsYXkvc2VlayBpbnN0ZWFkIG9mIG5haXZlbHkgY2hlY2tpbmcgZXZlcnkgMTAwbXM/XG4gICAgU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuX2RvVGlja0lkbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBobHMgPSB0aGlzLmhscywgY29uZmlnID0gaGxzLmNvbmZpZywgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgICAvLyBpZiBzdGFydCBsZXZlbCBub3QgcGFyc2VkIHlldCBPUlxuICAgICAgICAvLyBpZiB2aWRlbyBub3QgYXR0YWNoZWQgQU5EIHN0YXJ0IGZyYWdtZW50IGFscmVhZHkgcmVxdWVzdGVkIE9SIHN0YXJ0IGZyYWcgcHJlZmV0Y2ggZGlzYWJsZVxuICAgICAgICAvLyBleGl0IGxvb3AsIGFzIHdlIGVpdGhlciBuZWVkIG1vcmUgaW5mbyAobGV2ZWwgbm90IHBhcnNlZCkgb3Igd2UgbmVlZCBtZWRpYSB0byBiZSBhdHRhY2hlZCB0byBsb2FkIG5ldyBmcmFnbWVudFxuICAgICAgICBpZiAodGhpcy5sZXZlbExhc3RMb2FkZWQgPT09IHVuZGVmaW5lZCB8fCAoIW1lZGlhICYmICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCB8fCAhY29uZmlnLnN0YXJ0RnJhZ1ByZWZldGNoKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSBoYXZlIG5vdCB5ZXQgbG9hZGVkIGFueSBmcmFnbWVudCwgc3RhcnQgbG9hZGluZyBmcm9tIHN0YXJ0IHBvc2l0aW9uXG4gICAgICAgIHZhciBwb3M7XG4gICAgICAgIGlmICh0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICAgICAgICBwb3MgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvcyA9IHRoaXMubmV4dExvYWRQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZXRlcm1pbmUgbmV4dCBsb2FkIGxldmVsXG4gICAgICAgIHZhciBsZXZlbCA9IGhscy5uZXh0TG9hZExldmVsLCBsZXZlbEluZm8gPSB0aGlzLmxldmVsc1tsZXZlbF07XG4gICAgICAgIGlmICghbGV2ZWxJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxldmVsQml0cmF0ZSA9IGxldmVsSW5mby5iaXRyYXRlLCBtYXhCdWZMZW47XG4gICAgICAgIC8vIGNvbXB1dGUgbWF4IEJ1ZmZlciBMZW5ndGggdGhhdCB3ZSBjb3VsZCBnZXQgZnJvbSB0aGlzIGxvYWQgbGV2ZWwsIGJhc2VkIG9uIGxldmVsIGJpdHJhdGUuIGRvbid0IGJ1ZmZlciBtb3JlIHRoYW4gNjAgTUIgYW5kIG1vcmUgdGhhbiAzMHNcbiAgICAgICAgaWYgKGxldmVsQml0cmF0ZSkge1xuICAgICAgICAgICAgbWF4QnVmTGVuID0gTWF0aC5tYXgoOCAqIGNvbmZpZy5tYXhCdWZmZXJTaXplIC8gbGV2ZWxCaXRyYXRlLCBjb25maWcubWF4QnVmZmVyTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1heEJ1ZkxlbiA9IGNvbmZpZy5tYXhCdWZmZXJMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgbWF4QnVmTGVuID0gTWF0aC5taW4obWF4QnVmTGVuLCBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoKTtcbiAgICAgICAgLy8gZGV0ZXJtaW5lIG5leHQgY2FuZGlkYXRlIGZyYWdtZW50IHRvIGJlIGxvYWRlZCwgYmFzZWQgb24gY3VycmVudCBwb3NpdGlvbiBhbmQgZW5kIG9mIGJ1ZmZlciBwb3NpdGlvblxuICAgICAgICAvLyBlbnN1cmUgdXAgdG8gYGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGhgIG9mIGJ1ZmZlciB1cGZyb250XG4gICAgICAgIHZhciBidWZmZXJJbmZvID0gYnVmZmVyX2hlbHBlcl8xLkJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogbWVkaWEsIHBvcywgY29uZmlnLm1heEJ1ZmZlckhvbGUpLCBidWZmZXJMZW4gPSBidWZmZXJJbmZvLmxlbjtcbiAgICAgICAgLy8gU3RheSBpZGxlIGlmIHdlIGFyZSBzdGlsbCB3aXRoIGJ1ZmZlciBtYXJnaW5zXG4gICAgICAgIGlmIChidWZmZXJMZW4gPj0gbWF4QnVmTGVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYnVmZmVyIGxlbmd0aCBpcyBsZXNzIHRoYW4gbWF4QnVmTGVuIHRyeSB0byBsb2FkIGEgbmV3IGZyYWdtZW50IC4uLlxuICAgICAgICBsb2dnZXJfMS5sb2dnZXIudHJhY2UoXCJidWZmZXIgbGVuZ3RoIG9mIFwiICsgYnVmZmVyTGVuLnRvRml4ZWQoMykgKyBcIiBpcyBiZWxvdyBtYXggb2YgXCIgKyBtYXhCdWZMZW4udG9GaXhlZCgzKSArIFwiLiBjaGVja2luZyBmb3IgbW9yZSBwYXlsb2FkIC4uLlwiKTtcbiAgICAgICAgLy8gc2V0IG5leHQgbG9hZCBsZXZlbCA6IHRoaXMgd2lsbCB0cmlnZ2VyIGEgcGxheWxpc3QgbG9hZCBpZiBuZWVkZWRcbiAgICAgICAgdGhpcy5sZXZlbCA9IGhscy5uZXh0TG9hZExldmVsID0gbGV2ZWw7XG4gICAgICAgIHZhciBsZXZlbERldGFpbHMgPSBsZXZlbEluZm8uZGV0YWlscztcbiAgICAgICAgLy8gaWYgbGV2ZWwgaW5mbyBub3QgcmV0cmlldmVkIHlldCwgc3dpdGNoIHN0YXRlIGFuZCB3YWl0IGZvciBsZXZlbCByZXRyaWV2YWxcbiAgICAgICAgLy8gaWYgbGl2ZSBwbGF5bGlzdCwgZW5zdXJlIHRoYXQgbmV3IHBsYXlsaXN0IGhhcyBiZWVuIHJlZnJlc2hlZCB0byBhdm9pZCBsb2FkaW5nL3RyeSB0byBsb2FkXG4gICAgICAgIC8vIGEgdXNlbGVzcyBhbmQgb3V0ZGF0ZWQgZnJhZ21lbnQgKHRoYXQgbWlnaHQgZXZlbiBpbnRyb2R1Y2UgbG9hZCBlcnJvciBpZiBpdCBpcyBhbHJlYWR5IG91dCBvZiB0aGUgbGl2ZSBwbGF5bGlzdClcbiAgICAgICAgaWYgKCFsZXZlbERldGFpbHMgfHwgKGxldmVsRGV0YWlscy5saXZlICYmIHRoaXMubGV2ZWxMYXN0TG9hZGVkICE9PSBsZXZlbCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuV0FJVElOR19MRVZFTDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc3RyZWFtRW5kZWQoYnVmZmVySW5mbywgbGV2ZWxEZXRhaWxzKSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsdEF1ZGlvKSB7XG4gICAgICAgICAgICAgICAgZGF0YS50eXBlID0gJ3ZpZGVvJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5CVUZGRVJfRU9TLCBkYXRhKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuRU5ERUQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgaGF2ZSB0aGUgbGV2ZWxEZXRhaWxzIGZvciB0aGUgc2VsZWN0ZWQgdmFyaWFudCwgbGV0cyBjb250aW51ZSBlbnJpY2hlbiBvdXIgc3RyZWFtIChsb2FkIGtleXMvZnJhZ21lbnRzIG9yIHRyaWdnZXIgRU9TLCBldGMuLilcbiAgICAgICAgdGhpcy5fZmV0Y2hQYXlsb2FkT3JFb3MocG9zLCBidWZmZXJJbmZvLCBsZXZlbERldGFpbHMpO1xuICAgIH07XG4gICAgU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuX2ZldGNoUGF5bG9hZE9yRW9zID0gZnVuY3Rpb24gKHBvcywgYnVmZmVySW5mbywgbGV2ZWxEZXRhaWxzKSB7XG4gICAgICAgIHZhciBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cywgbGV2ZWwgPSB0aGlzLmxldmVsLCBmcmFnbWVudHMgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzLCBmcmFnTGVuID0gZnJhZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgLy8gZW1wdHkgcGxheWxpc3RcbiAgICAgICAgaWYgKGZyYWdMZW4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBmaW5kIGZyYWdtZW50IGluZGV4LCBjb250aWd1b3VzIHdpdGggZW5kIG9mIGJ1ZmZlciBwb3NpdGlvblxuICAgICAgICB2YXIgc3RhcnQgPSBmcmFnbWVudHNbMF0uc3RhcnQsIGVuZCA9IGZyYWdtZW50c1tmcmFnTGVuIC0gMV0uc3RhcnQgKyBmcmFnbWVudHNbZnJhZ0xlbiAtIDFdLmR1cmF0aW9uLCBidWZmZXJFbmQgPSBidWZmZXJJbmZvLmVuZCwgZnJhZztcbiAgICAgICAgaWYgKGxldmVsRGV0YWlscy5pbml0U2VnbWVudCAmJiAhbGV2ZWxEZXRhaWxzLmluaXRTZWdtZW50LmRhdGEpIHtcbiAgICAgICAgICAgIGZyYWcgPSBsZXZlbERldGFpbHMuaW5pdFNlZ21lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpbiBjYXNlIG9mIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byBlbnN1cmUgdGhhdCByZXF1ZXN0ZWQgcG9zaXRpb24gaXMgbm90IGxvY2F0ZWQgYmVmb3JlIHBsYXlsaXN0IHN0YXJ0XG4gICAgICAgICAgICBpZiAobGV2ZWxEZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbExpdmVNYW5pZmVzdFNpemUgPSB0aGlzLmNvbmZpZy5pbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZTtcbiAgICAgICAgICAgICAgICBpZiAoZnJhZ0xlbiA8IGluaXRpYWxMaXZlTWFuaWZlc3RTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKFwiQ2FuIG5vdCBzdGFydCBwbGF5YmFjayBvZiBhIGxldmVsLCByZWFzb246IG5vdCBlbm91Z2ggZnJhZ21lbnRzIFwiICsgZnJhZ0xlbiArIFwiIDwgXCIgKyBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnJhZyA9IHRoaXMuX2Vuc3VyZUZyYWdtZW50QXRMaXZlUG9pbnQobGV2ZWxEZXRhaWxzLCBidWZmZXJFbmQsIHN0YXJ0LCBlbmQsIGZyYWdQcmV2aW91cywgZnJhZ21lbnRzLCBmcmFnTGVuKTtcbiAgICAgICAgICAgICAgICAvLyBpZiBpdCBleHBsaWNpdGVseSByZXR1cm5zIG51bGwgZG9uJ3QgbG9hZCBhbnkgZnJhZ21lbnQgYW5kIGV4aXQgZnVuY3Rpb24gbm93XG4gICAgICAgICAgICAgICAgaWYgKGZyYWcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFZvRCBwbGF5bGlzdDogaWYgYnVmZmVyRW5kIGJlZm9yZSBzdGFydCBvZiBwbGF5bGlzdCwgbG9hZCBmaXJzdCBmcmFnbWVudFxuICAgICAgICAgICAgICAgIGlmIChidWZmZXJFbmQgPCBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBmcmFnID0gZnJhZ21lbnRzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgICAgIGZyYWcgPSB0aGlzLl9maW5kRnJhZ21lbnQoc3RhcnQsIGZyYWdQcmV2aW91cywgZnJhZ0xlbiwgZnJhZ21lbnRzLCBidWZmZXJFbmQsIGVuZCwgbGV2ZWxEZXRhaWxzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhZykge1xuICAgICAgICAgICAgaWYgKGZyYWcuZW5jcnlwdGVkKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIkxvYWRpbmcga2V5IGZvciBcIiArIGZyYWcuc24gKyBcIiBvZiBbXCIgKyBsZXZlbERldGFpbHMuc3RhcnRTTiArIFwiICxcIiArIGxldmVsRGV0YWlscy5lbmRTTiArIFwiXSxsZXZlbCBcIiArIGxldmVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkS2V5KGZyYWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIkxvYWRpbmcgXCIgKyBmcmFnLnNuICsgXCIgb2YgW1wiICsgbGV2ZWxEZXRhaWxzLnN0YXJ0U04gKyBcIiAsXCIgKyBsZXZlbERldGFpbHMuZW5kU04gKyBcIl0sbGV2ZWwgXCIgKyBsZXZlbCArIFwiLCBjdXJyZW50VGltZTpcIiArIHBvcy50b0ZpeGVkKDMpICsgXCIsYnVmZmVyRW5kOlwiICsgYnVmZmVyRW5kLnRvRml4ZWQoMykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRGcmFnbWVudChmcmFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuX2Vuc3VyZUZyYWdtZW50QXRMaXZlUG9pbnQgPSBmdW5jdGlvbiAobGV2ZWxEZXRhaWxzLCBidWZmZXJFbmQsIHN0YXJ0LCBlbmQsIGZyYWdQcmV2aW91cywgZnJhZ21lbnRzLCBmcmFnTGVuKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmhscy5jb25maWcsIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgICAgdmFyIGZyYWc7XG4gICAgICAgIC8vIGNoZWNrIGlmIHJlcXVlc3RlZCBwb3NpdGlvbiBpcyB3aXRoaW4gc2Vla2FibGUgYm91bmRhcmllcyA6XG4gICAgICAgIC8vIGxvZ2dlci5sb2coYHN0YXJ0L3Bvcy9idWZFbmQvc2Vla2luZzoke3N0YXJ0LnRvRml4ZWQoMyl9LyR7cG9zLnRvRml4ZWQoMyl9LyR7YnVmZmVyRW5kLnRvRml4ZWQoMyl9LyR7dGhpcy5tZWRpYS5zZWVraW5nfWApO1xuICAgICAgICB2YXIgbWF4TGF0ZW5jeSA9IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiA6IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgKiBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb247XG4gICAgICAgIGlmIChidWZmZXJFbmQgPCBNYXRoLm1heChzdGFydCAtIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBlbmQgLSBtYXhMYXRlbmN5KSkge1xuICAgICAgICAgICAgdmFyIGxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmNvbXB1dGVMaXZlUG9zaXRpb24oc3RhcnQsIGxldmVsRGV0YWlscyk7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiYnVmZmVyIGVuZDogXCIgKyBidWZmZXJFbmQudG9GaXhlZCgzKSArIFwiIGlzIGxvY2F0ZWQgdG9vIGZhciBmcm9tIHRoZSBlbmQgb2YgbGl2ZSBzbGlkaW5nIHBsYXlsaXN0LCByZXNldCBjdXJyZW50VGltZSB0byA6IFwiICsgbGl2ZVN5bmNQb3NpdGlvbi50b0ZpeGVkKDMpKTtcbiAgICAgICAgICAgIGJ1ZmZlckVuZCA9IGxpdmVTeW5jUG9zaXRpb247XG4gICAgICAgICAgICBpZiAobWVkaWEgJiYgbWVkaWEucmVhZHlTdGF0ZSAmJiBtZWRpYS5kdXJhdGlvbiA+IGxpdmVTeW5jUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IGxpdmVTeW5jUG9zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBsaXZlU3luY1Bvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGVuZCBvZiBidWZmZXIgZ3JlYXRlciB0aGFuIGxpdmUgZWRnZSwgZG9uJ3QgbG9hZCBhbnkgZnJhZ21lbnRcbiAgICAgICAgLy8gdGhpcyBjb3VsZCBoYXBwZW4gaWYgbGl2ZSBwbGF5bGlzdCBpbnRlcm1pdHRlbnRseSBzbGlkZXMgaW4gdGhlIHBhc3QuXG4gICAgICAgIC8vIGxldmVsIDEgbG9hZGVkIFsxODI1ODAxNjEsMTgyNTgwMTY3XVxuICAgICAgICAvLyBsZXZlbCAxIGxvYWRlZCBbMTgyNTgwMTYyLDE4MjU4MDE2OV1cbiAgICAgICAgLy8gTG9hZGluZyAxODI1ODAxNjggb2YgWzE4MjU4MDE2MiAsMTgyNTgwMTY5XSxsZXZlbCAxIC4uXG4gICAgICAgIC8vIExvYWRpbmcgMTgyNTgwMTY5IG9mIFsxODI1ODAxNjIgLDE4MjU4MDE2OV0sbGV2ZWwgMSAuLlxuICAgICAgICAvLyBsZXZlbCAxIGxvYWRlZCBbMTgyNTgwMTYyLDE4MjU4MDE2OF0gPD09PT09PT09PT09PT0gaGVyZSB3ZSBzaG91bGQgaGF2ZSBidWZmZXJFbmQgPiBlbmQuIGluIHRoYXQgY2FzZSBicmVhayB0byBhdm9pZCByZWxvYWRpbmcgMTgyNTgwMTY4XG4gICAgICAgIC8vIGxldmVsIDEgbG9hZGVkIFsxODI1ODAxNjQsMTgyNTgwMTcxXVxuICAgICAgICAvL1xuICAgICAgICAvLyBkb24ndCByZXR1cm4gbnVsbCBpbiBjYXNlIG1lZGlhIG5vdCBsb2FkZWQgeWV0IChyZWFkeXN0YXRlID09PSAwKVxuICAgICAgICBpZiAobGV2ZWxEZXRhaWxzLlBUU0tub3duICYmIGJ1ZmZlckVuZCA+IGVuZCAmJiBtZWRpYSAmJiBtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgJiYgIWxldmVsRGV0YWlscy5QVFNLbm93bikge1xuICAgICAgICAgICAgLyogd2UgYXJlIHN3aXRjaGluZyBsZXZlbCBvbiBsaXZlIHBsYXlsaXN0LCBidXQgd2UgZG9uJ3QgaGF2ZSBhbnkgUFRTIGluZm8gZm9yIHRoYXQgcXVhbGl0eSBsZXZlbCAuLi5cbiAgICAgICAgICAgICAgIHRyeSB0byBsb2FkIGZyYWcgbWF0Y2hpbmcgd2l0aCBuZXh0IFNOLlxuICAgICAgICAgICAgICAgZXZlbiBpZiBTTiBhcmUgbm90IHN5bmNocm9uaXplZCBiZXR3ZWVuIHBsYXlsaXN0cywgbG9hZGluZyB0aGlzIGZyYWcgd2lsbCBoZWxwIHVzXG4gICAgICAgICAgICAgICBjb21wdXRlIHBsYXlsaXN0IHNsaWRpbmcgYW5kIGZpbmQgdGhlIHJpZ2h0IG9uZSBhZnRlciBpbiBjYXNlIGl0IHdhcyBub3QgdGhlIHJpZ2h0IGNvbnNlY3V0aXZlIG9uZSAqL1xuICAgICAgICAgICAgaWYgKGZyYWdQcmV2aW91cykge1xuICAgICAgICAgICAgICAgIGlmIChsZXZlbERldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbGllcyBvbiBQRFQgaW4gb3JkZXIgdG8gc3dpdGNoIGJpdHJhdGVzIChTdXBwb3J0IEVYVC1YLURJU0NPTlRJTlVJVFkgd2l0aG91dCBFWFQtWC1ESVNDT05USU5VSVRZLVNFUVVFTkNFKVxuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwibGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCBsb2FkIGZyYWcgd2l0aCBzYW1lIFBEVDogXCIgKyBmcmFnUHJldmlvdXMucHJvZ3JhbURhdGVUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZnJhZyA9IGZyYWdtZW50X2ZpbmRlcnNfMS5maW5kRnJhZ21lbnRCeVBEVChmcmFnbWVudHMsIGZyYWdQcmV2aW91cy5lbmRQcm9ncmFtRGF0ZVRpbWUsIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZXMgYnVmZmVyIGFuZCBzZXF1ZW5jZSBudW1iZXIgdG8gY2FsY3VsYXRlIHN3aXRjaCBzZWdtZW50IChyZXF1aXJlZCBpZiB1c2luZyBFWFQtWC1ESVNDT05USU5VSVRZLVNFUVVFTkNFKVxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0U04gPSBmcmFnUHJldmlvdXMuc24gKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0U04gPj0gbGV2ZWxEZXRhaWxzLnN0YXJ0U04gJiYgdGFyZ2V0U04gPD0gbGV2ZWxEZXRhaWxzLmVuZFNOKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhZ05leHQgPSBmcmFnbWVudHNbdGFyZ2V0U04gLSBsZXZlbERldGFpbHMuc3RhcnRTTl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZ1ByZXZpb3VzLmNjID09PSBmcmFnTmV4dC5jYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcgPSBmcmFnTmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwibGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCBsb2FkIGZyYWcgd2l0aCBuZXh0IFNOOiBcIiArIGZyYWcuc24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIG5leHQgZnJhZyBTTiBub3QgYXZhaWxhYmxlIChvciBub3Qgd2l0aCBzYW1lIGNvbnRpbnVpdHkgY291bnRlcilcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9vayBmb3IgYSBmcmFnIHNoYXJpbmcgdGhlIHNhbWUgQ0NcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnID0gYmluYXJ5X3NlYXJjaF8xLmRlZmF1bHQuc2VhcmNoKGZyYWdtZW50cywgZnVuY3Rpb24gKGZyYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhZ1ByZXZpb3VzLmNjIC0gZnJhZy5jYztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwibGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCBsb2FkIGZyYWcgd2l0aCBzYW1lIENDOiBcIiArIGZyYWcuc24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgICAgICAgICAgLyogd2UgaGF2ZSBubyBpZGVhIGFib3V0IHdoaWNoIGZyYWdtZW50IHNob3VsZCBiZSBsb2FkZWQuXG4gICAgICAgICAgICAgICAgICAgc28gbGV0J3MgbG9hZCBtaWQgZnJhZ21lbnQuIGl0IHdpbGwgaGVscCBjb21wdXRpbmcgcGxheWxpc3Qgc2xpZGluZyBhbmQgZmluZCB0aGUgcmlnaHQgb25lXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmcmFnID0gZnJhZ21lbnRzW01hdGgubWluKGZyYWdMZW4gLSAxLCBNYXRoLnJvdW5kKGZyYWdMZW4gLyAyKSldO1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJsaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIHVua25vd24sIGxvYWQgbWlkZGxlIGZyYWcgOiBcIiArIGZyYWcuc24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcmFnO1xuICAgIH07XG4gICAgU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuX2ZpbmRGcmFnbWVudCA9IGZ1bmN0aW9uIChzdGFydCwgZnJhZ1ByZXZpb3VzLCBmcmFnTGVuLCBmcmFnbWVudHMsIGJ1ZmZlckVuZCwgZW5kLCBsZXZlbERldGFpbHMpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICAgICAgdmFyIGZyYWc7XG4gICAgICAgIGlmIChidWZmZXJFbmQgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciBsb29rdXBUb2xlcmFuY2UgPSAoYnVmZmVyRW5kID4gZW5kIC0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UpID8gMCA6IGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0b2xlcmFuY2UgaWYgaXQgd291bGQgcHV0IHRoZSBidWZmZXJFbmQgcGFzdCB0aGUgYWN0dWFsIGVuZCBvZiBzdHJlYW1cbiAgICAgICAgICAgIC8vIFVzZXMgYnVmZmVyIGFuZCBzZXF1ZW5jZSBudW1iZXIgdG8gY2FsY3VsYXRlIHN3aXRjaCBzZWdtZW50IChyZXF1aXJlZCBpZiB1c2luZyBFWFQtWC1ESVNDT05USU5VSVRZLVNFUVVFTkNFKVxuICAgICAgICAgICAgZnJhZyA9IGZyYWdtZW50X2ZpbmRlcnNfMS5maW5kRnJhZ21lbnRCeVBUUyhmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgYnVmZmVyRW5kLCBsb29rdXBUb2xlcmFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcmVhY2ggZW5kIG9mIHBsYXlsaXN0XG4gICAgICAgICAgICBmcmFnID0gZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhZykge1xuICAgICAgICAgICAgdmFyIGN1clNOSWR4ID0gZnJhZy5zbiAtIGxldmVsRGV0YWlscy5zdGFydFNOO1xuICAgICAgICAgICAgdmFyIHNhbWVMZXZlbCA9IGZyYWdQcmV2aW91cyAmJiBmcmFnLmxldmVsID09PSBmcmFnUHJldmlvdXMubGV2ZWw7XG4gICAgICAgICAgICB2YXIgcHJldkZyYWcgPSBmcmFnbWVudHNbY3VyU05JZHggLSAxXTtcbiAgICAgICAgICAgIHZhciBuZXh0RnJhZyA9IGZyYWdtZW50c1tjdXJTTklkeCArIDFdO1xuICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZygnZmluZCBTTiBtYXRjaGluZyB3aXRoIHBvczonICsgIGJ1ZmZlckVuZCArICc6JyArIGZyYWcuc24pO1xuICAgICAgICAgICAgaWYgKGZyYWdQcmV2aW91cyAmJiBmcmFnLnNuID09PSBmcmFnUHJldmlvdXMuc24pIHtcbiAgICAgICAgICAgICAgICBpZiAoc2FtZUxldmVsICYmICFmcmFnLmJhY2t0cmFja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcmFnLnNuIDwgbGV2ZWxEZXRhaWxzLmVuZFNOKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFQVFMgPSBmcmFnUHJldmlvdXMuZGVsdGFQVFM7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHNpZ25pZmljYW50IGRlbHRhIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvLCBsYXJnZXIgdGhhbiBtYXggYWxsb3dlZCBob2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGlmIHByZXZpb3VzIHJlbXV4ZWQgZnJhZ21lbnQgZGlkIG5vdCBzdGFydCB3aXRoIGEga2V5ZnJhbWUuIChmcmFnUHJldmlvdXMuZHJvcHBlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCdzIHRyeSB0byBsb2FkIHByZXZpb3VzIGZyYWdtZW50IGFnYWluIHRvIGdldCBsYXN0IGtleWZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIHdlIHdpbGwgcmVsb2FkIGFnYWluIGN1cnJlbnQgZnJhZ21lbnQgKHRoYXQgd2F5IHdlIHNob3VsZCBiZSBhYmxlIHRvIGZpbGwgdGhlIGJ1ZmZlciBob2xlIC4uLilcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWx0YVBUUyAmJiBkZWx0YVBUUyA+IGNvbmZpZy5tYXhCdWZmZXJIb2xlICYmIGZyYWdQcmV2aW91cy5kcm9wcGVkICYmIGN1clNOSWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyA9IHByZXZGcmFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKCdTTiBqdXN0IGxvYWRlZCwgd2l0aCBsYXJnZSBQVFMgZ2FwIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvLCBtYXliZSBmcmFnIGlzIG5vdCBzdGFydGluZyB3aXRoIGEga2V5ZnJhbWUgPyBsb2FkIHByZXZpb3VzIG9uZSB0byB0cnkgdG8gb3ZlcmNvbWUgdGhpcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyA9IG5leHRGcmFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJTTiBqdXN0IGxvYWRlZCwgbG9hZCBuZXh0IG9uZTogXCIgKyBmcmFnLnNuLCBmcmFnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZyYWcuYmFja3RyYWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBiYWNrdHJhY2sgYSBtYXggb2YgMSBjb25zZWN1dGl2ZSBmcmFnbWVudCB0byBwcmV2ZW50IHNsaWRpbmcgYmFjayB0b28gZmFyIHdoZW4gbGl0dGxlIG9yIG5vIGZyYWdzIHN0YXJ0IHdpdGgga2V5ZnJhbWVzXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0RnJhZyAmJiBuZXh0RnJhZy5iYWNrdHJhY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oXCJBbHJlYWR5IGJhY2t0cmFja2VkIGZyb20gZnJhZ21lbnQgXCIgKyBuZXh0RnJhZy5zbiArIFwiLCB3aWxsIG5vdCBiYWNrdHJhY2sgdG8gZnJhZ21lbnQgXCIgKyBmcmFnLnNuICsgXCIuIExvYWRpbmcgZnJhZ21lbnQgXCIgKyBuZXh0RnJhZy5zbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnID0gbmV4dEZyYWc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIGZyYWdtZW50IGhhcyBkcm9wcGVkIGZyYW1lcyBhbmQgaXQncyBpbiBhIHNhbWUgbGV2ZWwvc2VxdWVuY2UsIGxvYWQgdGhlIHByZXZpb3VzIGZyYWdtZW50IHRvIHRyeSBhbmQgZmluZCB0aGUga2V5ZnJhbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBkcm9wcGVkIGNvdW50IG5vdyBzaW5jZSBpdCB3b24ndCBiZSByZXNldCB1bnRpbCB3ZSBwYXJzZSB0aGUgZnJhZ21lbnQgYWdhaW4sIHdoaWNoIHByZXZlbnRzIGluZmluaXRlIGJhY2t0cmFja2luZyBvbiB0aGUgc2FtZSBzZWdtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybignTG9hZGVkIGZyYWdtZW50IHdpdGggZHJvcHBlZCBmcmFtZXMsIGJhY2t0cmFja2luZyAxIHNlZ21lbnQgdG8gZmluZCBhIGtleWZyYW1lJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnLmRyb3BwZWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZGcmFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyA9IHByZXZGcmFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcuYmFja3RyYWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VyU05JZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW4ndCBiYWNrdHJhY2sgb24gdmVyeSBmaXJzdCBmcmFnbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcmFnO1xuICAgIH07XG4gICAgU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuX2xvYWRLZXkgPSBmdW5jdGlvbiAoZnJhZykge1xuICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLktFWV9MT0FESU5HO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuS0VZX0xPQURJTkcsIHsgZnJhZzogZnJhZyB9KTtcbiAgICB9O1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLl9sb2FkRnJhZ21lbnQgPSBmdW5jdGlvbiAoZnJhZykge1xuICAgICAgICAvLyBDaGVjayBpZiBmcmFnbWVudCBpcyBub3QgbG9hZGVkXG4gICAgICAgIHZhciBmcmFnU3RhdGUgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKTtcbiAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gRG9uJ3QgdXBkYXRlIG5leHRMb2FkUG9zaXRpb24gZm9yIGZyYWdtZW50cyB3aGljaCBhcmUgbm90IGJ1ZmZlcmVkXG4gICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoZnJhZy5zbikgJiYgIWZyYWcuYml0cmF0ZVRlc3QpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGZyYWcuc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsbG93IGJhY2t0cmFja2VkIGZyYWdtZW50cyB0byBsb2FkXG4gICAgICAgIGlmIChmcmFnLmJhY2t0cmFja2VkIHx8IGZyYWdTdGF0ZSA9PT0gZnJhZ21lbnRfdHJhY2tlcl8xLkZyYWdtZW50U3RhdGUuTk9UX0xPQURFRCB8fCBmcmFnU3RhdGUgPT09IGZyYWdtZW50X3RyYWNrZXJfMS5GcmFnbWVudFN0YXRlLlBBUlRJQUwpIHtcbiAgICAgICAgICAgIGZyYWcuYXV0b0xldmVsID0gdGhpcy5obHMuYXV0b0xldmVsRW5hYmxlZDtcbiAgICAgICAgICAgIGZyYWcuYml0cmF0ZVRlc3QgPSB0aGlzLmJpdHJhdGVUZXN0O1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkZSQUdfTE9BRElORywgeyBmcmFnOiBmcmFnIH0pO1xuICAgICAgICAgICAgLy8gbGF6eSBkZW11eGVyIGluaXQsIGFzIHRoaXMgY291bGQgdGFrZSBzb21lIHRpbWUgLi4uIGRvIGl0IGR1cmluZyBmcmFnIGxvYWRpbmdcbiAgICAgICAgICAgIGlmICghdGhpcy5kZW11eGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZW11eGVyID0gbmV3IGRlbXV4ZXJfMS5kZWZhdWx0KHRoaXMuaGxzLCAnbWFpbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5GUkFHX0xPQURJTkc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZnJhZ1N0YXRlID09PSBmcmFnbWVudF90cmFja2VyXzEuRnJhZ21lbnRTdGF0ZS5BUFBFTkRJTkcpIHtcbiAgICAgICAgICAgIC8vIExvd2VyIHRoZSBidWZmZXIgc2l6ZSBhbmQgdHJ5IGFnYWluXG4gICAgICAgICAgICBpZiAodGhpcy5fcmVkdWNlTWF4QnVmZmVyTGVuZ3RoKGZyYWcuZHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZSwgXCJzdGF0ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXh0U3RhdGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBuZXh0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIm1haW4gc3RyZWFtOlwiICsgcHJldmlvdXNTdGF0ZSArIFwiLT5cIiArIG5leHRTdGF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LlNUUkVBTV9TVEFURV9UUkFOU0lUSU9OLCB7IHByZXZpb3VzU3RhdGU6IHByZXZpb3VzU3RhdGUsIG5leHRTdGF0ZTogbmV4dFN0YXRlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5nZXRCdWZmZXJlZEZyYWcgPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbiwgcGxheWxpc3RfbG9hZGVyXzEuZGVmYXVsdC5MZXZlbFR5cGUuTUFJTik7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUsIFwiY3VycmVudExldmVsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyYWcgPSB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhtZWRpYS5jdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYWcubGV2ZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUsIFwibmV4dEJ1ZmZlcmVkRnJhZ1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgICAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICAgICAgICAgIC8vIGZpcnN0IGdldCBlbmQgcmFuZ2Ugb2YgY3VycmVudCBmcmFnbWVudFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvbGxvd2luZ0J1ZmZlcmVkRnJhZyh0aGlzLmdldEJ1ZmZlcmVkRnJhZyhtZWRpYS5jdXJyZW50VGltZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmZvbGxvd2luZ0J1ZmZlcmVkRnJhZyA9IGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgICAgICAvLyB0cnkgdG8gZ2V0IHJhbmdlIG9mIG5leHQgZnJhZ21lbnQgKDUwMG1zIGFmdGVyIHRoaXMgcmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXJlZEZyYWcoZnJhZy5lbmRQVFMgKyAwLjUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLCBcIm5leHRMZXZlbFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGZyYWcgPSB0aGlzLm5leHRCdWZmZXJlZEZyYWc7XG4gICAgICAgICAgICBpZiAoZnJhZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcmFnLmxldmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5fY2hlY2tGcmFnbWVudENoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmcmFnUGxheWluZ0N1cnJlbnQsIGN1cnJlbnRUaW1lLCB2aWRlbyA9IHRoaXMubWVkaWE7XG4gICAgICAgIGlmICh2aWRlbyAmJiB2aWRlby5yZWFkeVN0YXRlICYmIHZpZGVvLnNlZWtpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjdXJyZW50VGltZSA9IHZpZGVvLmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgLyogaWYgdmlkZW8gZWxlbWVudCBpcyBpbiBzZWVrZWQgc3RhdGUsIGN1cnJlbnRUaW1lIGNhbiBvbmx5IGluY3JlYXNlLlxuICAgICAgICAgICAgICAoYXNzdW1pbmcgdGhhdCBwbGF5YmFjayByYXRlIGlzIHBvc2l0aXZlIC4uLilcbiAgICAgICAgICAgICAgQXMgc29tZXRpbWVzIGN1cnJlbnRUaW1lIGp1bXBzIGJhY2sgdG8gemVybyBhZnRlciBhXG4gICAgICAgICAgICAgIG1lZGlhIGRlY29kZSBlcnJvciwgY2hlY2sgdGhpcywgdG8gYXZvaWQgc2Vla2luZyBiYWNrIHRvXG4gICAgICAgICAgICAgIHdyb25nIHBvc2l0aW9uIGFmdGVyIGEgbWVkaWEgZGVjb2RlIGVycm9yXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRUaW1lID4gdGhpcy5sYXN0Q3VycmVudFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJ1ZmZlcl9oZWxwZXJfMS5CdWZmZXJIZWxwZXIuaXNCdWZmZXJlZCh2aWRlbywgY3VycmVudFRpbWUpKSB7XG4gICAgICAgICAgICAgICAgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdGhpcy5nZXRCdWZmZXJlZEZyYWcoY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYnVmZmVyX2hlbHBlcl8xLkJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKHZpZGVvLCBjdXJyZW50VGltZSArIDAuMSkpIHtcbiAgICAgICAgICAgICAgICAvKiBlbnN1cmUgdGhhdCBGUkFHX0NIQU5HRUQgZXZlbnQgaXMgdHJpZ2dlcmVkIGF0IHN0YXJ0dXAsXG4gICAgICAgICAgICAgICAgICB3aGVuIGZpcnN0IHZpZGVvIGZyYW1lIGlzIGRpc3BsYXllZCBhbmQgcGxheWJhY2sgaXMgcGF1c2VkLlxuICAgICAgICAgICAgICAgICAgYWRkIGEgdG9sZXJhbmNlIG9mIDEwMG1zLCBpbiBjYXNlIGN1cnJlbnQgcG9zaXRpb24gaXMgbm90IGJ1ZmZlcmVkLFxuICAgICAgICAgICAgICAgICAgY2hlY2sgaWYgY3VycmVudCBwb3MrMTAwbXMgaXMgYnVmZmVyZWQgYW5kIHVzZSB0aGF0IGJ1ZmZlciByYW5nZVxuICAgICAgICAgICAgICAgICAgZm9yIEZSQUdfQ0hBTkdFRCBldmVudCByZXBvcnRpbmcgKi9cbiAgICAgICAgICAgICAgICBmcmFnUGxheWluZ0N1cnJlbnQgPSB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhjdXJyZW50VGltZSArIDAuMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJhZ1BsYXlpbmdDdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyYWdQbGF5aW5nID0gZnJhZ1BsYXlpbmdDdXJyZW50O1xuICAgICAgICAgICAgICAgIGlmIChmcmFnUGxheWluZyAhPT0gdGhpcy5mcmFnUGxheWluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRlJBR19DSEFOR0VELCB7IGZyYWc6IGZyYWdQbGF5aW5nIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhZ1BsYXlpbmdMZXZlbCA9IGZyYWdQbGF5aW5nLmxldmVsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZnJhZ1BsYXlpbmcgfHwgdGhpcy5mcmFnUGxheWluZy5sZXZlbCAhPT0gZnJhZ1BsYXlpbmdMZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkxFVkVMX1NXSVRDSEVELCB7IGxldmVsOiBmcmFnUGxheWluZ0xldmVsIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhZ1BsYXlpbmcgPSBmcmFnUGxheWluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qXG4gICAgICBvbiBpbW1lZGlhdGUgbGV2ZWwgc3dpdGNoIDpcbiAgICAgICAtIHBhdXNlIHBsYXliYWNrIGlmIHBsYXlpbmdcbiAgICAgICAtIGNhbmNlbCBhbnkgcGVuZGluZyBsb2FkIHJlcXVlc3RcbiAgICAgICAtIGFuZCB0cmlnZ2VyIGEgYnVmZmVyIGZsdXNoXG4gICAgKi9cbiAgICBTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5pbW1lZGlhdGVMZXZlbFN3aXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnaW1tZWRpYXRlTGV2ZWxTd2l0Y2gnKTtcbiAgICAgICAgaWYgKCF0aGlzLmltbWVkaWF0ZVN3aXRjaCkge1xuICAgICAgICAgICAgdGhpcy5pbW1lZGlhdGVTd2l0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSwgcHJldmlvdXNseVBhdXNlZCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzbHlQYXVzZWQgPSBtZWRpYS5wYXVzZWQ7XG4gICAgICAgICAgICAgICAgbWVkaWEucGF1c2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IHJlc3RhcnQgcGxheWJhY2sgYWZ0ZXIgaW5zdGFudCBsZXZlbCBzd2l0Y2ggaW4gY2FzZSBtZWRpYSBub3QgYXR0YWNoZWRcbiAgICAgICAgICAgICAgICBwcmV2aW91c2x5UGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNseVBhdXNlZCA9IHByZXZpb3VzbHlQYXVzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgICAgaWYgKGZyYWdDdXJyZW50ICYmIGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICAgIC8vIGZsdXNoIGV2ZXJ5dGhpbmdcbiAgICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIG9uIGltbWVkaWF0ZSBsZXZlbCBzd2l0Y2ggZW5kLCBhZnRlciBuZXcgZnJhZ21lbnQgaGFzIGJlZW4gYnVmZmVyZWQ6XG4gICAgICogLSBudWRnZSB2aWRlbyBkZWNvZGVyIGJ5IHNsaWdodGx5IGFkanVzdGluZyB2aWRlbyBjdXJyZW50VGltZSAoaWYgY3VycmVudFRpbWUgYnVmZmVyZWQpXG4gICAgICogLSByZXN1bWUgdGhlIHBsYXliYWNrIGlmIG5lZWRlZFxuICAgICAqL1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmltbWVkaWF0ZUxldmVsU3dpdGNoRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgICBpZiAobWVkaWEgJiYgbWVkaWEuYnVmZmVyZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmltbWVkaWF0ZVN3aXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlcl9oZWxwZXJfMS5CdWZmZXJIZWxwZXIuaXNCdWZmZXJlZChtZWRpYSwgbWVkaWEuY3VycmVudFRpbWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBudWRnZSBpZiBjdXJyZW50VGltZSBpcyBidWZmZXJlZFxuICAgICAgICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lIC09IDAuMDAwMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5wcmV2aW91c2x5UGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgbWVkaWEucGxheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiB0cnkgdG8gc3dpdGNoIEFTQVAgd2l0aG91dCBicmVha2luZyB2aWRlbyBwbGF5YmFjazpcbiAgICAgKiBpbiBvcmRlciB0byBlbnN1cmUgc21vb3RoIGJ1dCBxdWljayBsZXZlbCBzd2l0Y2hpbmcsXG4gICAgICogd2UgbmVlZCB0byBmaW5kIHRoZSBuZXh0IGZsdXNoYWJsZSBidWZmZXIgcmFuZ2VcbiAgICAgKiB3ZSBzaG91bGQgdGFrZSBpbnRvIGFjY291bnQgbmV3IHNlZ21lbnQgZmV0Y2ggdGltZVxuICAgICAqL1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm5leHRMZXZlbFN3aXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgbWVkaWEgaXMgZGVmaW5lZCBhbmQgdGhhdCBtZXRhZGF0YSBhcmUgYXZhaWxhYmxlICh0byByZXRyaWV2ZSBjdXJyZW50VGltZSlcbiAgICAgICAgaWYgKG1lZGlhICYmIG1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBmZXRjaGRlbGF5ID0gdm9pZCAwLCBmcmFnUGxheWluZ0N1cnJlbnQgPSB2b2lkIDAsIG5leHRCdWZmZXJlZEZyYWcgPSB2b2lkIDA7XG4gICAgICAgICAgICBmcmFnUGxheWluZ0N1cnJlbnQgPSB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhtZWRpYS5jdXJyZW50VGltZSk7XG4gICAgICAgICAgICBpZiAoZnJhZ1BsYXlpbmdDdXJyZW50ICYmIGZyYWdQbGF5aW5nQ3VycmVudC5zdGFydFBUUyA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBmbHVzaCBidWZmZXIgcHJlY2VkaW5nIGN1cnJlbnQgZnJhZ21lbnQgKGZsdXNoIHVudGlsIGN1cnJlbnQgZnJhZ21lbnQgc3RhcnQgb2Zmc2V0KVxuICAgICAgICAgICAgICAgIC8vIG1pbnVzIDFzIHRvIGF2b2lkIHZpZGVvIGZyZWV6aW5nLCB0aGF0IGNvdWxkIGhhcHBlbiBpZiB3ZSBmbHVzaCBrZXlmcmFtZSBvZiBjdXJyZW50IHZpZGVvIC4uLlxuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsIGZyYWdQbGF5aW5nQ3VycmVudC5zdGFydFBUUyAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtZWRpYS5wYXVzZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBhZGQgYSBzYWZldHkgZGVsYXkgb2YgMXNcbiAgICAgICAgICAgICAgICB2YXIgbmV4dExldmVsSWQgPSB0aGlzLmhscy5uZXh0TG9hZExldmVsLCBuZXh0TGV2ZWwgPSB0aGlzLmxldmVsc1tuZXh0TGV2ZWxJZF0sIGZyYWdMYXN0S2JwcyA9IHRoaXMuZnJhZ0xhc3RLYnBzO1xuICAgICAgICAgICAgICAgIGlmIChmcmFnTGFzdEticHMgJiYgdGhpcy5mcmFnQ3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBmZXRjaGRlbGF5ID0gdGhpcy5mcmFnQ3VycmVudC5kdXJhdGlvbiAqIG5leHRMZXZlbC5iaXRyYXRlIC8gKDEwMDAgKiBmcmFnTGFzdEticHMpICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZldGNoZGVsYXkgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZldGNoZGVsYXkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZygnZmV0Y2hkZWxheTonK2ZldGNoZGVsYXkpO1xuICAgICAgICAgICAgLy8gZmluZCBidWZmZXIgcmFuZ2UgdGhhdCB3aWxsIGJlIHJlYWNoZWQgb25jZSBuZXcgZnJhZ21lbnQgd2lsbCBiZSBmZXRjaGVkXG4gICAgICAgICAgICBuZXh0QnVmZmVyZWRGcmFnID0gdGhpcy5nZXRCdWZmZXJlZEZyYWcobWVkaWEuY3VycmVudFRpbWUgKyBmZXRjaGRlbGF5KTtcbiAgICAgICAgICAgIGlmIChuZXh0QnVmZmVyZWRGcmFnKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuIGZsdXNoIGJ1ZmZlciByYW5nZSBmb2xsb3dpbmcgdGhpcyBvbmUgd2l0aG91dCBzdGFsbGluZyBwbGF5YmFja1xuICAgICAgICAgICAgICAgIG5leHRCdWZmZXJlZEZyYWcgPSB0aGlzLmZvbGxvd2luZ0J1ZmZlcmVkRnJhZyhuZXh0QnVmZmVyZWRGcmFnKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dEJ1ZmZlcmVkRnJhZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmUgaGVyZSwgd2UgY2FuIGFsc28gY2FuY2VsIGFueSBsb2FkaW5nL2RlbXV4aW5nIGluIHByb2dyZXNzLCBhcyB0aGV5IGFyZSB1c2VsZXNzXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcmFnQ3VycmVudCAmJiBmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdDdXJyZW50LmxvYWRlci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCBmbHVzaCBwb3NpdGlvbiBpcyB0aGUgc3RhcnQgUFRTIG9mIG5leHQgYnVmZmVyZWQgZnJhZy5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgdXNlIGZyYWcubmF4U3RhcnRQVFMgd2hpY2ggaXMgbWF4KGF1ZGlvIHN0YXJ0UFRTLCB2aWRlbyBzdGFydFBUUykuXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlcmUgaXMgYSBzbWFsbCBQVFMgRGVsdGEgYmV0d2VlbiBhdWRpbyBhbmQgdmlkZW8sIHVzaW5nIG1heFN0YXJ0UFRTIGF2b2lkcyBmbHVzaGluZyBsYXN0IHNhbXBsZXMgZnJvbSBjdXJyZW50IGZyYWdtZW50XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKG5leHRCdWZmZXJlZEZyYWcubWF4U3RhcnRQVFMsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5mbHVzaE1haW5CdWZmZXIgPSBmdW5jdGlvbiAoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLkJVRkZFUl9GTFVTSElORztcbiAgICAgICAgdmFyIGZsdXNoU2NvcGUgPSB7IHN0YXJ0T2Zmc2V0OiBzdGFydE9mZnNldCwgZW5kT2Zmc2V0OiBlbmRPZmZzZXQgfTtcbiAgICAgICAgLy8gaWYgYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrcyBhcmUgdXNlZCwgb25seSBmbHVzaCB2aWRlbywgb3RoZXJ3aXNlIGZsdXNoIGV2ZXJ5dGhpbmdcbiAgICAgICAgaWYgKHRoaXMuYWx0QXVkaW8pIHtcbiAgICAgICAgICAgIGZsdXNoU2NvcGUudHlwZSA9ICd2aWRlbyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkJVRkZFUl9GTFVTSElORywgZmx1c2hTY29wZSk7XG4gICAgfTtcbiAgICBTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbk1lZGlhQXR0YWNoZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IGRhdGEubWVkaWE7XG4gICAgICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub25NZWRpYVNlZWtpbmcuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbnZzZWVrZWQgPSB0aGlzLm9uTWVkaWFTZWVrZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbnZlbmRlZCA9IHRoaXMub25NZWRpYUVuZGVkLmJpbmQodGhpcyk7XG4gICAgICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgICAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVrZWQnLCB0aGlzLm9udnNlZWtlZCk7XG4gICAgICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5vbnZlbmRlZCk7XG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgaWYgKHRoaXMubGV2ZWxzICYmIGNvbmZpZy5hdXRvU3RhcnRMb2FkKSB7XG4gICAgICAgICAgICB0aGlzLmhscy5zdGFydExvYWQoY29uZmlnLnN0YXJ0UG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2FwQ29udHJvbGxlciA9IG5ldyBnYXBfY29udHJvbGxlcl8xLmRlZmF1bHQoY29uZmlnLCBtZWRpYSwgdGhpcy5mcmFnbWVudFRyYWNrZXIsIHRoaXMuaGxzKTtcbiAgICB9O1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uTWVkaWFEZXRhY2hpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICAgIGlmIChtZWRpYSAmJiBtZWRpYS5lbmRlZCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnTVNFIGRldGFjaGluZyBhbmQgdmlkZW8gZW5kZWQsIHJlc2V0IHN0YXJ0UG9zaXRpb24nKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXNldCBmcmFnbWVudCBiYWNrdHJhY2tlZCBmbGFnXG4gICAgICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcbiAgICAgICAgaWYgKGxldmVscykge1xuICAgICAgICAgICAgbGV2ZWxzLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxldmVsLmRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwuZGV0YWlscy5mcmFnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LmJhY2t0cmFja2VkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZW1vdmUgdmlkZW8gbGlzdGVuZXJzXG4gICAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMub252c2Vla2luZyk7XG4gICAgICAgICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWVrZWQnLCB0aGlzLm9udnNlZWtlZCk7XG4gICAgICAgICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xuICAgICAgICAgICAgdGhpcy5vbnZzZWVraW5nID0gdGhpcy5vbnZzZWVrZWQgPSB0aGlzLm9udmVuZGVkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIH07XG4gICAgU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25NZWRpYVNlZWtlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSwgY3VycmVudFRpbWUgPSBtZWRpYSA/IG1lZGlhLmN1cnJlbnRUaW1lIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGN1cnJlbnRUaW1lKSkge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIm1lZGlhIHNlZWtlZCB0byBcIiArIGN1cnJlbnRUaW1lLnRvRml4ZWQoMykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRpY2sgdG8gc3BlZWQgdXAgRlJBR01FTlRfUExBWUlORyB0cmlnZ2VyaW5nXG4gICAgICAgIHRoaXMudGljaygpO1xuICAgIH07XG4gICAgU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25NYW5pZmVzdExvYWRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHJlc2V0IGJ1ZmZlciBvbiBtYW5pZmVzdCBsb2FkaW5nXG4gICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ3RyaWdnZXIgQlVGRkVSX1JFU0VUJyk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5CVUZGRVJfUkVTRVQpO1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICAgICAgdGhpcy5zdGFsbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICB9O1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uTWFuaWZlc3RQYXJzZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgYWFjID0gZmFsc2UsIGhlYWFjID0gZmFsc2UsIGNvZGVjO1xuICAgICAgICBkYXRhLmxldmVscy5mb3JFYWNoKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgICAgLy8gZGV0ZWN0IGlmIHdlIGhhdmUgZGlmZmVyZW50IGtpbmQgb2YgYXVkaW8gY29kZWNzIHVzZWQgYW1vbmdzdCBwbGF5bGlzdHNcbiAgICAgICAgICAgIGNvZGVjID0gbGV2ZWwuYXVkaW9Db2RlYztcbiAgICAgICAgICAgIGlmIChjb2RlYykge1xuICAgICAgICAgICAgICAgIGlmIChjb2RlYy5pbmRleE9mKCdtcDRhLjQwLjInKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYWFjID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBoZWFhYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hdWRpb0NvZGVjU3dpdGNoID0gKGFhYyAmJiBoZWFhYyk7XG4gICAgICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2l0Y2gpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ2JvdGggQUFDL0hFLUFBQyBhdWRpbyBmb3VuZCBpbiBsZXZlbHM7IGRlY2xhcmluZyBsZXZlbCBjb2RlYyBhcyBIRS1BQUMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxldmVscyA9IGRhdGEubGV2ZWxzO1xuICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgIGlmIChjb25maWcuYXV0b1N0YXJ0TG9hZCB8fCB0aGlzLmZvcmNlU3RhcnRMb2FkKSB7XG4gICAgICAgICAgICB0aGlzLmhscy5zdGFydExvYWQoY29uZmlnLnN0YXJ0UG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbkxldmVsTG9hZGVkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIG5ld0RldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgICAgIHZhciBuZXdMZXZlbElkID0gZGF0YS5sZXZlbDtcbiAgICAgICAgdmFyIGxhc3RMZXZlbCA9IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxMYXN0TG9hZGVkXTtcbiAgICAgICAgdmFyIGN1ckxldmVsID0gdGhpcy5sZXZlbHNbbmV3TGV2ZWxJZF07XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IG5ld0RldGFpbHMudG90YWxkdXJhdGlvbjtcbiAgICAgICAgdmFyIHNsaWRpbmcgPSAwO1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwibGV2ZWwgXCIgKyBuZXdMZXZlbElkICsgXCIgbG9hZGVkIFtcIiArIG5ld0RldGFpbHMuc3RhcnRTTiArIFwiLFwiICsgbmV3RGV0YWlscy5lbmRTTiArIFwiXSxkdXJhdGlvbjpcIiArIGR1cmF0aW9uKTtcbiAgICAgICAgaWYgKG5ld0RldGFpbHMubGl2ZSkge1xuICAgICAgICAgICAgdmFyIGN1ckRldGFpbHMgPSBjdXJMZXZlbC5kZXRhaWxzO1xuICAgICAgICAgICAgaWYgKGN1ckRldGFpbHMgJiYgbmV3RGV0YWlscy5mcmFnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGFscmVhZHkgaGF2ZSBkZXRhaWxzIGZvciB0aGF0IGxldmVsLCBtZXJnZSB0aGVtXG4gICAgICAgICAgICAgICAgTGV2ZWxIZWxwZXIubWVyZ2VEZXRhaWxzKGN1ckRldGFpbHMsIG5ld0RldGFpbHMpO1xuICAgICAgICAgICAgICAgIHNsaWRpbmcgPSBuZXdEZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICAgICAgICAgICAgICB0aGlzLmxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmNvbXB1dGVMaXZlUG9zaXRpb24oc2xpZGluZywgY3VyRGV0YWlscyk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0RldGFpbHMuUFRTS25vd24gJiYgTnVtYmVyLmlzRmluaXRlKHNsaWRpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJsaXZlIHBsYXlsaXN0IHNsaWRpbmc6XCIgKyBzbGlkaW5nLnRvRml4ZWQoMykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnbGl2ZSBwbGF5bGlzdCAtIG91dGRhdGVkIFBUUywgdW5rbm93biBzbGlkaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIGRpc2NvbnRpbnVpdGllc18xLmFsaWduU3RyZWFtKHRoaXMuZnJhZ1ByZXZpb3VzLCBsYXN0TGV2ZWwsIG5ld0RldGFpbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ2xpdmUgcGxheWxpc3QgLSBmaXJzdCBsb2FkLCB1bmtub3duIHNsaWRpbmcnKTtcbiAgICAgICAgICAgICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZGlzY29udGludWl0aWVzXzEuYWxpZ25TdHJlYW0odGhpcy5mcmFnUHJldmlvdXMsIGxhc3RMZXZlbCwgbmV3RGV0YWlscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3ZlcnJpZGUgbGV2ZWwgaW5mb1xuICAgICAgICBjdXJMZXZlbC5kZXRhaWxzID0gbmV3RGV0YWlscztcbiAgICAgICAgdGhpcy5sZXZlbExhc3RMb2FkZWQgPSBuZXdMZXZlbElkO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuTEVWRUxfVVBEQVRFRCwgeyBkZXRhaWxzOiBuZXdEZXRhaWxzLCBsZXZlbDogbmV3TGV2ZWxJZCB9KTtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiBzZXQgdG8gLTEuIHVzZSBpdCBzdHJhaWdodCBhd2F5IGlmIHZhbHVlIGlzIGRlZmluZWRcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0UG9zaXRpb24gPT09IC0xIHx8IHRoaXMubGFzdEN1cnJlbnRUaW1lID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIGZpcnN0LCBjaGVjayBpZiBzdGFydCB0aW1lIG9mZnNldCBoYXMgYmVlbiBzZXQgaW4gcGxheWxpc3QsIGlmIHllcywgdXNlIHRoaXMgdmFsdWVcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRUaW1lT2Zmc2V0ID0gbmV3RGV0YWlscy5zdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShzdGFydFRpbWVPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydFRpbWVPZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwibmVnYXRpdmUgc3RhcnQgdGltZSBvZmZzZXQgXCIgKyBzdGFydFRpbWVPZmZzZXQgKyBcIiwgY291bnQgZnJvbSBlbmQgb2YgbGFzdCBmcmFnbWVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZU9mZnNldCA9IHNsaWRpbmcgKyBkdXJhdGlvbiArIHN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwic3RhcnQgdGltZSBvZmZzZXQgZm91bmQgaW4gcGxheWxpc3QsIGFkanVzdCBzdGFydFBvc2l0aW9uIHRvIFwiICsgc3RhcnRUaW1lT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbGl2ZSBwbGF5bGlzdCwgc2V0IHN0YXJ0IHBvc2l0aW9uIHRvIGJlIGZyYWdtZW50IE4tdGhpcy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50ICh1c3VhbGx5IDMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdEZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMuY29tcHV0ZUxpdmVQb3NpdGlvbihzbGlkaW5nLCBuZXdEZXRhaWxzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJjb25maWd1cmUgc3RhcnRQb3NpdGlvbiB0byBcIiArIHRoaXMuc3RhcnRQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9ubHkgc3dpdGNoIGJhdGNrIHRvIElETEUgc3RhdGUgaWYgd2Ugd2VyZSB3YWl0aW5nIGZvciBsZXZlbCB0byBzdGFydCBkb3dubG9hZGluZyBhIG5ldyBmcmFnbWVudFxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLldBSVRJTkdfTEVWRUwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuSURMRTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgIH07XG4gICAgU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25LZXlMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuS0VZX0xPQURJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuSURMRTtcbiAgICAgICAgICAgIHRoaXMudGljaygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbkZyYWdMb2FkZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBmcmFnQ3VycmVudCA9IF9hLmZyYWdDdXJyZW50LCBobHMgPSBfYS5obHMsIGxldmVscyA9IF9hLmxldmVscywgbWVkaWEgPSBfYS5tZWRpYTtcbiAgICAgICAgdmFyIGZyYWdMb2FkZWQgPSBkYXRhLmZyYWc7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuRlJBR19MT0FESU5HICYmXG4gICAgICAgICAgICBmcmFnQ3VycmVudCAmJlxuICAgICAgICAgICAgZnJhZ0xvYWRlZC50eXBlID09PSAnbWFpbicgJiZcbiAgICAgICAgICAgIGZyYWdMb2FkZWQubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXG4gICAgICAgICAgICBmcmFnTG9hZGVkLnNuID09PSBmcmFnQ3VycmVudC5zbikge1xuICAgICAgICAgICAgdmFyIHN0YXRzID0gZGF0YS5zdGF0cztcbiAgICAgICAgICAgIHZhciBjdXJyZW50TGV2ZWwgPSBsZXZlbHNbZnJhZ0N1cnJlbnQubGV2ZWxdO1xuICAgICAgICAgICAgdmFyIGRldGFpbHMgPSBjdXJyZW50TGV2ZWwuZGV0YWlscztcbiAgICAgICAgICAgIC8vIHJlc2V0IGZyYWcgYml0cmF0ZSB0ZXN0IGluIGFueSBjYXNlIGFmdGVyIGZyYWcgbG9hZGVkIGV2ZW50XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGZyYWcgd2FzIGxvYWRlZCB0byBwZXJmb3JtIGEgYml0cmF0ZSB0ZXN0IEFORCBpZiBobHMubmV4dExvYWRMZXZlbCBpcyBncmVhdGVyIHRoYW4gMFxuICAgICAgICAgICAgLy8gdGhlbiB0aGlzIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIGJlIGFibGUgdG8gbG9hZCBhIGZyYWdtZW50IGF0IGEgaGlnaGVyIHF1YWxpdHkgbGV2ZWxcbiAgICAgICAgICAgIHRoaXMuYml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdHMgPSBzdGF0cztcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJMb2FkZWQgXCIgKyBmcmFnQ3VycmVudC5zbiArIFwiIG9mIFtcIiArIGRldGFpbHMuc3RhcnRTTiArIFwiICxcIiArIGRldGFpbHMuZW5kU04gKyBcIl0sbGV2ZWwgXCIgKyBmcmFnQ3VycmVudC5sZXZlbCk7XG4gICAgICAgICAgICBpZiAoZnJhZ0xvYWRlZC5iaXRyYXRlVGVzdCAmJiBobHMubmV4dExvYWRMZXZlbCkge1xuICAgICAgICAgICAgICAgIC8vIHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUgLi4uIHdlIGp1c3QgbG9hZGVkIGEgZnJhZ21lbnQgdG8gZGV0ZXJtaW5lIGFkZXF1YXRlIHN0YXJ0IGJpdHJhdGUgYW5kIGluaXRpYWxpemUgYXV0b3N3aXRjaCBhbGdvXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5JRExFO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3RhdHMudHBhcnNlZCA9IHN0YXRzLnRidWZmZXJlZCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkZSQUdfQlVGRkVSRUQsIHsgc3RhdHM6IHN0YXRzLCBmcmFnOiBmcmFnQ3VycmVudCwgaWQ6ICdtYWluJyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZyYWdMb2FkZWQuc24gPT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gYmFzZV9zdHJlYW1fY29udHJvbGxlcl8xLlN0YXRlLklETEU7XG4gICAgICAgICAgICAgICAgc3RhdHMudHBhcnNlZCA9IHN0YXRzLnRidWZmZXJlZCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgICAgICBkZXRhaWxzLmluaXRTZWdtZW50LmRhdGEgPSBkYXRhLnBheWxvYWQ7XG4gICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5GUkFHX0JVRkZFUkVELCB7IHN0YXRzOiBzdGF0cywgZnJhZzogZnJhZ0N1cnJlbnQsIGlkOiAnbWFpbicgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiUGFyc2luZyBcIiArIGZyYWdDdXJyZW50LnNuICsgXCIgb2YgW1wiICsgZGV0YWlscy5zdGFydFNOICsgXCIgLFwiICsgZGV0YWlscy5lbmRTTiArIFwiXSxsZXZlbCBcIiArIGZyYWdDdXJyZW50LmxldmVsICsgXCIsIGNjIFwiICsgZnJhZ0N1cnJlbnQuY2MpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuUEFSU0lORztcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBCaXRyYXRlIHRlc3QgZnJhZ3MgYXJlIG5vdCB1c3VhbGx5IGJ1ZmZlcmVkIHNvIHRoZSBmcmFnbWVudCB0cmFja2VyIGlnbm9yZXMgdGhlbS4gSWYgSGxzLmpzIGRlY2lkZXMgdG8gYnVmZmVyXG4gICAgICAgICAgICAgICAgLy8gaXQgKGFuZCB0aGVyZWZvcmUgZW5kcyB1cCBhdCB0aGlzIGxpbmUpLCB0aGVuIHRoZSBmcmFnbWVudCB0cmFja2VyIG5lZWRzIHRvIGJlIG1hbnVhbGx5IGluZm9ybWVkLlxuICAgICAgICAgICAgICAgIGlmIChmcmFnTG9hZGVkLmJpdHJhdGVUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdMb2FkZWQuYml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIub25GcmFnTG9hZGVkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWc6IGZyYWdMb2FkZWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRpbWUgT2Zmc2V0IGlzIGFjY3VyYXRlIGlmIGxldmVsIFBUUyBpcyBrbm93biwgb3IgaWYgcGxheWxpc3QgaXMgbm90IHNsaWRpbmcgKG5vdCBsaXZlKSBhbmQgaWYgbWVkaWEgaXMgbm90IHNlZWtpbmcgKHRoaXMgaXMgdG8gb3ZlcmNvbWUgcG90ZW50aWFsIHRpbWVzdGFtcCBkcmlmdHMgYmV0d2VlbiBwbGF5bGlzdHMgYW5kIGZyYWdtZW50cylcbiAgICAgICAgICAgICAgICB2YXIgYWNjdXJhdGVUaW1lT2Zmc2V0ID0gIShtZWRpYSAmJiBtZWRpYS5zZWVraW5nKSAmJiAoZGV0YWlscy5QVFNLbm93biB8fCAhZGV0YWlscy5saXZlKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5pdFNlZ21lbnREYXRhID0gZGV0YWlscy5pbml0U2VnbWVudCA/IGRldGFpbHMuaW5pdFNlZ21lbnQuZGF0YSA6IFtdO1xuICAgICAgICAgICAgICAgIHZhciBhdWRpb0NvZGVjID0gdGhpcy5fZ2V0QXVkaW9Db2RlYyhjdXJyZW50TGV2ZWwpO1xuICAgICAgICAgICAgICAgIC8vIHRyYW5zbXV4IHRoZSBNUEVHLVRTIGRhdGEgdG8gSVNPLUJNRkYgc2VnbWVudHNcbiAgICAgICAgICAgICAgICB2YXIgZGVtdXhlciA9IHRoaXMuZGVtdXhlciA9IHRoaXMuZGVtdXhlciB8fCBuZXcgZGVtdXhlcl8xLmRlZmF1bHQodGhpcy5obHMsICdtYWluJyk7XG4gICAgICAgICAgICAgICAgZGVtdXhlci5wdXNoKGRhdGEucGF5bG9hZCwgaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCBjdXJyZW50TGV2ZWwudmlkZW9Db2RlYywgZnJhZ0N1cnJlbnQsIGRldGFpbHMudG90YWxkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuICAgIH07XG4gICAgU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25GcmFnUGFyc2luZ0luaXRTZWdtZW50ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgICAgdmFyIGZyYWdOZXcgPSBkYXRhLmZyYWc7XG4gICAgICAgIGlmIChmcmFnQ3VycmVudCAmJlxuICAgICAgICAgICAgZGF0YS5pZCA9PT0gJ21haW4nICYmXG4gICAgICAgICAgICBmcmFnTmV3LnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxuICAgICAgICAgICAgZnJhZ05ldy5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5QQVJTSU5HKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2tzID0gZGF0YS50cmFja3MsIHRyYWNrTmFtZSA9IHZvaWQgMCwgdHJhY2sgPSB2b2lkIDA7XG4gICAgICAgICAgICAvLyBpZiBhdWRpbyB0cmFjayBpcyBleHBlY3RlZCB0byBjb21lIGZyb20gYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXIsIGRpc2NhcmQgYW55IGNvbWluZyBmcm9tIG1haW5cbiAgICAgICAgICAgIGlmICh0cmFja3MuYXVkaW8gJiYgdGhpcy5hbHRBdWRpbykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0cmFja3MuYXVkaW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpbmNsdWRlIGxldmVsQ29kZWMgaW4gYXVkaW8gYW5kIHZpZGVvIHRyYWNrc1xuICAgICAgICAgICAgdHJhY2sgPSB0cmFja3MuYXVkaW87XG4gICAgICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgYXVkaW9Db2RlYyA9IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxdLmF1ZGlvQ29kZWMsIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChhdWRpb0NvZGVjICYmIHRoaXMuYXVkaW9Db2RlY1N3YXApIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnc3dhcHBpbmcgcGxheWxpc3QgYXVkaW8gY29kZWMnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaW4gY2FzZSBBQUMgYW5kIEhFLUFBQyBhdWRpbyBjb2RlY3MgYXJlIHNpZ25hbGxlZCBpbiBtYW5pZmVzdFxuICAgICAgICAgICAgICAgIC8vIGZvcmNlIEhFLUFBQyAsIGFzIGl0IHNlZW1zIHRoYXQgbW9zdCBicm93c2VycyBwcmVmZXJzIHRoYXQgd2F5LFxuICAgICAgICAgICAgICAgIC8vIGV4Y2VwdCBmb3IgbW9ubyBzdHJlYW1zIE9SIG9uIEZGXG4gICAgICAgICAgICAgICAgLy8gdGhlc2UgY29uZGl0aW9ucyBtaWdodCBuZWVkIHRvIGJlIHJldmlld2VkIC4uLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2l0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgZm9yY2UgSEUtQUFDIGlmIG1vbm8gc3RyZWFtXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFjay5tZXRhZGF0YS5jaGFubmVsQ291bnQgIT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGZvcmNlIEhFLUFBQyBpZiBmaXJlZm94XG4gICAgICAgICAgICAgICAgICAgICAgICB1YS5pbmRleE9mKCdmaXJlZm94JykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSEUtQUFDIGlzIGJyb2tlbiBvbiBBbmRyb2lkLCBhbHdheXMgc2lnbmFsIGF1ZGlvIGNvZGVjIGFzIEFBQyBldmVuIGlmIHZhcmlhbnQgbWFuaWZlc3Qgc3RhdGVzIG90aGVyd2lzZVxuICAgICAgICAgICAgICAgIGlmICh1YS5pbmRleE9mKCdhbmRyb2lkJykgIT09IC0xICYmIHRyYWNrLmNvbnRhaW5lciAhPT0gJ2F1ZGlvL21wZWcnKSB7IC8vIEV4Y2x1ZGUgbXBlZyBhdWRpb1xuICAgICAgICAgICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJBbmRyb2lkOiBmb3JjZSBhdWRpbyBjb2RlYyB0byBcIiArIGF1ZGlvQ29kZWMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmFjay5sZXZlbENvZGVjID0gYXVkaW9Db2RlYztcbiAgICAgICAgICAgICAgICB0cmFjay5pZCA9IGRhdGEuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjayA9IHRyYWNrcy52aWRlbztcbiAgICAgICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgICAgICAgIHRyYWNrLmxldmVsQ29kZWMgPSB0aGlzLmxldmVsc1t0aGlzLmxldmVsXS52aWRlb0NvZGVjO1xuICAgICAgICAgICAgICAgIHRyYWNrLmlkID0gZGF0YS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5CVUZGRVJfQ09ERUNTLCB0cmFja3MpO1xuICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIHRyYWNrcyB0aGF0IGFyZSBnb2luZyB0byBiZSBwcm92aWRlZCB0byBidWZmZXJDb250cm9sbGVyXG4gICAgICAgICAgICBmb3IgKHRyYWNrTmFtZSBpbiB0cmFja3MpIHtcbiAgICAgICAgICAgICAgICB0cmFjayA9IHRyYWNrc1t0cmFja05hbWVdO1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJtYWluIHRyYWNrOlwiICsgdHJhY2tOYW1lICsgXCIsY29udGFpbmVyOlwiICsgdHJhY2suY29udGFpbmVyICsgXCIsY29kZWNzW2xldmVsL3BhcnNlZF09W1wiICsgdHJhY2subGV2ZWxDb2RlYyArIFwiL1wiICsgdHJhY2suY29kZWMgKyBcIl1cIik7XG4gICAgICAgICAgICAgICAgdmFyIGluaXRTZWdtZW50ID0gdHJhY2suaW5pdFNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGluaXRTZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBhcm0gcGVuZGluZyBCdWZmZXJpbmcgZmxhZyBiZWZvcmUgYXBwZW5kaW5nIGEgc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuQlVGRkVSX0FQUEVORElORywgeyB0eXBlOiB0cmFja05hbWUsIGRhdGE6IGluaXRTZWdtZW50LCBwYXJlbnQ6ICdtYWluJywgY29udGVudDogJ2luaXRTZWdtZW50JyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25GcmFnUGFyc2luZ0RhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgICB2YXIgZnJhZ05ldyA9IGRhdGEuZnJhZztcbiAgICAgICAgaWYgKGZyYWdDdXJyZW50ICYmXG4gICAgICAgICAgICBkYXRhLmlkID09PSAnbWFpbicgJiZcbiAgICAgICAgICAgIGZyYWdOZXcuc24gPT09IGZyYWdDdXJyZW50LnNuICYmXG4gICAgICAgICAgICBmcmFnTmV3LmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxuICAgICAgICAgICAgIShkYXRhLnR5cGUgPT09ICdhdWRpbycgJiYgdGhpcy5hbHRBdWRpbykgJiYgLy8gZmlsdGVyIG91dCBtYWluIGF1ZGlvIGlmIGF1ZGlvIHRyYWNrIGlzIGxvYWRlZCB0aHJvdWdoIGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuUEFSU0lORykge1xuICAgICAgICAgICAgdmFyIGxldmVsID0gdGhpcy5sZXZlbHNbdGhpcy5sZXZlbF0sIGZyYWcgPSBmcmFnQ3VycmVudDtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGRhdGEuZW5kUFRTKSkge1xuICAgICAgICAgICAgICAgIGRhdGEuZW5kUFRTID0gZGF0YS5zdGFydFBUUyArIGZyYWdDdXJyZW50LmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIGRhdGEuZW5kRFRTID0gZGF0YS5zdGFydERUUyArIGZyYWdDdXJyZW50LmR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuaGFzQXVkaW8gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBmcmFnLmFkZEVsZW1lbnRhcnlTdHJlYW0oZnJhZ21lbnRfMS5kZWZhdWx0LkVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5oYXNWaWRlbyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGZyYWcuYWRkRWxlbWVudGFyeVN0cmVhbShmcmFnbWVudF8xLmRlZmF1bHQuRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJQYXJzZWQgXCIgKyBkYXRhLnR5cGUgKyBcIixQVFM6W1wiICsgZGF0YS5zdGFydFBUUy50b0ZpeGVkKDMpICsgXCIsXCIgKyBkYXRhLmVuZFBUUy50b0ZpeGVkKDMpICsgXCJdLERUUzpbXCIgKyBkYXRhLnN0YXJ0RFRTLnRvRml4ZWQoMykgKyBcIi9cIiArIGRhdGEuZW5kRFRTLnRvRml4ZWQoMykgKyBcIl0sbmI6XCIgKyBkYXRhLm5iICsgXCIsZHJvcHBlZDpcIiArIChkYXRhLmRyb3BwZWQgfHwgMCkpO1xuICAgICAgICAgICAgLy8gRGV0ZWN0IGdhcHMgaW4gYSBmcmFnbWVudCAgYW5kIHRyeSB0byBmaXggaXQgYnkgZmluZGluZyBhIGtleWZyYW1lIGluIHRoZSBwcmV2aW91cyBmcmFnbWVudCAoc2VlIF9maW5kRnJhZ21lbnRzKVxuICAgICAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgICAgIGZyYWcuZHJvcHBlZCA9IGRhdGEuZHJvcHBlZDtcbiAgICAgICAgICAgICAgICBpZiAoZnJhZy5kcm9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZnJhZy5iYWNrdHJhY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxldmVsRGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGV2ZWxEZXRhaWxzICYmIGZyYWcuc24gPT09IGxldmVsRGV0YWlscy5zdGFydFNOKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oJ21pc3NpbmcgdmlkZW8gZnJhbWUocykgb24gZmlyc3QgZnJhZywgYXBwZW5kaW5nIHdpdGggZ2FwJywgZnJhZy5zbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybignbWlzc2luZyB2aWRlbyBmcmFtZShzKSwgYmFja3RyYWNraW5nIGZyYWdtZW50JywgZnJhZy5zbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGJhY2sgdG8gdGhlIElETEUgc3RhdGUgd2l0aG91dCBhcHBlbmRpbmcgdG8gYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2F1c2VzIGZpbmRGcmFnbWVudHMgdG8gYmFja3RyYWNrIGEgc2VnbWVudCBhbmQgZmluZCB0aGUga2V5ZnJhbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBdWRpbyBmcmFnbWVudHMgYXJyaXZpbmcgYmVmb3JlIHZpZGVvIHNldHMgdGhlIG5leHRMb2FkUG9zaXRpb24sIGNhdXNpbmcgX2ZpbmRGcmFnbWVudHMgdG8gc2tpcCB0aGUgYmFja3RyYWNrZWQgZnJhZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnLmJhY2t0cmFja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBkYXRhLnN0YXJ0UFRTO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuSURMRTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IGZyYWc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oJ0FscmVhZHkgYmFja3RyYWNrZWQgb24gdGhpcyBmcmFnbWVudCwgYXBwZW5kaW5nIHdpdGggdGhlIGdhcCcsIGZyYWcuc24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHJlc2V0IHRoZSBiYWNrdHJhY2tlZCBmbGFnIGlmIHdlJ3ZlIGxvYWRlZCB0aGUgZnJhZyB3aXRob3V0IGFueSBkcm9wcGVkIGZyYW1lc1xuICAgICAgICAgICAgICAgICAgICBmcmFnLmJhY2t0cmFja2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRyaWZ0ID0gTGV2ZWxIZWxwZXIudXBkYXRlRnJhZ1BUU0RUUyhsZXZlbC5kZXRhaWxzLCBmcmFnLCBkYXRhLnN0YXJ0UFRTLCBkYXRhLmVuZFBUUywgZGF0YS5zdGFydERUUywgZGF0YS5lbmREVFMpLCBobHNfMiA9IHRoaXMuaGxzO1xuICAgICAgICAgICAgaGxzXzIudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkxFVkVMX1BUU19VUERBVEVELCB7IGRldGFpbHM6IGxldmVsLmRldGFpbHMsIGxldmVsOiB0aGlzLmxldmVsLCBkcmlmdDogZHJpZnQsIHR5cGU6IGRhdGEudHlwZSwgc3RhcnQ6IGRhdGEuc3RhcnRQVFMsIGVuZDogZGF0YS5lbmRQVFMgfSk7XG4gICAgICAgICAgICAvLyBoYXMgcmVtdXhlciBkcm9wcGVkIHZpZGVvIGZyYW1lcyBsb2NhdGVkIGJlZm9yZSBmaXJzdCBrZXlmcmFtZSA/XG4gICAgICAgICAgICBbZGF0YS5kYXRhMSwgZGF0YS5kYXRhMl0uZm9yRWFjaChmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBhcHBlbmQgaW4gUEFSU0lORyBzdGF0ZSAocmF0aW9uYWxlIGlzIHRoYXQgYW4gYXBwZW5kaW5nIGVycm9yIGNvdWxkIGhhcHBlbiBzeW5jaHJvbm91c2x5IG9uIGZpcnN0IHNlZ21lbnQgYXBwZW5kaW5nKVxuICAgICAgICAgICAgICAgIC8vIGluIHRoYXQgY2FzZSBpdCBpcyB1c2VsZXNzIHRvIGFwcGVuZCBmb2xsb3dpbmcgc2VnbWVudHNcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGggJiYgX3RoaXMuc3RhdGUgPT09IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5QQVJTSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFwcGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYXJtIHBlbmRpbmcgQnVmZmVyaW5nIGZsYWcgYmVmb3JlIGFwcGVuZGluZyBhIHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucGVuZGluZ0J1ZmZlcmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGhsc18yLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5CVUZGRVJfQVBQRU5ESU5HLCB7IHR5cGU6IGRhdGEudHlwZSwgZGF0YTogYnVmZmVyLCBwYXJlbnQ6ICdtYWluJywgY29udGVudDogJ2RhdGEnIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uRnJhZ1BhcnNlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAgIHZhciBmcmFnTmV3ID0gZGF0YS5mcmFnO1xuICAgICAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgICAgIGRhdGEuaWQgPT09ICdtYWluJyAmJlxuICAgICAgICAgICAgZnJhZ05ldy5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiZcbiAgICAgICAgICAgIGZyYWdOZXcubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuUEFSU0lORykge1xuICAgICAgICAgICAgdGhpcy5zdGF0cy50cGFyc2VkID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5QQVJTRUQ7XG4gICAgICAgICAgICB0aGlzLl9jaGVja0FwcGVuZGVkUGFyc2VkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uQXVkaW9UcmFja1N3aXRjaGluZyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIGlmIGFueSBVUkwgZm91bmQgb24gbmV3IGF1ZGlvIHRyYWNrLCBpdCBpcyBhbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tcbiAgICAgICAgdmFyIGFsdEF1ZGlvID0gISFkYXRhLnVybCwgdHJhY2tJZCA9IGRhdGEuaWQ7XG4gICAgICAgIC8vIGlmIHdlIHN3aXRjaCBvbiBtYWluIGF1ZGlvLCBlbnN1cmUgdGhhdCBtYWluIGZyYWdtZW50IHNjaGVkdWxpbmcgaXMgc3luY2VkIHdpdGggbWVkaWEuYnVmZmVyZWRcbiAgICAgICAgLy8gZG9uJ3QgZG8gYW55dGhpbmcgaWYgd2Ugc3dpdGNoIHRvIGFsdCBhdWRpbzogYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXIgaXMgaGFuZGxpbmcgaXQuXG4gICAgICAgIC8vIHdlIHdpbGwganVzdCBoYXZlIHRvIGNoYW5nZSBidWZmZXIgc2NoZWR1bGluZyBvbiBhdWRpb1RyYWNrU3dpdGNoZWRcbiAgICAgICAgaWYgKCFhbHRBdWRpbykge1xuICAgICAgICAgICAgaWYgKHRoaXMubWVkaWFCdWZmZXIgIT09IHRoaXMubWVkaWEpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdzd2l0Y2hpbmcgb24gbWFpbiBhdWRpbywgdXNlIG1lZGlhLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZycpO1xuICAgICAgICAgICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhO1xuICAgICAgICAgICAgICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byByZWZpbGwgYXVkaW8gYnVmZmVyIGZyb20gbWFpbjogY2FuY2VsIGFueSBmcmFnIGxvYWRpbmcgdG8gc3BlZWQgdXAgYXVkaW8gc3dpdGNoXG4gICAgICAgICAgICAgICAgaWYgKGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdzd2l0Y2hpbmcgdG8gbWFpbiBhdWRpbyB0cmFjaywgY2FuY2VsIG1haW4gZnJhZ21lbnQgbG9hZCcpO1xuICAgICAgICAgICAgICAgICAgICBmcmFnQ3VycmVudC5sb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIGRlc3Ryb3kgZGVtdXhlciB0byBmb3JjZSBpbml0IHNlZ21lbnQgZ2VuZXJhdGlvbiAoZm9sbG93aW5nIGF1ZGlvIHN3aXRjaClcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZW11eGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVtdXhlci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVtdXhlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIGxvYWQgbmV3IGZyYWdtZW50XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5JRExFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhsc18zID0gdGhpcy5obHM7XG4gICAgICAgICAgICAvLyBzd2l0Y2hpbmcgdG8gbWFpbiBhdWRpbywgZmx1c2ggYWxsIGF1ZGlvIGFuZCB0cmlnZ2VyIHRyYWNrIHN3aXRjaGVkXG4gICAgICAgICAgICBobHNfMy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuQlVGRkVSX0ZMVVNISU5HLCB7IHN0YXJ0T2Zmc2V0OiAwLCBlbmRPZmZzZXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgdHlwZTogJ2F1ZGlvJyB9KTtcbiAgICAgICAgICAgIGhsc18zLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5BVURJT19UUkFDS19TV0lUQ0hFRCwgeyBpZDogdHJhY2tJZCB9KTtcbiAgICAgICAgICAgIHRoaXMuYWx0QXVkaW8gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25BdWRpb1RyYWNrU3dpdGNoZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgdHJhY2tJZCA9IGRhdGEuaWQsIGFsdEF1ZGlvID0gISF0aGlzLmhscy5hdWRpb1RyYWNrc1t0cmFja0lkXS51cmw7XG4gICAgICAgIGlmIChhbHRBdWRpbykge1xuICAgICAgICAgICAgdmFyIHZpZGVvQnVmZmVyID0gdGhpcy52aWRlb0J1ZmZlcjtcbiAgICAgICAgICAgIC8vIGlmIHdlIHN3aXRjaGVkIG9uIGFsdGVybmF0ZSBhdWRpbywgZW5zdXJlIHRoYXQgbWFpbiBmcmFnbWVudCBzY2hlZHVsaW5nIGlzIHN5bmNlZCB3aXRoIHZpZGVvIHNvdXJjZWJ1ZmZlciBidWZmZXJlZFxuICAgICAgICAgICAgaWYgKHZpZGVvQnVmZmVyICYmIHRoaXMubWVkaWFCdWZmZXIgIT09IHZpZGVvQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnc3dpdGNoaW5nIG9uIGFsdGVybmF0ZSBhdWRpbywgdXNlIHZpZGVvLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZycpO1xuICAgICAgICAgICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB2aWRlb0J1ZmZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFsdEF1ZGlvID0gYWx0QXVkaW87XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgIH07XG4gICAgU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25CdWZmZXJDcmVhdGVkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHRyYWNrcyA9IGRhdGEudHJhY2tzLCBtZWRpYVRyYWNrLCBuYW1lLCBhbHRlcm5hdGUgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgdHlwZSBpbiB0cmFja3MpIHtcbiAgICAgICAgICAgIHZhciB0cmFjayA9IHRyYWNrc1t0eXBlXTtcbiAgICAgICAgICAgIGlmICh0cmFjay5pZCA9PT0gJ21haW4nKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgbWVkaWFUcmFjayA9IHRyYWNrO1xuICAgICAgICAgICAgICAgIC8vIGtlZXAgdmlkZW8gc291cmNlIGJ1ZmZlciByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZGVvQnVmZmVyID0gdHJhY2tzW3R5cGVdLmJ1ZmZlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbHRlcm5hdGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhbHRlcm5hdGUgJiYgbWVkaWFUcmFjaykge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcImFsdGVybmF0ZSB0cmFjayBmb3VuZCwgdXNlIFwiICsgbmFtZSArIFwiLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZ1wiKTtcbiAgICAgICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBtZWRpYVRyYWNrLmJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbkJ1ZmZlckFwcGVuZGVkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEucGFyZW50ID09PSAnbWFpbicpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5QQVJTSU5HIHx8IHN0YXRlID09PSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuUEFSU0VEKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIGFwcGVuZGVkXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gKGRhdGEucGVuZGluZyA+IDApO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrQXBwZW5kZWRQYXJzZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuX2NoZWNrQXBwZW5kZWRQYXJzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5QQVJTRUQgJiYgKCF0aGlzLmFwcGVuZGVkIHx8ICF0aGlzLnBlbmRpbmdCdWZmZXJpbmcpKSB7XG4gICAgICAgICAgICB2YXIgZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoZnJhZykge1xuICAgICAgICAgICAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYTtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwibWFpbiBidWZmZXJlZCA6IFwiICsgdGltZV9yYW5nZXNfMS5kZWZhdWx0LnRvU3RyaW5nKG1lZGlhLmJ1ZmZlcmVkKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgICAgICAgICAgICAgIHZhciBzdGF0cyA9IHRoaXMuc3RhdHM7XG4gICAgICAgICAgICAgICAgc3RhdHMudGJ1ZmZlcmVkID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgICAgIC8vIHdlIHNob3VsZCBnZXQgcmlkIG9mIHRoaXMuZnJhZ0xhc3RLYnBzXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFnTGFzdEticHMgPSBNYXRoLnJvdW5kKDggKiBzdGF0cy50b3RhbCAvIChzdGF0cy50YnVmZmVyZWQgLSBzdGF0cy50Zmlyc3QpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRlJBR19CVUZGRVJFRCwgeyBzdGF0czogc3RhdHMsIGZyYWc6IGZyYWcsIGlkOiAnbWFpbicgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5JRExFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZyB8fCB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgICAvLyBkb24ndCBoYW5kbGUgZnJhZyBlcnJvciBub3QgcmVsYXRlZCB0byBtYWluIGZyYWdtZW50XG4gICAgICAgIGlmIChmcmFnICYmIGZyYWcudHlwZSAhPT0gJ21haW4nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gMC41IDogdG9sZXJhbmNlIG5lZWRlZCBhcyBzb21lIGJyb3dzZXJzIHN0YWxscyBwbGF5YmFjayBiZWZvcmUgcmVhY2hpbmcgYnVmZmVyZWQgZW5kXG4gICAgICAgIHZhciBtZWRpYUJ1ZmZlcmVkID0gISF0aGlzLm1lZGlhICYmIGJ1ZmZlcl9oZWxwZXJfMS5CdWZmZXJIZWxwZXIuaXNCdWZmZXJlZCh0aGlzLm1lZGlhLCB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lKSAmJiBidWZmZXJfaGVscGVyXzEuQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodGhpcy5tZWRpYSwgdGhpcy5tZWRpYS5jdXJyZW50VGltZSArIDAuNSk7XG4gICAgICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICAgICAgICBjYXNlIGVycm9yc18xLkVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XG4gICAgICAgICAgICBjYXNlIGVycm9yc18xLkVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgICAgICAgIGNhc2UgZXJyb3JzXzEuRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgICAgICAgICAgY2FzZSBlcnJvcnNfMS5FcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEuZmF0YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCByZXRyeWluZyB1bnRpbCB0aGUgbGltaXQgd2lsbCBiZSByZWFjaGVkXG4gICAgICAgICAgICAgICAgICAgIGlmICgodGhpcy5mcmFnTG9hZEVycm9yICsgMSkgPD0gdGhpcy5jb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhwb25lbnRpYWwgYmFja29mZiBjYXBwZWQgdG8gY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsYXkgPSBNYXRoLm1pbihNYXRoLnBvdygyLCB0aGlzLmZyYWdMb2FkRXJyb3IpICogdGhpcy5jb25maWcuZnJhZ0xvYWRpbmdSZXRyeURlbGF5LCB0aGlzLmNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybihcIm1lZGlhQ29udHJvbGxlcjogZnJhZyBsb2FkaW5nIGZhaWxlZCwgcmV0cnkgaW4gXCIgKyBkZWxheSArIFwiIG1zXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXRyeURhdGUgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgKyBkZWxheTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHJ5IGxvYWRpbmcgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGxvYWRlZG1ldGFkYXRhIGlzIG5vdCBzZXQsIGl0IG1lYW5zIHRoYXQgd2UgYXJlIGVtZXJnZW5jeSBzd2l0Y2ggZG93biBvbiBmaXJzdCBmcmFnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UsIHJlc2V0IHN0YXJ0RnJhZ1JlcXVlc3RlZCBmbGFnXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvcisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5lcnJvcihcIm1lZGlhQ29udHJvbGxlcjogXCIgKyBkYXRhLmRldGFpbHMgKyBcIiByZWFjaGVzIG1heCByZXRyeSwgcmVkaXNwYXRjaCBhcyBmYXRhbCAuLi5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzd2l0Y2ggZXJyb3IgdG8gZmF0YWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZmF0YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5FUlJPUjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZXJyb3JzXzEuRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I6XG4gICAgICAgICAgICBjYXNlIGVycm9yc18xLkVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5FUlJPUikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgZmF0YWwgZXJyb3IsIHN0b3AgcHJvY2Vzc2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5FUlJPUjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKFwic3RyZWFtQ29udHJvbGxlcjogXCIgKyBkYXRhLmRldGFpbHMgKyBcIixzd2l0Y2ggdG8gXCIgKyB0aGlzLnN0YXRlICsgXCIgc3RhdGUgLi4uXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gY2FzZSBvZiBub24gZmF0YWwgZXJyb3Igd2hpbGUgbG9hZGluZyBsZXZlbCwgaWYgbGV2ZWwgY29udHJvbGxlciBpcyBub3QgcmV0cnlpbmcgdG8gbG9hZCBsZXZlbCAsIHN3aXRjaCBiYWNrIHRvIElETEVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGF0YS5sZXZlbFJldHJ5ICYmIHRoaXMuc3RhdGUgPT09IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5XQUlUSU5HX0xFVkVMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5JRExFO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBlcnJvcnNfMS5FcnJvckRldGFpbHMuQlVGRkVSX0ZVTExfRVJST1I6XG4gICAgICAgICAgICAgICAgLy8gaWYgaW4gYXBwZW5kaW5nIHN0YXRlXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEucGFyZW50ID09PSAnbWFpbicgJiYgKHRoaXMuc3RhdGUgPT09IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5QQVJTSU5HIHx8IHRoaXMuc3RhdGUgPT09IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5QQVJTRUQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlZHVjZSBtYXggYnVmIGxlbiBpZiBjdXJyZW50IHBvc2l0aW9uIGlzIGJ1ZmZlcmVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZWRpYUJ1ZmZlcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWR1Y2VNYXhCdWZmZXJMZW5ndGgodGhpcy5jb25maWcubWF4QnVmZmVyTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuSURMRTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgcG9zaXRpb24gaXMgbm90IGJ1ZmZlcmVkLCBidXQgYnJvd3NlciBpcyBzdGlsbCBjb21wbGFpbmluZyBhYm91dCBidWZmZXIgZnVsbCBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBoYXBwZW5zIG9uIElFL0VkZ2UsIHJlZmVyIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL3B1bGwvNzA4XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UgZmx1c2ggdGhlIHdob2xlIGJ1ZmZlciB0byByZWNvdmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybignYnVmZmVyIGZ1bGwgZXJyb3IgYWxzbyBtZWRpYS5jdXJyZW50VGltZSBpcyBub3QgYnVmZmVyZWQsIGZsdXNoIGV2ZXJ5dGhpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmx1c2ggZXZlcnl0aGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLl9yZWR1Y2VNYXhCdWZmZXJMZW5ndGggPSBmdW5jdGlvbiAobWluTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgaWYgKGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggPj0gbWluTGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyByZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggYXMgaXQgbWlnaHQgYmUgdG9vIGhpZ2guIHdlIGRvIHRoaXMgdG8gYXZvaWQgbG9vcCBmbHVzaGluZyAuLi5cbiAgICAgICAgICAgIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggLz0gMjtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKFwibWFpbjpyZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggdG8gXCIgKyBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoICsgXCJzXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoZSBoZWFsdGggb2YgdGhlIGJ1ZmZlciBhbmQgYXR0ZW1wdHMgdG8gcmVzb2x2ZSBwbGF5YmFjayBzdGFsbHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5fY2hlY2tCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICAgIGlmICghbWVkaWEgfHwgbWVkaWEucmVhZHlTdGF0ZSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gRXhpdCBlYXJseSBpZiB3ZSBkb24ndCBoYXZlIG1lZGlhIG9yIGlmIHRoZSBtZWRpYSBoYXNuJ3QgYnVmZmVyZCBhbnl0aGluZyB5ZXQgKHJlYWR5U3RhdGUgMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IG1lZGlhO1xuICAgICAgICB2YXIgYnVmZmVyZWQgPSBtZWRpYUJ1ZmZlci5idWZmZXJlZDtcbiAgICAgICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhICYmIGJ1ZmZlcmVkLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9zZWVrVG9TdGFydFBvcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaW1tZWRpYXRlU3dpdGNoKSB7XG4gICAgICAgICAgICB0aGlzLmltbWVkaWF0ZUxldmVsU3dpdGNoRW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdhcENvbnRyb2xsZXIucG9sbCh0aGlzLmxhc3RDdXJyZW50VGltZSwgYnVmZmVyZWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5TdGF0ZS5JRExFO1xuICAgICAgICAvLyBpZiBsb2FkZWRtZXRhZGF0YSBpcyBub3Qgc2V0LCBpdCBtZWFucyB0aGF0IHdlIGFyZSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gb24gZmlyc3QgZnJhZ1xuICAgICAgICAvLyBpbiB0aGF0IGNhc2UsIHJlc2V0IHN0YXJ0RnJhZ1JlcXVlc3RlZCBmbGFnXG4gICAgICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICB9O1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uQnVmZmVyRmx1c2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyogYWZ0ZXIgc3VjY2Vzc2Z1bCBidWZmZXIgZmx1c2hpbmcsIGZpbHRlciBmbHVzaGVkIGZyYWdtZW50cyBmcm9tIGJ1ZmZlcmVkRnJhZ3NcbiAgICAgICAgICB1c2UgbWVkaWFCdWZmZXJlZCBpbnN0ZWFkIG9mIG1lZGlhIChzbyB0aGF0IHdlIHdpbGwgY2hlY2sgYWdhaW5zdCB2aWRlby5idWZmZXJlZCByYW5nZXMgaW4gY2FzZSBvZiBhbHQgYXVkaW8gdHJhY2spXG4gICAgICAgICovXG4gICAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYTtcbiAgICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgICAgICAvLyBmaWx0ZXIgZnJhZ21lbnRzIHBvdGVudGlhbGx5IGV2aWN0ZWQgZnJvbSBidWZmZXIuIHRoaXMgaXMgdG8gYXZvaWQgbWVtbGVhayBvbiBsaXZlIHN0cmVhbXNcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLmRldGVjdEV2aWN0ZWRGcmFnbWVudHMoZnJhZ21lbnRfMS5kZWZhdWx0LkVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTywgbWVkaWEuYnVmZmVyZWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1vdmUgdG8gSURMRSBvbmNlIGZsdXNoIGNvbXBsZXRlLiB0aGlzIHNob3VsZCB0cmlnZ2VyIG5ldyBmcmFnbWVudCBsb2FkaW5nXG4gICAgICAgIHRoaXMuc3RhdGUgPSBiYXNlX3N0cmVhbV9jb250cm9sbGVyXzEuU3RhdGUuSURMRTtcbiAgICAgICAgLy8gcmVzZXQgcmVmZXJlbmNlIHRvIGZyYWdcbiAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIH07XG4gICAgU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuc3dhcEF1ZGlvQ29kZWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYXVkaW9Db2RlY1N3YXAgPSAhdGhpcy5hdWRpb0NvZGVjU3dhcDtcbiAgICB9O1xuICAgIFN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmNvbXB1dGVMaXZlUG9zaXRpb24gPSBmdW5jdGlvbiAoc2xpZGluZywgbGV2ZWxEZXRhaWxzKSB7XG4gICAgICAgIHZhciB0YXJnZXRMYXRlbmN5ID0gdGhpcy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gdGhpcy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbiA6IHRoaXMuY29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCAqIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbjtcbiAgICAgICAgcmV0dXJuIHNsaWRpbmcgKyBNYXRoLm1heCgwLCBsZXZlbERldGFpbHMudG90YWxkdXJhdGlvbiAtIHRhcmdldExhdGVuY3kpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2Vla3MgdG8gdGhlIHNldCBzdGFydFBvc2l0aW9uIGlmIG5vdCBlcXVhbCB0byB0aGUgbWVkaWFFbGVtZW50J3MgY3VycmVudCB0aW1lLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuX3NlZWtUb1N0YXJ0UG9zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAgICAgLy8gb25seSBhZGp1c3QgY3VycmVudFRpbWUgaWYgZGlmZmVyZW50IGZyb20gc3RhcnRQb3NpdGlvbiBvciBpZiBzdGFydFBvc2l0aW9uIG5vdCBidWZmZXJlZFxuICAgICAgICAvLyBhdCB0aGF0IHN0YWdlLCB0aGVyZSBzaG91bGQgYmUgb25seSBvbmUgYnVmZmVyZWQgcmFuZ2UsIGFzIHdlIHJlYWNoIHRoYXQgY29kZSBhZnRlciBmaXJzdCBmcmFnbWVudCBoYXMgYmVlbiBidWZmZXJlZFxuICAgICAgICB2YXIgc3RhcnRQb3NpdGlvbiA9IG1lZGlhLnNlZWtpbmcgPyBjdXJyZW50VGltZSA6IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgLy8gaWYgY3VycmVudFRpbWUgbm90IG1hdGNoaW5nIHdpdGggZXhwZWN0ZWQgc3RhcnRQb3NpdGlvbiBvciBzdGFydFBvc2l0aW9uIG5vdCBidWZmZXJlZCBidXQgY2xvc2UgdG8gZmlyc3QgYnVmZmVyZWRcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lICE9PSBzdGFydFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAvLyBpZiBzdGFydFBvc2l0aW9uIG5vdCBidWZmZXJlZCwgbGV0J3Mgc2VlayB0byBidWZmZXJlZC5zdGFydCgwKVxuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcInRhcmdldCBzdGFydCBwb3NpdGlvbiBub3QgYnVmZmVyZWQsIHNlZWsgdG8gYnVmZmVyZWQuc3RhcnQoMCkgXCIgKyBzdGFydFBvc2l0aW9uICsgXCIgZnJvbSBjdXJyZW50IHRpbWUgXCIgKyBjdXJyZW50VGltZSArIFwiIFwiKTtcbiAgICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuX2dldEF1ZGlvQ29kZWMgPSBmdW5jdGlvbiAoY3VycmVudExldmVsKSB7XG4gICAgICAgIHZhciBhdWRpb0NvZGVjID0gdGhpcy5jb25maWcuZGVmYXVsdEF1ZGlvQ29kZWMgfHwgY3VycmVudExldmVsLmF1ZGlvQ29kZWM7XG4gICAgICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2FwKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdzd2FwcGluZyBwbGF5bGlzdCBhdWRpbyBjb2RlYycpO1xuICAgICAgICAgICAgaWYgKGF1ZGlvQ29kZWMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXVkaW9Db2RlYztcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZSwgXCJsaXZlU3luY1Bvc2l0aW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGl2ZVN5bmNQb3NpdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpdmVTeW5jUG9zaXRpb24gPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFN0cmVhbUNvbnRyb2xsZXI7XG59KGJhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTdHJlYW1Db250cm9sbGVyO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIuanNcIilbXCJOdW1iZXJcIl0pKVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL3N1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9zdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIEBjbGFzcyBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXJcbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMuanNcIik7XG52YXIgbG9nZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIuanNcIik7XG52YXIgZGVjcnlwdGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9jcnlwdC9kZWNyeXB0ZXIgKi8gXCIuL3NyYy9jcnlwdC9kZWNyeXB0ZXIuanNcIik7XG52YXIgdGFza19sb29wXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90YXNrLWxvb3AgKi8gXCIuL3NyYy90YXNrLWxvb3AuanNcIik7XG52YXIgYnVmZmVyX2hlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvYnVmZmVyLWhlbHBlciAqLyBcIi4vc3JjL3V0aWxzL2J1ZmZlci1oZWxwZXIuanNcIik7XG52YXIgZnJhZ21lbnRfZmluZGVyc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mcmFnbWVudC1maW5kZXJzICovIFwiLi9zcmMvY29udHJvbGxlci9mcmFnbWVudC1maW5kZXJzLmpzXCIpO1xudmFyIGZyYWdtZW50X3RyYWNrZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZnJhZ21lbnQtdHJhY2tlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtdHJhY2tlci5qc1wiKTtcbnZhciBwZXJmb3JtYW5jZSA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcbmV4cG9ydHMuU3VidGl0bGVTdHJlYW1Db250cm9sbGVyU3RhdGUgPSB7XG4gICAgU1RPUFBFRDogJ1NUT1BQRUQnLFxuICAgIElETEU6ICdJRExFJyxcbiAgICBLRVlfTE9BRElORzogJ0tFWV9MT0FESU5HJyxcbiAgICBGUkFHX0xPQURJTkc6ICdGUkFHX0xPQURJTkcnXG59O1xudmFyIFN0YXRlID0gZXhwb3J0cy5TdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXJTdGF0ZTtcbnZhciBUSUNLX0lOVEVSVkFMID0gNTAwOyAvLyBob3cgb2Z0ZW4gdG8gdGljayBpbiBtc1xudmFyIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3VidGl0bGVTdHJlYW1Db250cm9sbGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcihobHMsIGZyYWdtZW50VHJhY2tlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBobHMsIGV2ZW50c18xLmRlZmF1bHQuTUVESUFfQVRUQUNIRUQsIGV2ZW50c18xLmRlZmF1bHQuTUVESUFfREVUQUNISU5HLCBldmVudHNfMS5kZWZhdWx0LkVSUk9SLCBldmVudHNfMS5kZWZhdWx0LktFWV9MT0FERUQsIGV2ZW50c18xLmRlZmF1bHQuRlJBR19MT0FERUQsIGV2ZW50c18xLmRlZmF1bHQuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIGV2ZW50c18xLmRlZmF1bHQuU1VCVElUTEVfVFJBQ0tfU1dJVENILCBldmVudHNfMS5kZWZhdWx0LlNVQlRJVExFX1RSQUNLX0xPQURFRCwgZXZlbnRzXzEuZGVmYXVsdC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZnJhZ21lbnRUcmFja2VyID0gZnJhZ21lbnRUcmFja2VyO1xuICAgICAgICBfdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgICAgIF90aGlzLnRyYWNrcyA9IFtdO1xuICAgICAgICBfdGhpcy50cmFja3NCdWZmZXJlZCA9IFtdO1xuICAgICAgICBfdGhpcy5jdXJyZW50VHJhY2tJZCA9IC0xO1xuICAgICAgICBfdGhpcy5kZWNyeXB0ZXIgPSBuZXcgZGVjcnlwdGVyXzEuZGVmYXVsdChobHMsIGhscy5jb25maWcpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25IYW5kbGVyRGVzdHJveWVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm9uSGFuZGxlckRlc3Ryb3llZC5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vblN1YnRpdGxlRnJhZ1Byb2Nlc3NlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICBpZiAoIWRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWZmZXJlZCA9IHRoaXMudHJhY2tzQnVmZmVyZWRbdGhpcy5jdXJyZW50VHJhY2tJZF07XG4gICAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnO1xuICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IGZyYWc7XG4gICAgICAgIGlmICghYnVmZmVyZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUvdXBkYXRlIGEgYnVmZmVyZWQgYXJyYXkgbWF0Y2hpbmcgdGhlIGludGVyZmFjZSB1c2VkIGJ5IEJ1ZmZlckhlbHBlci5idWZmZXJlZEluZm9cbiAgICAgICAgLy8gc28gd2UgY2FuIHJlLXVzZSB0aGUgbG9naWMgdXNlZCB0byBkZXRlY3QgaG93IG11Y2ggaGF2ZSBiZWVuIGJ1ZmZlcmVkXG4gICAgICAgIC8vIEZJWE1FOiBwdXQgdGhpcyBpbiBhIHV0aWxpdHkgZnVuY3Rpb24gb3IgcHJvcGVyIG9iamVjdCBmb3IgdGltZS1yYW5nZXMgbWFuaXB1bGF0aW9uP1xuICAgICAgICB2YXIgdGltZVJhbmdlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZnJhZy5zdGFydCA+PSBidWZmZXJlZFtpXS5zdGFydCAmJiBmcmFnLnN0YXJ0IDw9IGJ1ZmZlcmVkW2ldLmVuZCkge1xuICAgICAgICAgICAgICAgIHRpbWVSYW5nZSA9IGJ1ZmZlcmVkW2ldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lUmFuZ2UpIHtcbiAgICAgICAgICAgIHRpbWVSYW5nZS5lbmQgPSBmcmFnLnN0YXJ0ICsgZnJhZy5kdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZlcmVkLnB1c2goe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBmcmFnLnN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogZnJhZy5zdGFydCArIGZyYWcuZHVyYXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uTWVkaWFBdHRhY2hlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9O1xuICAgIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIH07XG4gICAgLy8gSWYgc29tZXRoaW5nIGdvZXMgd3JvbmcsIHByb2NlZGUgdG8gbmV4dCBmcmFnLCBpZiB3ZSB3ZXJlIHByb2Nlc3Npbmcgb25lLlxuICAgIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnO1xuICAgICAgICAvLyBkb24ndCBoYW5kbGUgZXJyb3Igbm90IHJlbGF0ZWQgdG8gc3VidGl0bGUgZnJhZ21lbnRcbiAgICAgICAgaWYgKCFmcmFnIHx8IGZyYWcudHlwZSAhPT0gJ3N1YnRpdGxlJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH07XG4gICAgLy8gR290IGFsbCBuZXcgc3VidGl0bGUgdHJhY2tzLlxuICAgIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdzdWJ0aXRsZSB0cmFja3MgdXBkYXRlZCcpO1xuICAgICAgICB0aGlzLnRyYWNrc0J1ZmZlcmVkID0gW107XG4gICAgICAgIHRoaXMudHJhY2tzID0gZGF0YS5zdWJ0aXRsZVRyYWNrcztcbiAgICAgICAgdGhpcy50cmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgICAgIF90aGlzLnRyYWNrc0J1ZmZlcmVkW3RyYWNrLmlkXSA9IFtdO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25TdWJ0aXRsZVRyYWNrU3dpdGNoID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VHJhY2tJZCA9IGRhdGEuaWQ7XG4gICAgICAgIGlmICghdGhpcy50cmFja3MgfHwgdGhpcy5jdXJyZW50VHJhY2tJZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIHRyYWNrIGhhcyB0aGUgbmVjZXNzYXJ5IGRldGFpbHMgdG8gbG9hZCBmcmFnbWVudHNcbiAgICAgICAgdmFyIGN1cnJlbnRUcmFjayA9IHRoaXMudHJhY2tzW3RoaXMuY3VycmVudFRyYWNrSWRdO1xuICAgICAgICBpZiAoY3VycmVudFRyYWNrICYmIGN1cnJlbnRUcmFjay5kZXRhaWxzKSB7XG4gICAgICAgICAgICB0aGlzLnNldEludGVydmFsKFRJQ0tfSU5URVJWQUwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBHb3QgYSBuZXcgc2V0IG9mIHN1YnRpdGxlIGZyYWdtZW50cy5cbiAgICBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uU3VidGl0bGVUcmFja0xvYWRlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBpZCA9IGRhdGEuaWQsIGRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgICAgIGlmICghdGhpcy50cmFja3MpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKCdDYW4gbm90IHVwZGF0ZSBzdWJ0aXRsZSBkZXRhaWxzLCBubyB0cmFja3MgZm91bmQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50cmFja3NbaWRdKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdVcGRhdGluZyBzdWJ0aXRsZSB0cmFjayBkZXRhaWxzJyk7XG4gICAgICAgICAgICB0aGlzLnRyYWNrc1tpZF0uZGV0YWlscyA9IGRldGFpbHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMKTtcbiAgICB9O1xuICAgIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25LZXlMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5LRVlfTE9BRElORykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25GcmFnTG9hZGVkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgICAgdmFyIGRlY3J5cHREYXRhID0gZGF0YS5mcmFnLmRlY3J5cHRkYXRhO1xuICAgICAgICB2YXIgZnJhZ0xvYWRlZCA9IGRhdGEuZnJhZztcbiAgICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRlJBR19MT0FESU5HICYmXG4gICAgICAgICAgICBmcmFnQ3VycmVudCAmJlxuICAgICAgICAgICAgZGF0YS5mcmFnLnR5cGUgPT09ICdzdWJ0aXRsZScgJiZcbiAgICAgICAgICAgIGZyYWdDdXJyZW50LnNuID09PSBkYXRhLmZyYWcuc24pIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB0aGUgcGF5bG9hZCBuZWVkcyB0byBiZSBkZWNyeXB0ZWRcbiAgICAgICAgICAgIGlmIChkYXRhLnBheWxvYWQuYnl0ZUxlbmd0aCA+IDAgJiYgKGRlY3J5cHREYXRhICYmIGRlY3J5cHREYXRhLmtleSAmJiBkZWNyeXB0RGF0YS5tZXRob2QgPT09ICdBRVMtMTI4JykpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRUaW1lXzEgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgICAgICAvLyBkZWNyeXB0IHRoZSBzdWJ0aXRsZXNcbiAgICAgICAgICAgICAgICB0aGlzLmRlY3J5cHRlci5kZWNyeXB0KGRhdGEucGF5bG9hZCwgZGVjcnlwdERhdGEua2V5LmJ1ZmZlciwgZGVjcnlwdERhdGEuaXYuYnVmZmVyLCBmdW5jdGlvbiAoZGVjcnlwdGVkRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkZSQUdfREVDUllQVEVELCB7IGZyYWc6IGZyYWdMb2FkZWQsIHBheWxvYWQ6IGRlY3J5cHRlZERhdGEsIHN0YXRzOiB7IHRzdGFydDogc3RhcnRUaW1lXzEsIHRkZWNyeXB0OiBlbmRUaW1lIH0gfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuZG9UaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBTdGF0ZS5JRExFOlxuICAgICAgICAgICAgICAgIHZhciB0cmFja3MgPSB0aGlzLnRyYWNrcztcbiAgICAgICAgICAgICAgICB2YXIgdHJhY2tJZCA9IHRoaXMuY3VycmVudFRyYWNrSWQ7XG4gICAgICAgICAgICAgICAgaWYgKCF0cmFja3MgfHwgIXRyYWNrc1t0cmFja0lkXSB8fCAhdHJhY2tzW3RyYWNrSWRdLmRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0cmFja0RldGFpbHMgPSB0cmFja3NbdHJhY2tJZF0uZGV0YWlscztcbiAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgICAgICAgdmFyIG1heEJ1ZmZlckhvbGUgPSBjb25maWcubWF4QnVmZmVySG9sZTtcbiAgICAgICAgICAgICAgICB2YXIgbWF4Q29uZmlnQnVmZmVyID0gTWF0aC5taW4oY29uZmlnLm1heEJ1ZmZlckxlbmd0aCwgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdmFyIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTtcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyZWRJbmZvID0gYnVmZmVyX2hlbHBlcl8xLkJ1ZmZlckhlbHBlci5idWZmZXJlZEluZm8odGhpcy5fZ2V0QnVmZmVyZWQoKSwgdGhpcy5tZWRpYS5jdXJyZW50VGltZSwgbWF4QnVmZmVySG9sZSk7XG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmZlckVuZCA9IGJ1ZmZlcmVkSW5mby5lbmQ7XG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmZlckxlbiA9IGJ1ZmZlcmVkSW5mby5sZW47XG4gICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50cyA9IHRyYWNrRGV0YWlscy5mcmFnbWVudHM7XG4gICAgICAgICAgICAgICAgdmFyIGZyYWdMZW4gPSBmcmFnbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBmcmFnbWVudHNbZnJhZ0xlbiAtIDFdLnN0YXJ0ICsgZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXS5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICB2YXIgZm91bmRGcmFnID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmIChidWZmZXJMZW4gPCBtYXhDb25maWdCdWZmZXIgJiYgYnVmZmVyRW5kIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kRnJhZyA9IGZyYWdtZW50X2ZpbmRlcnNfMS5maW5kRnJhZ21lbnRCeVBUUyh0aGlzLmZyYWdQcmV2aW91cywgZnJhZ21lbnRzLCBidWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0cmFja0RldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lICYmIHRoaXMuZnJhZ1ByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kRnJhZyA9IGZyYWdtZW50X2ZpbmRlcnNfMS5maW5kRnJhZ21lbnRCeVBEVChmcmFnbWVudHMsIHRoaXMuZnJhZ1ByZXZpb3VzLmVuZFByb2dyYW1EYXRlVGltZSwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmb3VuZEZyYWcgJiYgZm91bmRGcmFnLmVuY3J5cHRlZCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiTG9hZGluZyBrZXkgZm9yIFwiICsgZm91bmRGcmFnLnNuKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLktFWV9MT0FESU5HO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuS0VZX0xPQURJTkcsIHsgZnJhZzogZm91bmRGcmFnIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3VuZEZyYWcgJiYgdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZm91bmRGcmFnKSA9PT0gZnJhZ21lbnRfdHJhY2tlcl8xLkZyYWdtZW50U3RhdGUuTk9UX0xPQURFRCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGxvYWQgaWYgZnJhZ21lbnQgaXMgbm90IGxvYWRlZFxuICAgICAgICAgICAgICAgICAgICBmb3VuZEZyYWcudHJhY2tJZCA9IHRyYWNrSWQ7IC8vIEZyYWdzIGRvbid0IGtub3cgdGhlaXIgc3VidGl0bGUgdHJhY2sgSUQsIHNvIGxldCdzIGp1c3QgYWRkIHRoYXQuLi5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IGZvdW5kRnJhZztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElORztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkZSQUdfTE9BRElORywgeyBmcmFnOiBmb3VuZEZyYWcgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLl9nZXRCdWZmZXJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tzQnVmZmVyZWRbdGhpcy5jdXJyZW50VHJhY2tJZF0gfHwgW107XG4gICAgfTtcbiAgICByZXR1cm4gU3VidGl0bGVTdHJlYW1Db250cm9sbGVyO1xufSh0YXNrX2xvb3BfMS5kZWZhdWx0KSk7XG5leHBvcnRzLlN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciA9IFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL3N1YnRpdGxlLXRyYWNrLWNvbnRyb2xsZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvc3VidGl0bGUtdHJhY2stY29udHJvbGxlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gKiBzdWJ0aXRsZSB0cmFjayBjb250cm9sbGVyXG4qL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMuanNcIik7XG52YXIgZXZlbnRfaGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnQtaGFuZGxlciAqLyBcIi4vc3JjL2V2ZW50LWhhbmRsZXIuanNcIik7XG52YXIgbG9nZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIuanNcIik7XG5mdW5jdGlvbiBmaWx0ZXJTdWJ0aXRsZVRyYWNrcyh0ZXh0VHJhY2tMaXN0KSB7XG4gICAgdmFyIHRyYWNrcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dFRyYWNrTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGV4dFRyYWNrTGlzdFtpXS5raW5kID09PSAnc3VidGl0bGVzJykge1xuICAgICAgICAgICAgdHJhY2tzLnB1c2godGV4dFRyYWNrTGlzdFtpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRyYWNrcztcbn1cbnZhciBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3VidGl0bGVUcmFja0NvbnRyb2xsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3VidGl0bGVUcmFja0NvbnRyb2xsZXIoaGxzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGhscywgZXZlbnRzXzEuZGVmYXVsdC5NRURJQV9BVFRBQ0hFRCwgZXZlbnRzXzEuZGVmYXVsdC5NRURJQV9ERVRBQ0hJTkcsIGV2ZW50c18xLmRlZmF1bHQuTUFOSUZFU1RfTE9BRElORywgZXZlbnRzXzEuZGVmYXVsdC5NQU5JRkVTVF9MT0FERUQsIGV2ZW50c18xLmRlZmF1bHQuU1VCVElUTEVfVFJBQ0tfTE9BREVEKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50cmFja3MgPSBbXTtcbiAgICAgICAgX3RoaXMudHJhY2tJZCA9IC0xO1xuICAgICAgICBfdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufSBzdWJ0aXRsZURpc3BsYXkgRW5hYmxlL2Rpc2FibGUgc3VidGl0bGUgZGlzcGxheSByZW5kZXJpbmdcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnN1YnRpdGxlRGlzcGxheSA9IHRydWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU3VidGl0bGVUcmFja0NvbnRyb2xsZXIucHJvdG90eXBlLl9vblRleHRUcmFja3NDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBNZWRpYSBpcyB1bmRlZmluZWQgd2hlbiBzd2l0Y2hpbmcgc3RyZWFtcyB2aWEgbG9hZFNvdXJjZSgpXG4gICAgICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0cmFja0lkID0gLTE7XG4gICAgICAgIHZhciB0cmFja3MgPSBmaWx0ZXJTdWJ0aXRsZVRyYWNrcyh0aGlzLm1lZGlhLnRleHRUcmFja3MpO1xuICAgICAgICBmb3IgKHZhciBpZCA9IDA7IGlkIDwgdHJhY2tzLmxlbmd0aDsgaWQrKykge1xuICAgICAgICAgICAgaWYgKHRyYWNrc1tpZF0ubW9kZSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgYnJlYWsgaW4gY2FzZSB0aGVyZSBpcyBhIGZvbGxvd2luZyB0cmFjayB3aXRoIHNob3dpbmcuXG4gICAgICAgICAgICAgICAgdHJhY2tJZCA9IGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHJhY2tzW2lkXS5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgICAgICAgICB0cmFja0lkID0gaWQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0dGluZyBjdXJyZW50IHN1YnRpdGxlVHJhY2sgd2lsbCBpbnZva2UgY29kZS5cbiAgICAgICAgdGhpcy5zdWJ0aXRsZVRyYWNrID0gdHJhY2tJZDtcbiAgICB9O1xuICAgIFN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBldmVudF9oYW5kbGVyXzEuZGVmYXVsdC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgLy8gTGlzdGVuIGZvciBzdWJ0aXRsZSB0cmFjayBjaGFuZ2UsIHRoZW4gZXh0cmFjdCB0aGUgY3VycmVudCB0cmFjayBJRC5cbiAgICBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5wcm90b3R5cGUub25NZWRpYUF0dGFjaGVkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnF1ZXVlZERlZmF1bHRUcmFjaykge1xuICAgICAgICAgICAgdGhpcy5zdWJ0aXRsZVRyYWNrID0gdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2s7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFja0NoYW5nZUxpc3RlbmVyID0gdGhpcy5fb25UZXh0VHJhY2tzQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcgPSAhKHRoaXMubWVkaWEudGV4dFRyYWNrcyAmJiAnb25jaGFuZ2UnIGluIHRoaXMubWVkaWEudGV4dFRyYWNrcyk7XG4gICAgICAgIGlmICh0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuc3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudHJhY2tDaGFuZ2VMaXN0ZW5lcigpO1xuICAgICAgICAgICAgfSwgNTAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWVkaWEudGV4dFRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLnRyYWNrQ2hhbmdlTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5wcm90b3R5cGUub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudXNlVGV4dFRyYWNrUG9sbGluZykge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWVkaWEudGV4dFRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLnRyYWNrQ2hhbmdlTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIH07XG4gICAgLy8gUmVzZXQgc3VidGl0bGUgdHJhY2tzIG9uIG1hbmlmZXN0IGxvYWRpbmdcbiAgICBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5wcm90b3R5cGUub25NYW5pZmVzdExvYWRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgICAgIHRoaXMudHJhY2tJZCA9IC0xO1xuICAgIH07XG4gICAgLy8gRmlyZWQgd2hlbmV2ZXIgYSBuZXcgbWFuaWZlc3QgaXMgbG9hZGVkLlxuICAgIFN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZS5vbk1hbmlmZXN0TG9hZGVkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRyYWNrcyA9IGRhdGEuc3VidGl0bGVzIHx8IFtdO1xuICAgICAgICB0aGlzLnRyYWNrcyA9IHRyYWNrcztcbiAgICAgICAgdGhpcy50cmFja0lkID0gLTE7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCwgeyBzdWJ0aXRsZVRyYWNrczogdHJhY2tzIH0pO1xuICAgICAgICAvLyBsb29wIHRocm91Z2ggYXZhaWxhYmxlIHN1YnRpdGxlIHRyYWNrcyBhbmQgYXV0b3NlbGVjdCBkZWZhdWx0IGlmIG5lZWRlZFxuICAgICAgICAvLyBUT0RPOiBpbXByb3ZlIHNlbGVjdGlvbiBsb2dpYyB0byBoYW5kbGUgZm9yY2VkLCBldGNcbiAgICAgICAgdHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgICAgICBpZiAodHJhY2suZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIC8vIHNldHRpbmcgdGhpcy5zdWJ0aXRsZVRyYWNrIHdpbGwgdHJpZ2dlciBpbnRlcm5hbCBsb2dpY1xuICAgICAgICAgICAgICAgIC8vIGlmIG1lZGlhIGhhcyBub3QgYmVlbiBhdHRhY2hlZCB5ZXQsIGl0IHdpbGwgZmFpbFxuICAgICAgICAgICAgICAgIC8vIHdlIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIGRlZmF1bHQgdHJhY2sgaWRcbiAgICAgICAgICAgICAgICAvLyBhbmQgd2UnbGwgc2V0IHN1YnRpdGxlVHJhY2sgd2hlbiBvbk1lZGlhQXR0YWNoZWQgaXMgdHJpZ2dlcmVkXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm1lZGlhKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN1YnRpdGxlVHJhY2sgPSB0cmFjay5pZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnF1ZXVlZERlZmF1bHRUcmFjayA9IHRyYWNrLmlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBUcmlnZ2VyIHN1YnRpdGxlIHRyYWNrIHBsYXlsaXN0IHJlbG9hZC5cbiAgICBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5wcm90b3R5cGUub25UaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJhY2tJZCA9IHRoaXMudHJhY2tJZDtcbiAgICAgICAgdmFyIHN1YnRpdGxlVHJhY2sgPSB0aGlzLnRyYWNrc1t0cmFja0lkXTtcbiAgICAgICAgaWYgKCFzdWJ0aXRsZVRyYWNrKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRldGFpbHMgPSBzdWJ0aXRsZVRyYWNrLmRldGFpbHM7XG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gbG9hZCBwbGF5bGlzdCBmb3IgdGhpcyBzdWJ0aXRsZSBUcmFja1xuICAgICAgICBpZiAoIWRldGFpbHMgfHwgZGV0YWlscy5saXZlKSB7XG4gICAgICAgICAgICAvLyB0cmFjayBub3QgcmV0cmlldmVkIHlldCwgb3IgbGl2ZSBwbGF5bGlzdCB3ZSBuZWVkIHRvIChyZSlsb2FkIGl0XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiKHJlKWxvYWRpbmcgcGxheWxpc3QgZm9yIHN1YnRpdGxlIHRyYWNrIFwiICsgdHJhY2tJZCk7XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuU1VCVElUTEVfVFJBQ0tfTE9BRElORywgeyB1cmw6IHN1YnRpdGxlVHJhY2sudXJsLCBpZDogdHJhY2tJZCB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3VidGl0bGVUcmFja0NvbnRyb2xsZXIucHJvdG90eXBlLm9uU3VidGl0bGVUcmFja0xvYWRlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChkYXRhLmlkIDwgdGhpcy50cmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwic3VidGl0bGUgdHJhY2sgXCIgKyBkYXRhLmlkICsgXCIgbG9hZGVkXCIpO1xuICAgICAgICAgICAgdGhpcy50cmFja3NbZGF0YS5pZF0uZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGN1cnJlbnQgcGxheWxpc3QgaXMgYSBsaXZlIHBsYXlsaXN0XG4gICAgICAgICAgICBpZiAoZGF0YS5kZXRhaWxzLmxpdmUgJiYgIXRoaXMudGltZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBsaXZlIHBsYXlsaXN0IHdlIHdpbGwgaGF2ZSB0byByZWxvYWQgaXQgcGVyaW9kaWNhbGx5XG4gICAgICAgICAgICAgICAgLy8gc2V0IHJlbG9hZCBwZXJpb2QgdG8gcGxheWxpc3QgdGFyZ2V0IGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25UaWNrKCk7XG4gICAgICAgICAgICAgICAgfSwgMTAwMCAqIGRhdGEuZGV0YWlscy50YXJnZXRkdXJhdGlvbiwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGEuZGV0YWlscy5saXZlICYmIHRoaXMudGltZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBwbGF5bGlzdCBpcyBub3QgbGl2ZSBhbmQgdGltZXIgaXMgYXJtZWQgOiBzdG9wcGluZyBpdFxuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BUaW1lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3VidGl0bGVUcmFja0NvbnRyb2xsZXIucHJvdG90eXBlLCBcInN1YnRpdGxlVHJhY2tzXCIsIHtcbiAgICAgICAgLyoqIGdldCBhbHRlcm5hdGUgc3VidGl0bGUgdHJhY2tzIGxpc3QgZnJvbSBwbGF5bGlzdCAqKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFja3M7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5wcm90b3R5cGUsIFwic3VidGl0bGVUcmFja1wiLCB7XG4gICAgICAgIC8qKiBnZXQgaW5kZXggb2YgdGhlIHNlbGVjdGVkIHN1YnRpdGxlIHRyYWNrIChpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0cykgKiovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tJZDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqIHNlbGVjdCBhIHN1YnRpdGxlIHRyYWNrLCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHMqKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoc3VidGl0bGVUcmFja0lkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50cmFja0lkICE9PSBzdWJ0aXRsZVRyYWNrSWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90b2dnbGVUcmFja01vZGVzKHN1YnRpdGxlVHJhY2tJZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdWJ0aXRsZVRyYWNrSW50ZXJuYWwoc3VidGl0bGVUcmFja0lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgcmVzcG9uc2libGUgZm9yIHZhbGlkYXRpbmcgdGhlIHN1YnRpdGxlIGluZGV4IGFuZCBwZXJpb2RpY2FsbHkgcmVsb2FkaW5nIGlmIGxpdmUuXG4gICAgICogRGlzcGF0Y2hlcyB0aGUgU1VCVElUTEVfVFJBQ0tfU1dJVENIIGV2ZW50LCB3aGljaCBpbnN0cnVjdHMgdGhlIHN1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyIHRvIGxvYWQgdGhlIHNlbGVjdGVkIHRyYWNrLlxuICAgICAqIEBwYXJhbSBuZXdJZCAtIFRoZSBpZCBvZiB0aGUgc3VidGl0bGUgdHJhY2sgdG8gYWN0aXZhdGUuXG4gICAgICovXG4gICAgU3VidGl0bGVUcmFja0NvbnRyb2xsZXIucHJvdG90eXBlLnNldFN1YnRpdGxlVHJhY2tJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZXdJZCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBobHMgPSBfYS5obHMsIHRyYWNrcyA9IF9hLnRyYWNrcztcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdJZCAhPT0gJ251bWJlcicgfHwgbmV3SWQgPCAtMSB8fCBuZXdJZCA+PSB0cmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RvcFRpbWVyKCk7XG4gICAgICAgIHRoaXMudHJhY2tJZCA9IG5ld0lkO1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwic3dpdGNoaW5nIHRvIHN1YnRpdGxlIHRyYWNrIFwiICsgbmV3SWQpO1xuICAgICAgICBobHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LlNVQlRJVExFX1RSQUNLX1NXSVRDSCwgeyBpZDogbmV3SWQgfSk7XG4gICAgICAgIGlmIChuZXdJZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGxvYWQgcGxheWxpc3QgZm9yIHRoaXMgc3VidGl0bGUgVHJhY2tcbiAgICAgICAgdmFyIHN1YnRpdGxlVHJhY2sgPSB0cmFja3NbbmV3SWRdO1xuICAgICAgICB2YXIgZGV0YWlscyA9IHN1YnRpdGxlVHJhY2suZGV0YWlscztcbiAgICAgICAgaWYgKCFkZXRhaWxzIHx8IGRldGFpbHMubGl2ZSkge1xuICAgICAgICAgICAgLy8gdHJhY2sgbm90IHJldHJpZXZlZCB5ZXQsIG9yIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byAocmUpbG9hZCBpdFxuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIihyZSlsb2FkaW5nIHBsYXlsaXN0IGZvciBzdWJ0aXRsZSB0cmFjayBcIiArIG5ld0lkKTtcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuU1VCVElUTEVfVFJBQ0tfTE9BRElORywgeyB1cmw6IHN1YnRpdGxlVHJhY2sudXJsLCBpZDogbmV3SWQgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZS5fc3RvcFRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEaXNhYmxlcyB0aGUgb2xkIHN1YnRpdGxlVHJhY2sgYW5kIHNldHMgY3VycmVudCBtb2RlIG9uIHRoZSBuZXh0IHN1YnRpdGxlVHJhY2suXG4gICAgICogVGhpcyBvcGVyYXRlcyBvbiB0aGUgRE9NIHRleHRUcmFja3MuXG4gICAgICogQSB2YWx1ZSBvZiAtMSB3aWxsIGRpc2FibGUgYWxsIHN1YnRpdGxlIHRyYWNrcy5cbiAgICAgKiBAcGFyYW0gbmV3SWQgLSBUaGUgaWQgb2YgdGhlIG5leHQgdHJhY2sgdG8gZW5hYmxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5wcm90b3R5cGUuX3RvZ2dsZVRyYWNrTW9kZXMgPSBmdW5jdGlvbiAobmV3SWQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgbWVkaWEgPSBfYS5tZWRpYSwgc3VidGl0bGVEaXNwbGF5ID0gX2Euc3VidGl0bGVEaXNwbGF5LCB0cmFja0lkID0gX2EudHJhY2tJZDtcbiAgICAgICAgaWYgKCFtZWRpYSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZXh0VHJhY2tzID0gZmlsdGVyU3VidGl0bGVUcmFja3MobWVkaWEudGV4dFRyYWNrcyk7XG4gICAgICAgIGlmIChuZXdJZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwodGV4dFRyYWNrcykuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgICAgICAgICB0cmFjay5tb2RlID0gJ2Rpc2FibGVkJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG9sZFRyYWNrID0gdGV4dFRyYWNrc1t0cmFja0lkXTtcbiAgICAgICAgICAgIGlmIChvbGRUcmFjaykge1xuICAgICAgICAgICAgICAgIG9sZFRyYWNrLm1vZGUgPSAnZGlzYWJsZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBuZXh0VHJhY2sgPSB0ZXh0VHJhY2tzW25ld0lkXTtcbiAgICAgICAgaWYgKG5leHRUcmFjaykge1xuICAgICAgICAgICAgbmV4dFRyYWNrLm1vZGUgPSBzdWJ0aXRsZURpc3BsYXkgPyAnc2hvd2luZycgOiAnaGlkZGVuJztcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xufShldmVudF9oYW5kbGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci90aW1lbGluZS1jb250cm9sbGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL3RpbWVsaW5lLWNvbnRyb2xsZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKE51bWJlcikge1xuLypcbiAqIFRpbWVsaW5lIENvbnRyb2xsZXJcbiovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy5qc1wiKTtcbnZhciBldmVudF9oYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudC1oYW5kbGVyICovIFwiLi9zcmMvZXZlbnQtaGFuZGxlci5qc1wiKTtcbnZhciBjZWFfNjA4X3BhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvY2VhLTYwOC1wYXJzZXIgKi8gXCIuL3NyYy91dGlscy9jZWEtNjA4LXBhcnNlci5qc1wiKTtcbnZhciBvdXRwdXRfZmlsdGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9vdXRwdXQtZmlsdGVyICovIFwiLi9zcmMvdXRpbHMvb3V0cHV0LWZpbHRlci5qc1wiKTtcbnZhciB3ZWJ2dHRfcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy93ZWJ2dHQtcGFyc2VyICovIFwiLi9zcmMvdXRpbHMvd2VidnR0LXBhcnNlci5qc1wiKTtcbnZhciBsb2dnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci5qc1wiKTtcbnZhciB0ZXh0dHJhY2tfdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL3RleHR0cmFjay11dGlscyAqLyBcIi4vc3JjL3V0aWxzL3RleHR0cmFjay11dGlscy5qc1wiKTtcbmZ1bmN0aW9uIGNhblJldXNlVnR0VGV4dFRyYWNrKGluVXNlVHJhY2ssIG1hbmlmZXN0VHJhY2spIHtcbiAgICByZXR1cm4gaW5Vc2VUcmFjayAmJiBpblVzZVRyYWNrLmxhYmVsID09PSBtYW5pZmVzdFRyYWNrLm5hbWUgJiYgIShpblVzZVRyYWNrLnRleHRUcmFjazEgfHwgaW5Vc2VUcmFjay50ZXh0VHJhY2syKTtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdGlvbih4MSwgeDIsIHkxLCB5Mikge1xuICAgIHJldHVybiBNYXRoLm1pbih4MiwgeTIpIC0gTWF0aC5tYXgoeDEsIHkxKTtcbn1cbnZhciBUaW1lbGluZUNvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRpbWVsaW5lQ29udHJvbGxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaW1lbGluZUNvbnRyb2xsZXIoaGxzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGhscywgZXZlbnRzXzEuZGVmYXVsdC5NRURJQV9BVFRBQ0hJTkcsIGV2ZW50c18xLmRlZmF1bHQuTUVESUFfREVUQUNISU5HLCBldmVudHNfMS5kZWZhdWx0LkZSQUdfUEFSU0lOR19VU0VSREFUQSwgZXZlbnRzXzEuZGVmYXVsdC5GUkFHX0RFQ1JZUFRFRCwgZXZlbnRzXzEuZGVmYXVsdC5NQU5JRkVTVF9MT0FESU5HLCBldmVudHNfMS5kZWZhdWx0Lk1BTklGRVNUX0xPQURFRCwgZXZlbnRzXzEuZGVmYXVsdC5GUkFHX0xPQURFRCwgZXZlbnRzXzEuZGVmYXVsdC5MRVZFTF9TV0lUQ0hJTkcsIGV2ZW50c18xLmRlZmF1bHQuSU5JVF9QVFNfRk9VTkQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmhscyA9IGhscztcbiAgICAgICAgX3RoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICAgICAgX3RoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIF90aGlzLkN1ZXMgPSBobHMuY29uZmlnLmN1ZUhhbmRsZXI7XG4gICAgICAgIF90aGlzLnRleHRUcmFja3MgPSBbXTtcbiAgICAgICAgX3RoaXMudHJhY2tzID0gW107XG4gICAgICAgIF90aGlzLnVucGFyc2VkVnR0RnJhZ3MgPSBbXTtcbiAgICAgICAgX3RoaXMuaW5pdFBUUyA9IFtdO1xuICAgICAgICBfdGhpcy5jdWVSYW5nZXMgPSBbXTtcbiAgICAgICAgX3RoaXMuY2FwdGlvbnNUcmFja3MgPSB7fTtcbiAgICAgICAgX3RoaXMuY2FwdGlvbnNQcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgdGV4dFRyYWNrMToge1xuICAgICAgICAgICAgICAgIGxhYmVsOiBfdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2sxTGFiZWwsXG4gICAgICAgICAgICAgICAgbGFuZ3VhZ2VDb2RlOiBfdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2sxTGFuZ3VhZ2VDb2RlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGV4dFRyYWNrMjoge1xuICAgICAgICAgICAgICAgIGxhYmVsOiBfdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2syTGFiZWwsXG4gICAgICAgICAgICAgICAgbGFuZ3VhZ2VDb2RlOiBfdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2syTGFuZ3VhZ2VDb2RlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChfdGhpcy5jb25maWcuZW5hYmxlQ0VBNzA4Q2FwdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBjaGFubmVsMSA9IG5ldyBvdXRwdXRfZmlsdGVyXzEuZGVmYXVsdChfdGhpcywgJ3RleHRUcmFjazEnKTtcbiAgICAgICAgICAgIHZhciBjaGFubmVsMiA9IG5ldyBvdXRwdXRfZmlsdGVyXzEuZGVmYXVsdChfdGhpcywgJ3RleHRUcmFjazInKTtcbiAgICAgICAgICAgIF90aGlzLmNlYTYwOFBhcnNlciA9IG5ldyBjZWFfNjA4X3BhcnNlcl8xLmRlZmF1bHQoMCwgY2hhbm5lbDEsIGNoYW5uZWwyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRpbWVsaW5lQ29udHJvbGxlci5wcm90b3R5cGUuYWRkQ3VlcyA9IGZ1bmN0aW9uICh0cmFja05hbWUsIHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKSB7XG4gICAgICAgIC8vIHNraXAgY3VlcyB3aGljaCBvdmVybGFwIG1vcmUgdGhhbiA1MCUgd2l0aCBwcmV2aW91c2x5IHBhcnNlZCB0aW1lIHJhbmdlc1xuICAgICAgICB2YXIgcmFuZ2VzID0gdGhpcy5jdWVSYW5nZXM7XG4gICAgICAgIHZhciBtZXJnZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHJhbmdlcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgIHZhciBjdWVSYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgIHZhciBvdmVybGFwID0gaW50ZXJzZWN0aW9uKGN1ZVJhbmdlWzBdLCBjdWVSYW5nZVsxXSwgc3RhcnRUaW1lLCBlbmRUaW1lKTtcbiAgICAgICAgICAgIGlmIChvdmVybGFwID49IDApIHtcbiAgICAgICAgICAgICAgICBjdWVSYW5nZVswXSA9IE1hdGgubWluKGN1ZVJhbmdlWzBdLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIGN1ZVJhbmdlWzFdID0gTWF0aC5tYXgoY3VlUmFuZ2VbMV0sIGVuZFRpbWUpO1xuICAgICAgICAgICAgICAgIG1lcmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKChvdmVybGFwIC8gKGVuZFRpbWUgLSBzdGFydFRpbWUpKSA+IDAuNSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbWVyZ2VkKSB7XG4gICAgICAgICAgICByYW5nZXMucHVzaChbc3RhcnRUaW1lLCBlbmRUaW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5DdWVzLm5ld0N1ZSh0aGlzLmNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0sIHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKTtcbiAgICB9O1xuICAgIC8vIFRyaWdnZXJlZCB3aGVuIGFuIGluaXRpYWwgUFRTIGlzIGZvdW5kOyB1c2VkIGZvciBzeW5jaHJvbmlzYXRpb24gb2YgV2ViVlRULlxuICAgIFRpbWVsaW5lQ29udHJvbGxlci5wcm90b3R5cGUub25Jbml0UHRzRm91bmQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZGF0YS5pZCA9PT0gJ21haW4nKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRQVFNbZGF0YS5mcmFnLmNjXSA9IGRhdGEuaW5pdFBUUztcbiAgICAgICAgfVxuICAgICAgICAvLyBEdWUgdG8gYXN5bmNocm9ub3VzIHByb2Nlc3NpbmcsIGluaXRpYWwgUFRTIG1heSBhcnJpdmUgbGF0ZXIgdGhhbiB0aGUgZmlyc3QgVlRUIGZyYWdtZW50cyBhcmUgbG9hZGVkLlxuICAgICAgICAvLyBQYXJzZSBhbnkgdW5wYXJzZWQgZnJhZ21lbnRzIHVwb24gcmVjZWl2aW5nIHRoZSBpbml0aWFsIFBUUy5cbiAgICAgICAgaWYgKHRoaXMudW5wYXJzZWRWdHRGcmFncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB1bnBhcnNlZFZ0dEZyYWdzID0gdGhpcy51bnBhcnNlZFZ0dEZyYWdzO1xuICAgICAgICAgICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gW107XG4gICAgICAgICAgICB1bnBhcnNlZFZ0dEZyYWdzLmZvckVhY2goZnVuY3Rpb24gKGZyYWcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkZyYWdMb2FkZWQoZnJhZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGltZWxpbmVDb250cm9sbGVyLnByb3RvdHlwZS5nZXRFeGlzdGluZ1RyYWNrID0gZnVuY3Rpb24gKHRyYWNrTmFtZSkge1xuICAgICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVkaWEudGV4dFRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0VHJhY2sgPSBtZWRpYS50ZXh0VHJhY2tzW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0VHJhY2tbdHJhY2tOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4dFRyYWNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFRpbWVsaW5lQ29udHJvbGxlci5wcm90b3R5cGUuY3JlYXRlQ2FwdGlvbnNUcmFjayA9IGZ1bmN0aW9uICh0cmFja05hbWUpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5jYXB0aW9uc1Byb3BlcnRpZXNbdHJhY2tOYW1lXSwgbGFiZWwgPSBfYS5sYWJlbCwgbGFuZ3VhZ2VDb2RlID0gX2EubGFuZ3VhZ2VDb2RlO1xuICAgICAgICB2YXIgY2FwdGlvbnNUcmFja3MgPSB0aGlzLmNhcHRpb25zVHJhY2tzO1xuICAgICAgICBpZiAoIWNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0pIHtcbiAgICAgICAgICAgIC8vIEVuYWJsZSByZXVzZSBvZiBleGlzdGluZyB0ZXh0IHRyYWNrLlxuICAgICAgICAgICAgdmFyIGV4aXN0aW5nVHJhY2sgPSB0aGlzLmdldEV4aXN0aW5nVHJhY2sodHJhY2tOYW1lKTtcbiAgICAgICAgICAgIGlmICghZXhpc3RpbmdUcmFjaykge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0VHJhY2sgPSB0aGlzLmNyZWF0ZVRleHRUcmFjaygnY2FwdGlvbnMnLCBsYWJlbCwgbGFuZ3VhZ2VDb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dFRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBhIHNwZWNpYWwgcHJvcGVydHkgb24gdGhlIHRyYWNrIHNvIHdlIGtub3cgaXQncyBtYW5hZ2VkIGJ5IEhscy5qc1xuICAgICAgICAgICAgICAgICAgICB0ZXh0VHJhY2tbdHJhY2tOYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0gPSB0ZXh0VHJhY2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSA9IGV4aXN0aW5nVHJhY2s7XG4gICAgICAgICAgICAgICAgdGV4dHRyYWNrX3V0aWxzXzEuY2xlYXJDdXJyZW50Q3VlcyhjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdKTtcbiAgICAgICAgICAgICAgICB0ZXh0dHJhY2tfdXRpbHNfMS5zZW5kQWRkVHJhY2tFdmVudChjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdLCB0aGlzLm1lZGlhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVGltZWxpbmVDb250cm9sbGVyLnByb3RvdHlwZS5jcmVhdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiAoa2luZCwgbGFiZWwsIGxhbmcpIHtcbiAgICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVkaWEuYWRkVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5nKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGltZWxpbmVDb250cm9sbGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBldmVudF9oYW5kbGVyXzEuZGVmYXVsdC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgVGltZWxpbmVDb250cm9sbGVyLnByb3RvdHlwZS5vbk1lZGlhQXR0YWNoaW5nID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgICAgIHRoaXMuX2NsZWFuVHJhY2tzKCk7XG4gICAgfTtcbiAgICBUaW1lbGluZUNvbnRyb2xsZXIucHJvdG90eXBlLm9uTWVkaWFEZXRhY2hpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYXB0aW9uc1RyYWNrcyA9IHRoaXMuY2FwdGlvbnNUcmFja3M7XG4gICAgICAgIE9iamVjdC5rZXlzKGNhcHRpb25zVHJhY2tzKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFja05hbWUpIHtcbiAgICAgICAgICAgIHRleHR0cmFja191dGlsc18xLmNsZWFyQ3VycmVudEN1ZXMoY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSk7XG4gICAgICAgICAgICBkZWxldGUgY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUaW1lbGluZUNvbnRyb2xsZXIucHJvdG90eXBlLm9uTWFuaWZlc3RMb2FkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxhc3RTbiA9IC0xOyAvLyBEZXRlY3QgZGlzY29udGlndWl0eSBpbiBmcmFnbWVudCBwYXJzaW5nXG4gICAgICAgIHRoaXMucHJldkNDID0gLTE7XG4gICAgICAgIHRoaXMudnR0Q0NzID0ge1xuICAgICAgICAgICAgY2NPZmZzZXQ6IDAsXG4gICAgICAgICAgICBwcmVzZW50YXRpb25PZmZzZXQ6IDAsXG4gICAgICAgICAgICAwOiB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IDAsIHByZXZDQzogLTEsIG5ldzogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fY2xlYW5UcmFja3MoKTtcbiAgICB9O1xuICAgIFRpbWVsaW5lQ29udHJvbGxlci5wcm90b3R5cGUuX2NsZWFuVHJhY2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjbGVhciBvdXRkYXRlZCBzdWJ0aXRsZXNcbiAgICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgICAgICB2YXIgdGV4dFRyYWNrcyA9IG1lZGlhLnRleHRUcmFja3M7XG4gICAgICAgICAgICBpZiAodGV4dFRyYWNrcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dFRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0dHJhY2tfdXRpbHNfMS5jbGVhckN1cnJlbnRDdWVzKHRleHRUcmFja3NbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVGltZWxpbmVDb250cm9sbGVyLnByb3RvdHlwZS5vbk1hbmlmZXN0TG9hZGVkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50ZXh0VHJhY2tzID0gW107XG4gICAgICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncyA9IHRoaXMudW5wYXJzZWRWdHRGcmFncyB8fCBbXTtcbiAgICAgICAgdGhpcy5pbml0UFRTID0gW107XG4gICAgICAgIHRoaXMuY3VlUmFuZ2VzID0gW107XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVXZWJWVFQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2tzID0gZGF0YS5zdWJ0aXRsZXMgfHwgW107XG4gICAgICAgICAgICB2YXIgaW5Vc2VUcmFja3NfMSA9IHRoaXMubWVkaWEgPyB0aGlzLm1lZGlhLnRleHRUcmFja3MgOiBbXTtcbiAgICAgICAgICAgIHRoaXMudHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0VHJhY2s7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgaW5Vc2VUcmFja3NfMS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluVXNlVHJhY2sgPSBbXS5zbGljZS5jYWxsKGluVXNlVHJhY2tzXzEpLmZpbmQoZnVuY3Rpb24gKGluVXNlVHJhY2spIHsgcmV0dXJuIGNhblJldXNlVnR0VGV4dFRyYWNrKGluVXNlVHJhY2ssIHRyYWNrKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldXNlIHRyYWNrcyB3aXRoIHRoZSBzYW1lIGxhYmVsLCBidXQgZG8gbm90IHJldXNlIDYwOC83MDggdHJhY2tzXG4gICAgICAgICAgICAgICAgICAgIGlmIChpblVzZVRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0VHJhY2sgPSBpblVzZVRyYWNrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGV4dFRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRUcmFjayA9IF90aGlzLmNyZWF0ZVRleHRUcmFjaygnc3VidGl0bGVzJywgdHJhY2submFtZSwgdHJhY2subGFuZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0cmFjay5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRUcmFjay5tb2RlID0gX3RoaXMuaGxzLnN1YnRpdGxlRGlzcGxheSA/ICdzaG93aW5nJyA6ICdoaWRkZW4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dFRyYWNrLm1vZGUgPSAnZGlzYWJsZWQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy50ZXh0VHJhY2tzLnB1c2godGV4dFRyYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUaW1lbGluZUNvbnRyb2xsZXIucHJvdG90eXBlLm9uTGV2ZWxTd2l0Y2hpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IHRoaXMuaGxzLmN1cnJlbnRMZXZlbC5jbG9zZWRDYXB0aW9ucyAhPT0gJ05PTkUnO1xuICAgIH07XG4gICAgVGltZWxpbmVDb250cm9sbGVyLnByb3RvdHlwZS5vbkZyYWdMb2FkZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZywgcGF5bG9hZCA9IGRhdGEucGF5bG9hZDtcbiAgICAgICAgaWYgKGZyYWcudHlwZSA9PT0gJ21haW4nKSB7XG4gICAgICAgICAgICB2YXIgc24gPSBmcmFnLnNuO1xuICAgICAgICAgICAgLy8gaWYgdGhpcyBmcmFnIGlzbid0IGNvbnRpZ3VvdXMsIGNsZWFyIHRoZSBwYXJzZXIgc28gY3VlcyB3aXRoIGJhZCBzdGFydC9lbmQgdGltZXMgYXJlbid0IGFkZGVkIHRvIHRoZSB0ZXh0VHJhY2tcbiAgICAgICAgICAgIGlmIChzbiAhPT0gdGhpcy5sYXN0U24gKyAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlYTYwOFBhcnNlciA9IHRoaXMuY2VhNjA4UGFyc2VyO1xuICAgICAgICAgICAgICAgIGlmIChjZWE2MDhQYXJzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VhNjA4UGFyc2VyLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sYXN0U24gPSBzbjtcbiAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJyYWNlLXN0eWxlXG4gICAgICAgIC8vIElmIGZyYWdtZW50IGlzIHN1YnRpdGxlIHR5cGUsIHBhcnNlIGFzIFdlYlZUVC5cbiAgICAgICAgZWxzZSBpZiAoZnJhZy50eXBlID09PSAnc3VidGl0bGUnKSB7XG4gICAgICAgICAgICBpZiAocGF5bG9hZC5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCBhbiBpbml0aWFsIHN5bmNocm9uaXNhdGlvbiBQVFMuIFN0b3JlIGZyYWdtZW50cyBhcyBsb25nIGFzIG5vbmUgaGFzIGFycml2ZWQuXG4gICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodGhpcy5pbml0UFRTW2ZyYWcuY2NdKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVucGFyc2VkVnR0RnJhZ3MucHVzaChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5pdFBUUy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmlzaCB1bnN1Y2Nlc3NmdWxseSwgb3RoZXJ3aXNlIHRoZSBzdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlciBjb3VsZCBiZSBibG9ja2VkIGZyb20gbG9hZGluZyBuZXcgZnJhZ3MuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHsgc3VjY2VzczogZmFsc2UsIGZyYWc6IGZyYWcgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZGVjcnlwdERhdGEgPSBmcmFnLmRlY3J5cHRkYXRhO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzdWJ0aXRsZXMgYXJlIG5vdCBlbmNyeXB0ZWQsIHBhcnNlIFZUVHMgbm93LiBPdGhlcndpc2UsIHdlIG5lZWQgdG8gd2FpdC5cbiAgICAgICAgICAgICAgICBpZiAoKGRlY3J5cHREYXRhID09IG51bGwpIHx8IChkZWNyeXB0RGF0YS5rZXkgPT0gbnVsbCkgfHwgKGRlY3J5cHREYXRhLm1ldGhvZCAhPT0gJ0FFUy0xMjgnKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZVZUVHMoZnJhZywgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSB0aGVyZSBpcyBubyBwYXlsb2FkLCBmaW5pc2ggdW5zdWNjZXNzZnVsbHkuXG4gICAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7IHN1Y2Nlc3M6IGZhbHNlLCBmcmFnOiBmcmFnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUaW1lbGluZUNvbnRyb2xsZXIucHJvdG90eXBlLl9wYXJzZVZUVHMgPSBmdW5jdGlvbiAoZnJhZywgcGF5bG9hZCkge1xuICAgICAgICB2YXIgdnR0Q0NzID0gdGhpcy52dHRDQ3M7XG4gICAgICAgIGlmICghdnR0Q0NzW2ZyYWcuY2NdKSB7XG4gICAgICAgICAgICB2dHRDQ3NbZnJhZy5jY10gPSB7IHN0YXJ0OiBmcmFnLnN0YXJ0LCBwcmV2Q0M6IHRoaXMucHJldkNDLCBuZXc6IHRydWUgfTtcbiAgICAgICAgICAgIHRoaXMucHJldkNDID0gZnJhZy5jYztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGV4dFRyYWNrcyA9IHRoaXMudGV4dFRyYWNrcywgaGxzID0gdGhpcy5obHM7XG4gICAgICAgIC8vIFBhcnNlIHRoZSBXZWJWVFQgZmlsZSBjb250ZW50cy5cbiAgICAgICAgd2VidnR0X3BhcnNlcl8xLmRlZmF1bHQucGFyc2UocGF5bG9hZCwgdGhpcy5pbml0UFRTW2ZyYWcuY2NdLCB2dHRDQ3MsIGZyYWcuY2MsIGZ1bmN0aW9uIChjdWVzKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFRyYWNrID0gdGV4dFRyYWNrc1tmcmFnLnRyYWNrSWRdO1xuICAgICAgICAgICAgLy8gV2ViVlRUUGFyc2VyLnBhcnNlIGlzIGFuIGFzeW5jIG1ldGhvZCBhbmQgaWYgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0ZXh0IHRyYWNrIG1vZGUgaXMgc2V0IHRvIFwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgLy8gYmVmb3JlIHBhcnNpbmcgaXMgZG9uZSB0aGVuIGRvbid0IHRyeSB0byBhY2Nlc3MgY3VycmVudFRyYWNrLmN1ZXMuZ2V0Q3VlQnlJZCBhcyBjdWVzIHdpbGwgYmUgbnVsbFxuICAgICAgICAgICAgLy8gYW5kIHRyeWluZyB0byBhY2Nlc3MgZ2V0Q3VlQnlJZCBtZXRob2Qgb2YgY3VlcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRUcmFjay5tb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwgeyBzdWNjZXNzOiBmYWxzZSwgZnJhZzogZnJhZyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgY3VlcyBhbmQgdHJpZ2dlciBldmVudCB3aXRoIHN1Y2Nlc3MgdHJ1ZS5cbiAgICAgICAgICAgIGN1ZXMuZm9yRWFjaChmdW5jdGlvbiAoY3VlKSB7XG4gICAgICAgICAgICAgICAgLy8gU29tZXRpbWVzIHRoZXJlIGFyZSBjdWUgb3ZlcmxhcHMgb24gc2VnbWVudGVkIHZ0dHMgc28gdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAvLyBjdWUgY2FuIGFwcGVhciBtb3JlIHRoYW4gb25jZSBpbiBkaWZmZXJlbnQgdnR0IGZpbGVzLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYXZvaWQgc2hvd2luZyBkdXBsaWNhdGVkIGN1ZXMgd2l0aCBzYW1lIHRpbWVjb2RlIGFuZCB0ZXh0LlxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudFRyYWNrLmN1ZXMuZ2V0Q3VlQnlJZChjdWUuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VHJhY2suYWRkQ3VlKGN1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRUcmFja0N1ZSA9IG5ldyB3aW5kb3cuVGV4dFRyYWNrQ3VlKGN1ZS5zdGFydFRpbWUsIGN1ZS5lbmRUaW1lLCBjdWUudGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0VHJhY2tDdWUuaWQgPSBjdWUuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VHJhY2suYWRkQ3VlKHRleHRUcmFja0N1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHsgc3VjY2VzczogdHJ1ZSwgZnJhZzogZnJhZyB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHdyb25nIHdoaWxlIHBhcnNpbmcuIFRyaWdnZXIgZXZlbnQgd2l0aCBzdWNjZXNzIGZhbHNlLlxuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIkZhaWxlZCB0byBwYXJzZSBWVFQgY3VlOiBcIiArIGUpO1xuICAgICAgICAgICAgaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwgeyBzdWNjZXNzOiBmYWxzZSwgZnJhZzogZnJhZyB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUaW1lbGluZUNvbnRyb2xsZXIucHJvdG90eXBlLm9uRnJhZ0RlY3J5cHRlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBkZWNyeXB0ZWREYXRhID0gZGF0YS5wYXlsb2FkLCBmcmFnID0gZGF0YS5mcmFnO1xuICAgICAgICBpZiAoZnJhZy50eXBlID09PSAnc3VidGl0bGUnKSB7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh0aGlzLmluaXRQVFNbZnJhZy5jY10pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzLnB1c2goZGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGFyc2VWVFRzKGZyYWcsIGRlY3J5cHRlZERhdGEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUaW1lbGluZUNvbnRyb2xsZXIucHJvdG90eXBlLm9uRnJhZ1BhcnNpbmdVc2VyZGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIHB1c2ggYWxsIG9mIHRoZSBDRUEtNzA4IG1lc3NhZ2VzIGludG8gdGhlIGludGVycHJldGVyXG4gICAgICAgIC8vIGltbWVkaWF0ZWx5LiBJdCB3aWxsIGNyZWF0ZSB0aGUgcHJvcGVyIHRpbWVzdGFtcHMgYmFzZWQgb24gb3VyIFBUUyB2YWx1ZVxuICAgICAgICBpZiAodGhpcy5lbmFibGVkICYmIHRoaXMuY29uZmlnLmVuYWJsZUNFQTcwOENhcHRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjY2RhdGFzID0gdGhpcy5leHRyYWN0Q2VhNjA4RGF0YShkYXRhLnNhbXBsZXNbaV0uYnl0ZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2VhNjA4UGFyc2VyLmFkZERhdGEoZGF0YS5zYW1wbGVzW2ldLnB0cywgY2NkYXRhcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRpbWVsaW5lQ29udHJvbGxlci5wcm90b3R5cGUuZXh0cmFjdENlYTYwOERhdGEgPSBmdW5jdGlvbiAoYnl0ZUFycmF5KSB7XG4gICAgICAgIHZhciBjb3VudCA9IGJ5dGVBcnJheVswXSAmIDMxO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSAyO1xuICAgICAgICB2YXIgdG1wQnl0ZSwgY2NieXRlMSwgY2NieXRlMiwgY2NWYWxpZCwgY2NUeXBlO1xuICAgICAgICB2YXIgYWN0dWFsQ0NCeXRlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgICAgICAgIHRtcEJ5dGUgPSBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICAgICAgICBjY2J5dGUxID0gMHg3RiAmIGJ5dGVBcnJheVtwb3NpdGlvbisrXTtcbiAgICAgICAgICAgIGNjYnl0ZTIgPSAweDdGICYgYnl0ZUFycmF5W3Bvc2l0aW9uKytdO1xuICAgICAgICAgICAgY2NWYWxpZCA9ICg0ICYgdG1wQnl0ZSkgIT09IDA7XG4gICAgICAgICAgICBjY1R5cGUgPSAzICYgdG1wQnl0ZTtcbiAgICAgICAgICAgIGlmIChjY2J5dGUxID09PSAwICYmIGNjYnl0ZTIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjY1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNjVHlwZSA9PT0gMCkgeyAvLyB8fCBjY1R5cGUgPT09IDFcbiAgICAgICAgICAgICAgICAgICAgYWN0dWFsQ0NCeXRlcy5wdXNoKGNjYnl0ZTEpO1xuICAgICAgICAgICAgICAgICAgICBhY3R1YWxDQ0J5dGVzLnB1c2goY2NieXRlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3R1YWxDQ0J5dGVzO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVsaW5lQ29udHJvbGxlcjtcbn0oZXZlbnRfaGFuZGxlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFRpbWVsaW5lQ29udHJvbGxlcjtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLmpzXCIpW1wiTnVtYmVyXCJdKSlcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY3J5cHQvYWVzLWNyeXB0by5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NyeXB0L2Flcy1jcnlwdG8uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEFFU0NyeXB0byA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBRVNDcnlwdG8oc3VidGxlLCBpdikge1xuICAgICAgICB0aGlzLnN1YnRsZSA9IHN1YnRsZTtcbiAgICAgICAgdGhpcy5hZXNJViA9IGl2O1xuICAgIH1cbiAgICBBRVNDcnlwdG8ucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbiAoZGF0YSwga2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnRsZS5kZWNyeXB0KHsgbmFtZTogJ0FFUy1DQkMnLCBpdjogdGhpcy5hZXNJViB9LCBrZXksIGRhdGEpO1xuICAgIH07XG4gICAgcmV0dXJuIEFFU0NyeXB0bztcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBBRVNDcnlwdG87XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY3J5cHQvYWVzLWRlY3J5cHRvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NyeXB0L2Flcy1kZWNyeXB0b3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gUEtDUzdcbmZ1bmN0aW9uIHJlbW92ZVBhZGRpbmcoYnVmZmVyKSB7XG4gICAgdmFyIG91dHB1dEJ5dGVzID0gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgdmFyIHBhZGRpbmdCeXRlcyA9IG91dHB1dEJ5dGVzICYmIChuZXcgRGF0YVZpZXcoYnVmZmVyKSkuZ2V0VWludDgob3V0cHV0Qnl0ZXMgLSAxKTtcbiAgICBpZiAocGFkZGluZ0J5dGVzKSB7XG4gICAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoMCwgb3V0cHV0Qnl0ZXMgLSBwYWRkaW5nQnl0ZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG59XG5leHBvcnRzLnJlbW92ZVBhZGRpbmcgPSByZW1vdmVQYWRkaW5nO1xudmFyIEFFU0RlY3J5cHRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBRVNEZWNyeXB0b3IoKSB7XG4gICAgICAgIC8vIFN0YXRpYyBhZnRlciBydW5uaW5nIGluaXRUYWJsZVxuICAgICAgICB0aGlzLnJjb24gPSBbMHgwLCAweDEsIDB4MiwgMHg0LCAweDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzZdO1xuICAgICAgICB0aGlzLnN1Yk1peCA9IFtuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KV07XG4gICAgICAgIHRoaXMuaW52U3ViTWl4ID0gW25ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpXTtcbiAgICAgICAgdGhpcy5zQm94ID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgICAgIHRoaXMuaW52U0JveCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgICAgICAvLyBDaGFuZ2VzIGR1cmluZyBydW50aW1lXG4gICAgICAgIHRoaXMua2V5ID0gbmV3IFVpbnQzMkFycmF5KDApO1xuICAgICAgICB0aGlzLmluaXRUYWJsZSgpO1xuICAgIH1cbiAgICAvLyBVc2luZyB2aWV3LmdldFVpbnQzMigpIGFsc28gc3dhcHMgdGhlIGJ5dGUgb3JkZXIuXG4gICAgQUVTRGVjcnlwdG9yLnByb3RvdHlwZS51aW50OEFycmF5VG9VaW50MzJBcnJheV8gPSBmdW5jdGlvbiAoYXJyYXlCdWZmZXIpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpO1xuICAgICAgICB2YXIgbmV3QXJyYXkgPSBuZXcgVWludDMyQXJyYXkoNCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICBuZXdBcnJheVtpXSA9IHZpZXcuZ2V0VWludDMyKGkgKiA0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3QXJyYXk7XG4gICAgfTtcbiAgICBBRVNEZWNyeXB0b3IucHJvdG90eXBlLmluaXRUYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNCb3ggPSB0aGlzLnNCb3g7XG4gICAgICAgIHZhciBpbnZTQm94ID0gdGhpcy5pbnZTQm94O1xuICAgICAgICB2YXIgc3ViTWl4ID0gdGhpcy5zdWJNaXg7XG4gICAgICAgIHZhciBzdWJNaXgwID0gc3ViTWl4WzBdO1xuICAgICAgICB2YXIgc3ViTWl4MSA9IHN1Yk1peFsxXTtcbiAgICAgICAgdmFyIHN1Yk1peDIgPSBzdWJNaXhbMl07XG4gICAgICAgIHZhciBzdWJNaXgzID0gc3ViTWl4WzNdO1xuICAgICAgICB2YXIgaW52U3ViTWl4ID0gdGhpcy5pbnZTdWJNaXg7XG4gICAgICAgIHZhciBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xuICAgICAgICB2YXIgaW52U3ViTWl4MSA9IGludlN1Yk1peFsxXTtcbiAgICAgICAgdmFyIGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XG4gICAgICAgIHZhciBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xuICAgICAgICB2YXIgZCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgIHZhciB4aSA9IDA7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA8IDEyOCkge1xuICAgICAgICAgICAgICAgIGRbaV0gPSBpIDw8IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkW2ldID0gKGkgPDwgMSkgXiAweDExYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzeCA9IHhpIF4gKHhpIDw8IDEpIF4gKHhpIDw8IDIpIF4gKHhpIDw8IDMpIF4gKHhpIDw8IDQpO1xuICAgICAgICAgICAgc3ggPSAoc3ggPj4+IDgpIF4gKHN4ICYgMHhmZikgXiAweDYzO1xuICAgICAgICAgICAgc0JveFt4XSA9IHN4O1xuICAgICAgICAgICAgaW52U0JveFtzeF0gPSB4O1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSBtdWx0aXBsaWNhdGlvblxuICAgICAgICAgICAgdmFyIHgyID0gZFt4XTtcbiAgICAgICAgICAgIHZhciB4NCA9IGRbeDJdO1xuICAgICAgICAgICAgdmFyIHg4ID0gZFt4NF07XG4gICAgICAgICAgICAvLyBDb21wdXRlIHN1Yi9pbnZTdWIgYnl0ZXMsIG1peCBjb2x1bW5zIHRhYmxlc1xuICAgICAgICAgICAgdmFyIHQgPSAoZFtzeF0gKiAweDEwMSkgXiAoc3ggKiAweDEwMTAxMDApO1xuICAgICAgICAgICAgc3ViTWl4MFt4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KTtcbiAgICAgICAgICAgIHN1Yk1peDFbeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xuICAgICAgICAgICAgc3ViTWl4Mlt4XSA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KTtcbiAgICAgICAgICAgIHN1Yk1peDNbeF0gPSB0O1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSBpbnYgc3ViIGJ5dGVzLCBpbnYgbWl4IGNvbHVtbnMgdGFibGVzXG4gICAgICAgICAgICB0ID0gKHg4ICogMHgxMDEwMTAxKSBeICh4NCAqIDB4MTAwMDEpIF4gKHgyICogMHgxMDEpIF4gKHggKiAweDEwMTAxMDApO1xuICAgICAgICAgICAgaW52U3ViTWl4MFtzeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XG4gICAgICAgICAgICBpbnZTdWJNaXgxW3N4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XG4gICAgICAgICAgICBpbnZTdWJNaXgyW3N4XSA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KTtcbiAgICAgICAgICAgIGludlN1Yk1peDNbc3hdID0gdDtcbiAgICAgICAgICAgIC8vIENvbXB1dGUgbmV4dCBjb3VudGVyXG4gICAgICAgICAgICBpZiAoIXgpIHtcbiAgICAgICAgICAgICAgICB4ID0geGkgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeCA9IHgyIF4gZFtkW2RbeDggXiB4Ml1dXTtcbiAgICAgICAgICAgICAgICB4aSBePSBkW2RbeGldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQUVTRGVjcnlwdG9yLnByb3RvdHlwZS5leHBhbmRLZXkgPSBmdW5jdGlvbiAoa2V5QnVmZmVyKSB7XG4gICAgICAgIC8vIGNvbnZlcnQga2V5QnVmZmVyIHRvIFVpbnQzMkFycmF5XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLnVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhrZXlCdWZmZXIpO1xuICAgICAgICB2YXIgc2FtZUtleSA9IHRydWU7XG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICB3aGlsZSAob2Zmc2V0IDwga2V5Lmxlbmd0aCAmJiBzYW1lS2V5KSB7XG4gICAgICAgICAgICBzYW1lS2V5ID0gKGtleVtvZmZzZXRdID09PSB0aGlzLmtleVtvZmZzZXRdKTtcbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzYW1lS2V5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHZhciBrZXlTaXplID0gdGhpcy5rZXlTaXplID0ga2V5Lmxlbmd0aDtcbiAgICAgICAgaWYgKGtleVNpemUgIT09IDQgJiYga2V5U2l6ZSAhPT0gNiAmJiBrZXlTaXplICE9PSA4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWVzIGtleSBzaXplPScgKyBrZXlTaXplKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga3NSb3dzID0gdGhpcy5rc1Jvd3MgPSAoa2V5U2l6ZSArIDYgKyAxKSAqIDQ7XG4gICAgICAgIHZhciBrc1JvdztcbiAgICAgICAgdmFyIGludktzUm93O1xuICAgICAgICB2YXIga2V5U2NoZWR1bGUgPSB0aGlzLmtleVNjaGVkdWxlID0gbmV3IFVpbnQzMkFycmF5KGtzUm93cyk7XG4gICAgICAgIHZhciBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuaW52S2V5U2NoZWR1bGUgPSBuZXcgVWludDMyQXJyYXkoa3NSb3dzKTtcbiAgICAgICAgdmFyIHNib3ggPSB0aGlzLnNCb3g7XG4gICAgICAgIHZhciByY29uID0gdGhpcy5yY29uO1xuICAgICAgICB2YXIgaW52U3ViTWl4ID0gdGhpcy5pbnZTdWJNaXg7XG4gICAgICAgIHZhciBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xuICAgICAgICB2YXIgaW52U3ViTWl4MSA9IGludlN1Yk1peFsxXTtcbiAgICAgICAgdmFyIGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XG4gICAgICAgIHZhciBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xuICAgICAgICB2YXIgcHJldjtcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIGZvciAoa3NSb3cgPSAwOyBrc1JvdyA8IGtzUm93czsga3NSb3crKykge1xuICAgICAgICAgICAgaWYgKGtzUm93IDwga2V5U2l6ZSkge1xuICAgICAgICAgICAgICAgIHByZXYgPSBrZXlTY2hlZHVsZVtrc1Jvd10gPSBrZXlba3NSb3ddO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdCA9IHByZXY7XG4gICAgICAgICAgICBpZiAoa3NSb3cgJSBrZXlTaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gUm90IHdvcmRcbiAgICAgICAgICAgICAgICB0ID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xuICAgICAgICAgICAgICAgIC8vIFN1YiB3b3JkXG4gICAgICAgICAgICAgICAgdCA9IChzYm94W3QgPj4+IDI0XSA8PCAyNCkgfCAoc2JveFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKHNib3hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBzYm94W3QgJiAweGZmXTtcbiAgICAgICAgICAgICAgICAvLyBNaXggUmNvblxuICAgICAgICAgICAgICAgIHQgXj0gcmNvblsoa3NSb3cgLyBrZXlTaXplKSB8IDBdIDw8IDI0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09PSA0KSB7XG4gICAgICAgICAgICAgICAgLy8gU3ViIHdvcmRcbiAgICAgICAgICAgICAgICB0ID0gKHNib3hbdCA+Pj4gMjRdIDw8IDI0KSB8IChzYm94Wyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoc2JveFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IHNib3hbdCAmIDB4ZmZdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0gcHJldiA9IChrZXlTY2hlZHVsZVtrc1JvdyAtIGtleVNpemVdIF4gdCkgPj4+IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpbnZLc1JvdyA9IDA7IGludktzUm93IDwga3NSb3dzOyBpbnZLc1JvdysrKSB7XG4gICAgICAgICAgICBrc1JvdyA9IGtzUm93cyAtIGludktzUm93O1xuICAgICAgICAgICAgaWYgKGludktzUm93ICYgMykge1xuICAgICAgICAgICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSA0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnZLc1JvdyA8IDQgfHwga3NSb3cgPD0gNCkge1xuICAgICAgICAgICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBpbnZTdWJNaXgwW3Nib3hbdCA+Pj4gMjRdXSBeIGludlN1Yk1peDFbc2JveFsodCA+Pj4gMTYpICYgMHhmZl1dIF4gaW52U3ViTWl4MltzYm94Wyh0ID4+PiA4KSAmIDB4ZmZdXSBeIGludlN1Yk1peDNbc2JveFt0ICYgMHhmZl1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID4+PiAwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBBZGRpbmcgdGhpcyBhcyBhIG1ldGhvZCBncmVhdGx5IGltcHJvdmVzIHBlcmZvcm1hbmNlLlxuICAgIEFFU0RlY3J5cHRvci5wcm90b3R5cGUubmV0d29ya1RvSG9zdE9yZGVyU3dhcCA9IGZ1bmN0aW9uICh3b3JkKSB7XG4gICAgICAgIHJldHVybiAod29yZCA8PCAyNCkgfCAoKHdvcmQgJiAweGZmMDApIDw8IDgpIHwgKCh3b3JkICYgMHhmZjAwMDApID4+IDgpIHwgKHdvcmQgPj4+IDI0KTtcbiAgICB9O1xuICAgIEFFU0RlY3J5cHRvci5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uIChpbnB1dEFycmF5QnVmZmVyLCBvZmZzZXQsIGFlc0lWLCByZW1vdmVQS0NTN1BhZGRpbmcpIHtcbiAgICAgICAgdmFyIG5Sb3VuZHMgPSB0aGlzLmtleVNpemUgKyA2O1xuICAgICAgICB2YXIgaW52S2V5U2NoZWR1bGUgPSB0aGlzLmludktleVNjaGVkdWxlO1xuICAgICAgICB2YXIgaW52U0JPWCA9IHRoaXMuaW52U0JveDtcbiAgICAgICAgdmFyIGludlN1Yk1peCA9IHRoaXMuaW52U3ViTWl4O1xuICAgICAgICB2YXIgaW52U3ViTWl4MCA9IGludlN1Yk1peFswXTtcbiAgICAgICAgdmFyIGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgICAgIHZhciBpbnZTdWJNaXgyID0gaW52U3ViTWl4WzJdO1xuICAgICAgICB2YXIgaW52U3ViTWl4MyA9IGludlN1Yk1peFszXTtcbiAgICAgICAgdmFyIGluaXRWZWN0b3IgPSB0aGlzLnVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhhZXNJVik7XG4gICAgICAgIHZhciBpbml0VmVjdG9yMCA9IGluaXRWZWN0b3JbMF07XG4gICAgICAgIHZhciBpbml0VmVjdG9yMSA9IGluaXRWZWN0b3JbMV07XG4gICAgICAgIHZhciBpbml0VmVjdG9yMiA9IGluaXRWZWN0b3JbMl07XG4gICAgICAgIHZhciBpbml0VmVjdG9yMyA9IGluaXRWZWN0b3JbM107XG4gICAgICAgIHZhciBpbnB1dEludDMyID0gbmV3IEludDMyQXJyYXkoaW5wdXRBcnJheUJ1ZmZlcik7XG4gICAgICAgIHZhciBvdXRwdXRJbnQzMiA9IG5ldyBJbnQzMkFycmF5KGlucHV0SW50MzIubGVuZ3RoKTtcbiAgICAgICAgdmFyIHQwLCB0MSwgdDIsIHQzO1xuICAgICAgICB2YXIgczAsIHMxLCBzMiwgczM7XG4gICAgICAgIHZhciBpbnB1dFdvcmRzMCwgaW5wdXRXb3JkczEsIGlucHV0V29yZHMyLCBpbnB1dFdvcmRzMztcbiAgICAgICAgdmFyIGtzUm93LCBpO1xuICAgICAgICB2YXIgc3dhcFdvcmQgPSB0aGlzLm5ldHdvcmtUb0hvc3RPcmRlclN3YXA7XG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBpbnB1dEludDMyLmxlbmd0aCkge1xuICAgICAgICAgICAgaW5wdXRXb3JkczAgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldF0pO1xuICAgICAgICAgICAgaW5wdXRXb3JkczEgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldCArIDFdKTtcbiAgICAgICAgICAgIGlucHV0V29yZHMyID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAyXSk7XG4gICAgICAgICAgICBpbnB1dFdvcmRzMyA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0ICsgM10pO1xuICAgICAgICAgICAgczAgPSBpbnB1dFdvcmRzMCBeIGludktleVNjaGVkdWxlWzBdO1xuICAgICAgICAgICAgczEgPSBpbnB1dFdvcmRzMyBeIGludktleVNjaGVkdWxlWzFdO1xuICAgICAgICAgICAgczIgPSBpbnB1dFdvcmRzMiBeIGludktleVNjaGVkdWxlWzJdO1xuICAgICAgICAgICAgczMgPSBpbnB1dFdvcmRzMSBeIGludktleVNjaGVkdWxlWzNdO1xuICAgICAgICAgICAga3NSb3cgPSA0O1xuICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSByb3VuZHMgb2YgZGVjcnlwdGlvblxuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IG5Sb3VuZHM7IGkrKykge1xuICAgICAgICAgICAgICAgIHQwID0gaW52U3ViTWl4MFtzMCA+Pj4gMjRdIF4gaW52U3ViTWl4MVsoczEgPj4gMTYpICYgMHhmZl0gXiBpbnZTdWJNaXgyWyhzMiA+PiA4KSAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMyAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAgICAgICAgICAgIHQxID0gaW52U3ViTWl4MFtzMSA+Pj4gMjRdIF4gaW52U3ViTWl4MVsoczIgPj4gMTYpICYgMHhmZl0gXiBpbnZTdWJNaXgyWyhzMyA+PiA4KSAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMCAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAxXTtcbiAgICAgICAgICAgICAgICB0MiA9IGludlN1Yk1peDBbczIgPj4+IDI0XSBeIGludlN1Yk1peDFbKHMzID4+IDE2KSAmIDB4ZmZdIF4gaW52U3ViTWl4MlsoczAgPj4gOCkgJiAweGZmXSBeIGludlN1Yk1peDNbczEgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMl07XG4gICAgICAgICAgICAgICAgdDMgPSBpbnZTdWJNaXgwW3MzID4+PiAyNF0gXiBpbnZTdWJNaXgxWyhzMCA+PiAxNikgJiAweGZmXSBeIGludlN1Yk1peDJbKHMxID4+IDgpICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MyICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDNdO1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzdGF0ZVxuICAgICAgICAgICAgICAgIHMwID0gdDA7XG4gICAgICAgICAgICAgICAgczEgPSB0MTtcbiAgICAgICAgICAgICAgICBzMiA9IHQyO1xuICAgICAgICAgICAgICAgIHMzID0gdDM7XG4gICAgICAgICAgICAgICAga3NSb3cgPSBrc1JvdyArIDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIGFkZCByb3VuZCBrZXlcbiAgICAgICAgICAgIHQwID0gKChpbnZTQk9YW3MwID4+PiAyNF0gPDwgMjQpIF4gKGludlNCT1hbKHMxID4+IDE2KSAmIDB4ZmZdIDw8IDE2KSBeIChpbnZTQk9YWyhzMiA+PiA4KSAmIDB4ZmZdIDw8IDgpIF4gaW52U0JPWFtzMyAmIDB4ZmZdKSBeIGludktleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgICAgICAgIHQxID0gKChpbnZTQk9YW3MxID4+PiAyNF0gPDwgMjQpIF4gKGludlNCT1hbKHMyID4+IDE2KSAmIDB4ZmZdIDw8IDE2KSBeIChpbnZTQk9YWyhzMyA+PiA4KSAmIDB4ZmZdIDw8IDgpIF4gaW52U0JPWFtzMCAmIDB4ZmZdKSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMV07XG4gICAgICAgICAgICB0MiA9ICgoaW52U0JPWFtzMiA+Pj4gMjRdIDw8IDI0KSBeIChpbnZTQk9YWyhzMyA+PiAxNikgJiAweGZmXSA8PCAxNikgXiAoaW52U0JPWFsoczAgPj4gOCkgJiAweGZmXSA8PCA4KSBeIGludlNCT1hbczEgJiAweGZmXSkgXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDJdO1xuICAgICAgICAgICAgdDMgPSAoKGludlNCT1hbczMgPj4+IDI0XSA8PCAyNCkgXiAoaW52U0JPWFsoczAgPj4gMTYpICYgMHhmZl0gPDwgMTYpIF4gKGludlNCT1hbKHMxID4+IDgpICYgMHhmZl0gPDwgOCkgXiBpbnZTQk9YW3MyICYgMHhmZl0pIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAzXTtcbiAgICAgICAgICAgIGtzUm93ID0ga3NSb3cgKyAzO1xuICAgICAgICAgICAgLy8gV3JpdGVcbiAgICAgICAgICAgIG91dHB1dEludDMyW29mZnNldF0gPSBzd2FwV29yZCh0MCBeIGluaXRWZWN0b3IwKTtcbiAgICAgICAgICAgIG91dHB1dEludDMyW29mZnNldCArIDFdID0gc3dhcFdvcmQodDMgXiBpbml0VmVjdG9yMSk7XG4gICAgICAgICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAyXSA9IHN3YXBXb3JkKHQyIF4gaW5pdFZlY3RvcjIpO1xuICAgICAgICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0ICsgM10gPSBzd2FwV29yZCh0MSBeIGluaXRWZWN0b3IzKTtcbiAgICAgICAgICAgIC8vIHJlc2V0IGluaXRWZWN0b3IgdG8gbGFzdCA0IHVuc2lnbmVkIGludFxuICAgICAgICAgICAgaW5pdFZlY3RvcjAgPSBpbnB1dFdvcmRzMDtcbiAgICAgICAgICAgIGluaXRWZWN0b3IxID0gaW5wdXRXb3JkczE7XG4gICAgICAgICAgICBpbml0VmVjdG9yMiA9IGlucHV0V29yZHMyO1xuICAgICAgICAgICAgaW5pdFZlY3RvcjMgPSBpbnB1dFdvcmRzMztcbiAgICAgICAgICAgIG9mZnNldCA9IG9mZnNldCArIDQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbW92ZVBLQ1M3UGFkZGluZyA/IHJlbW92ZVBhZGRpbmcob3V0cHV0SW50MzIuYnVmZmVyKSA6IG91dHB1dEludDMyLmJ1ZmZlcjtcbiAgICB9O1xuICAgIEFFU0RlY3J5cHRvci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5rZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMua2V5U2l6ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5rc1Jvd3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc0JveCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5pbnZTQm94ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnN1Yk1peCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5pbnZTdWJNaXggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMua2V5U2NoZWR1bGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaW52S2V5U2NoZWR1bGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmNvbiA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHJldHVybiBBRVNEZWNyeXB0b3I7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQUVTRGVjcnlwdG9yO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NyeXB0L2RlY3J5cHRlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY3J5cHQvZGVjcnlwdGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGFlc19jcnlwdG9fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYWVzLWNyeXB0byAqLyBcIi4vc3JjL2NyeXB0L2Flcy1jcnlwdG8uanNcIik7XG52YXIgZmFzdF9hZXNfa2V5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Zhc3QtYWVzLWtleSAqLyBcIi4vc3JjL2NyeXB0L2Zhc3QtYWVzLWtleS5qc1wiKTtcbnZhciBhZXNfZGVjcnlwdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Flcy1kZWNyeXB0b3IgKi8gXCIuL3NyYy9jcnlwdC9hZXMtZGVjcnlwdG9yLmpzXCIpO1xudmFyIGVycm9yc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLmpzXCIpO1xudmFyIGxvZ2dlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLmpzXCIpO1xudmFyIGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLmpzXCIpO1xudmFyIGdldF9zZWxmX3Njb3BlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9nZXQtc2VsZi1zY29wZSAqLyBcIi4vc3JjL3V0aWxzL2dldC1zZWxmLXNjb3BlLmpzXCIpO1xuLy8gc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMTIzNzI1OS81ODk0OTNcbnZhciBnbG9iYWwgPSBnZXRfc2VsZl9zY29wZV8xLmdldFNlbGZTY29wZSgpOyAvLyBzYWZlZ3VhcmQgZm9yIGNvZGUgdGhhdCBtaWdodCBydW4gYm90aCBvbiB3b3JrZXIgYW5kIG1haW4gdGhyZWFkXG52YXIgRGVjcnlwdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlY3J5cHRlcihvYnNlcnZlciwgY29uZmlnLCBfYSkge1xuICAgICAgICB2YXIgX2IgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLnJlbW92ZVBLQ1M3UGFkZGluZywgcmVtb3ZlUEtDUzdQYWRkaW5nID0gX2IgPT09IHZvaWQgMCA/IHRydWUgOiBfYjtcbiAgICAgICAgdGhpcy5sb2dFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5yZW1vdmVQS0NTN1BhZGRpbmcgPSByZW1vdmVQS0NTN1BhZGRpbmc7XG4gICAgICAgIC8vIGJ1aWx0IGluIGRlY3J5cHRvciBleHBlY3RzIFBLQ1M3IHBhZGRpbmdcbiAgICAgICAgaWYgKHJlbW92ZVBLQ1M3UGFkZGluZykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgYnJvd3NlckNyeXB0byA9IGdsb2JhbC5jcnlwdG87XG4gICAgICAgICAgICAgICAgaWYgKGJyb3dzZXJDcnlwdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJ0bGUgPSBicm93c2VyQ3J5cHRvLnN1YnRsZSB8fCBicm93c2VyQ3J5cHRvLndlYmtpdFN1YnRsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNhYmxlV2ViQ3J5cHRvID0gIXRoaXMuc3VidGxlO1xuICAgIH1cbiAgICBEZWNyeXB0ZXIucHJvdG90eXBlLmlzU3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmRpc2FibGVXZWJDcnlwdG8gJiYgdGhpcy5jb25maWcuZW5hYmxlU29mdHdhcmVBRVMpO1xuICAgIH07XG4gICAgRGVjcnlwdGVyLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24gKGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVXZWJDcnlwdG8gJiYgdGhpcy5jb25maWcuZW5hYmxlU29mdHdhcmVBRVMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdKUyBBRVMgZGVjcnlwdCcpO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRlY3J5cHRvciA9IHRoaXMuZGVjcnlwdG9yO1xuICAgICAgICAgICAgaWYgKCFkZWNyeXB0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY3J5cHRvciA9IGRlY3J5cHRvciA9IG5ldyBhZXNfZGVjcnlwdG9yXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjcnlwdG9yLmV4cGFuZEtleShrZXkpO1xuICAgICAgICAgICAgY2FsbGJhY2soZGVjcnlwdG9yLmRlY3J5cHQoZGF0YSwgMCwgaXYsIHRoaXMucmVtb3ZlUEtDUzdQYWRkaW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sb2dFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnV2ViQ3J5cHRvIEFFUyBkZWNyeXB0Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3VidGxlXzEgPSB0aGlzLnN1YnRsZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmtleSAhPT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgdGhpcy5mYXN0QWVzS2V5ID0gbmV3IGZhc3RfYWVzX2tleV8xLmRlZmF1bHQoc3VidGxlXzEsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZhc3RBZXNLZXkuZXhwYW5kS2V5KClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYWVzS2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gZGVjcnlwdCB1c2luZyB3ZWIgY3J5cHRvXG4gICAgICAgICAgICAgICAgdmFyIGNyeXB0byA9IG5ldyBhZXNfY3J5cHRvXzEuZGVmYXVsdChzdWJ0bGVfMSwgaXYpO1xuICAgICAgICAgICAgICAgIGNyeXB0by5kZWNyeXB0KGRhdGEsIGFlc0tleSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25XZWJDcnlwdG9FcnJvcihlcnIsIGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25XZWJDcnlwdG9FcnJvcihlcnIsIGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWNyeXB0ZXIucHJvdG90eXBlLm9uV2ViQ3J5cHRvRXJyb3IgPSBmdW5jdGlvbiAoZXJyLCBkYXRhLCBrZXksIGl2LCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlU29mdHdhcmVBRVMpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ1dlYkNyeXB0byBFcnJvciwgZGlzYWJsZSBXZWJDcnlwdG8gQVBJJyk7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVXZWJDcnlwdG8gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5sb2dFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZGVjcnlwdChkYXRhLCBrZXksIGl2LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIuZXJyb3IoXCJkZWNyeXB0aW5nIGVycm9yIDogXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBlcnJvcnNfMS5FcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBlcnJvcnNfMS5FcnJvckRldGFpbHMuRlJBR19ERUNSWVBUX0VSUk9SLCBmYXRhbDogdHJ1ZSwgcmVhc29uOiBlcnIubWVzc2FnZSB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVjcnlwdGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVjcnlwdG9yID0gdGhpcy5kZWNyeXB0b3I7XG4gICAgICAgIGlmIChkZWNyeXB0b3IpIHtcbiAgICAgICAgICAgIGRlY3J5cHRvci5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmRlY3J5cHRvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERlY3J5cHRlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBEZWNyeXB0ZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY3J5cHQvZmFzdC1hZXMta2V5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jcnlwdC9mYXN0LWFlcy1rZXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRmFzdEFFU0tleSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGYXN0QUVTS2V5KHN1YnRsZSwga2V5KSB7XG4gICAgICAgIHRoaXMuc3VidGxlID0gc3VidGxlO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICB9XG4gICAgRmFzdEFFU0tleS5wcm90b3R5cGUuZXhwYW5kS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCB0aGlzLmtleSwgeyBuYW1lOiAnQUVTLUNCQycgfSwgZmFsc2UsIFsnZW5jcnlwdCcsICdkZWNyeXB0J10pO1xuICAgIH07XG4gICAgcmV0dXJuIEZhc3RBRVNLZXk7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRmFzdEFFU0tleTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC9hYWNkZW11eGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvYWFjZGVtdXhlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKE51bWJlcikge1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBBQUMgZGVtdXhlclxuICovXG52YXIgQURUUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYWR0cyAqLyBcIi4vc3JjL2RlbXV4L2FkdHMuanNcIik7XG52YXIgbG9nZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIuanNcIik7XG52YXIgaWQzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9pZDMgKi8gXCIuL3NyYy9kZW11eC9pZDMuanNcIik7XG52YXIgQUFDRGVtdXhlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBQUNEZW11eGVyKG9ic2VydmVyLCByZW11eGVyLCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5yZW11eGVyID0gcmVtdXhlcjtcbiAgICB9XG4gICAgQUFDRGVtdXhlci5wcm90b3R5cGUucmVzZXRJbml0U2VnbWVudCA9IGZ1bmN0aW9uIChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZHVyYXRpb24pIHtcbiAgICAgICAgdGhpcy5fYXVkaW9UcmFjayA9IHsgY29udGFpbmVyOiAnYXVkaW8vYWR0cycsIHR5cGU6ICdhdWRpbycsIGlkOiAwLCBzZXF1ZW5jZU51bWJlcjogMCwgaXNBQUM6IHRydWUsIHNhbXBsZXM6IFtdLCBsZW46IDAsIG1hbmlmZXN0Q29kZWM6IGF1ZGlvQ29kZWMsIGR1cmF0aW9uOiBkdXJhdGlvbiwgaW5wdXRUaW1lU2NhbGU6IDkwMDAwIH07XG4gICAgfTtcbiAgICBBQUNEZW11eGVyLnByb3RvdHlwZS5yZXNldFRpbWVTdGFtcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB9O1xuICAgIEFBQ0RlbXV4ZXIucHJvYmUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBmb3IgdGhlIEFEVFMgc3luYyB3b3JkXG4gICAgICAgIC8vIExvb2sgZm9yIEFEVFMgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExMSBYMDBYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMVxuICAgICAgICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIDAgZm9yIEFEVFNcbiAgICAgICAgLy8gTW9yZSBpbmZvIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXG4gICAgICAgIHZhciBpZDNEYXRhID0gaWQzXzEuZGVmYXVsdC5nZXRJRDNEYXRhKGRhdGEsIDApIHx8IFtdO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gaWQzRGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGxlbmd0aF8xID0gZGF0YS5sZW5ndGg7IG9mZnNldCA8IGxlbmd0aF8xOyBvZmZzZXQrKykge1xuICAgICAgICAgICAgaWYgKEFEVFMucHJvYmUoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ0FEVFMgc3luYyB3b3JkIGZvdW5kICEnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvLyBmZWVkIGluY29taW5nIGRhdGEgdG8gdGhlIGZyb250IG9mIHRoZSBwYXJzaW5nIHBpcGVsaW5lXG4gICAgQUFDRGVtdXhlci5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKGRhdGEsIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgICAgICB2YXIgdHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrO1xuICAgICAgICB2YXIgaWQzRGF0YSA9IGlkM18xLmRlZmF1bHQuZ2V0SUQzRGF0YShkYXRhLCAwKSB8fCBbXTtcbiAgICAgICAgdmFyIHRpbWVzdGFtcCA9IGlkM18xLmRlZmF1bHQuZ2V0VGltZVN0YW1wKGlkM0RhdGEpO1xuICAgICAgICB2YXIgcHRzID0gTnVtYmVyLmlzRmluaXRlKHRpbWVzdGFtcCkgPyB0aW1lc3RhbXAgKiA5MCA6IHRpbWVPZmZzZXQgKiA5MDAwMDtcbiAgICAgICAgdmFyIGZyYW1lSW5kZXggPSAwO1xuICAgICAgICB2YXIgc3RhbXAgPSBwdHM7XG4gICAgICAgIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdmFyIG9mZnNldCA9IGlkM0RhdGEubGVuZ3RoO1xuICAgICAgICB2YXIgaWQzU2FtcGxlcyA9IFt7IHB0czogc3RhbXAsIGR0czogc3RhbXAsIGRhdGE6IGlkM0RhdGEgfV07XG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBpZiAoQURUUy5pc0hlYWRlcihkYXRhLCBvZmZzZXQpICYmIChvZmZzZXQgKyA1KSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIEFEVFMuaW5pdFRyYWNrQ29uZmlnKHRyYWNrLCB0aGlzLm9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIHRyYWNrLm1hbmlmZXN0Q29kZWMpO1xuICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IEFEVFMuYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGZyYW1lLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgc3RhbXAgPSBmcmFtZS5zYW1wbGUucHRzO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdVbmFibGUgdG8gcGFyc2UgQUFDIGZyYW1lJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlkM18xLmRlZmF1bHQuaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIGlkM0RhdGEgPSBpZDNfMS5kZWZhdWx0LmdldElEM0RhdGEoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZDNTYW1wbGVzLnB1c2goeyBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wLCBkYXRhOiBpZDNEYXRhIH0pO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBpZDNEYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcgZm91bmQsIGtlZXAgbG9va2luZ1xuICAgICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtdXhlci5yZW11eCh0cmFjaywgeyBzYW1wbGVzOiBbXSB9LCB7IHNhbXBsZXM6IGlkM1NhbXBsZXMsIGlucHV0VGltZVNjYWxlOiA5MDAwMCB9LCB7IHNhbXBsZXM6IFtdIH0sIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgfTtcbiAgICBBQUNEZW11eGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIH07XG4gICAgcmV0dXJuIEFBQ0RlbXV4ZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQUFDRGVtdXhlcjtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLmpzXCIpW1wiTnVtYmVyXCJdKSlcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGVtdXgvYWR0cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RlbXV4L2FkdHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiAgQURUUyBwYXJzZXIgaGVscGVyXG4gKi9cbnZhciBsb2dnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci5qc1wiKTtcbnZhciBlcnJvcnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy5qc1wiKTtcbnZhciBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy5qc1wiKTtcbmZ1bmN0aW9uIGdldEF1ZGlvQ29uZmlnKG9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpIHtcbiAgICB2YXIgYWR0c09iamVjdFR5cGUsIC8vIDppbnRcbiAgICBhZHRzU2FtcGxlaW5nSW5kZXgsIC8vIDppbnRcbiAgICBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXgsIC8vIDppbnRcbiAgICBhZHRzQ2hhbmVsQ29uZmlnLCAvLyA6aW50XG4gICAgY29uZmlnLCB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCksIG1hbmlmZXN0Q29kZWMgPSBhdWRpb0NvZGVjLCBhZHRzU2FtcGxlaW5nUmF0ZXMgPSBbXG4gICAgICAgIDk2MDAwLCA4ODIwMCxcbiAgICAgICAgNjQwMDAsIDQ4MDAwLFxuICAgICAgICA0NDEwMCwgMzIwMDAsXG4gICAgICAgIDI0MDAwLCAyMjA1MCxcbiAgICAgICAgMTYwMDAsIDEyMDAwLFxuICAgICAgICAxMTAyNSwgODAwMCxcbiAgICAgICAgNzM1MFxuICAgIF07XG4gICAgLy8gYnl0ZSAyXG4gICAgYWR0c09iamVjdFR5cGUgPSAoKGRhdGFbb2Zmc2V0ICsgMl0gJiAweEMwKSA+Pj4gNikgKyAxO1xuICAgIGFkdHNTYW1wbGVpbmdJbmRleCA9ICgoZGF0YVtvZmZzZXQgKyAyXSAmIDB4M0MpID4+PiAyKTtcbiAgICBpZiAoYWR0c1NhbXBsZWluZ0luZGV4ID4gYWR0c1NhbXBsZWluZ1JhdGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgb2JzZXJ2ZXIudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IGVycm9yc18xLkVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IGVycm9yc18xLkVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsIGZhdGFsOiB0cnVlLCByZWFzb246IFwiaW52YWxpZCBBRFRTIHNhbXBsaW5nIGluZGV4OlwiICsgYWR0c1NhbXBsZWluZ0luZGV4IH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGFkdHNDaGFuZWxDb25maWcgPSAoKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDAxKSA8PCAyKTtcbiAgICAvLyBieXRlIDNcbiAgICBhZHRzQ2hhbmVsQ29uZmlnIHw9ICgoZGF0YVtvZmZzZXQgKyAzXSAmIDB4QzApID4+PiA2KTtcbiAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwibWFuaWZlc3QgY29kZWM6XCIgKyBhdWRpb0NvZGVjICsgXCIsQURUUyBkYXRhOnR5cGU6XCIgKyBhZHRzT2JqZWN0VHlwZSArIFwiLHNhbXBsZWluZ0luZGV4OlwiICsgYWR0c1NhbXBsZWluZ0luZGV4ICsgXCJbXCIgKyBhZHRzU2FtcGxlaW5nUmF0ZXNbYWR0c1NhbXBsZWluZ0luZGV4XSArIFwiSHpdLGNoYW5uZWxDb25maWc6XCIgKyBhZHRzQ2hhbmVsQ29uZmlnKTtcbiAgICAvLyBmaXJlZm94OiBmcmVxIGxlc3MgdGhhbiAyNGtIeiA9IEFBQyBTQlIgKEhFLUFBQylcbiAgICBpZiAoL2ZpcmVmb3gvaS50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICAgICAgaWYgKGFkdHNTYW1wbGVpbmdJbmRleCA+PSA2KSB7XG4gICAgICAgICAgICBhZHRzT2JqZWN0VHlwZSA9IDU7XG4gICAgICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XG4gICAgICAgICAgICAvLyBIRS1BQUMgdXNlcyBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pICwgaGlnaCBmcmVxdWVuY2llcyBhcmUgY29uc3RydWN0ZWQgZnJvbSBsb3cgZnJlcXVlbmNpZXNcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGEgZmFjdG9yIDIgYmV0d2VlbiBmcmFtZSBzYW1wbGUgcmF0ZSBhbmQgb3V0cHV0IHNhbXBsZSByYXRlXG4gICAgICAgICAgICAvLyBtdWx0aXBseSBmcmVxdWVuY3kgYnkgMiAoc2VlIHRhYmxlIGJlbG93LCBlcXVpdmFsZW50IHRvIHN1YnN0cmFjdCAzKVxuICAgICAgICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4IC0gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICAgICAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICAgICAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbmRyb2lkIDogYWx3YXlzIHVzZSBBQUNcbiAgICB9XG4gICAgZWxzZSBpZiAodXNlckFnZW50LmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEpIHtcbiAgICAgICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8qICBmb3Igb3RoZXIgYnJvd3NlcnMgKENocm9tZS9WaXZhbGRpL09wZXJhIC4uLilcbiAgICAgICAgICAgIGFsd2F5cyBmb3JjZSBhdWRpbyB0eXBlIHRvIGJlIEhFLUFBQyBTQlIsIGFzIHNvbWUgYnJvd3NlcnMgZG8gbm90IHN1cHBvcnQgYXVkaW8gY29kZWMgc3dpdGNoIHByb3Blcmx5IChsaWtlIENocm9tZSAuLi4pXG4gICAgICAgICovXG4gICAgICAgIGFkdHNPYmplY3RUeXBlID0gNTtcbiAgICAgICAgY29uZmlnID0gbmV3IEFycmF5KDQpO1xuICAgICAgICAvLyBpZiAobWFuaWZlc3QgY29kZWMgaXMgSEUtQUFDIG9yIEhFLUFBQ3YyKSBPUiAobWFuaWZlc3QgY29kZWMgbm90IHNwZWNpZmllZCBBTkQgZnJlcXVlbmN5IGxlc3MgdGhhbiAyNGtIeilcbiAgICAgICAgaWYgKChhdWRpb0NvZGVjICYmICgoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjI5JykgIT09IC0xKSB8fFxuICAgICAgICAgICAgKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSkpIHx8XG4gICAgICAgICAgICAoIWF1ZGlvQ29kZWMgJiYgYWR0c1NhbXBsZWluZ0luZGV4ID49IDYpKSB7XG4gICAgICAgICAgICAvLyBIRS1BQUMgdXNlcyBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pICwgaGlnaCBmcmVxdWVuY2llcyBhcmUgY29uc3RydWN0ZWQgZnJvbSBsb3cgZnJlcXVlbmNpZXNcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGEgZmFjdG9yIDIgYmV0d2VlbiBmcmFtZSBzYW1wbGUgcmF0ZSBhbmQgb3V0cHV0IHNhbXBsZSByYXRlXG4gICAgICAgICAgICAvLyBtdWx0aXBseSBmcmVxdWVuY3kgYnkgMiAoc2VlIHRhYmxlIGJlbG93LCBlcXVpdmFsZW50IHRvIHN1YnN0cmFjdCAzKVxuICAgICAgICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4IC0gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIChtYW5pZmVzdCBjb2RlYyBpcyBBQUMpIEFORCAoZnJlcXVlbmN5IGxlc3MgdGhhbiAyNGtIeiBBTkQgbmIgY2hhbm5lbCBpcyAxKSBPUiAobWFuaWZlc3QgY29kZWMgbm90IHNwZWNpZmllZCBhbmQgbW9ubyBhdWRpbylcbiAgICAgICAgICAgIC8vIENocm9tZSBmYWlscyB0byBwbGF5IGJhY2sgd2l0aCBsb3cgZnJlcXVlbmN5IEFBQyBMQyBtb25vIHdoZW4gaW5pdGlhbGl6ZWQgd2l0aCBIRS1BQUMuICBUaGlzIGlzIG5vdCBhIHByb2JsZW0gd2l0aCBzdGVyZW8uXG4gICAgICAgICAgICBpZiAoYXVkaW9Db2RlYyAmJiBhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuMicpICE9PSAtMSAmJiAoKGFkdHNTYW1wbGVpbmdJbmRleCA+PSA2ICYmIGFkdHNDaGFuZWxDb25maWcgPT09IDEpIHx8XG4gICAgICAgICAgICAgICAgL3ZpdmFsZGkvaS50ZXN0KHVzZXJBZ2VudCkpIHx8XG4gICAgICAgICAgICAgICAgKCFhdWRpb0NvZGVjICYmIGFkdHNDaGFuZWxDb25maWcgPT09IDEpKSB7XG4gICAgICAgICAgICAgICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiByZWZlciB0byBodHRwOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1NUEVHLTRfQXVkaW8jQXVkaW9fU3BlY2lmaWNfQ29uZmlnXG4gICAgICAgIElTTyAxNDQ5Ni0zIChBQUMpLnBkZiAtIFRhYmxlIDEuMTMg4oCUIFN5bnRheCBvZiBBdWRpb1NwZWNpZmljQ29uZmlnKClcbiAgICAgIEF1ZGlvIFByb2ZpbGUgLyBBdWRpbyBPYmplY3QgVHlwZVxuICAgICAgMDogTnVsbFxuICAgICAgMTogQUFDIE1haW5cbiAgICAgIDI6IEFBQyBMQyAoTG93IENvbXBsZXhpdHkpXG4gICAgICAzOiBBQUMgU1NSIChTY2FsYWJsZSBTYW1wbGUgUmF0ZSlcbiAgICAgIDQ6IEFBQyBMVFAgKExvbmcgVGVybSBQcmVkaWN0aW9uKVxuICAgICAgNTogU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKVxuICAgICAgNjogQUFDIFNjYWxhYmxlXG4gICAgIHNhbXBsaW5nIGZyZXFcbiAgICAgIDA6IDk2MDAwIEh6XG4gICAgICAxOiA4ODIwMCBIelxuICAgICAgMjogNjQwMDAgSHpcbiAgICAgIDM6IDQ4MDAwIEh6XG4gICAgICA0OiA0NDEwMCBIelxuICAgICAgNTogMzIwMDAgSHpcbiAgICAgIDY6IDI0MDAwIEh6XG4gICAgICA3OiAyMjA1MCBIelxuICAgICAgODogMTYwMDAgSHpcbiAgICAgIDk6IDEyMDAwIEh6XG4gICAgICAxMDogMTEwMjUgSHpcbiAgICAgIDExOiA4MDAwIEh6XG4gICAgICAxMjogNzM1MCBIelxuICAgICAgMTM6IFJlc2VydmVkXG4gICAgICAxNDogUmVzZXJ2ZWRcbiAgICAgIDE1OiBmcmVxdWVuY3kgaXMgd3JpdHRlbiBleHBsaWN0bHlcbiAgICAgIENoYW5uZWwgQ29uZmlndXJhdGlvbnNcbiAgICAgIFRoZXNlIGFyZSB0aGUgY2hhbm5lbCBjb25maWd1cmF0aW9uczpcbiAgICAgIDA6IERlZmluZWQgaW4gQU9UIFNwZWNpZmMgQ29uZmlnXG4gICAgICAxOiAxIGNoYW5uZWw6IGZyb250LWNlbnRlclxuICAgICAgMjogMiBjaGFubmVsczogZnJvbnQtbGVmdCwgZnJvbnQtcmlnaHRcbiAgICAqL1xuICAgIC8vIGF1ZGlvT2JqZWN0VHlwZSA9IHByb2ZpbGUgPT4gcHJvZmlsZSwgdGhlIE1QRUctNCBBdWRpbyBPYmplY3QgVHlwZSBtaW51cyAxXG4gICAgY29uZmlnWzBdID0gYWR0c09iamVjdFR5cGUgPDwgMztcbiAgICAvLyBzYW1wbGluZ0ZyZXF1ZW5jeUluZGV4XG4gICAgY29uZmlnWzBdIHw9IChhZHRzU2FtcGxlaW5nSW5kZXggJiAweDBFKSA+PiAxO1xuICAgIGNvbmZpZ1sxXSB8PSAoYWR0c1NhbXBsZWluZ0luZGV4ICYgMHgwMSkgPDwgNztcbiAgICAvLyBjaGFubmVsQ29uZmlndXJhdGlvblxuICAgIGNvbmZpZ1sxXSB8PSBhZHRzQ2hhbmVsQ29uZmlnIDw8IDM7XG4gICAgaWYgKGFkdHNPYmplY3RUeXBlID09PSA1KSB7XG4gICAgICAgIC8vIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleFxuICAgICAgICBjb25maWdbMV0gfD0gKGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCAmIDB4MEUpID4+IDE7XG4gICAgICAgIGNvbmZpZ1syXSA9IChhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggJiAweDAxKSA8PCA3O1xuICAgICAgICAvLyBhZHRzT2JqZWN0VHlwZSAoZm9yY2UgdG8gMiwgY2hyb21lIGlzIGNoZWNraW5nIHRoYXQgb2JqZWN0IHR5cGUgaXMgbGVzcyB0aGFuIDUgPz8/XG4gICAgICAgIC8vICAgIGh0dHBzOi8vY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMuZ2l0LysvbWFzdGVyL21lZGlhL2Zvcm1hdHMvbXA0L2FhYy5jY1xuICAgICAgICBjb25maWdbMl0gfD0gMiA8PCAyO1xuICAgICAgICBjb25maWdbM10gPSAwO1xuICAgIH1cbiAgICByZXR1cm4geyBjb25maWc6IGNvbmZpZywgc2FtcGxlcmF0ZTogYWR0c1NhbXBsZWluZ1JhdGVzW2FkdHNTYW1wbGVpbmdJbmRleF0sIGNoYW5uZWxDb3VudDogYWR0c0NoYW5lbENvbmZpZywgY29kZWM6ICgnbXA0YS40MC4nICsgYWR0c09iamVjdFR5cGUpLCBtYW5pZmVzdENvZGVjOiBtYW5pZmVzdENvZGVjIH07XG59XG5leHBvcnRzLmdldEF1ZGlvQ29uZmlnID0gZ2V0QXVkaW9Db25maWc7XG5mdW5jdGlvbiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGRhdGFbb2Zmc2V0XSA9PT0gMHhmZiAmJiAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4ZjYpID09PSAweGYwO1xufVxuZXhwb3J0cy5pc0hlYWRlclBhdHRlcm4gPSBpc0hlYWRlclBhdHRlcm47XG5mdW5jdGlvbiBnZXRIZWFkZXJMZW5ndGgoZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIChkYXRhW29mZnNldCArIDFdICYgMHgwMSA/IDcgOiA5KTtcbn1cbmV4cG9ydHMuZ2V0SGVhZGVyTGVuZ3RoID0gZ2V0SGVhZGVyTGVuZ3RoO1xuZnVuY3Rpb24gZ2V0RnVsbEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCkge1xuICAgIHJldHVybiAoKGRhdGFbb2Zmc2V0ICsgM10gJiAweDAzKSA8PCAxMSkgfFxuICAgICAgICAoZGF0YVtvZmZzZXQgKyA0XSA8PCAzKSB8XG4gICAgICAgICgoZGF0YVtvZmZzZXQgKyA1XSAmIDB4RTApID4+PiA1KTtcbn1cbmV4cG9ydHMuZ2V0RnVsbEZyYW1lTGVuZ3RoID0gZ2V0RnVsbEZyYW1lTGVuZ3RoO1xuZnVuY3Rpb24gaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSB7XG4gICAgLy8gTG9vayBmb3IgQURUUyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTExIFgwMFggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxXG4gICAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyAwIGZvciBBRFRTXG4gICAgLy8gTW9yZSBpbmZvIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXG4gICAgaWYgKG9mZnNldCArIDEgPCBkYXRhLmxlbmd0aCAmJiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5pc0hlYWRlciA9IGlzSGVhZGVyO1xuZnVuY3Rpb24gcHJvYmUoZGF0YSwgb2Zmc2V0KSB7XG4gICAgLy8gc2FtZSBhcyBpc0hlYWRlciBidXQgd2UgYWxzbyBjaGVjayB0aGF0IEFEVFMgZnJhbWUgZm9sbG93cyBsYXN0IEFEVFMgZnJhbWVcbiAgICAvLyBvciBlbmQgb2YgZGF0YSBpcyByZWFjaGVkXG4gICAgaWYgKG9mZnNldCArIDEgPCBkYXRhLmxlbmd0aCAmJiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICAvLyBBRFRTIGhlYWRlciBMZW5ndGhcbiAgICAgICAgdmFyIGhlYWRlckxlbmd0aCA9IGdldEhlYWRlckxlbmd0aChkYXRhLCBvZmZzZXQpO1xuICAgICAgICAvLyBBRFRTIGZyYW1lIExlbmd0aFxuICAgICAgICB2YXIgZnJhbWVMZW5ndGggPSBoZWFkZXJMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgKyA1IDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZyYW1lTGVuZ3RoID0gZ2V0RnVsbEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld09mZnNldCA9IG9mZnNldCArIGZyYW1lTGVuZ3RoO1xuICAgICAgICBpZiAobmV3T2Zmc2V0ID09PSBkYXRhLmxlbmd0aCB8fCAobmV3T2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIGlzSGVhZGVyUGF0dGVybihkYXRhLCBuZXdPZmZzZXQpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5wcm9iZSA9IHByb2JlO1xuZnVuY3Rpb24gaW5pdFRyYWNrQ29uZmlnKHRyYWNrLCBvYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCBhdWRpb0NvZGVjKSB7XG4gICAgaWYgKCF0cmFjay5zYW1wbGVyYXRlKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBnZXRBdWRpb0NvbmZpZyhvYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCBhdWRpb0NvZGVjKTtcbiAgICAgICAgdHJhY2suY29uZmlnID0gY29uZmlnLmNvbmZpZztcbiAgICAgICAgdHJhY2suc2FtcGxlcmF0ZSA9IGNvbmZpZy5zYW1wbGVyYXRlO1xuICAgICAgICB0cmFjay5jaGFubmVsQ291bnQgPSBjb25maWcuY2hhbm5lbENvdW50O1xuICAgICAgICB0cmFjay5jb2RlYyA9IGNvbmZpZy5jb2RlYztcbiAgICAgICAgdHJhY2subWFuaWZlc3RDb2RlYyA9IGNvbmZpZy5tYW5pZmVzdENvZGVjO1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwicGFyc2VkIGNvZGVjOlwiICsgdHJhY2suY29kZWMgKyBcIixyYXRlOlwiICsgY29uZmlnLnNhbXBsZXJhdGUgKyBcIixuYiBjaGFubmVsOlwiICsgY29uZmlnLmNoYW5uZWxDb3VudCk7XG4gICAgfVxufVxuZXhwb3J0cy5pbml0VHJhY2tDb25maWcgPSBpbml0VHJhY2tDb25maWc7XG5mdW5jdGlvbiBnZXRGcmFtZUR1cmF0aW9uKHNhbXBsZXJhdGUpIHtcbiAgICByZXR1cm4gMTAyNCAqIDkwMDAwIC8gc2FtcGxlcmF0ZTtcbn1cbmV4cG9ydHMuZ2V0RnJhbWVEdXJhdGlvbiA9IGdldEZyYW1lRHVyYXRpb247XG5mdW5jdGlvbiBwYXJzZUZyYW1lSGVhZGVyKGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4LCBmcmFtZUR1cmF0aW9uKSB7XG4gICAgdmFyIGhlYWRlckxlbmd0aCwgZnJhbWVMZW5ndGgsIHN0YW1wO1xuICAgIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAvLyBUaGUgcHJvdGVjdGlvbiBza2lwIGJpdCB0ZWxscyB1cyBpZiB3ZSBoYXZlIDIgYnl0ZXMgb2YgQ1JDIGRhdGEgYXQgdGhlIGVuZCBvZiB0aGUgQURUUyBoZWFkZXJcbiAgICBoZWFkZXJMZW5ndGggPSBnZXRIZWFkZXJMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcbiAgICAvLyByZXRyaWV2ZSBmcmFtZSBzaXplXG4gICAgZnJhbWVMZW5ndGggPSBnZXRGdWxsRnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcbiAgICBmcmFtZUxlbmd0aCAtPSBoZWFkZXJMZW5ndGg7XG4gICAgaWYgKChmcmFtZUxlbmd0aCA+IDApICYmICgob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoICsgZnJhbWVMZW5ndGgpIDw9IGxlbmd0aCkpIHtcbiAgICAgICAgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcbiAgICAgICAgLy8gbG9nZ2VyLmxvZyhgQUFDIGZyYW1lLCBvZmZzZXQvbGVuZ3RoL3RvdGFsL3B0czoke29mZnNldCtoZWFkZXJMZW5ndGh9LyR7ZnJhbWVMZW5ndGh9LyR7ZGF0YS5ieXRlTGVuZ3RofS8keyhzdGFtcC85MCkudG9GaXhlZCgwKX1gKTtcbiAgICAgICAgcmV0dXJuIHsgaGVhZGVyTGVuZ3RoOiBoZWFkZXJMZW5ndGgsIGZyYW1lTGVuZ3RoOiBmcmFtZUxlbmd0aCwgc3RhbXA6IHN0YW1wIH07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5leHBvcnRzLnBhcnNlRnJhbWVIZWFkZXIgPSBwYXJzZUZyYW1lSGVhZGVyO1xuZnVuY3Rpb24gYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KSB7XG4gICAgdmFyIGZyYW1lRHVyYXRpb24gPSBnZXRGcmFtZUR1cmF0aW9uKHRyYWNrLnNhbXBsZXJhdGUpO1xuICAgIHZhciBoZWFkZXIgPSBwYXJzZUZyYW1lSGVhZGVyKGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4LCBmcmFtZUR1cmF0aW9uKTtcbiAgICBpZiAoaGVhZGVyKSB7XG4gICAgICAgIHZhciBzdGFtcCA9IGhlYWRlci5zdGFtcDtcbiAgICAgICAgdmFyIGhlYWRlckxlbmd0aCA9IGhlYWRlci5oZWFkZXJMZW5ndGg7XG4gICAgICAgIHZhciBmcmFtZUxlbmd0aCA9IGhlYWRlci5mcmFtZUxlbmd0aDtcbiAgICAgICAgLy8gbG9nZ2VyLmxvZyhgQUFDIGZyYW1lLCBvZmZzZXQvbGVuZ3RoL3RvdGFsL3B0czoke29mZnNldCtoZWFkZXJMZW5ndGh9LyR7ZnJhbWVMZW5ndGh9LyR7ZGF0YS5ieXRlTGVuZ3RofS8keyhzdGFtcC85MCkudG9GaXhlZCgwKX1gKTtcbiAgICAgICAgdmFyIGFhY1NhbXBsZSA9IHtcbiAgICAgICAgICAgIHVuaXQ6IGRhdGEuc3ViYXJyYXkob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoLCBvZmZzZXQgKyBoZWFkZXJMZW5ndGggKyBmcmFtZUxlbmd0aCksXG4gICAgICAgICAgICBwdHM6IHN0YW1wLFxuICAgICAgICAgICAgZHRzOiBzdGFtcFxuICAgICAgICB9O1xuICAgICAgICB0cmFjay5zYW1wbGVzLnB1c2goYWFjU2FtcGxlKTtcbiAgICAgICAgdHJhY2subGVuICs9IGZyYW1lTGVuZ3RoO1xuICAgICAgICByZXR1cm4geyBzYW1wbGU6IGFhY1NhbXBsZSwgbGVuZ3RoOiBmcmFtZUxlbmd0aCArIGhlYWRlckxlbmd0aCB9O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5hcHBlbmRGcmFtZSA9IGFwcGVuZEZyYW1lO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RlbXV4L2RlbXV4ZXItaW5saW5lLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RlbXV4L2RlbXV4ZXItaW5saW5lLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqXG4gKiBpbmxpbmUgZGVtdXhlcjogcHJvYmUgZnJhZ21lbnRzIGFuZCBpbnN0YW50aWF0ZVxuICogYXBwcm9wcmlhdGUgZGVtdXhlciBkZXBlbmRpbmcgb24gY29udGVudCB0eXBlIChUU0RlbXV4ZXIsIEFBQ0RlbXV4ZXIsIC4uLilcbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy5qc1wiKTtcbnZhciBlcnJvcnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy5qc1wiKTtcbnZhciBkZWNyeXB0ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2NyeXB0L2RlY3J5cHRlciAqLyBcIi4vc3JjL2NyeXB0L2RlY3J5cHRlci5qc1wiKTtcbnZhciBhYWNkZW11eGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9hYWNkZW11eGVyICovIFwiLi9zcmMvZGVtdXgvYWFjZGVtdXhlci5qc1wiKTtcbnZhciBtcDRkZW11eGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9tcDRkZW11eGVyICovIFwiLi9zcmMvZGVtdXgvbXA0ZGVtdXhlci5qc1wiKTtcbnZhciB0c2RlbXV4ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L3RzZGVtdXhlciAqLyBcIi4vc3JjL2RlbXV4L3RzZGVtdXhlci5qc1wiKTtcbnZhciBtcDNkZW11eGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9tcDNkZW11eGVyICovIFwiLi9zcmMvZGVtdXgvbXAzZGVtdXhlci5qc1wiKTtcbnZhciBtcDRfcmVtdXhlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vcmVtdXgvbXA0LXJlbXV4ZXIgKi8gXCIuL3NyYy9yZW11eC9tcDQtcmVtdXhlci5qc1wiKTtcbnZhciBwYXNzdGhyb3VnaF9yZW11eGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9yZW11eC9wYXNzdGhyb3VnaC1yZW11eGVyICovIFwiLi9zcmMvcmVtdXgvcGFzc3Rocm91Z2gtcmVtdXhlci5qc1wiKTtcbnZhciBnZXRfc2VsZl9zY29wZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvZ2V0LXNlbGYtc2NvcGUgKi8gXCIuL3NyYy91dGlscy9nZXQtc2VsZi1zY29wZS5qc1wiKTtcbnZhciBsb2dnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci5qc1wiKTtcbi8vIHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTEyMzcyNTkvNTg5NDkzXG52YXIgZ2xvYmFsID0gZ2V0X3NlbGZfc2NvcGVfMS5nZXRTZWxmU2NvcGUoKTsgLy8gc2FmZWd1YXJkIGZvciBjb2RlIHRoYXQgbWlnaHQgcnVuIGJvdGggb24gd29ya2VyIGFuZCBtYWluIHRocmVhZFxudmFyIG5vdztcbi8vIHBlcmZvcm1hbmNlLm5vdygpIG5vdCBhdmFpbGFibGUgb24gV2ViV29ya2VyLCBhdCBsZWFzdCBvbiBTYWZhcmkgRGVza3RvcFxudHJ5IHtcbiAgICBub3cgPSBnbG9iYWwucGVyZm9ybWFuY2Uubm93LmJpbmQoZ2xvYmFsLnBlcmZvcm1hbmNlKTtcbn1cbmNhdGNoIChlcnIpIHtcbiAgICBsb2dnZXJfMS5sb2dnZXIuZGVidWcoJ1VuYWJsZSB0byB1c2UgUGVyZm9ybWFuY2UgQVBJIG9uIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgICBub3cgPSBnbG9iYWwuRGF0ZS5ub3c7XG59XG52YXIgRGVtdXhlcklubGluZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZW11eGVySW5saW5lKG9ic2VydmVyLCB0eXBlU3VwcG9ydGVkLCBjb25maWcsIHZlbmRvcikge1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLnZlbmRvciA9IHZlbmRvcjtcbiAgICB9XG4gICAgRGVtdXhlcklubGluZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgICAgIGlmIChkZW11eGVyKSB7XG4gICAgICAgICAgICBkZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVtdXhlcklubGluZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBkZWNyeXB0ZGF0YSwgaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoLCBjb250aWd1b3VzLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBkZWZhdWx0SW5pdFBUUykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoKGRhdGEuYnl0ZUxlbmd0aCA+IDApICYmIChkZWNyeXB0ZGF0YSAhPSBudWxsKSAmJiAoZGVjcnlwdGRhdGEua2V5ICE9IG51bGwpICYmIChkZWNyeXB0ZGF0YS5tZXRob2QgPT09ICdBRVMtMTI4JykpIHtcbiAgICAgICAgICAgIHZhciBkZWNyeXB0ZXIgPSB0aGlzLmRlY3J5cHRlcjtcbiAgICAgICAgICAgIGlmIChkZWNyeXB0ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlY3J5cHRlciA9IHRoaXMuZGVjcnlwdGVyID0gbmV3IGRlY3J5cHRlcl8xLmRlZmF1bHQodGhpcy5vYnNlcnZlciwgdGhpcy5jb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0YXJ0VGltZV8xID0gbm93KCk7XG4gICAgICAgICAgICBkZWNyeXB0ZXIuZGVjcnlwdChkYXRhLCBkZWNyeXB0ZGF0YS5rZXkuYnVmZmVyLCBkZWNyeXB0ZGF0YS5pdi5idWZmZXIsIGZ1bmN0aW9uIChkZWNyeXB0ZWREYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuZFRpbWUgPSBub3coKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vYnNlcnZlci50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRlJBR19ERUNSWVBURUQsIHsgc3RhdHM6IHsgdHN0YXJ0OiBzdGFydFRpbWVfMSwgdGRlY3J5cHQ6IGVuZFRpbWUgfSB9KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5wdXNoRGVjcnlwdGVkKG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZERhdGEpLCBkZWNyeXB0ZGF0YSwgbmV3IFVpbnQ4QXJyYXkoaW5pdFNlZ21lbnQpLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCwgY29udGlndW91cywgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgZGVmYXVsdEluaXRQVFMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hEZWNyeXB0ZWQobmV3IFVpbnQ4QXJyYXkoZGF0YSksIGRlY3J5cHRkYXRhLCBuZXcgVWludDhBcnJheShpbml0U2VnbWVudCksIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoLCBjb250aWd1b3VzLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBkZWZhdWx0SW5pdFBUUyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlbXV4ZXJJbmxpbmUucHJvdG90eXBlLnB1c2hEZWNyeXB0ZWQgPSBmdW5jdGlvbiAoZGF0YSwgZGVjcnlwdGRhdGEsIGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCwgY29udGlndW91cywgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgZGVmYXVsdEluaXRQVFMpIHtcbiAgICAgICAgdmFyIGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgICAgIGlmICghZGVtdXhlciB8fFxuICAgICAgICAgICAgLy8gaW4gY2FzZSBvZiBjb250aW51aXR5IGNoYW5nZSwgb3IgdHJhY2sgc3dpdGNoXG4gICAgICAgICAgICAvLyB3ZSBtaWdodCBzd2l0Y2ggZnJvbSBjb250ZW50IHR5cGUgKEFBQyBjb250YWluZXIgdG8gVFMgY29udGFpbmVyLCBvciBUUyB0byBmbXA0IGZvciBleGFtcGxlKVxuICAgICAgICAgICAgLy8gc28gbGV0J3MgY2hlY2sgdGhhdCBjdXJyZW50IGRlbXV4ZXIgaXMgc3RpbGwgdmFsaWRcbiAgICAgICAgICAgICgoZGlzY29udGludWl0eSB8fCB0cmFja1N3aXRjaCkgJiYgIXRoaXMucHJvYmUoZGF0YSkpKSB7XG4gICAgICAgICAgICB2YXIgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyO1xuICAgICAgICAgICAgdmFyIHR5cGVTdXBwb3J0ZWQgPSB0aGlzLnR5cGVTdXBwb3J0ZWQ7XG4gICAgICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgICAvLyBwcm9iaW5nIG9yZGVyIGlzIFRTL0FBQy9NUDMvTVA0XG4gICAgICAgICAgICB2YXIgbXV4Q29uZmlnID0gW1xuICAgICAgICAgICAgICAgIHsgZGVtdXg6IHRzZGVtdXhlcl8xLmRlZmF1bHQsIHJlbXV4OiBtcDRfcmVtdXhlcl8xLmRlZmF1bHQgfSxcbiAgICAgICAgICAgICAgICB7IGRlbXV4OiBtcDRkZW11eGVyXzEuZGVmYXVsdCwgcmVtdXg6IHBhc3N0aHJvdWdoX3JlbXV4ZXJfMS5kZWZhdWx0IH0sXG4gICAgICAgICAgICAgICAgeyBkZW11eDogYWFjZGVtdXhlcl8xLmRlZmF1bHQsIHJlbXV4OiBtcDRfcmVtdXhlcl8xLmRlZmF1bHQgfSxcbiAgICAgICAgICAgICAgICB7IGRlbXV4OiBtcDNkZW11eGVyXzEuZGVmYXVsdCwgcmVtdXg6IG1wNF9yZW11eGVyXzEuZGVmYXVsdCB9XG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgLy8gcHJvYmUgZm9yIGNvbnRlbnQgdHlwZVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG11eENvbmZpZy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBtdXggPSBtdXhDb25maWdbaV07XG4gICAgICAgICAgICAgICAgdmFyIHByb2JlID0gbXV4LmRlbXV4LnByb2JlO1xuICAgICAgICAgICAgICAgIGlmIChwcm9iZShkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVtdXhlcl8xID0gdGhpcy5yZW11eGVyID0gbmV3IG11eC5yZW11eChvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkLCB0aGlzLnZlbmRvcik7XG4gICAgICAgICAgICAgICAgICAgIGRlbXV4ZXIgPSBuZXcgbXV4LmRlbXV4KG9ic2VydmVyLCByZW11eGVyXzEsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvYmUgPSBwcm9iZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkZW11eGVyKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IGVycm9yc18xLkVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IGVycm9yc18xLkVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsIGZhdGFsOiB0cnVlLCByZWFzb246ICdubyBkZW11eCBtYXRjaGluZyB3aXRoIGNvbnRlbnQgZm91bmQnIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVtdXhlciA9IGRlbXV4ZXI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlbXV4ZXIgPSB0aGlzLnJlbXV4ZXI7XG4gICAgICAgIGlmIChkaXNjb250aW51aXR5IHx8IHRyYWNrU3dpdGNoKSB7XG4gICAgICAgICAgICBkZW11eGVyLnJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHJlbXV4ZXIucmVzZXRJbml0U2VnbWVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXNjb250aW51aXR5KSB7XG4gICAgICAgICAgICBkZW11eGVyLnJlc2V0VGltZVN0YW1wKGRlZmF1bHRJbml0UFRTKTtcbiAgICAgICAgICAgIHJlbXV4ZXIucmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQVFMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGVtdXhlci5zZXREZWNyeXB0RGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZGVtdXhlci5zZXREZWNyeXB0RGF0YShkZWNyeXB0ZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVtdXhlci5hcHBlbmQoZGF0YSwgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICB9O1xuICAgIHJldHVybiBEZW11eGVySW5saW5lO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IERlbXV4ZXJJbmxpbmU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGVtdXgvZGVtdXhlci13b3JrZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvZGVtdXhlci13b3JrZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGRlbXV4ZXIgd2ViIHdvcmtlci5cbiAqICAtIGxpc3RlbiB0byB3b3JrZXIgbWVzc2FnZSwgYW5kIHRyaWdnZXIgRGVtdXhlcklubGluZSB1cG9uIHJlY2VwdGlvbiBvZiBGcmFnbWVudHMuXG4gKiAgLSBwcm92aWRlcyBNUDQgQm94ZXMgYmFjayB0byBtYWluIHRocmVhZCB1c2luZyBbdHJhbnNmZXJhYmxlIG9iamVjdHNdKGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi91cGRhdGVzLzIwMTEvMTIvVHJhbnNmZXJhYmxlLU9iamVjdHMtTGlnaHRuaW5nLUZhc3QpIGluIG9yZGVyIHRvIG1pbmltaXplIG1lc3NhZ2UgcGFzc2luZyBvdmVyaGVhZC5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRlbXV4ZXJfaW5saW5lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9kZW11eGVyLWlubGluZSAqLyBcIi4vc3JjL2RlbXV4L2RlbXV4ZXItaW5saW5lLmpzXCIpO1xudmFyIGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLmpzXCIpO1xudmFyIGxvZ2dlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLmpzXCIpO1xudmFyIGV2ZW50c18yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZXZlbnRzICovIFwiLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanNcIik7XG52YXIgRGVtdXhlcldvcmtlciA9IGZ1bmN0aW9uIChzZWxmKSB7XG4gICAgLy8gb2JzZXJ2ZXIgc2V0dXBcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgZXZlbnRzXzIuRXZlbnRFbWl0dGVyKCk7XG4gICAgb2JzZXJ2ZXIudHJpZ2dlciA9IGZ1bmN0aW9uIHRyaWdnZXIoZXZlbnQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGRhdGFbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgb2JzZXJ2ZXIuZW1pdC5hcHBseShvYnNlcnZlciwgW2V2ZW50LCBldmVudF0uY29uY2F0KGRhdGEpKTtcbiAgICB9O1xuICAgIG9ic2VydmVyLm9mZiA9IGZ1bmN0aW9uIG9mZihldmVudCkge1xuICAgICAgICB2YXIgZGF0YSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgZGF0YVtfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBvYnNlcnZlci5yZW1vdmVMaXN0ZW5lci5hcHBseShvYnNlcnZlciwgW2V2ZW50XS5jb25jYXQoZGF0YSkpO1xuICAgIH07XG4gICAgdmFyIGZvcndhcmRNZXNzYWdlID0gZnVuY3Rpb24gKGV2LCBkYXRhKSB7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyBldmVudDogZXYsIGRhdGE6IGRhdGEgfSk7XG4gICAgfTtcbiAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBldi5kYXRhO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnZGVtdXhlciBjbWQ6JyArIGRhdGEuY21kKTtcbiAgICAgICAgc3dpdGNoIChkYXRhLmNtZCkge1xuICAgICAgICAgICAgY2FzZSAnaW5pdCc6XG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IEpTT04ucGFyc2UoZGF0YS5jb25maWcpO1xuICAgICAgICAgICAgICAgIHNlbGYuZGVtdXhlciA9IG5ldyBkZW11eGVyX2lubGluZV8xLmRlZmF1bHQob2JzZXJ2ZXIsIGRhdGEudHlwZVN1cHBvcnRlZCwgY29uZmlnLCBkYXRhLnZlbmRvcik7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZW5hYmxlTG9ncyhjb25maWcuZGVidWcpO1xuICAgICAgICAgICAgICAgIC8vIHNpZ25hbCBlbmQgb2Ygd29ya2VyIGluaXRcbiAgICAgICAgICAgICAgICBmb3J3YXJkTWVzc2FnZSgnaW5pdCcsIG51bGwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGVtdXgnOlxuICAgICAgICAgICAgICAgIHNlbGYuZGVtdXhlci5wdXNoKGRhdGEuZGF0YSwgZGF0YS5kZWNyeXB0ZGF0YSwgZGF0YS5pbml0U2VnbWVudCwgZGF0YS5hdWRpb0NvZGVjLCBkYXRhLnZpZGVvQ29kZWMsIGRhdGEudGltZU9mZnNldCwgZGF0YS5kaXNjb250aW51aXR5LCBkYXRhLnRyYWNrU3dpdGNoLCBkYXRhLmNvbnRpZ3VvdXMsIGRhdGEuZHVyYXRpb24sIGRhdGEuYWNjdXJhdGVUaW1lT2Zmc2V0LCBkYXRhLmRlZmF1bHRJbml0UFRTKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBmb3J3YXJkIGV2ZW50cyB0byBtYWluIHRocmVhZFxuICAgIG9ic2VydmVyLm9uKGV2ZW50c18xLmRlZmF1bHQuRlJBR19ERUNSWVBURUQsIGZvcndhcmRNZXNzYWdlKTtcbiAgICBvYnNlcnZlci5vbihldmVudHNfMS5kZWZhdWx0LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIGZvcndhcmRNZXNzYWdlKTtcbiAgICBvYnNlcnZlci5vbihldmVudHNfMS5kZWZhdWx0LkZSQUdfUEFSU0VELCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgb2JzZXJ2ZXIub24oZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIG9ic2VydmVyLm9uKGV2ZW50c18xLmRlZmF1bHQuRlJBR19QQVJTSU5HX01FVEFEQVRBLCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgb2JzZXJ2ZXIub24oZXZlbnRzXzEuZGVmYXVsdC5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIGZvcndhcmRNZXNzYWdlKTtcbiAgICBvYnNlcnZlci5vbihldmVudHNfMS5kZWZhdWx0LklOSVRfUFRTX0ZPVU5ELCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgLy8gc3BlY2lhbCBjYXNlIGZvciBGUkFHX1BBUlNJTkdfREFUQTogcGFzcyBkYXRhMS9kYXRhMiBhcyB0cmFuc2ZlcmFibGUgb2JqZWN0IChubyBjb3B5KVxuICAgIG9ic2VydmVyLm9uKGV2ZW50c18xLmRlZmF1bHQuRlJBR19QQVJTSU5HX0RBVEEsIGZ1bmN0aW9uIChldiwgZGF0YSkge1xuICAgICAgICB2YXIgdHJhbnNmZXJhYmxlID0gW107XG4gICAgICAgIHZhciBtZXNzYWdlID0geyBldmVudDogZXYsIGRhdGE6IGRhdGEgfTtcbiAgICAgICAgaWYgKGRhdGEuZGF0YTEpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuZGF0YTEgPSBkYXRhLmRhdGExLmJ1ZmZlcjtcbiAgICAgICAgICAgIHRyYW5zZmVyYWJsZS5wdXNoKGRhdGEuZGF0YTEuYnVmZmVyKTtcbiAgICAgICAgICAgIGRlbGV0ZSBkYXRhLmRhdGExO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmRhdGEyKSB7XG4gICAgICAgICAgICBtZXNzYWdlLmRhdGEyID0gZGF0YS5kYXRhMi5idWZmZXI7XG4gICAgICAgICAgICB0cmFuc2ZlcmFibGUucHVzaChkYXRhLmRhdGEyLmJ1ZmZlcik7XG4gICAgICAgICAgICBkZWxldGUgZGF0YS5kYXRhMjtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVyYWJsZSk7XG4gICAgfSk7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gRGVtdXhlcldvcmtlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC9kZW11eGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvZGVtdXhlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKE51bWJlcikge1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHdvcmsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB3ZWJ3b3JraWZ5LXdlYnBhY2sgKi8gXCIuL25vZGVfbW9kdWxlcy93ZWJ3b3JraWZ5LXdlYnBhY2svaW5kZXguanNcIik7XG52YXIgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMuanNcIik7XG52YXIgZGVtdXhlcl9pbmxpbmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L2RlbXV4ZXItaW5saW5lICovIFwiLi9zcmMvZGVtdXgvZGVtdXhlci1pbmxpbmUuanNcIik7XG52YXIgbG9nZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIuanNcIik7XG52YXIgZXJyb3JzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMuanNcIik7XG52YXIgbWVkaWFzb3VyY2VfaGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tZWRpYXNvdXJjZS1oZWxwZXIgKi8gXCIuL3NyYy91dGlscy9tZWRpYXNvdXJjZS1oZWxwZXIuanNcIik7XG52YXIgZ2V0X3NlbGZfc2NvcGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2dldC1zZWxmLXNjb3BlICovIFwiLi9zcmMvdXRpbHMvZ2V0LXNlbGYtc2NvcGUuanNcIik7XG52YXIgb2JzZXJ2ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL29ic2VydmVyICovIFwiLi9zcmMvb2JzZXJ2ZXIuanNcIik7XG4vLyBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzExMjM3MjU5LzU4OTQ5M1xudmFyIGdsb2JhbCA9IGdldF9zZWxmX3Njb3BlXzEuZ2V0U2VsZlNjb3BlKCk7IC8vIHNhZmVndWFyZCBmb3IgY29kZSB0aGF0IG1pZ2h0IHJ1biBib3RoIG9uIHdvcmtlciBhbmQgbWFpbiB0aHJlYWRcbnZhciBNZWRpYVNvdXJjZSA9IG1lZGlhc291cmNlX2hlbHBlcl8xLmdldE1lZGlhU291cmNlKCk7XG52YXIgRGVtdXhlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZW11eGVyKGhscywgaWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5obHMgPSBobHM7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdmFyIG9ic2VydmVyID0gdGhpcy5vYnNlcnZlciA9IG5ldyBvYnNlcnZlcl8xLk9ic2VydmVyKCk7XG4gICAgICAgIHZhciBjb25maWcgPSBobHMuY29uZmlnO1xuICAgICAgICB2YXIgZm9yd2FyZE1lc3NhZ2UgPSBmdW5jdGlvbiAoZXYsIGRhdGEpIHtcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgICAgICAgICAgZGF0YS5mcmFnID0gX3RoaXMuZnJhZztcbiAgICAgICAgICAgIGRhdGEuaWQgPSBfdGhpcy5pZDtcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKGV2LCBkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZm9yd2FyZCBldmVudHMgdG8gbWFpbiB0aHJlYWRcbiAgICAgICAgb2JzZXJ2ZXIub24oZXZlbnRzXzEuZGVmYXVsdC5GUkFHX0RFQ1JZUFRFRCwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgICAgICBvYnNlcnZlci5vbihldmVudHNfMS5kZWZhdWx0LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIGZvcndhcmRNZXNzYWdlKTtcbiAgICAgICAgb2JzZXJ2ZXIub24oZXZlbnRzXzEuZGVmYXVsdC5GUkFHX1BBUlNJTkdfREFUQSwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgICAgICBvYnNlcnZlci5vbihldmVudHNfMS5kZWZhdWx0LkZSQUdfUEFSU0VELCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgICAgIG9ic2VydmVyLm9uKGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIGZvcndhcmRNZXNzYWdlKTtcbiAgICAgICAgb2JzZXJ2ZXIub24oZXZlbnRzXzEuZGVmYXVsdC5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIGZvcndhcmRNZXNzYWdlKTtcbiAgICAgICAgb2JzZXJ2ZXIub24oZXZlbnRzXzEuZGVmYXVsdC5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIGZvcndhcmRNZXNzYWdlKTtcbiAgICAgICAgb2JzZXJ2ZXIub24oZXZlbnRzXzEuZGVmYXVsdC5JTklUX1BUU19GT1VORCwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgICAgICB2YXIgdHlwZVN1cHBvcnRlZCA9IHtcbiAgICAgICAgICAgIG1wNDogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCd2aWRlby9tcDQnKSxcbiAgICAgICAgICAgIG1wZWc6IE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgnYXVkaW8vbXBlZycpLFxuICAgICAgICAgICAgbXAzOiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ2F1ZGlvL21wNDsgY29kZWNzPVwibXAzXCInKVxuICAgICAgICB9O1xuICAgICAgICAvLyBuYXZpZ2F0b3IudmVuZG9yIGlzIG5vdCBhbHdheXMgYXZhaWxhYmxlIGluIFdlYiBXb3JrZXJcbiAgICAgICAgLy8gcmVmZXIgdG8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dvcmtlckdsb2JhbFNjb3BlL25hdmlnYXRvclxuICAgICAgICB2YXIgdmVuZG9yID0gbmF2aWdhdG9yLnZlbmRvcjtcbiAgICAgICAgaWYgKGNvbmZpZy5lbmFibGVXb3JrZXIgJiYgKHR5cGVvZiAoV29ya2VyKSAhPT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdkZW11eGluZyBpbiB3ZWJ3b3JrZXInKTtcbiAgICAgICAgICAgIHZhciB3ID0gdm9pZCAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3ID0gdGhpcy53ID0gd29yaygvKnJlcXVpcmUucmVzb2x2ZSovKC8qISAuLi9kZW11eC9kZW11eGVyLXdvcmtlci5qcyAqLyBcIi4vc3JjL2RlbXV4L2RlbXV4ZXItd29ya2VyLmpzXCIpKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9ud21zZyA9IHRoaXMub25Xb3JrZXJNZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5vbndtc2cpO1xuICAgICAgICAgICAgICAgIHcub25lcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IGVycm9yc18xLkVycm9yVHlwZXMuT1RIRVJfRVJST1IsIGRldGFpbHM6IGVycm9yc18xLkVycm9yRGV0YWlscy5JTlRFUk5BTF9FWENFUFRJT04sIGZhdGFsOiB0cnVlLCBldmVudDogJ2RlbXV4ZXJXb3JrZXInLCBlcnI6IHsgbWVzc2FnZTogZXZlbnQubWVzc2FnZSArICcgKCcgKyBldmVudC5maWxlbmFtZSArICc6JyArIGV2ZW50LmxpbmVubyArICcpJyB9IH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdy5wb3N0TWVzc2FnZSh7IGNtZDogJ2luaXQnLCB0eXBlU3VwcG9ydGVkOiB0eXBlU3VwcG9ydGVkLCB2ZW5kb3I6IHZlbmRvciwgaWQ6IGlkLCBjb25maWc6IEpTT04uc3RyaW5naWZ5KGNvbmZpZykgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oJ0Vycm9yIGluIHdvcmtlcjonLCBlcnIpO1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5lcnJvcignRXJyb3Igd2hpbGUgaW5pdGlhbGl6aW5nIERlbXV4ZXJXb3JrZXIsIGZhbGxiYWNrIG9uIERlbXV4ZXJJbmxpbmUnKTtcbiAgICAgICAgICAgICAgICBpZiAodykge1xuICAgICAgICAgICAgICAgICAgICAvLyByZXZva2UgdGhlIE9iamVjdCBVUkwgdGhhdCB3YXMgdXNlZCB0byBjcmVhdGUgZGVtdXhlciB3b3JrZXIsIHNvIGFzIG5vdCB0byBsZWFrIGl0XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbC5VUkwucmV2b2tlT2JqZWN0VVJMKHcub2JqZWN0VVJMKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kZW11eGVyID0gbmV3IGRlbXV4ZXJfaW5saW5lXzEuZGVmYXVsdChvYnNlcnZlciwgdHlwZVN1cHBvcnRlZCwgY29uZmlnLCB2ZW5kb3IpO1xuICAgICAgICAgICAgICAgIHRoaXMudyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVtdXhlciA9IG5ldyBkZW11eGVyX2lubGluZV8xLmRlZmF1bHQob2JzZXJ2ZXIsIHR5cGVTdXBwb3J0ZWQsIGNvbmZpZywgdmVuZG9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBEZW11eGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgaWYgKHcpIHtcbiAgICAgICAgICAgIHcucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMub253bXNnKTtcbiAgICAgICAgICAgIHcudGVybWluYXRlKCk7XG4gICAgICAgICAgICB0aGlzLncgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgICAgICAgICBpZiAoZGVtdXhlcikge1xuICAgICAgICAgICAgICAgIGRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVtdXhlciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcjtcbiAgICAgICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZW11eGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBmcmFnLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBkZWZhdWx0SW5pdFBUUykge1xuICAgICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgICAgdmFyIHRpbWVPZmZzZXQgPSBOdW1iZXIuaXNGaW5pdGUoZnJhZy5zdGFydFBUUykgPyBmcmFnLnN0YXJ0UFRTIDogZnJhZy5zdGFydDtcbiAgICAgICAgdmFyIGRlY3J5cHRkYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTtcbiAgICAgICAgdmFyIGxhc3RGcmFnID0gdGhpcy5mcmFnO1xuICAgICAgICB2YXIgZGlzY29udGludWl0eSA9ICEobGFzdEZyYWcgJiYgKGZyYWcuY2MgPT09IGxhc3RGcmFnLmNjKSk7XG4gICAgICAgIHZhciB0cmFja1N3aXRjaCA9ICEobGFzdEZyYWcgJiYgKGZyYWcubGV2ZWwgPT09IGxhc3RGcmFnLmxldmVsKSk7XG4gICAgICAgIHZhciBuZXh0U04gPSBsYXN0RnJhZyAmJiAoZnJhZy5zbiA9PT0gKGxhc3RGcmFnLnNuICsgMSkpO1xuICAgICAgICB2YXIgY29udGlndW91cyA9ICF0cmFja1N3aXRjaCAmJiBuZXh0U047XG4gICAgICAgIGlmIChkaXNjb250aW51aXR5KSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKHRoaXMuaWQgKyBcIjpkaXNjb250aW51aXR5IGRldGVjdGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFja1N3aXRjaCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyh0aGlzLmlkICsgXCI6c3dpdGNoIGRldGVjdGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnJhZyA9IGZyYWc7XG4gICAgICAgIGlmICh3KSB7XG4gICAgICAgICAgICAvLyBwb3N0IGZyYWdtZW50IHBheWxvYWQgYXMgdHJhbnNmZXJhYmxlIG9iamVjdHMgZm9yIEFycmF5QnVmZmVyIChubyBjb3B5KVxuICAgICAgICAgICAgdy5wb3N0TWVzc2FnZSh7IGNtZDogJ2RlbXV4JywgZGF0YTogZGF0YSwgZGVjcnlwdGRhdGE6IGRlY3J5cHRkYXRhLCBpbml0U2VnbWVudDogaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWM6IGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWM6IHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQ6IHRpbWVPZmZzZXQsIGRpc2NvbnRpbnVpdHk6IGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoOiB0cmFja1N3aXRjaCwgY29udGlndW91czogY29udGlndW91cywgZHVyYXRpb246IGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQ6IGFjY3VyYXRlVGltZU9mZnNldCwgZGVmYXVsdEluaXRQVFM6IGRlZmF1bHRJbml0UFRTIH0sIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IFtkYXRhXSA6IFtdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkZW11eGVyID0gdGhpcy5kZW11eGVyO1xuICAgICAgICAgICAgaWYgKGRlbXV4ZXIpIHtcbiAgICAgICAgICAgICAgICBkZW11eGVyLnB1c2goZGF0YSwgZGVjcnlwdGRhdGEsIGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCwgY29udGlndW91cywgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgZGVmYXVsdEluaXRQVFMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBEZW11eGVyLnByb3RvdHlwZS5vbldvcmtlck1lc3NhZ2UgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBldi5kYXRhLCBobHMgPSB0aGlzLmhscztcbiAgICAgICAgc3dpdGNoIChkYXRhLmV2ZW50KSB7XG4gICAgICAgICAgICBjYXNlICdpbml0JzpcbiAgICAgICAgICAgICAgICAvLyByZXZva2UgdGhlIE9iamVjdCBVUkwgdGhhdCB3YXMgdXNlZCB0byBjcmVhdGUgZGVtdXhlciB3b3JrZXIsIHNvIGFzIG5vdCB0byBsZWFrIGl0XG4gICAgICAgICAgICAgICAgZ2xvYmFsLlVSTC5yZXZva2VPYmplY3RVUkwodGhpcy53Lm9iamVjdFVSTCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIEZSQUdfUEFSU0lOR19EQVRBOiBkYXRhMSBhbmQgZGF0YTIgYXJlIHRyYW5zZmVyYWJsZSBvYmplY3RzXG4gICAgICAgICAgICBjYXNlIGV2ZW50c18xLmRlZmF1bHQuRlJBR19QQVJTSU5HX0RBVEE6XG4gICAgICAgICAgICAgICAgZGF0YS5kYXRhLmRhdGExID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5kYXRhMSk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZGF0YTIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5kYXRhLmRhdGEyID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5kYXRhMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBkYXRhLmRhdGEgPSBkYXRhLmRhdGEgfHwge307XG4gICAgICAgICAgICAgICAgZGF0YS5kYXRhLmZyYWcgPSB0aGlzLmZyYWc7XG4gICAgICAgICAgICAgICAgZGF0YS5kYXRhLmlkID0gdGhpcy5pZDtcbiAgICAgICAgICAgICAgICBobHMudHJpZ2dlcihkYXRhLmV2ZW50LCBkYXRhLmRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGVtdXhlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBEZW11eGVyO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIuanNcIilbXCJOdW1iZXJcIl0pKVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC9leHAtZ29sb21iLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvZXhwLWdvbG9tYi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFBhcnNlciBmb3IgZXhwb25lbnRpYWwgR29sb21iIGNvZGVzLCBhIHZhcmlhYmxlLWJpdHdpZHRoIG51bWJlciBlbmNvZGluZyBzY2hlbWUgdXNlZCBieSBoMjY0LlxuKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsb2dnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci5qc1wiKTtcbnZhciBFeHBHb2xvbWIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXhwR29sb21iKGRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgLy8gdGhlIG51bWJlciBvZiBieXRlcyBsZWZ0IHRvIGV4YW1pbmUgaW4gdGhpcy5kYXRhXG4gICAgICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgIC8vIHRoZSBjdXJyZW50IHdvcmQgYmVpbmcgZXhhbWluZWRcbiAgICAgICAgdGhpcy53b3JkID0gMDsgLy8gOnVpbnRcbiAgICAgICAgLy8gdGhlIG51bWJlciBvZiBiaXRzIGxlZnQgdG8gZXhhbWluZSBpbiB0aGUgY3VycmVudCB3b3JkXG4gICAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSA9IDA7IC8vIDp1aW50XG4gICAgfVxuICAgIC8vICgpOnZvaWRcbiAgICBFeHBHb2xvbWIucHJvdG90eXBlLmxvYWRXb3JkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSwgYnl0ZXNBdmFpbGFibGUgPSB0aGlzLmJ5dGVzQXZhaWxhYmxlLCBwb3NpdGlvbiA9IGRhdGEuYnl0ZUxlbmd0aCAtIGJ5dGVzQXZhaWxhYmxlLCB3b3JraW5nQnl0ZXMgPSBuZXcgVWludDhBcnJheSg0KSwgYXZhaWxhYmxlQnl0ZXMgPSBNYXRoLm1pbig0LCBieXRlc0F2YWlsYWJsZSk7XG4gICAgICAgIGlmIChhdmFpbGFibGVCeXRlcyA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBieXRlcyBhdmFpbGFibGUnKTtcbiAgICAgICAgfVxuICAgICAgICB3b3JraW5nQnl0ZXMuc2V0KGRhdGEuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICsgYXZhaWxhYmxlQnl0ZXMpKTtcbiAgICAgICAgdGhpcy53b3JkID0gbmV3IERhdGFWaWV3KHdvcmtpbmdCeXRlcy5idWZmZXIpLmdldFVpbnQzMigwKTtcbiAgICAgICAgLy8gdHJhY2sgdGhlIGFtb3VudCBvZiB0aGlzLmRhdGEgdGhhdCBoYXMgYmVlbiBwcm9jZXNzZWRcbiAgICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlID0gYXZhaWxhYmxlQnl0ZXMgKiA4O1xuICAgICAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlIC09IGF2YWlsYWJsZUJ5dGVzO1xuICAgIH07XG4gICAgLy8gKGNvdW50OmludCk6dm9pZFxuICAgIEV4cEdvbG9tYi5wcm90b3R5cGUuc2tpcEJpdHMgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICAgICAgdmFyIHNraXBCeXRlczsgLy8gOmludFxuICAgICAgICBpZiAodGhpcy5iaXRzQXZhaWxhYmxlID4gY291bnQpIHtcbiAgICAgICAgICAgIHRoaXMud29yZCA8PD0gY291bnQ7XG4gICAgICAgICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb3VudCAtPSB0aGlzLmJpdHNBdmFpbGFibGU7XG4gICAgICAgICAgICBza2lwQnl0ZXMgPSBjb3VudCA+PiAzO1xuICAgICAgICAgICAgY291bnQgLT0gKHNraXBCeXRlcyA+PiAzKTtcbiAgICAgICAgICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgLT0gc2tpcEJ5dGVzO1xuICAgICAgICAgICAgdGhpcy5sb2FkV29yZCgpO1xuICAgICAgICAgICAgdGhpcy53b3JkIDw8PSBjb3VudDtcbiAgICAgICAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBjb3VudDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gKHNpemU6aW50KTp1aW50XG4gICAgRXhwR29sb21iLnByb3RvdHlwZS5yZWFkQml0cyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIHZhciBiaXRzID0gTWF0aC5taW4odGhpcy5iaXRzQXZhaWxhYmxlLCBzaXplKSwgLy8gOnVpbnRcbiAgICAgICAgdmFsdSA9IHRoaXMud29yZCA+Pj4gKDMyIC0gYml0cyk7IC8vIDp1aW50XG4gICAgICAgIGlmIChzaXplID4gMzIpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5lcnJvcignQ2Fubm90IHJlYWQgbW9yZSB0aGFuIDMyIGJpdHMgYXQgYSB0aW1lJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGJpdHM7XG4gICAgICAgIGlmICh0aGlzLmJpdHNBdmFpbGFibGUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLndvcmQgPDw9IGJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5ieXRlc0F2YWlsYWJsZSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICAgICAgfVxuICAgICAgICBiaXRzID0gc2l6ZSAtIGJpdHM7XG4gICAgICAgIGlmIChiaXRzID4gMCAmJiB0aGlzLmJpdHNBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1IDw8IGJpdHMgfCB0aGlzLnJlYWRCaXRzKGJpdHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vICgpOnVpbnRcbiAgICBFeHBHb2xvbWIucHJvdG90eXBlLnNraXBMWiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxlYWRpbmdaZXJvQ291bnQ7IC8vIDp1aW50XG4gICAgICAgIGZvciAobGVhZGluZ1plcm9Db3VudCA9IDA7IGxlYWRpbmdaZXJvQ291bnQgPCB0aGlzLmJpdHNBdmFpbGFibGU7ICsrbGVhZGluZ1plcm9Db3VudCkge1xuICAgICAgICAgICAgaWYgKCh0aGlzLndvcmQgJiAoMHg4MDAwMDAwMCA+Pj4gbGVhZGluZ1plcm9Db3VudCkpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIGZpcnN0IGJpdCBvZiB3b3JraW5nIHdvcmQgaXMgMVxuICAgICAgICAgICAgICAgIHRoaXMud29yZCA8PD0gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgICAgICAgICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBleGhhdXN0ZWQgd29yZCBhbmQgc3RpbGwgaGF2ZSBub3QgZm91bmQgYSAxXG4gICAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdaZXJvQ291bnQgKyB0aGlzLnNraXBMWigpO1xuICAgIH07XG4gICAgLy8gKCk6dm9pZFxuICAgIEV4cEdvbG9tYi5wcm90b3R5cGUuc2tpcFVFRyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5za2lwQml0cygxICsgdGhpcy5za2lwTFooKSk7XG4gICAgfTtcbiAgICAvLyAoKTp2b2lkXG4gICAgRXhwR29sb21iLnByb3RvdHlwZS5za2lwRUcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExaKCkpO1xuICAgIH07XG4gICAgLy8gKCk6dWludFxuICAgIEV4cEdvbG9tYi5wcm90b3R5cGUucmVhZFVFRyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNseiA9IHRoaXMuc2tpcExaKCk7IC8vIDp1aW50XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKGNseiArIDEpIC0gMTtcbiAgICB9O1xuICAgIC8vICgpOmludFxuICAgIEV4cEdvbG9tYi5wcm90b3R5cGUucmVhZEVHID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdSA9IHRoaXMucmVhZFVFRygpOyAvLyA6aW50XG4gICAgICAgIGlmICgweDAxICYgdmFsdSkge1xuICAgICAgICAgICAgLy8gdGhlIG51bWJlciBpcyBvZGQgaWYgdGhlIGxvdyBvcmRlciBiaXQgaXMgc2V0XG4gICAgICAgICAgICByZXR1cm4gKDEgKyB2YWx1KSA+Pj4gMTsgLy8gYWRkIDEgdG8gbWFrZSBpdCBldmVuLCBhbmQgZGl2aWRlIGJ5IDJcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtMSAqICh2YWx1ID4+PiAxKTsgLy8gZGl2aWRlIGJ5IHR3byB0aGVuIG1ha2UgaXQgbmVnYXRpdmVcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gU29tZSBjb252ZW5pZW5jZSBmdW5jdGlvbnNcbiAgICAvLyA6Qm9vbGVhblxuICAgIEV4cEdvbG9tYi5wcm90b3R5cGUucmVhZEJvb2xlYW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDEpID09PSAxO1xuICAgIH07XG4gICAgLy8gKCk6aW50XG4gICAgRXhwR29sb21iLnByb3RvdHlwZS5yZWFkVUJ5dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDgpO1xuICAgIH07XG4gICAgLy8gKCk6aW50XG4gICAgRXhwR29sb21iLnByb3RvdHlwZS5yZWFkVVNob3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkQml0cygxNik7XG4gICAgfTtcbiAgICAvLyAoKTppbnRcbiAgICBFeHBHb2xvbWIucHJvdG90eXBlLnJlYWRVSW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkQml0cygzMik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZHZhbmNlIHRoZSBFeHBHb2xvbWIgZGVjb2RlciBwYXN0IGEgc2NhbGluZyBsaXN0LiBUaGUgc2NhbGluZ1xuICAgICAqIGxpc3QgaXMgb3B0aW9uYWxseSB0cmFuc21pdHRlZCBhcyBwYXJ0IG9mIGEgc2VxdWVuY2UgcGFyYW1ldGVyXG4gICAgICogc2V0IGFuZCBpcyBub3QgcmVsZXZhbnQgdG8gdHJhbnNtdXhpbmcuXG4gICAgICogQHBhcmFtIGNvdW50IHtudW1iZXJ9IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGlzIHNjYWxpbmcgbGlzdFxuICAgICAqIEBzZWUgUmVjb21tZW5kYXRpb24gSVRVLVQgSC4yNjQsIFNlY3Rpb24gNy4zLjIuMS4xLjFcbiAgICAgKi9cbiAgICBFeHBHb2xvbWIucHJvdG90eXBlLnNraXBTY2FsaW5nTGlzdCA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgICAgICB2YXIgbGFzdFNjYWxlID0gOCwgbmV4dFNjYWxlID0gOCwgaiwgZGVsdGFTY2FsZTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgICAgICAgIGlmIChuZXh0U2NhbGUgIT09IDApIHtcbiAgICAgICAgICAgICAgICBkZWx0YVNjYWxlID0gdGhpcy5yZWFkRUcoKTtcbiAgICAgICAgICAgICAgICBuZXh0U2NhbGUgPSAobGFzdFNjYWxlICsgZGVsdGFTY2FsZSArIDI1NikgJSAyNTY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0U2NhbGUgPSAobmV4dFNjYWxlID09PSAwKSA/IGxhc3RTY2FsZSA6IG5leHRTY2FsZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVhZCBhIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQgYW5kIHJldHVybiBzb21lIGludGVyZXN0aW5nIHZpZGVvXG4gICAgICogcHJvcGVydGllcy4gQSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0IGlzIHRoZSBIMjY0IG1ldGFkYXRhIHRoYXRcbiAgICAgKiBkZXNjcmliZXMgdGhlIHByb3BlcnRpZXMgb2YgdXBjb21pbmcgdmlkZW8gZnJhbWVzLlxuICAgICAqIEBwYXJhbSBkYXRhIHtVaW50OEFycmF5fSB0aGUgYnl0ZXMgb2YgYSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0XG4gICAgICogQHJldHVybiB7b2JqZWN0fSBhbiBvYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIHBhcnNlZCBmcm9tIHRoZVxuICAgICAqIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQsIGluY2x1ZGluZyB0aGUgZGltZW5zaW9ucyBvZiB0aGVcbiAgICAgKiBhc3NvY2lhdGVkIHZpZGVvIGZyYW1lcy5cbiAgICAgKi9cbiAgICBFeHBHb2xvbWIucHJvdG90eXBlLnJlYWRTUFMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmcmFtZUNyb3BMZWZ0T2Zmc2V0ID0gMCwgZnJhbWVDcm9wUmlnaHRPZmZzZXQgPSAwLCBmcmFtZUNyb3BUb3BPZmZzZXQgPSAwLCBmcmFtZUNyb3BCb3R0b21PZmZzZXQgPSAwLCBwcm9maWxlSWRjLCBwcm9maWxlQ29tcGF0LCBsZXZlbElkYywgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlLCBwaWNXaWR0aEluTWJzTWludXMxLCBwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxLCBmcmFtZU1ic09ubHlGbGFnLCBzY2FsaW5nTGlzdENvdW50LCBpLCByZWFkVUJ5dGUgPSB0aGlzLnJlYWRVQnl0ZS5iaW5kKHRoaXMpLCByZWFkQml0cyA9IHRoaXMucmVhZEJpdHMuYmluZCh0aGlzKSwgcmVhZFVFRyA9IHRoaXMucmVhZFVFRy5iaW5kKHRoaXMpLCByZWFkQm9vbGVhbiA9IHRoaXMucmVhZEJvb2xlYW4uYmluZCh0aGlzKSwgc2tpcEJpdHMgPSB0aGlzLnNraXBCaXRzLmJpbmQodGhpcyksIHNraXBFRyA9IHRoaXMuc2tpcEVHLmJpbmQodGhpcyksIHNraXBVRUcgPSB0aGlzLnNraXBVRUcuYmluZCh0aGlzKSwgc2tpcFNjYWxpbmdMaXN0ID0gdGhpcy5za2lwU2NhbGluZ0xpc3QuYmluZCh0aGlzKTtcbiAgICAgICAgcmVhZFVCeXRlKCk7XG4gICAgICAgIHByb2ZpbGVJZGMgPSByZWFkVUJ5dGUoKTsgLy8gcHJvZmlsZV9pZGNcbiAgICAgICAgcHJvZmlsZUNvbXBhdCA9IHJlYWRCaXRzKDUpOyAvLyBjb25zdHJhaW50X3NldFswLTRdX2ZsYWcsIHUoNSlcbiAgICAgICAgc2tpcEJpdHMoMyk7IC8vIHJlc2VydmVkX3plcm9fM2JpdHMgdSgzKSxcbiAgICAgICAgbGV2ZWxJZGMgPSByZWFkVUJ5dGUoKTsgLy8gbGV2ZWxfaWRjIHUoOClcbiAgICAgICAgc2tpcFVFRygpOyAvLyBzZXFfcGFyYW1ldGVyX3NldF9pZFxuICAgICAgICAvLyBzb21lIHByb2ZpbGVzIGhhdmUgbW9yZSBvcHRpb25hbCBkYXRhIHdlIGRvbid0IG5lZWRcbiAgICAgICAgaWYgKHByb2ZpbGVJZGMgPT09IDEwMCB8fFxuICAgICAgICAgICAgcHJvZmlsZUlkYyA9PT0gMTEwIHx8XG4gICAgICAgICAgICBwcm9maWxlSWRjID09PSAxMjIgfHxcbiAgICAgICAgICAgIHByb2ZpbGVJZGMgPT09IDI0NCB8fFxuICAgICAgICAgICAgcHJvZmlsZUlkYyA9PT0gNDQgfHxcbiAgICAgICAgICAgIHByb2ZpbGVJZGMgPT09IDgzIHx8XG4gICAgICAgICAgICBwcm9maWxlSWRjID09PSA4NiB8fFxuICAgICAgICAgICAgcHJvZmlsZUlkYyA9PT0gMTE4IHx8XG4gICAgICAgICAgICBwcm9maWxlSWRjID09PSAxMjgpIHtcbiAgICAgICAgICAgIHZhciBjaHJvbWFGb3JtYXRJZGMgPSByZWFkVUVHKCk7XG4gICAgICAgICAgICBpZiAoY2hyb21hRm9ybWF0SWRjID09PSAzKSB7XG4gICAgICAgICAgICAgICAgc2tpcEJpdHMoMSk7XG4gICAgICAgICAgICB9IC8vIHNlcGFyYXRlX2NvbG91cl9wbGFuZV9mbGFnXG4gICAgICAgICAgICBza2lwVUVHKCk7IC8vIGJpdF9kZXB0aF9sdW1hX21pbnVzOFxuICAgICAgICAgICAgc2tpcFVFRygpOyAvLyBiaXRfZGVwdGhfY2hyb21hX21pbnVzOFxuICAgICAgICAgICAgc2tpcEJpdHMoMSk7IC8vIHFwcHJpbWVfeV96ZXJvX3RyYW5zZm9ybV9ieXBhc3NfZmxhZ1xuICAgICAgICAgICAgaWYgKHJlYWRCb29sZWFuKCkpIHsgLy8gc2VxX3NjYWxpbmdfbWF0cml4X3ByZXNlbnRfZmxhZ1xuICAgICAgICAgICAgICAgIHNjYWxpbmdMaXN0Q291bnQgPSAoY2hyb21hRm9ybWF0SWRjICE9PSAzKSA/IDggOiAxMjtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2NhbGluZ0xpc3RDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWFkQm9vbGVhbigpKSB7IC8vIHNlcV9zY2FsaW5nX2xpc3RfcHJlc2VudF9mbGFnWyBpIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpIDwgNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBTY2FsaW5nTGlzdCgxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwU2NhbGluZ0xpc3QoNjQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNraXBVRUcoKTsgLy8gbG9nMl9tYXhfZnJhbWVfbnVtX21pbnVzNFxuICAgICAgICB2YXIgcGljT3JkZXJDbnRUeXBlID0gcmVhZFVFRygpO1xuICAgICAgICBpZiAocGljT3JkZXJDbnRUeXBlID09PSAwKSB7XG4gICAgICAgICAgICByZWFkVUVHKCk7IC8vIGxvZzJfbWF4X3BpY19vcmRlcl9jbnRfbHNiX21pbnVzNFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgc2tpcEJpdHMoMSk7IC8vIGRlbHRhX3BpY19vcmRlcl9hbHdheXNfemVyb19mbGFnXG4gICAgICAgICAgICBza2lwRUcoKTsgLy8gb2Zmc2V0X2Zvcl9ub25fcmVmX3BpY1xuICAgICAgICAgICAgc2tpcEVHKCk7IC8vIG9mZnNldF9mb3JfdG9wX3RvX2JvdHRvbV9maWVsZFxuICAgICAgICAgICAgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlID0gcmVhZFVFRygpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2tpcEVHKCk7XG4gICAgICAgICAgICB9IC8vIG9mZnNldF9mb3JfcmVmX2ZyYW1lWyBpIF1cbiAgICAgICAgfVxuICAgICAgICBza2lwVUVHKCk7IC8vIG1heF9udW1fcmVmX2ZyYW1lc1xuICAgICAgICBza2lwQml0cygxKTsgLy8gZ2Fwc19pbl9mcmFtZV9udW1fdmFsdWVfYWxsb3dlZF9mbGFnXG4gICAgICAgIHBpY1dpZHRoSW5NYnNNaW51czEgPSByZWFkVUVHKCk7XG4gICAgICAgIHBpY0hlaWdodEluTWFwVW5pdHNNaW51czEgPSByZWFkVUVHKCk7XG4gICAgICAgIGZyYW1lTWJzT25seUZsYWcgPSByZWFkQml0cygxKTtcbiAgICAgICAgaWYgKGZyYW1lTWJzT25seUZsYWcgPT09IDApIHtcbiAgICAgICAgICAgIHNraXBCaXRzKDEpO1xuICAgICAgICB9IC8vIG1iX2FkYXB0aXZlX2ZyYW1lX2ZpZWxkX2ZsYWdcbiAgICAgICAgc2tpcEJpdHMoMSk7IC8vIGRpcmVjdF84eDhfaW5mZXJlbmNlX2ZsYWdcbiAgICAgICAgaWYgKHJlYWRCb29sZWFuKCkpIHsgLy8gZnJhbWVfY3JvcHBpbmdfZmxhZ1xuICAgICAgICAgICAgZnJhbWVDcm9wTGVmdE9mZnNldCA9IHJlYWRVRUcoKTtcbiAgICAgICAgICAgIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgICAgICAgZnJhbWVDcm9wVG9wT2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgICAgICAgZnJhbWVDcm9wQm90dG9tT2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwaXhlbFJhdGlvID0gWzEsIDFdO1xuICAgICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAgICAgLy8gdnVpX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnXG4gICAgICAgICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAgICAgICAgIC8vIGFzcGVjdF9yYXRpb19pbmZvX3ByZXNlbnRfZmxhZ1xuICAgICAgICAgICAgICAgIHZhciBhc3BlY3RSYXRpb0lkYyA9IHJlYWRVQnl0ZSgpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYXNwZWN0UmF0aW9JZGMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzEyLCAxMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxMCwgMTFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTYsIDExXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzQwLCAzM107XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsyNCwgMTFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMjAsIDExXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzMyLCAxMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFs4MCwgMzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE4LCAxMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTUsIDExXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFs2NCwgMzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE2MCwgOTldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzQsIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzMsIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzIsIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjU1OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gW3JlYWRVQnl0ZSgpIDw8IDggfCByZWFkVUJ5dGUoKSwgcmVhZFVCeXRlKCkgPDwgOCB8IHJlYWRVQnl0ZSgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogTWF0aC5jZWlsKCgoKHBpY1dpZHRoSW5NYnNNaW51czEgKyAxKSAqIDE2KSAtIGZyYW1lQ3JvcExlZnRPZmZzZXQgKiAyIC0gZnJhbWVDcm9wUmlnaHRPZmZzZXQgKiAyKSksXG4gICAgICAgICAgICBoZWlnaHQ6ICgoMiAtIGZyYW1lTWJzT25seUZsYWcpICogKHBpY0hlaWdodEluTWFwVW5pdHNNaW51czEgKyAxKSAqIDE2KSAtICgoZnJhbWVNYnNPbmx5RmxhZyA/IDIgOiA0KSAqIChmcmFtZUNyb3BUb3BPZmZzZXQgKyBmcmFtZUNyb3BCb3R0b21PZmZzZXQpKSxcbiAgICAgICAgICAgIHBpeGVsUmF0aW86IHBpeGVsUmF0aW9cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEV4cEdvbG9tYi5wcm90b3R5cGUucmVhZFNsaWNlVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gc2tpcCBOQUx1IHR5cGVcbiAgICAgICAgdGhpcy5yZWFkVUJ5dGUoKTtcbiAgICAgICAgLy8gZGlzY2FyZCBmaXJzdF9tYl9pbl9zbGljZVxuICAgICAgICB0aGlzLnJlYWRVRUcoKTtcbiAgICAgICAgLy8gcmV0dXJuIHNsaWNlX3R5cGVcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZFVFRygpO1xuICAgIH07XG4gICAgcmV0dXJuIEV4cEdvbG9tYjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBFeHBHb2xvbWI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGVtdXgvaWQzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kZW11eC9pZDMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIElEMyBwYXJzZXJcbiAqL1xudmFyIElEMyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJRDMoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhbiBJRDMgaGVhZGVyIGNhbiBiZSBmb3VuZCBhdCBvZmZzZXQgaW4gZGF0YVxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YSAtIFRoZSBkYXRhIHRvIHNlYXJjaCBpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZ1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiBhbiBJRDMgaGVhZGVyIGlzIGZvdW5kXG4gICAgICovXG4gICAgSUQzLmlzSGVhZGVyID0gZnVuY3Rpb24gKGRhdGEsIG9mZnNldCkge1xuICAgICAgICAvKlxuICAgICAgICAqIGh0dHA6Ly9pZDMub3JnL2lkM3YyLjMuMFxuICAgICAgICAqIFswXSAgICAgPSAnSSdcbiAgICAgICAgKiBbMV0gICAgID0gJ0QnXG4gICAgICAgICogWzJdICAgICA9ICczJ1xuICAgICAgICAqIFszLDRdICAgPSB7VmVyc2lvbn1cbiAgICAgICAgKiBbNV0gICAgID0ge0ZsYWdzfVxuICAgICAgICAqIFs2LTldICAgPSB7SUQzIFNpemV9XG4gICAgICAgICpcbiAgICAgICAgKiBBbiBJRDN2MiB0YWcgY2FuIGJlIGRldGVjdGVkIHdpdGggdGhlIGZvbGxvd2luZyBwYXR0ZXJuOlxuICAgICAgICAqICAkNDkgNDQgMzMgeXkgeXkgeHggenogenogenogenpcbiAgICAgICAgKiBXaGVyZSB5eSBpcyBsZXNzIHRoYW4gJEZGLCB4eCBpcyB0aGUgJ2ZsYWdzJyBieXRlIGFuZCB6eiBpcyBsZXNzIHRoYW4gJDgwXG4gICAgICAgICovXG4gICAgICAgIGlmIChvZmZzZXQgKyAxMCA8PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gbG9vayBmb3IgJ0lEMycgaWRlbnRpZmllclxuICAgICAgICAgICAgaWYgKGRhdGFbb2Zmc2V0XSA9PT0gMHg0OSAmJiBkYXRhW29mZnNldCArIDFdID09PSAweDQ0ICYmIGRhdGFbb2Zmc2V0ICsgMl0gPT09IDB4MzMpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayB2ZXJzaW9uIGlzIHdpdGhpbiByYW5nZVxuICAgICAgICAgICAgICAgIGlmIChkYXRhW29mZnNldCArIDNdIDwgMHhGRiAmJiBkYXRhW29mZnNldCArIDRdIDwgMHhGRikge1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBzaXplIGlzIHdpdGhpbiByYW5nZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtvZmZzZXQgKyA2XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA3XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA4XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA5XSA8IDB4ODApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhbiBJRDMgZm9vdGVyIGNhbiBiZSBmb3VuZCBhdCBvZmZzZXQgaW4gZGF0YVxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YSAtIFRoZSBkYXRhIHRvIHNlYXJjaCBpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZ1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiBhbiBJRDMgZm9vdGVyIGlzIGZvdW5kXG4gICAgICovXG4gICAgSUQzLmlzRm9vdGVyID0gZnVuY3Rpb24gKGRhdGEsIG9mZnNldCkge1xuICAgICAgICAvKlxuICAgICAgICAqIFRoZSBmb290ZXIgaXMgYSBjb3B5IG9mIHRoZSBoZWFkZXIsIGJ1dCB3aXRoIGEgZGlmZmVyZW50IGlkZW50aWZpZXJcbiAgICAgICAgKi9cbiAgICAgICAgaWYgKG9mZnNldCArIDEwIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBsb29rIGZvciAnM0RJJyBpZGVudGlmaWVyXG4gICAgICAgICAgICBpZiAoZGF0YVtvZmZzZXRdID09PSAweDMzICYmIGRhdGFbb2Zmc2V0ICsgMV0gPT09IDB4NDQgJiYgZGF0YVtvZmZzZXQgKyAyXSA9PT0gMHg0OSkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHZlcnNpb24gaXMgd2l0aGluIHJhbmdlXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbb2Zmc2V0ICsgM10gPCAweEZGICYmIGRhdGFbb2Zmc2V0ICsgNF0gPCAweEZGKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHNpemUgaXMgd2l0aGluIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW29mZnNldCArIDZdIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDddIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDhdIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDldIDwgMHg4MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbnkgYWRqYWNlbnQgSUQzIHRhZ3MgZm91bmQgaW4gZGF0YSBzdGFydGluZyBhdCBvZmZzZXQsIGFzIG9uZSBibG9jayBvZiBkYXRhXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhIC0gVGhlIGRhdGEgdG8gc2VhcmNoIGluXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nXG4gICAgICogQHJldHVybiB7VWludDhBcnJheX0gLSBUaGUgYmxvY2sgb2YgZGF0YSBjb250YWluaW5nIGFueSBJRDMgdGFncyBmb3VuZFxuICAgICAqL1xuICAgIElEMy5nZXRJRDNEYXRhID0gZnVuY3Rpb24gKGRhdGEsIG9mZnNldCkge1xuICAgICAgICB2YXIgZnJvbnQgPSBvZmZzZXQ7XG4gICAgICAgIHZhciBsZW5ndGggPSAwO1xuICAgICAgICB3aGlsZSAoSUQzLmlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgICAgIC8vIElEMyBoZWFkZXIgaXMgMTAgYnl0ZXNcbiAgICAgICAgICAgIGxlbmd0aCArPSAxMDtcbiAgICAgICAgICAgIHZhciBzaXplID0gSUQzLl9yZWFkU2l6ZShkYXRhLCBvZmZzZXQgKyA2KTtcbiAgICAgICAgICAgIGxlbmd0aCArPSBzaXplO1xuICAgICAgICAgICAgaWYgKElEMy5pc0Zvb3RlcihkYXRhLCBvZmZzZXQgKyAxMCkpIHtcbiAgICAgICAgICAgICAgICAvLyBJRDMgZm9vdGVyIGlzIDEwIGJ5dGVzXG4gICAgICAgICAgICAgICAgbGVuZ3RoICs9IDEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEuc3ViYXJyYXkoZnJvbnQsIGZyb250ICsgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgSUQzLl9yZWFkU2l6ZSA9IGZ1bmN0aW9uIChkYXRhLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIHNpemUgPSAwO1xuICAgICAgICBzaXplID0gKChkYXRhW29mZnNldF0gJiAweDdmKSA8PCAyMSk7XG4gICAgICAgIHNpemUgfD0gKChkYXRhW29mZnNldCArIDFdICYgMHg3ZikgPDwgMTQpO1xuICAgICAgICBzaXplIHw9ICgoZGF0YVtvZmZzZXQgKyAyXSAmIDB4N2YpIDw8IDcpO1xuICAgICAgICBzaXplIHw9IChkYXRhW29mZnNldCArIDNdICYgMHg3Zik7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgZm9yIHRoZSBFbGVtZW50YXJ5IFN0cmVhbSB0aW1lc3RhbXAgZm91bmQgaW4gdGhlIElEMyBkYXRhIGNodW5rXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhIC0gQmxvY2sgb2YgZGF0YSBjb250YWluaW5nIG9uZSBvciBtb3JlIElEMyB0YWdzXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSB0aW1lc3RhbXBcbiAgICAgKi9cbiAgICBJRDMuZ2V0VGltZVN0YW1wID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGZyYW1lcyA9IElEMy5nZXRJRDNGcmFtZXMoZGF0YSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZnJhbWUgPSBmcmFtZXNbaV07XG4gICAgICAgICAgICBpZiAoSUQzLmlzVGltZVN0YW1wRnJhbWUoZnJhbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIElEMy5fcmVhZFRpbWVTdGFtcChmcmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSUQzIGZyYW1lIGlzIGFuIEVsZW1lbnRhcnkgU3RyZWFtIHRpbWVzdGFtcCBmcmFtZVxuICAgICAqIEBwYXJhbSB7SUQzIGZyYW1lfSBmcmFtZVxuICAgICAqL1xuICAgIElEMy5pc1RpbWVTdGFtcEZyYW1lID0gZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgICAgIHJldHVybiAoZnJhbWUgJiYgZnJhbWUua2V5ID09PSAnUFJJVicgJiYgZnJhbWUuaW5mbyA9PT0gJ2NvbS5hcHBsZS5zdHJlYW1pbmcudHJhbnNwb3J0U3RyZWFtVGltZXN0YW1wJyk7XG4gICAgfTtcbiAgICBJRDMuX2dldEZyYW1lRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8qXG4gICAgICAgIEZyYW1lIElEICAgICAgICR4eCB4eCB4eCB4eCAoZm91ciBjaGFyYWN0ZXJzKVxuICAgICAgICBTaXplICAgICAgICAgICAkeHggeHggeHggeHhcbiAgICAgICAgRmxhZ3MgICAgICAgICAgJHh4IHh4XG4gICAgICAgICovXG4gICAgICAgIHZhciB0eXBlID0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhWzBdLCBkYXRhWzFdLCBkYXRhWzJdLCBkYXRhWzNdKTtcbiAgICAgICAgdmFyIHNpemUgPSBJRDMuX3JlYWRTaXplKGRhdGEsIDQpO1xuICAgICAgICAvLyBza2lwIGZyYW1lIGlkLCBzaXplLCBhbmQgZmxhZ3NcbiAgICAgICAgdmFyIG9mZnNldCA9IDEwO1xuICAgICAgICByZXR1cm4geyB0eXBlOiB0eXBlLCBzaXplOiBzaXplLCBkYXRhOiBkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgc2l6ZSkgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgSUQzIGZyYW1lcyBmb3VuZCBpbiBhbGwgdGhlIElEMyB0YWdzIGluIHRoZSBpZDNEYXRhXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBpZDNEYXRhIC0gVGhlIElEMyBkYXRhIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgSUQzIHRhZ3NcbiAgICAgKiBAcmV0dXJuIHtJRDMgZnJhbWVbXX0gLSBBcnJheSBvZiBJRDMgZnJhbWUgb2JqZWN0c1xuICAgICAqL1xuICAgIElEMy5nZXRJRDNGcmFtZXMgPSBmdW5jdGlvbiAoaWQzRGF0YSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIGZyYW1lcyA9IFtdO1xuICAgICAgICB3aGlsZSAoSUQzLmlzSGVhZGVyKGlkM0RhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gSUQzLl9yZWFkU2l6ZShpZDNEYXRhLCBvZmZzZXQgKyA2KTtcbiAgICAgICAgICAgIC8vIHNraXAgcGFzdCBJRDMgaGVhZGVyXG4gICAgICAgICAgICBvZmZzZXQgKz0gMTA7XG4gICAgICAgICAgICB2YXIgZW5kID0gb2Zmc2V0ICsgc2l6ZTtcbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBmcmFtZXMgaW4gdGhlIElEMyB0YWdcbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgKyA4IDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lRGF0YSA9IElEMy5fZ2V0RnJhbWVEYXRhKGlkM0RhdGEuc3ViYXJyYXkob2Zmc2V0KSk7XG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gSUQzLl9kZWNvZGVGcmFtZShmcmFtZURhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBmcmFtZXMucHVzaChmcmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHNraXAgZnJhbWUgaGVhZGVyIGFuZCBmcmFtZSBkYXRhXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGZyYW1lRGF0YS5zaXplICsgMTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoSUQzLmlzRm9vdGVyKGlkM0RhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gMTA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyYW1lcztcbiAgICB9O1xuICAgIElEMy5fZGVjb2RlRnJhbWUgPSBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgaWYgKGZyYW1lLnR5cGUgPT09ICdQUklWJykge1xuICAgICAgICAgICAgcmV0dXJuIElEMy5fZGVjb2RlUHJpdkZyYW1lKGZyYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmcmFtZS50eXBlWzBdID09PSAnVCcpIHtcbiAgICAgICAgICAgIHJldHVybiBJRDMuX2RlY29kZVRleHRGcmFtZShmcmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZnJhbWUudHlwZVswXSA9PT0gJ1cnKSB7XG4gICAgICAgICAgICByZXR1cm4gSUQzLl9kZWNvZGVVUkxGcmFtZShmcmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIElEMy5fcmVhZFRpbWVTdGFtcCA9IGZ1bmN0aW9uICh0aW1lU3RhbXBGcmFtZSkge1xuICAgICAgICBpZiAodGltZVN0YW1wRnJhbWUuZGF0YS5ieXRlTGVuZ3RoID09PSA4KSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRpbWVTdGFtcEZyYW1lLmRhdGEpO1xuICAgICAgICAgICAgLy8gdGltZXN0YW1wIGlzIDMzIGJpdCBleHByZXNzZWQgYXMgYSBiaWctZW5kaWFuIGVpZ2h0LW9jdGV0IG51bWJlcixcbiAgICAgICAgICAgIC8vIHdpdGggdGhlIHVwcGVyIDMxIGJpdHMgc2V0IHRvIHplcm8uXG4gICAgICAgICAgICB2YXIgcHRzMzNCaXQgPSBkYXRhWzNdICYgMHgxO1xuICAgICAgICAgICAgdmFyIHRpbWVzdGFtcCA9IChkYXRhWzRdIDw8IDIzKSArXG4gICAgICAgICAgICAgICAgKGRhdGFbNV0gPDwgMTUpICtcbiAgICAgICAgICAgICAgICAoZGF0YVs2XSA8PCA3KSArXG4gICAgICAgICAgICAgICAgZGF0YVs3XTtcbiAgICAgICAgICAgIHRpbWVzdGFtcCAvPSA0NTtcbiAgICAgICAgICAgIGlmIChwdHMzM0JpdCkge1xuICAgICAgICAgICAgICAgIHRpbWVzdGFtcCArPSA0NzcyMTg1OC44NDtcbiAgICAgICAgICAgIH0gLy8gMl4zMiAvIDkwXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh0aW1lc3RhbXApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBJRDMuX2RlY29kZVByaXZGcmFtZSA9IGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICAvKlxuICAgICAgICBGb3JtYXQ6IDx0ZXh0IHN0cmluZz5cXDA8YmluYXJ5IGRhdGE+XG4gICAgICAgICovXG4gICAgICAgIGlmIChmcmFtZS5zaXplIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3duZXIgPSBJRDMuX3V0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEsIHRydWUpO1xuICAgICAgICB2YXIgcHJpdmF0ZURhdGEgPSBuZXcgVWludDhBcnJheShmcmFtZS5kYXRhLnN1YmFycmF5KG93bmVyLmxlbmd0aCArIDEpKTtcbiAgICAgICAgcmV0dXJuIHsga2V5OiBmcmFtZS50eXBlLCBpbmZvOiBvd25lciwgZGF0YTogcHJpdmF0ZURhdGEuYnVmZmVyIH07XG4gICAgfTtcbiAgICBJRDMuX2RlY29kZVRleHRGcmFtZSA9IGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICBpZiAoZnJhbWUuc2l6ZSA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyYW1lLnR5cGUgPT09ICdUWFhYJykge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIEZvcm1hdDpcbiAgICAgICAgICAgIFswXSAgID0ge1RleHQgRW5jb2Rpbmd9XG4gICAgICAgICAgICBbMS0/XSA9IHtEZXNjcmlwdGlvbn1cXDB7VmFsdWV9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gMTtcbiAgICAgICAgICAgIHZhciBkZXNjcmlwdGlvbiA9IElEMy5fdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCkpO1xuICAgICAgICAgICAgaW5kZXggKz0gZGVzY3JpcHRpb24ubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IElEMy5fdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCkpO1xuICAgICAgICAgICAgcmV0dXJuIHsga2V5OiBmcmFtZS50eXBlLCBpbmZvOiBkZXNjcmlwdGlvbiwgZGF0YTogdmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBGb3JtYXQ6XG4gICAgICAgICAgICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICAgICAgICAgICAgWzEtP10gPSB7VmFsdWV9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIHRleHQgPSBJRDMuX3V0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoMSkpO1xuICAgICAgICAgICAgcmV0dXJuIHsga2V5OiBmcmFtZS50eXBlLCBkYXRhOiB0ZXh0IH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElEMy5fZGVjb2RlVVJMRnJhbWUgPSBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgaWYgKGZyYW1lLnR5cGUgPT09ICdXWFhYJykge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIEZvcm1hdDpcbiAgICAgICAgICAgIFswXSAgID0ge1RleHQgRW5jb2Rpbmd9XG4gICAgICAgICAgICBbMS0/XSA9IHtEZXNjcmlwdGlvbn1cXDB7VVJMfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChmcmFtZS5zaXplIDwgMikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAxO1xuICAgICAgICAgICAgdmFyIGRlc2NyaXB0aW9uID0gSUQzLl91dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSk7XG4gICAgICAgICAgICBpbmRleCArPSBkZXNjcmlwdGlvbi5sZW5ndGggKyAxO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gSUQzLl91dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSk7XG4gICAgICAgICAgICByZXR1cm4geyBrZXk6IGZyYW1lLnR5cGUsIGluZm86IGRlc2NyaXB0aW9uLCBkYXRhOiB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIEZvcm1hdDpcbiAgICAgICAgICAgIFswLT9dID0ge1VSTH1cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgdXJsID0gSUQzLl91dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhKTtcbiAgICAgICAgICAgIHJldHVybiB7IGtleTogZnJhbWUudHlwZSwgZGF0YTogdXJsIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODkzNjk4NC91aW50OGFycmF5LXRvLXN0cmluZy1pbi1qYXZhc2NyaXB0LzIyMzczMTk3XG4gICAgLy8gaHR0cDovL3d3dy5vbmljb3MuY29tL3N0YWZmL2l6L2FtdXNlL2phdmFzY3JpcHQvZXhwZXJ0L3V0Zi50eHRcbiAgICAvKiB1dGYuanMgLSBVVEYtOCA8PT4gVVRGLTE2IGNvbnZlcnRpb25cbiAgICAgKlxuICAgICAqIENvcHlyaWdodCAoQykgMTk5OSBNYXNhbmFvIEl6dW1vIDxpekBvbmljb3MuY28uanA+XG4gICAgICogVmVyc2lvbjogMS4wXG4gICAgICogTGFzdE1vZGlmaWVkOiBEZWMgMjUgMTk5OVxuICAgICAqIFRoaXMgbGlicmFyeSBpcyBmcmVlLiAgWW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdC5cbiAgICAgKi9cbiAgICBJRDMuX3V0ZjhBcnJheVRvU3RyID0gZnVuY3Rpb24gKGFycmF5LCBleGl0T25OdWxsKSB7XG4gICAgICAgIGlmIChleGl0T25OdWxsID09PSB2b2lkIDApIHsgZXhpdE9uTnVsbCA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIHZhciBjO1xuICAgICAgICB2YXIgY2hhcjI7XG4gICAgICAgIHZhciBjaGFyMztcbiAgICAgICAgdmFyIG91dCA9ICcnO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgICBjID0gYXJyYXlbaSsrXTtcbiAgICAgICAgICAgIGlmIChjID09PSAweDAwICYmIGV4aXRPbk51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gMHgwMCB8fCBjID09PSAweDAzKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyAzIChFTkRfT0ZfVEVYVCkgb3IgMCAoTlVMTCkgdGhlbiBza2lwIGl0XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGMgPj4gNCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIC8vIDB4eHh4eHh4XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgIC8vIDExMHggeHh4eCAgIDEweHggeHh4eFxuICAgICAgICAgICAgICAgICAgICBjaGFyMiA9IGFycmF5W2krK107XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDB4MUYpIDw8IDYpIHwgKGNoYXIyICYgMHgzRikpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICAvLyAxMTEwIHh4eHggIDEweHggeHh4eCAgMTB4eCB4eHh4XG4gICAgICAgICAgICAgICAgICAgIGNoYXIyID0gYXJyYXlbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgY2hhcjMgPSBhcnJheVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgJiAweDBGKSA8PCAxMikgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKChjaGFyMiAmIDB4M0YpIDw8IDYpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICgoY2hhcjMgJiAweDNGKSA8PCAwKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIHJldHVybiBJRDM7XG59KCkpO1xudmFyIHV0ZjhBcnJheVRvU3RyID0gSUQzLl91dGY4QXJyYXlUb1N0cjtcbmV4cG9ydHMudXRmOEFycmF5VG9TdHIgPSB1dGY4QXJyYXlUb1N0cjtcbmV4cG9ydHMuZGVmYXVsdCA9IElEMztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC9tcDNkZW11eGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvbXAzZGVtdXhlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIE1QMyBkZW11eGVyXG4gKi9cbnZhciBpZDNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L2lkMyAqLyBcIi4vc3JjL2RlbXV4L2lkMy5qc1wiKTtcbnZhciBsb2dnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci5qc1wiKTtcbnZhciBtcGVnYXVkaW9fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbXBlZ2F1ZGlvICovIFwiLi9zcmMvZGVtdXgvbXBlZ2F1ZGlvLmpzXCIpO1xudmFyIE1QM0RlbXV4ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTVAzRGVtdXhlcihvYnNlcnZlciwgcmVtdXhlciwgY29uZmlnKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMucmVtdXhlciA9IHJlbXV4ZXI7XG4gICAgfVxuICAgIE1QM0RlbXV4ZXIucHJvdG90eXBlLnJlc2V0SW5pdFNlZ21lbnQgPSBmdW5jdGlvbiAoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB7IGNvbnRhaW5lcjogJ2F1ZGlvL21wZWcnLCB0eXBlOiAnYXVkaW8nLCBpZDogLTEsIHNlcXVlbmNlTnVtYmVyOiAwLCBpc0FBQzogZmFsc2UsIHNhbXBsZXM6IFtdLCBsZW46IDAsIG1hbmlmZXN0Q29kZWM6IGF1ZGlvQ29kZWMsIGR1cmF0aW9uOiBkdXJhdGlvbiwgaW5wdXRUaW1lU2NhbGU6IDkwMDAwIH07XG4gICAgfTtcbiAgICBNUDNEZW11eGVyLnByb3RvdHlwZS5yZXNldFRpbWVTdGFtcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB9O1xuICAgIE1QM0RlbXV4ZXIucHJvYmUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAvLyBjaGVjayBpZiBkYXRhIGNvbnRhaW5zIElEMyB0aW1lc3RhbXAgYW5kIE1QRUcgc3luYyB3b3JkXG4gICAgICAgIHZhciBvZmZzZXQsIGxlbmd0aDtcbiAgICAgICAgdmFyIGlkM0RhdGEgPSBpZDNfMS5kZWZhdWx0LmdldElEM0RhdGEoZGF0YSwgMCk7XG4gICAgICAgIGlmIChpZDNEYXRhICYmIGlkM18xLmRlZmF1bHQuZ2V0VGltZVN0YW1wKGlkM0RhdGEpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIExvb2sgZm9yIE1QRUcgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExWCBYWVpYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMSBhbmQgWSBvciBaIHNob3VsZCBiZSAxXG4gICAgICAgICAgICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIGRpZmZlcmVudCBmcm9tIDAgKExheWVyIEkgb3IgTGF5ZXIgSUkgb3IgTGF5ZXIgSUlJKVxuICAgICAgICAgICAgLy8gTW9yZSBpbmZvIGh0dHA6Ly93d3cubXAzLXRlY2gub3JnL3Byb2dyYW1tZXIvZnJhbWVfaGVhZGVyLmh0bWxcbiAgICAgICAgICAgIGZvciAob2Zmc2V0ID0gaWQzRGF0YS5sZW5ndGgsIGxlbmd0aCA9IE1hdGgubWluKGRhdGEubGVuZ3RoIC0gMSwgb2Zmc2V0ICsgMTAwKTsgb2Zmc2V0IDwgbGVuZ3RoOyBvZmZzZXQrKykge1xuICAgICAgICAgICAgICAgIGlmIChtcGVnYXVkaW9fMS5kZWZhdWx0LnByb2JlKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnTVBFRyBBdWRpbyBzeW5jIHdvcmQgZm91bmQgIScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLy8gZmVlZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBmcm9udCBvZiB0aGUgcGFyc2luZyBwaXBlbGluZVxuICAgIE1QM0RlbXV4ZXIucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChkYXRhLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICAgICAgdmFyIGlkM0RhdGEgPSBpZDNfMS5kZWZhdWx0LmdldElEM0RhdGEoZGF0YSwgMCk7XG4gICAgICAgIHZhciB0aW1lc3RhbXAgPSBpZDNfMS5kZWZhdWx0LmdldFRpbWVTdGFtcChpZDNEYXRhKTtcbiAgICAgICAgdmFyIHB0cyA9IHRpbWVzdGFtcCA/IDkwICogdGltZXN0YW1wIDogdGltZU9mZnNldCAqIDkwMDAwO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gaWQzRGF0YS5sZW5ndGg7XG4gICAgICAgIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdmFyIGZyYW1lSW5kZXggPSAwLCBzdGFtcCA9IDA7XG4gICAgICAgIHZhciB0cmFjayA9IHRoaXMuX2F1ZGlvVHJhY2s7XG4gICAgICAgIHZhciBpZDNTYW1wbGVzID0gW3sgcHRzOiBwdHMsIGR0czogcHRzLCBkYXRhOiBpZDNEYXRhIH1dO1xuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobXBlZ2F1ZGlvXzEuZGVmYXVsdC5pc0hlYWRlcihkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gbXBlZ2F1ZGlvXzEuZGVmYXVsdC5hcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0LCBwdHMsIGZyYW1lSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gZnJhbWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBzdGFtcCA9IGZyYW1lLnNhbXBsZS5wdHM7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lSW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ1VuYWJsZSB0byBwYXJzZSBNcGVnIGF1ZGlvIGZyYW1lJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlkM18xLmRlZmF1bHQuaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIGlkM0RhdGEgPSBpZDNfMS5kZWZhdWx0LmdldElEM0RhdGEoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZDNTYW1wbGVzLnB1c2goeyBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wLCBkYXRhOiBpZDNEYXRhIH0pO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBpZDNEYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcgZm91bmQsIGtlZXAgbG9va2luZ1xuICAgICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtdXhlci5yZW11eCh0cmFjaywgeyBzYW1wbGVzOiBbXSB9LCB7IHNhbXBsZXM6IGlkM1NhbXBsZXMsIGlucHV0VGltZVNjYWxlOiA5MDAwMCB9LCB7IHNhbXBsZXM6IFtdIH0sIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgfTtcbiAgICBNUDNEZW11eGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIH07XG4gICAgcmV0dXJuIE1QM0RlbXV4ZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTVAzRGVtdXhlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC9tcDRkZW11eGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvbXA0ZGVtdXhlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIE1QNCBkZW11eGVyXG4gKi9cbnZhciBsb2dnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci5qc1wiKTtcbnZhciBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy5qc1wiKTtcbnZhciBVSU5UMzJfTUFYID0gTWF0aC5wb3coMiwgMzIpIC0gMTtcbnZhciBNUDREZW11eGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1QNERlbXV4ZXIob2JzZXJ2ZXIsIHJlbXV4ZXIpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgICAgICB0aGlzLnJlbXV4ZXIgPSByZW11eGVyO1xuICAgIH1cbiAgICBNUDREZW11eGVyLnByb3RvdHlwZS5yZXNldFRpbWVTdGFtcCA9IGZ1bmN0aW9uIChpbml0UFRTKSB7XG4gICAgICAgIHRoaXMuaW5pdFBUUyA9IGluaXRQVFM7XG4gICAgfTtcbiAgICBNUDREZW11eGVyLnByb3RvdHlwZS5yZXNldEluaXRTZWdtZW50ID0gZnVuY3Rpb24gKGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkdXJhdGlvbikge1xuICAgICAgICAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gICAgICAgIGlmIChpbml0U2VnbWVudCAmJiBpbml0U2VnbWVudC5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhID0gTVA0RGVtdXhlci5wYXJzZUluaXRTZWdtZW50KGluaXRTZWdtZW50KTtcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgYXVkaW8gY29kZWMgaWYgbm90aGluZyBzcGVjaWZpZWRcbiAgICAgICAgICAgIC8vIFRPRE8gOiBleHRyYWN0IHRoYXQgZnJvbSBpbml0c2VnbWVudFxuICAgICAgICAgICAgaWYgKGF1ZGlvQ29kZWMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC41JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aWRlb0NvZGVjID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2aWRlb0NvZGVjID0gJ2F2YzEuNDJlMDFlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0cmFja3MgPSB7fTtcbiAgICAgICAgICAgIGlmIChpbml0RGF0YS5hdWRpbyAmJiBpbml0RGF0YS52aWRlbykge1xuICAgICAgICAgICAgICAgIHRyYWNrcy5hdWRpb3ZpZGVvID0geyBjb250YWluZXI6ICd2aWRlby9tcDQnLCBjb2RlYzogYXVkaW9Db2RlYyArICcsJyArIHZpZGVvQ29kZWMsIGluaXRTZWdtZW50OiBkdXJhdGlvbiA/IGluaXRTZWdtZW50IDogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGluaXREYXRhLmF1ZGlvKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrcy5hdWRpbyA9IHsgY29udGFpbmVyOiAnYXVkaW8vbXA0JywgY29kZWM6IGF1ZGlvQ29kZWMsIGluaXRTZWdtZW50OiBkdXJhdGlvbiA/IGluaXRTZWdtZW50IDogbnVsbCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5pdERhdGEudmlkZW8pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tzLnZpZGVvID0geyBjb250YWluZXI6ICd2aWRlby9tcDQnLCBjb2RlYzogdmlkZW9Db2RlYywgaW5pdFNlZ21lbnQ6IGR1cmF0aW9uID8gaW5pdFNlZ21lbnQgOiBudWxsIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCwgeyB0cmFja3M6IHRyYWNrcyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhdWRpb0NvZGVjKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb0NvZGVjID0gYXVkaW9Db2RlYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aWRlb0NvZGVjKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWRlb0NvZGVjID0gdmlkZW9Db2RlYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTVA0RGVtdXhlci5wcm9iZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIGVuc3VyZSB3ZSBmaW5kIGEgbW9vZiBib3ggaW4gdGhlIGZpcnN0IDE2IGtCXG4gICAgICAgIHJldHVybiBNUDREZW11eGVyLmZpbmRCb3goeyBkYXRhOiBkYXRhLCBzdGFydDogMCwgZW5kOiBNYXRoLm1pbihkYXRhLmxlbmd0aCwgMTYzODQpIH0sIFsnbW9vZiddKS5sZW5ndGggPiAwO1xuICAgIH07XG4gICAgTVA0RGVtdXhlci5iaW4yc3RyID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBidWZmZXIpO1xuICAgIH07XG4gICAgTVA0RGVtdXhlci5yZWFkVWludDE2ID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgICAgIGlmIChidWZmZXIuZGF0YSkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGJ1ZmZlci5zdGFydDtcbiAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWwgPSBidWZmZXJbb2Zmc2V0XSA8PCA4IHxcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyAxXTtcbiAgICAgICAgcmV0dXJuIHZhbCA8IDAgPyA2NTUzNiArIHZhbCA6IHZhbDtcbiAgICB9O1xuICAgIE1QNERlbXV4ZXIucmVhZFVpbnQzMiA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCkge1xuICAgICAgICBpZiAoYnVmZmVyLmRhdGEpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSBidWZmZXIuc3RhcnQ7XG4gICAgICAgICAgICBidWZmZXIgPSBidWZmZXIuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsID0gYnVmZmVyW29mZnNldF0gPDwgMjQgfFxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIDFdIDw8IDE2IHxcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyAyXSA8PCA4IHxcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyAzXTtcbiAgICAgICAgcmV0dXJuIHZhbCA8IDAgPyA0Mjk0OTY3Mjk2ICsgdmFsIDogdmFsO1xuICAgIH07XG4gICAgTVA0RGVtdXhlci53cml0ZVVpbnQzMiA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGJ1ZmZlci5kYXRhKSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gYnVmZmVyLnN0YXJ0O1xuICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyW29mZnNldF0gPSB2YWx1ZSA+PiAyNDtcbiAgICAgICAgYnVmZmVyW29mZnNldCArIDFdID0gKHZhbHVlID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+PiA4KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltvZmZzZXQgKyAzXSA9IHZhbHVlICYgMHhmZjtcbiAgICB9O1xuICAgIC8vIEZpbmQgdGhlIGRhdGEgZm9yIGEgYm94IHNwZWNpZmllZCBieSBpdHMgcGF0aFxuICAgIE1QNERlbXV4ZXIuZmluZEJveCA9IGZ1bmN0aW9uIChkYXRhLCBwYXRoKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW10sIGksIHNpemUsIHR5cGUsIGVuZCwgc3VicmVzdWx0cywgc3RhcnQsIGVuZGJveDtcbiAgICAgICAgaWYgKGRhdGEuZGF0YSkge1xuICAgICAgICAgICAgc3RhcnQgPSBkYXRhLnN0YXJ0O1xuICAgICAgICAgICAgZW5kID0gZGF0YS5lbmQ7XG4gICAgICAgICAgICBkYXRhID0gZGF0YS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgICAgZW5kID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHNob3J0LWNpcmN1aXQgdGhlIHNlYXJjaCBmb3IgZW1wdHkgcGF0aHNcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOykge1xuICAgICAgICAgICAgc2l6ZSA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMihkYXRhLCBpKTtcbiAgICAgICAgICAgIHR5cGUgPSBNUDREZW11eGVyLmJpbjJzdHIoZGF0YS5zdWJhcnJheShpICsgNCwgaSArIDgpKTtcbiAgICAgICAgICAgIGVuZGJveCA9IHNpemUgPiAxID8gaSArIHNpemUgOiBlbmQ7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gcGF0aFswXSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBlbmQgb2YgdGhlIHBhdGggYW5kIHdlJ3ZlIGZvdW5kIHRoZSBib3ggd2Ugd2VyZVxuICAgICAgICAgICAgICAgICAgICAvLyBsb29raW5nIGZvclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goeyBkYXRhOiBkYXRhLCBzdGFydDogaSArIDgsIGVuZDogZW5kYm94IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciB0aGUgbmV4dCBib3ggYWxvbmcgdGhlIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgc3VicmVzdWx0cyA9IE1QNERlbXV4ZXIuZmluZEJveCh7IGRhdGE6IGRhdGEsIHN0YXJ0OiBpICsgOCwgZW5kOiBlbmRib3ggfSwgcGF0aC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJyZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KHN1YnJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSA9IGVuZGJveDtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSd2ZSBmaW5pc2hlZCBzZWFyY2hpbmcgYWxsIG9mIGRhdGFcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBNUDREZW11eGVyLnBhcnNlU2VnbWVudEluZGV4ID0gZnVuY3Rpb24gKGluaXRTZWdtZW50KSB7XG4gICAgICAgIHZhciBtb292ID0gTVA0RGVtdXhlci5maW5kQm94KGluaXRTZWdtZW50LCBbJ21vb3YnXSlbMF07XG4gICAgICAgIHZhciBtb292RW5kT2Zmc2V0ID0gbW9vdiA/IG1vb3YuZW5kIDogbnVsbDsgLy8gd2UgbmVlZCB0aGlzIGluIGNhc2Ugd2UgbmVlZCB0byBjaG9wIG9mIGdhcmJhZ2Ugb2YgdGhlIGVuZCBvZiBjdXJyZW50IGRhdGFcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIHNpZHggPSBNUDREZW11eGVyLmZpbmRCb3goaW5pdFNlZ21lbnQsIFsnc2lkeCddKTtcbiAgICAgICAgdmFyIHJlZmVyZW5jZXM7XG4gICAgICAgIGlmICghc2lkeCB8fCAhc2lkeFswXSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmVmZXJlbmNlcyA9IFtdO1xuICAgICAgICBzaWR4ID0gc2lkeFswXTtcbiAgICAgICAgdmFyIHZlcnNpb24gPSBzaWR4LmRhdGFbMF07XG4gICAgICAgIC8vIHNldCBpbml0aWFsIG9mZnNldCwgd2Ugc2tpcCB0aGUgcmVmZXJlbmNlIElEIChub3QgbmVlZGVkKVxuICAgICAgICBpbmRleCA9IHZlcnNpb24gPT09IDAgPyA4IDogMTY7XG4gICAgICAgIHZhciB0aW1lc2NhbGUgPSBNUDREZW11eGVyLnJlYWRVaW50MzIoc2lkeCwgaW5kZXgpO1xuICAgICAgICBpbmRleCArPSA0O1xuICAgICAgICAvLyBUT0RPOiBwYXJzZSBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUgYW5kIGZpcnN0T2Zmc2V0XG4gICAgICAgIC8vIHVzdWFsbHkgemVybyBpbiBvdXIgY2FzZVxuICAgICAgICB2YXIgZWFybGllc3RQcmVzZW50YXRpb25UaW1lID0gMDtcbiAgICAgICAgdmFyIGZpcnN0T2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICAgIGluZGV4ICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbmRleCArPSAxNjtcbiAgICAgICAgfVxuICAgICAgICAvLyBza2lwIHJlc2VydmVkXG4gICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgIHZhciBzdGFydEJ5dGUgPSBzaWR4LmVuZCArIGZpcnN0T2Zmc2V0O1xuICAgICAgICB2YXIgcmVmZXJlbmNlc0NvdW50ID0gTVA0RGVtdXhlci5yZWFkVWludDE2KHNpZHgsIGluZGV4KTtcbiAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWZlcmVuY2VzQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJlZmVyZW5jZUluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICB2YXIgcmVmZXJlbmNlSW5mbyA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMihzaWR4LCByZWZlcmVuY2VJbmRleCk7XG4gICAgICAgICAgICByZWZlcmVuY2VJbmRleCArPSA0O1xuICAgICAgICAgICAgdmFyIHJlZmVyZW5jZVNpemUgPSByZWZlcmVuY2VJbmZvICYgMHg3RkZGRkZGRjtcbiAgICAgICAgICAgIHZhciByZWZlcmVuY2VUeXBlID0gKHJlZmVyZW5jZUluZm8gJiAweDgwMDAwMDAwKSA+Pj4gMzE7XG4gICAgICAgICAgICBpZiAocmVmZXJlbmNlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignU0lEWCBoYXMgaGllcmFyY2hpY2FsIHJlZmVyZW5jZXMgKG5vdCBzdXBwb3J0ZWQpJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN1YnNlZ21lbnREdXJhdGlvbiA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMihzaWR4LCByZWZlcmVuY2VJbmRleCk7XG4gICAgICAgICAgICByZWZlcmVuY2VJbmRleCArPSA0O1xuICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VTaXplOiByZWZlcmVuY2VTaXplLFxuICAgICAgICAgICAgICAgIHN1YnNlZ21lbnREdXJhdGlvbjogc3Vic2VnbWVudER1cmF0aW9uLFxuICAgICAgICAgICAgICAgIGluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IHN1YnNlZ21lbnREdXJhdGlvbiAvIHRpbWVzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0Qnl0ZSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBzdGFydEJ5dGUgKyByZWZlcmVuY2VTaXplIC0gMVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhcnRCeXRlICs9IHJlZmVyZW5jZVNpemU7XG4gICAgICAgICAgICAvLyBTa2lwcGluZyAxIGJpdCBmb3IgfHN0YXJ0c1dpdGhTYXB8LCAzIGJpdHMgZm9yIHxzYXBUeXBlfCwgYW5kIDI4IGJpdHNcbiAgICAgICAgICAgIC8vIGZvciB8c2FwRGVsdGF8LlxuICAgICAgICAgICAgcmVmZXJlbmNlSW5kZXggKz0gNDtcbiAgICAgICAgICAgIC8vIHNraXAgdG8gbmV4dCByZWZcbiAgICAgICAgICAgIGluZGV4ID0gcmVmZXJlbmNlSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVhcmxpZXN0UHJlc2VudGF0aW9uVGltZTogZWFybGllc3RQcmVzZW50YXRpb25UaW1lLFxuICAgICAgICAgICAgdGltZXNjYWxlOiB0aW1lc2NhbGUsXG4gICAgICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICAgICAgICAgICAgcmVmZXJlbmNlc0NvdW50OiByZWZlcmVuY2VzQ291bnQsXG4gICAgICAgICAgICByZWZlcmVuY2VzOiByZWZlcmVuY2VzLFxuICAgICAgICAgICAgbW9vdkVuZE9mZnNldDogbW9vdkVuZE9mZnNldFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGFuIE1QNCBpbml0aWFsaXphdGlvbiBzZWdtZW50IGFuZCBleHRyYWN0cyBzdHJlYW0gdHlwZSBhbmRcbiAgICAgKiB0aW1lc2NhbGUgdmFsdWVzIGZvciBhbnkgZGVjbGFyZWQgdHJhY2tzLiBUaW1lc2NhbGUgdmFsdWVzIGluZGljYXRlIHRoZVxuICAgICAqIG51bWJlciBvZiBjbG9jayB0aWNrcyBwZXIgc2Vjb25kIHRvIGFzc3VtZSBmb3IgdGltZS1iYXNlZCB2YWx1ZXNcbiAgICAgKiBlbHNld2hlcmUgaW4gdGhlIE1QNC5cbiAgICAgKlxuICAgICAqIFRvIGRldGVybWluZSB0aGUgc3RhcnQgdGltZSBvZiBhbiBNUDQsIHlvdSBuZWVkIHR3byBwaWVjZXMgb2ZcbiAgICAgKiBpbmZvcm1hdGlvbjogdGhlIHRpbWVzY2FsZSB1bml0IGFuZCB0aGUgZWFybGllc3QgYmFzZSBtZWRpYSBkZWNvZGVcbiAgICAgKiB0aW1lLiBNdWx0aXBsZSB0aW1lc2NhbGVzIGNhbiBiZSBzcGVjaWZpZWQgd2l0aGluIGFuIE1QNCBidXQgdGhlXG4gICAgICogYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBpcyBhbHdheXMgZXhwcmVzc2VkIGluIHRoZSB0aW1lc2NhbGUgZnJvbVxuICAgICAqIHRoZSBtZWRpYSBoZWFkZXIgYm94IGZvciB0aGUgdHJhY2s6XG4gICAgICogYGBgXG4gICAgICogbW9vdiA+IHRyYWsgPiBtZGlhID4gbWRoZC50aW1lc2NhbGVcbiAgICAgKiBtb292ID4gdHJhayA+IG1kaWEgPiBoZGxyXG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIGluaXQge1VpbnQ4QXJyYXl9IHRoZSBieXRlcyBvZiB0aGUgaW5pdCBzZWdtZW50XG4gICAgICogQHJldHVybiB7b2JqZWN0fSBhIGhhc2ggb2YgdHJhY2sgdHlwZSB0byB0aW1lc2NhbGUgdmFsdWVzIG9yIG51bGwgaWZcbiAgICAgKiB0aGUgaW5pdCBzZWdtZW50IGlzIG1hbGZvcm1lZC5cbiAgICAgKi9cbiAgICBNUDREZW11eGVyLnBhcnNlSW5pdFNlZ21lbnQgPSBmdW5jdGlvbiAoaW5pdFNlZ21lbnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgdHJha3MgPSBNUDREZW11eGVyLmZpbmRCb3goaW5pdFNlZ21lbnQsIFsnbW9vdicsICd0cmFrJ10pO1xuICAgICAgICB0cmFrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFrKSB7XG4gICAgICAgICAgICB2YXIgdGtoZCA9IE1QNERlbXV4ZXIuZmluZEJveCh0cmFrLCBbJ3RraGQnXSlbMF07XG4gICAgICAgICAgICBpZiAodGtoZCkge1xuICAgICAgICAgICAgICAgIHZhciB2ZXJzaW9uID0gdGtoZC5kYXRhW3RraGQuc3RhcnRdO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHZlcnNpb24gPT09IDAgPyAxMiA6IDIwO1xuICAgICAgICAgICAgICAgIHZhciB0cmFja0lkID0gTVA0RGVtdXhlci5yZWFkVWludDMyKHRraGQsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB2YXIgbWRoZCA9IE1QNERlbXV4ZXIuZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnbWRoZCddKVswXTtcbiAgICAgICAgICAgICAgICBpZiAobWRoZCkge1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uID0gbWRoZC5kYXRhW21kaGQuc3RhcnRdO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHZlcnNpb24gPT09IDAgPyAxMiA6IDIwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZXNjYWxlID0gTVA0RGVtdXhlci5yZWFkVWludDMyKG1kaGQsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhkbHIgPSBNUDREZW11eGVyLmZpbmRCb3godHJhaywgWydtZGlhJywgJ2hkbHInXSlbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChoZGxyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGRsclR5cGUgPSBNUDREZW11eGVyLmJpbjJzdHIoaGRsci5kYXRhLnN1YmFycmF5KGhkbHIuc3RhcnQgKyA4LCBoZGxyLnN0YXJ0ICsgMTIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0geyAnc291bic6ICdhdWRpbycsICd2aWRlJzogJ3ZpZGVvJyB9W2hkbHJUeXBlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXh0cmFjdCBjb2RlYyBpbmZvLiBUT0RPIDogcGFyc2UgY29kZWMgZGV0YWlscyB0byBiZSBhYmxlIHRvIGJ1aWxkIE1JTUUgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2RlY0JveCA9IE1QNERlbXV4ZXIuZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnbWluZicsICdzdGJsJywgJ3N0c2QnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGVjQm94Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlY0JveCA9IGNvZGVjQm94WzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29kZWNUeXBlID0gTVA0RGVtdXhlci5iaW4yc3RyKGNvZGVjQm94LmRhdGEuc3ViYXJyYXkoY29kZWNCb3guc3RhcnQgKyAxMiwgY29kZWNCb3guc3RhcnQgKyAxNikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiTVA0RGVtdXhlcjpcIiArIHR5cGUgKyBcIjpcIiArIGNvZGVjVHlwZSArIFwiIGZvdW5kXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbdHJhY2tJZF0gPSB7IHRpbWVzY2FsZTogdGltZXNjYWxlLCB0eXBlOiB0eXBlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3R5cGVdID0geyB0aW1lc2NhbGU6IHRpbWVzY2FsZSwgaWQ6IHRyYWNrSWQgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSBiYXNlIG1lZGlhIGRlY29kZSBzdGFydCB0aW1lLCBpbiBzZWNvbmRzLCBmb3IgYW4gTVA0XG4gICAqIGZyYWdtZW50LiBJZiBtdWx0aXBsZSBmcmFnbWVudHMgYXJlIHNwZWNpZmllZCwgdGhlIGVhcmxpZXN0IHRpbWUgaXNcbiAgICogcmV0dXJuZWQuXG4gICAqXG4gICAqIFRoZSBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGNhbiBiZSBwYXJzZWQgZnJvbSB0cmFjayBmcmFnbWVudFxuICAgKiBtZXRhZGF0YTpcbiAgICogYGBgXG4gICAqIG1vb2YgPiB0cmFmID4gdGZkdC5iYXNlTWVkaWFEZWNvZGVUaW1lXG4gICAqIGBgYFxuICAgKiBJdCByZXF1aXJlcyB0aGUgdGltZXNjYWxlIHZhbHVlIGZyb20gdGhlIG1kaGQgdG8gaW50ZXJwcmV0LlxuICAgKlxuICAgKiBAcGFyYW0gdGltZXNjYWxlIHtvYmplY3R9IGEgaGFzaCBvZiB0cmFjayBpZHMgdG8gdGltZXNjYWxlIHZhbHVlcy5cbiAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgZWFybGllc3QgYmFzZSBtZWRpYSBkZWNvZGUgc3RhcnQgdGltZSBmb3IgdGhlXG4gICAqIGZyYWdtZW50LCBpbiBzZWNvbmRzXG4gICAqL1xuICAgIE1QNERlbXV4ZXIuZ2V0U3RhcnREVFMgPSBmdW5jdGlvbiAoaW5pdERhdGEsIGZyYWdtZW50KSB7XG4gICAgICAgIHZhciB0cmFmcywgYmFzZVRpbWVzLCByZXN1bHQ7XG4gICAgICAgIC8vIHdlIG5lZWQgaW5mbyBmcm9tIHR3byBjaGlsZHJlbmQgb2YgZWFjaCB0cmFjayBmcmFnbWVudCBib3hcbiAgICAgICAgdHJhZnMgPSBNUDREZW11eGVyLmZpbmRCb3goZnJhZ21lbnQsIFsnbW9vZicsICd0cmFmJ10pO1xuICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIHN0YXJ0IHRpbWVzIGZvciBlYWNoIHRyYWNrXG4gICAgICAgIGJhc2VUaW1lcyA9IFtdLmNvbmNhdC5hcHBseShbXSwgdHJhZnMubWFwKGZ1bmN0aW9uICh0cmFmKSB7XG4gICAgICAgICAgICByZXR1cm4gTVA0RGVtdXhlci5maW5kQm94KHRyYWYsIFsndGZoZCddKS5tYXAoZnVuY3Rpb24gKHRmaGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQsIHNjYWxlLCBiYXNlVGltZTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHRyYWNrIGlkIGZyb20gdGhlIHRmaGRcbiAgICAgICAgICAgICAgICBpZCA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMih0ZmhkLCA0KTtcbiAgICAgICAgICAgICAgICAvLyBhc3N1bWUgYSA5MGtIeiBjbG9jayBpZiBubyB0aW1lc2NhbGUgd2FzIHNwZWNpZmllZFxuICAgICAgICAgICAgICAgIHNjYWxlID0gaW5pdERhdGFbaWRdLnRpbWVzY2FsZSB8fCA5MGUzO1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBmcm9tIHRoZSB0ZmR0XG4gICAgICAgICAgICAgICAgYmFzZVRpbWUgPSBNUDREZW11eGVyLmZpbmRCb3godHJhZiwgWyd0ZmR0J10pLm1hcChmdW5jdGlvbiAodGZkdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmVyc2lvbiwgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uID0gdGZkdC5kYXRhW3RmZHQuc3RhcnRdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBNUDREZW11eGVyLnJlYWRVaW50MzIodGZkdCwgNCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKj0gTWF0aC5wb3coMiwgMzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IE1QNERlbXV4ZXIucmVhZFVpbnQzMih0ZmR0LCA4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pWzBdO1xuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgYmFzZSB0aW1lIHRvIHNlY29uZHNcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVRpbWUgLyBzY2FsZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSk7XG4gICAgICAgIC8vIHJldHVybiB0aGUgbWluaW11bVxuICAgICAgICByZXN1bHQgPSBNYXRoLm1pbi5hcHBseShudWxsLCBiYXNlVGltZXMpO1xuICAgICAgICByZXR1cm4gaXNGaW5pdGUocmVzdWx0KSA/IHJlc3VsdCA6IDA7XG4gICAgfTtcbiAgICBNUDREZW11eGVyLm9mZnNldFN0YXJ0RFRTID0gZnVuY3Rpb24gKGluaXREYXRhLCBmcmFnbWVudCwgdGltZU9mZnNldCkge1xuICAgICAgICBNUDREZW11eGVyLmZpbmRCb3goZnJhZ21lbnQsIFsnbW9vZicsICd0cmFmJ10pLm1hcChmdW5jdGlvbiAodHJhZikge1xuICAgICAgICAgICAgcmV0dXJuIE1QNERlbXV4ZXIuZmluZEJveCh0cmFmLCBbJ3RmaGQnXSkubWFwKGZ1bmN0aW9uICh0ZmhkKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSB0cmFjayBpZCBmcm9tIHRoZSB0ZmhkXG4gICAgICAgICAgICAgICAgdmFyIGlkID0gTVA0RGVtdXhlci5yZWFkVWludDMyKHRmaGQsIDQpO1xuICAgICAgICAgICAgICAgIC8vIGFzc3VtZSBhIDkwa0h6IGNsb2NrIGlmIG5vIHRpbWVzY2FsZSB3YXMgc3BlY2lmaWVkXG4gICAgICAgICAgICAgICAgdmFyIHRpbWVzY2FsZSA9IGluaXREYXRhW2lkXS50aW1lc2NhbGUgfHwgOTBlMztcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgZnJvbSB0aGUgdGZkdFxuICAgICAgICAgICAgICAgIE1QNERlbXV4ZXIuZmluZEJveCh0cmFmLCBbJ3RmZHQnXSkubWFwKGZ1bmN0aW9uICh0ZmR0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ZXJzaW9uID0gdGZkdC5kYXRhW3RmZHQuc3RhcnRdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZU1lZGlhRGVjb2RlVGltZSA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMih0ZmR0LCA0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1QNERlbXV4ZXIud3JpdGVVaW50MzIodGZkdCwgNCwgYmFzZU1lZGlhRGVjb2RlVGltZSAtIHRpbWVPZmZzZXQgKiB0aW1lc2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSAqPSBNYXRoLnBvdygyLCAzMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lICs9IE1QNERlbXV4ZXIucmVhZFVpbnQzMih0ZmR0LCA4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgLT0gdGltZU9mZnNldCAqIHRpbWVzY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgPSBNYXRoLm1heChiYXNlTWVkaWFEZWNvZGVUaW1lLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cHBlciA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvd2VyID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBNUDREZW11eGVyLndyaXRlVWludDMyKHRmZHQsIDQsIHVwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1QNERlbXV4ZXIud3JpdGVVaW50MzIodGZkdCwgOCwgbG93ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBmZWVkIGluY29taW5nIGRhdGEgdG8gdGhlIGZyb250IG9mIHRoZSBwYXJzaW5nIHBpcGVsaW5lXG4gICAgTVA0RGVtdXhlci5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKGRhdGEsIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgICAgICB2YXIgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhO1xuICAgICAgICBpZiAoIWluaXREYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0SW5pdFNlZ21lbnQoZGF0YSwgdGhpcy5hdWRpb0NvZGVjLCB0aGlzLnZpZGVvQ29kZWMsIGZhbHNlKTtcbiAgICAgICAgICAgIGluaXREYXRhID0gdGhpcy5pbml0RGF0YTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnREVFMsIGluaXRQVFMgPSB0aGlzLmluaXRQVFM7XG4gICAgICAgIGlmIChpbml0UFRTID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBzdGFydERUU18xID0gTVA0RGVtdXhlci5nZXRTdGFydERUUyhpbml0RGF0YSwgZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmluaXRQVFMgPSBpbml0UFRTID0gc3RhcnREVFNfMSAtIHRpbWVPZmZzZXQ7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5JTklUX1BUU19GT1VORCwgeyBpbml0UFRTOiBpbml0UFRTIH0pO1xuICAgICAgICB9XG4gICAgICAgIE1QNERlbXV4ZXIub2Zmc2V0U3RhcnREVFMoaW5pdERhdGEsIGRhdGEsIGluaXRQVFMpO1xuICAgICAgICBzdGFydERUUyA9IE1QNERlbXV4ZXIuZ2V0U3RhcnREVFMoaW5pdERhdGEsIGRhdGEpO1xuICAgICAgICB0aGlzLnJlbXV4ZXIucmVtdXgoaW5pdERhdGEuYXVkaW8sIGluaXREYXRhLnZpZGVvLCBudWxsLCBudWxsLCBzdGFydERUUywgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0LCBkYXRhKTtcbiAgICB9O1xuICAgIE1QNERlbXV4ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgcmV0dXJuIE1QNERlbXV4ZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTVA0RGVtdXhlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC9tcGVnYXVkaW8uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RlbXV4L21wZWdhdWRpby5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogIE1QRUcgcGFyc2VyIGhlbHBlclxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTXBlZ0F1ZGlvID0ge1xuICAgIEJpdHJhdGVzTWFwOiBbXG4gICAgICAgIDMyLCA2NCwgOTYsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAyODgsIDMyMCwgMzUyLCAzODQsIDQxNiwgNDQ4LFxuICAgICAgICAzMiwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAzMjAsIDM4NCxcbiAgICAgICAgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDMyMCxcbiAgICAgICAgMzIsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE0NCwgMTYwLCAxNzYsIDE5MiwgMjI0LCAyNTYsXG4gICAgICAgIDgsIDE2LCAyNCwgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNDQsIDE2MFxuICAgIF0sXG4gICAgU2FtcGxpbmdSYXRlTWFwOiBbNDQxMDAsIDQ4MDAwLCAzMjAwMCwgMjIwNTAsIDI0MDAwLCAxNjAwMCwgMTEwMjUsIDEyMDAwLCA4MDAwXSxcbiAgICBTYW1wbGVzQ29lZmZpY2llbnRzOiBbXG4gICAgICAgIC8vIE1QRUcgMi41XG4gICAgICAgIFtcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICA3MixcbiAgICAgICAgICAgIDE0NCxcbiAgICAgICAgICAgIDEyIC8vIExheWVyMVxuICAgICAgICBdLFxuICAgICAgICAvLyBSZXNlcnZlZFxuICAgICAgICBbXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwIC8vIExheWVyMVxuICAgICAgICBdLFxuICAgICAgICAvLyBNUEVHIDJcbiAgICAgICAgW1xuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDcyLFxuICAgICAgICAgICAgMTQ0LFxuICAgICAgICAgICAgMTIgLy8gTGF5ZXIxXG4gICAgICAgIF0sXG4gICAgICAgIC8vIE1QRUcgMVxuICAgICAgICBbXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMTQ0LFxuICAgICAgICAgICAgMTQ0LFxuICAgICAgICAgICAgMTIgLy8gTGF5ZXIxXG4gICAgICAgIF1cbiAgICBdLFxuICAgIEJ5dGVzSW5TbG90OiBbXG4gICAgICAgIDAsXG4gICAgICAgIDEsXG4gICAgICAgIDEsXG4gICAgICAgIDQgLy8gTGF5ZXIxXG4gICAgXSxcbiAgICBhcHBlbmRGcmFtZTogZnVuY3Rpb24gKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCkge1xuICAgICAgICAvLyBVc2luZyBodHRwOi8vd3d3LmRhdGF2b3lhZ2UuY29tL21wZ3NjcmlwdC9tcGVnaGRyLmh0bSBhcyBhIHJlZmVyZW5jZVxuICAgICAgICBpZiAob2Zmc2V0ICsgMjQgPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVhZGVyID0gdGhpcy5wYXJzZUhlYWRlcihkYXRhLCBvZmZzZXQpO1xuICAgICAgICBpZiAoaGVhZGVyICYmIG9mZnNldCArIGhlYWRlci5mcmFtZUxlbmd0aCA8PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGZyYW1lRHVyYXRpb24gPSBoZWFkZXIuc2FtcGxlc1BlckZyYW1lICogOTAwMDAgLyBoZWFkZXIuc2FtcGxlUmF0ZTtcbiAgICAgICAgICAgIHZhciBzdGFtcCA9IHB0cyArIGZyYW1lSW5kZXggKiBmcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgdmFyIHNhbXBsZSA9IHsgdW5pdDogZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGhlYWRlci5mcmFtZUxlbmd0aCksIHB0czogc3RhbXAsIGR0czogc3RhbXAgfTtcbiAgICAgICAgICAgIHRyYWNrLmNvbmZpZyA9IFtdO1xuICAgICAgICAgICAgdHJhY2suY2hhbm5lbENvdW50ID0gaGVhZGVyLmNoYW5uZWxDb3VudDtcbiAgICAgICAgICAgIHRyYWNrLnNhbXBsZXJhdGUgPSBoZWFkZXIuc2FtcGxlUmF0ZTtcbiAgICAgICAgICAgIHRyYWNrLnNhbXBsZXMucHVzaChzYW1wbGUpO1xuICAgICAgICAgICAgdHJhY2subGVuICs9IGhlYWRlci5mcmFtZUxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiB7IHNhbXBsZTogc2FtcGxlLCBsZW5ndGg6IGhlYWRlci5mcmFtZUxlbmd0aCB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBwYXJzZUhlYWRlcjogZnVuY3Rpb24gKGRhdGEsIG9mZnNldCkge1xuICAgICAgICB2YXIgaGVhZGVyQiA9IChkYXRhW29mZnNldCArIDFdID4+IDMpICYgMztcbiAgICAgICAgdmFyIGhlYWRlckMgPSAoZGF0YVtvZmZzZXQgKyAxXSA+PiAxKSAmIDM7XG4gICAgICAgIHZhciBoZWFkZXJFID0gKGRhdGFbb2Zmc2V0ICsgMl0gPj4gNCkgJiAxNTtcbiAgICAgICAgdmFyIGhlYWRlckYgPSAoZGF0YVtvZmZzZXQgKyAyXSA+PiAyKSAmIDM7XG4gICAgICAgIHZhciBoZWFkZXJHID0gKGRhdGFbb2Zmc2V0ICsgMl0gPj4gMSkgJiAxO1xuICAgICAgICBpZiAoaGVhZGVyQiAhPT0gMSAmJiBoZWFkZXJFICE9PSAwICYmIGhlYWRlckUgIT09IDE1ICYmIGhlYWRlckYgIT09IDMpIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW5JbkJpdHJhdGVzID0gaGVhZGVyQiA9PT0gMyA/ICgzIC0gaGVhZGVyQykgOiAoaGVhZGVyQyA9PT0gMyA/IDMgOiA0KTtcbiAgICAgICAgICAgIHZhciBiaXRSYXRlID0gTXBlZ0F1ZGlvLkJpdHJhdGVzTWFwW2NvbHVtbkluQml0cmF0ZXMgKiAxNCArIGhlYWRlckUgLSAxXSAqIDEwMDA7XG4gICAgICAgICAgICB2YXIgY29sdW1uSW5TYW1wbGVSYXRlcyA9IGhlYWRlckIgPT09IDMgPyAwIDogaGVhZGVyQiA9PT0gMiA/IDEgOiAyO1xuICAgICAgICAgICAgdmFyIHNhbXBsZVJhdGUgPSBNcGVnQXVkaW8uU2FtcGxpbmdSYXRlTWFwW2NvbHVtbkluU2FtcGxlUmF0ZXMgKiAzICsgaGVhZGVyRl07XG4gICAgICAgICAgICB2YXIgY2hhbm5lbENvdW50ID0gZGF0YVtvZmZzZXQgKyAzXSA+PiA2ID09PSAzID8gMSA6IDI7IC8vIElmIGJpdHMgb2YgY2hhbm5lbCBtb2RlIGFyZSBgMTFgIHRoZW4gaXQgaXMgYSBzaW5nbGUgY2hhbm5lbCAoTW9ubylcbiAgICAgICAgICAgIHZhciBzYW1wbGVDb2VmZmljaWVudCA9IE1wZWdBdWRpby5TYW1wbGVzQ29lZmZpY2llbnRzW2hlYWRlckJdW2hlYWRlckNdO1xuICAgICAgICAgICAgdmFyIGJ5dGVzSW5TbG90ID0gTXBlZ0F1ZGlvLkJ5dGVzSW5TbG90W2hlYWRlckNdO1xuICAgICAgICAgICAgdmFyIHNhbXBsZXNQZXJGcmFtZSA9IHNhbXBsZUNvZWZmaWNpZW50ICogOCAqIGJ5dGVzSW5TbG90O1xuICAgICAgICAgICAgdmFyIGZyYW1lTGVuZ3RoID0gcGFyc2VJbnQoc2FtcGxlQ29lZmZpY2llbnQgKiBiaXRSYXRlIC8gc2FtcGxlUmF0ZSArIGhlYWRlckcsIDEwKSAqIGJ5dGVzSW5TbG90O1xuICAgICAgICAgICAgcmV0dXJuIHsgc2FtcGxlUmF0ZTogc2FtcGxlUmF0ZSwgY2hhbm5lbENvdW50OiBjaGFubmVsQ291bnQsIGZyYW1lTGVuZ3RoOiBmcmFtZUxlbmd0aCwgc2FtcGxlc1BlckZyYW1lOiBzYW1wbGVzUGVyRnJhbWUgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgaXNIZWFkZXJQYXR0ZXJuOiBmdW5jdGlvbiAoZGF0YSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBkYXRhW29mZnNldF0gPT09IDB4ZmYgJiYgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweGUwKSA9PT0gMHhlMCAmJiAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MDYpICE9PSAweDAwO1xuICAgIH0sXG4gICAgaXNIZWFkZXI6IGZ1bmN0aW9uIChkYXRhLCBvZmZzZXQpIHtcbiAgICAgICAgLy8gTG9vayBmb3IgTVBFRyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTFYIFhZWlggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxIGFuZCBZIG9yIFogc2hvdWxkIGJlIDFcbiAgICAgICAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyBkaWZmZXJlbnQgZnJvbSAwIChMYXllciBJIG9yIExheWVyIElJIG9yIExheWVyIElJSSlcbiAgICAgICAgLy8gTW9yZSBpbmZvIGh0dHA6Ly93d3cubXAzLXRlY2gub3JnL3Byb2dyYW1tZXIvZnJhbWVfaGVhZGVyLmh0bWxcbiAgICAgICAgaWYgKG9mZnNldCArIDEgPCBkYXRhLmxlbmd0aCAmJiB0aGlzLmlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBwcm9iZTogZnVuY3Rpb24gKGRhdGEsIG9mZnNldCkge1xuICAgICAgICAvLyBzYW1lIGFzIGlzSGVhZGVyIGJ1dCB3ZSBhbHNvIGNoZWNrIHRoYXQgTVBFRyBmcmFtZSBmb2xsb3dzIGxhc3QgTVBFRyBmcmFtZVxuICAgICAgICAvLyBvciBlbmQgb2YgZGF0YSBpcyByZWFjaGVkXG4gICAgICAgIGlmIChvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgdGhpcy5pc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgLy8gTVBFRyBoZWFkZXIgTGVuZ3RoXG4gICAgICAgICAgICB2YXIgaGVhZGVyTGVuZ3RoID0gNDtcbiAgICAgICAgICAgIC8vIE1QRUcgZnJhbWUgTGVuZ3RoXG4gICAgICAgICAgICB2YXIgaGVhZGVyID0gdGhpcy5wYXJzZUhlYWRlcihkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgdmFyIGZyYW1lTGVuZ3RoID0gaGVhZGVyTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGhlYWRlciAmJiBoZWFkZXIuZnJhbWVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmcmFtZUxlbmd0aCA9IGhlYWRlci5mcmFtZUxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXdPZmZzZXQgPSBvZmZzZXQgKyBmcmFtZUxlbmd0aDtcbiAgICAgICAgICAgIGlmIChuZXdPZmZzZXQgPT09IGRhdGEubGVuZ3RoIHx8IChuZXdPZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgdGhpcy5pc0hlYWRlclBhdHRlcm4oZGF0YSwgbmV3T2Zmc2V0KSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IE1wZWdBdWRpbztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC9zYW1wbGUtYWVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvc2FtcGxlLWFlcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFNBTVBMRS1BRVMgZGVjcnlwdGVyXG4qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRlY3J5cHRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vY3J5cHQvZGVjcnlwdGVyICovIFwiLi9zcmMvY3J5cHQvZGVjcnlwdGVyLmpzXCIpO1xudmFyIFNhbXBsZUFlc0RlY3J5cHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTYW1wbGVBZXNEZWNyeXB0ZXIob2JzZXJ2ZXIsIGNvbmZpZywgZGVjcnlwdGRhdGEsIGRpc2NhcmRFUEIpIHtcbiAgICAgICAgdGhpcy5kZWNyeXB0ZGF0YSA9IGRlY3J5cHRkYXRhO1xuICAgICAgICB0aGlzLmRpc2NhcmRFUEIgPSBkaXNjYXJkRVBCO1xuICAgICAgICB0aGlzLmRlY3J5cHRlciA9IG5ldyBkZWNyeXB0ZXJfMS5kZWZhdWx0KG9ic2VydmVyLCBjb25maWcsIHsgcmVtb3ZlUEtDUzdQYWRkaW5nOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgU2FtcGxlQWVzRGVjcnlwdGVyLnByb3RvdHlwZS5kZWNyeXB0QnVmZmVyID0gZnVuY3Rpb24gKGVuY3J5cHRlZERhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZGVjcnlwdGVyLmRlY3J5cHQoZW5jcnlwdGVkRGF0YSwgdGhpcy5kZWNyeXB0ZGF0YS5rZXkuYnVmZmVyLCB0aGlzLmRlY3J5cHRkYXRhLml2LmJ1ZmZlciwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgLy8gQUFDIC0gZW5jcnlwdCBhbGwgZnVsbCAxNiBieXRlcyBibG9ja3Mgc3RhcnRpbmcgZnJvbSBvZmZzZXQgMTZcbiAgICBTYW1wbGVBZXNEZWNyeXB0ZXIucHJvdG90eXBlLmRlY3J5cHRBYWNTYW1wbGUgPSBmdW5jdGlvbiAoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrLCBzeW5jKSB7XG4gICAgICAgIHZhciBjdXJVbml0ID0gc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdDtcbiAgICAgICAgdmFyIGVuY3J5cHRlZERhdGEgPSBjdXJVbml0LnN1YmFycmF5KDE2LCBjdXJVbml0Lmxlbmd0aCAtIGN1clVuaXQubGVuZ3RoICUgMTYpO1xuICAgICAgICB2YXIgZW5jcnlwdGVkQnVmZmVyID0gZW5jcnlwdGVkRGF0YS5idWZmZXIuc2xpY2UoZW5jcnlwdGVkRGF0YS5ieXRlT2Zmc2V0LCBlbmNyeXB0ZWREYXRhLmJ5dGVPZmZzZXQgKyBlbmNyeXB0ZWREYXRhLmxlbmd0aCk7XG4gICAgICAgIHZhciBsb2NhbHRoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkQnVmZmVyLCBmdW5jdGlvbiAoZGVjcnlwdGVkRGF0YSkge1xuICAgICAgICAgICAgZGVjcnlwdGVkRGF0YSA9IG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZERhdGEpO1xuICAgICAgICAgICAgY3VyVW5pdC5zZXQoZGVjcnlwdGVkRGF0YSwgMTYpO1xuICAgICAgICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgICAgICAgICAgbG9jYWx0aGlzLmRlY3J5cHRBYWNTYW1wbGVzKHNhbXBsZXMsIHNhbXBsZUluZGV4ICsgMSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNhbXBsZUFlc0RlY3J5cHRlci5wcm90b3R5cGUuZGVjcnlwdEFhY1NhbXBsZXMgPSBmdW5jdGlvbiAoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgICAgIGZvciAoOzsgc2FtcGxlSW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKHNhbXBsZUluZGV4ID49IHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdC5sZW5ndGggPCAzMikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN5bmMgPSB0aGlzLmRlY3J5cHRlci5pc1N5bmMoKTtcbiAgICAgICAgICAgIHRoaXMuZGVjcnlwdEFhY1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgY2FsbGJhY2ssIHN5bmMpO1xuICAgICAgICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBBVkMgLSBlbmNyeXB0IG9uZSAxNiBieXRlcyBibG9jayBvdXQgb2YgdGVuLCBzdGFydGluZyBmcm9tIG9mZnNldCAzMlxuICAgIFNhbXBsZUFlc0RlY3J5cHRlci5wcm90b3R5cGUuZ2V0QXZjRW5jcnlwdGVkRGF0YSA9IGZ1bmN0aW9uIChkZWNvZGVkRGF0YSkge1xuICAgICAgICB2YXIgZW5jcnlwdGVkRGF0YUxlbiA9IE1hdGguZmxvb3IoKGRlY29kZWREYXRhLmxlbmd0aCAtIDQ4KSAvIDE2MCkgKiAxNiArIDE2O1xuICAgICAgICB2YXIgZW5jcnlwdGVkRGF0YSA9IG5ldyBJbnQ4QXJyYXkoZW5jcnlwdGVkRGF0YUxlbik7XG4gICAgICAgIHZhciBvdXRwdXRQb3MgPSAwO1xuICAgICAgICBmb3IgKHZhciBpbnB1dFBvcyA9IDMyOyBpbnB1dFBvcyA8PSBkZWNvZGVkRGF0YS5sZW5ndGggLSAxNjsgaW5wdXRQb3MgKz0gMTYwLCBvdXRwdXRQb3MgKz0gMTYpIHtcbiAgICAgICAgICAgIGVuY3J5cHRlZERhdGEuc2V0KGRlY29kZWREYXRhLnN1YmFycmF5KGlucHV0UG9zLCBpbnB1dFBvcyArIDE2KSwgb3V0cHV0UG9zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5jcnlwdGVkRGF0YTtcbiAgICB9O1xuICAgIFNhbXBsZUFlc0RlY3J5cHRlci5wcm90b3R5cGUuZ2V0QXZjRGVjcnlwdGVkVW5pdCA9IGZ1bmN0aW9uIChkZWNvZGVkRGF0YSwgZGVjcnlwdGVkRGF0YSkge1xuICAgICAgICBkZWNyeXB0ZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkRGF0YSk7XG4gICAgICAgIHZhciBpbnB1dFBvcyA9IDA7XG4gICAgICAgIGZvciAodmFyIG91dHB1dFBvcyA9IDMyOyBvdXRwdXRQb3MgPD0gZGVjb2RlZERhdGEubGVuZ3RoIC0gMTY7IG91dHB1dFBvcyArPSAxNjAsIGlucHV0UG9zICs9IDE2KSB7XG4gICAgICAgICAgICBkZWNvZGVkRGF0YS5zZXQoZGVjcnlwdGVkRGF0YS5zdWJhcnJheShpbnB1dFBvcywgaW5wdXRQb3MgKyAxNiksIG91dHB1dFBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlY29kZWREYXRhO1xuICAgIH07XG4gICAgU2FtcGxlQWVzRGVjcnlwdGVyLnByb3RvdHlwZS5kZWNyeXB0QXZjU2FtcGxlID0gZnVuY3Rpb24gKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXgsIGNhbGxiYWNrLCBjdXJVbml0LCBzeW5jKSB7XG4gICAgICAgIHZhciBkZWNvZGVkRGF0YSA9IHRoaXMuZGlzY2FyZEVQQihjdXJVbml0LmRhdGEpO1xuICAgICAgICB2YXIgZW5jcnlwdGVkRGF0YSA9IHRoaXMuZ2V0QXZjRW5jcnlwdGVkRGF0YShkZWNvZGVkRGF0YSk7XG4gICAgICAgIHZhciBsb2NhbHRoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkRGF0YS5idWZmZXIsIGZ1bmN0aW9uIChkZWNyeXB0ZWREYXRhKSB7XG4gICAgICAgICAgICBjdXJVbml0LmRhdGEgPSBsb2NhbHRoaXMuZ2V0QXZjRGVjcnlwdGVkVW5pdChkZWNvZGVkRGF0YSwgZGVjcnlwdGVkRGF0YSk7XG4gICAgICAgICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgICAgICAgICBsb2NhbHRoaXMuZGVjcnlwdEF2Y1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCArIDEsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTYW1wbGVBZXNEZWNyeXB0ZXIucHJvdG90eXBlLmRlY3J5cHRBdmNTYW1wbGVzID0gZnVuY3Rpb24gKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgICAgIGZvciAoOzsgc2FtcGxlSW5kZXgrKywgdW5pdEluZGV4ID0gMCkge1xuICAgICAgICAgICAgaWYgKHNhbXBsZUluZGV4ID49IHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3VyVW5pdHMgPSBzYW1wbGVzW3NhbXBsZUluZGV4XS51bml0cztcbiAgICAgICAgICAgIGZvciAoOzsgdW5pdEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBpZiAodW5pdEluZGV4ID49IGN1clVuaXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGN1clVuaXQgPSBjdXJVbml0c1t1bml0SW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChjdXJVbml0Lmxlbmd0aCA8PSA0OCB8fCAoY3VyVW5pdC50eXBlICE9PSAxICYmIGN1clVuaXQudHlwZSAhPT0gNSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzeW5jID0gdGhpcy5kZWNyeXB0ZXIuaXNTeW5jKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNyeXB0QXZjU2FtcGxlKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXgsIGNhbGxiYWNrLCBjdXJVbml0LCBzeW5jKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNhbXBsZUFlc0RlY3J5cHRlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTYW1wbGVBZXNEZWNyeXB0ZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGVtdXgvdHNkZW11eGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kZW11eC90c2RlbXV4ZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIGhpZ2hseSBvcHRpbWl6ZWQgVFMgZGVtdXhlcjpcbiAqIHBhcnNlIFBBVCwgUE1UXG4gKiBleHRyYWN0IFBFUyBwYWNrZXQgZnJvbSBhdWRpbyBhbmQgdmlkZW8gUElEc1xuICogZXh0cmFjdCBBVkMvSDI2NCBOQUwgdW5pdHMgYW5kIEFBQy9BRFRTIHNhbXBsZXMgZnJvbSBQRVMgcGFja2V0XG4gKiB0cmlnZ2VyIHRoZSByZW11eGVyIHVwb24gcGFyc2luZyBjb21wbGV0aW9uXG4gKiBpdCBhbHNvIHRyaWVzIHRvIHdvcmthcm91bmQgYXMgYmVzdCBhcyBpdCBjYW4gYXVkaW8gY29kZWMgc3dpdGNoIChIRS1BQUMgdG8gQUFDIGFuZCB2aWNlIHZlcnNhKSwgd2l0aG91dCBoYXZpbmcgdG8gcmVzdGFydCB0aGUgTWVkaWFTb3VyY2UuXG4gKiBpdCBhbHNvIGNvbnRyb2xzIHRoZSByZW11eGluZyBwcm9jZXNzIDpcbiAqIHVwb24gZGlzY29udGludWl0eSBvciBsZXZlbCBzd2l0Y2ggZGV0ZWN0aW9uLCBpdCB3aWxsIGFsc28gbm90aWZpZXMgdGhlIHJlbXV4ZXIgc28gdGhhdCBpdCBjYW4gcmVzZXQgaXRzIHN0YXRlLlxuKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBBRFRTID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9hZHRzICovIFwiLi9zcmMvZGVtdXgvYWR0cy5qc1wiKTtcbnZhciBtcGVnYXVkaW9fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbXBlZ2F1ZGlvICovIFwiLi9zcmMvZGVtdXgvbXBlZ2F1ZGlvLmpzXCIpO1xudmFyIGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLmpzXCIpO1xudmFyIGV4cF9nb2xvbWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZXhwLWdvbG9tYiAqLyBcIi4vc3JjL2RlbXV4L2V4cC1nb2xvbWIuanNcIik7XG52YXIgc2FtcGxlX2Flc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zYW1wbGUtYWVzICovIFwiLi9zcmMvZGVtdXgvc2FtcGxlLWFlcy5qc1wiKTtcbi8vIGltcG9ydCBIZXggZnJvbSAnLi4vdXRpbHMvaGV4JztcbnZhciBsb2dnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci5qc1wiKTtcbnZhciBlcnJvcnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy5qc1wiKTtcbi8vIFdlIGFyZSB1c2luZyBmaXhlZCB0cmFjayBJRHMgZm9yIGRyaXZpbmcgdGhlIE1QNCByZW11eGVyXG4vLyBpbnN0ZWFkIG9mIGZvbGxvd2luZyB0aGUgVFMgUElEcy5cbi8vIFRoZXJlIGlzIG5vIHJlYXNvbiBub3QgdG8gZG8gdGhpcyBhbmQgc29tZSBicm93c2Vycy9Tb3VyY2VCdWZmZXItZGVtdXhlcnNcbi8vIG1heSBub3QgbGlrZSBpZiB0aGVyZSBhcmUgVHJhY2tJRCBcInN3aXRjaGVzXCJcbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvMTMzMVxuLy8gSGVyZSB3ZSBhcmUgbWFwcGluZyBvdXIgaW50ZXJuYWwgdHJhY2sgdHlwZXMgdG8gY29uc3RhbnQgTVA0IHRyYWNrIElEc1xuLy8gV2l0aCBNU0UgY3VycmVudGx5IG9uZSBjYW4gb25seSBoYXZlIG9uZSB0cmFjayBvZiBlYWNoLCBhbmQgd2UgYXJlIG11eGluZ1xuLy8gd2hhdGV2ZXIgdmlkZW8vYXVkaW8gcmVuZGl0aW9uIGluIHRoZW0uXG52YXIgUmVtdXhlclRyYWNrSWRDb25maWcgPSB7XG4gICAgdmlkZW86IDEsXG4gICAgYXVkaW86IDIsXG4gICAgaWQzOiAzLFxuICAgIHRleHQ6IDRcbn07XG52YXIgVFNEZW11eGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRTRGVtdXhlcihvYnNlcnZlciwgcmVtdXhlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XG4gICAgICAgIHRoaXMucmVtdXhlciA9IHJlbXV4ZXI7XG4gICAgICAgIHRoaXMuc2FtcGxlQWVzID0gbnVsbDtcbiAgICB9XG4gICAgVFNEZW11eGVyLnByb3RvdHlwZS5zZXREZWNyeXB0RGF0YSA9IGZ1bmN0aW9uIChkZWNyeXB0ZGF0YSkge1xuICAgICAgICBpZiAoKGRlY3J5cHRkYXRhICE9IG51bGwpICYmIChkZWNyeXB0ZGF0YS5rZXkgIT0gbnVsbCkgJiYgKGRlY3J5cHRkYXRhLm1ldGhvZCA9PT0gJ1NBTVBMRS1BRVMnKSkge1xuICAgICAgICAgICAgdGhpcy5zYW1wbGVBZXMgPSBuZXcgc2FtcGxlX2Flc18xLmRlZmF1bHQodGhpcy5vYnNlcnZlciwgdGhpcy5jb25maWcsIGRlY3J5cHRkYXRhLCB0aGlzLmRpc2NhcmRFUEIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zYW1wbGVBZXMgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUU0RlbXV4ZXIucHJvYmUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgc3luY09mZnNldCA9IFRTRGVtdXhlci5fc3luY09mZnNldChkYXRhKTtcbiAgICAgICAgaWYgKHN5bmNPZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3luY09mZnNldCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKFwiTVBFRzItVFMgZGV0ZWN0ZWQgYnV0IGZpcnN0IHN5bmMgd29yZCBmb3VuZCBAIG9mZnNldCBcIiArIHN5bmNPZmZzZXQgKyBcIiwganVuayBhaGVhZCA/XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRTRGVtdXhlci5fc3luY09mZnNldCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIHNjYW4gMTAwMCBmaXJzdCBieXRlc1xuICAgICAgICB2YXIgc2NhbndpbmRvdyA9IE1hdGgubWluKDEwMDAsIGRhdGEubGVuZ3RoIC0gMyAqIDE4OCk7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBzY2Fud2luZG93KSB7XG4gICAgICAgICAgICAvLyBhIFRTIGZyYWdtZW50IHNob3VsZCBjb250YWluIGF0IGxlYXN0IDMgVFMgcGFja2V0cywgYSBQQVQsIGEgUE1ULCBhbmQgb25lIFBJRCwgZWFjaCBzdGFydGluZyB3aXRoIDB4NDdcbiAgICAgICAgICAgIGlmIChkYXRhW2ldID09PSAweDQ3ICYmIGRhdGFbaSArIDE4OF0gPT09IDB4NDcgJiYgZGF0YVtpICsgMiAqIDE4OF0gPT09IDB4NDcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdHJhY2sgbW9kZWwgaW50ZXJuYWwgdG8gZGVtdXhlciB1c2VkIHRvIGRyaXZlIHJlbXV4aW5nIGlucHV0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAnYXVkaW8nIHwgJ3ZpZGVvJyB8ICdpZDMnIHwgJ3RleHQnXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBUU0RlbXV4ZXIncyBpbnRlcm5hbCB0cmFjayBtb2RlbFxuICAgICAqL1xuICAgIFRTRGVtdXhlci5jcmVhdGVUcmFjayA9IGZ1bmN0aW9uICh0eXBlLCBkdXJhdGlvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udGFpbmVyOiB0eXBlID09PSAndmlkZW8nIHx8IHR5cGUgPT09ICdhdWRpbycgPyAndmlkZW8vbXAydCcgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgaWQ6IFJlbXV4ZXJUcmFja0lkQ29uZmlnW3R5cGVdLFxuICAgICAgICAgICAgcGlkOiAtMSxcbiAgICAgICAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgICAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgICAgICAgc2FtcGxlczogW10sXG4gICAgICAgICAgICBsZW46IDAsXG4gICAgICAgICAgICBkcm9wcGVkOiB0eXBlID09PSAndmlkZW8nID8gMCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGlzQUFDOiB0eXBlID09PSAnYXVkaW8nID8gdHJ1ZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0eXBlID09PSAnYXVkaW8nID8gZHVyYXRpb24gOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgbmV3IGluaXQgc2VnbWVudCBvbiB0aGUgZGVtdXhlci9yZW11eGVyIGludGVyZmFjZS4gTmVlZGVkIGZvciBkaXNjb250aW51aXRpZXMvdHJhY2stc3dpdGNoZXMgKG9yIGF0IHN0cmVhbSBzdGFydClcbiAgICAgKiBSZXNldHMgYWxsIGludGVybmFsIHRyYWNrIGluc3RhbmNlcyBvZiB0aGUgZGVtdXhlci5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZSBJbXBsZW1lbnRzIGdlbmVyaWMgZGVtdXhpbmcvcmVtdXhpbmcgaW50ZXJmYWNlIChzZWUgRGVtdXhlcklubGluZSlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaW5pdFNlZ21lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXVkaW9Db2RlY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2aWRlb0NvZGVjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIChpbiBUUyB0aW1lc2NhbGUgPSA5MGtIeilcbiAgICAgKi9cbiAgICBUU0RlbXV4ZXIucHJvdG90eXBlLnJlc2V0SW5pdFNlZ21lbnQgPSBmdW5jdGlvbiAoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMucG10UGFyc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BtdElkID0gLTE7XG4gICAgICAgIHRoaXMuX2F2Y1RyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCd2aWRlbycsIGR1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5fYXVkaW9UcmFjayA9IFRTRGVtdXhlci5jcmVhdGVUcmFjaygnYXVkaW8nLCBkdXJhdGlvbik7XG4gICAgICAgIHRoaXMuX2lkM1RyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCdpZDMnLCBkdXJhdGlvbik7XG4gICAgICAgIHRoaXMuX3R4dFRyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCd0ZXh0JywgZHVyYXRpb24pO1xuICAgICAgICAvLyBmbHVzaCBhbnkgcGFydGlhbCBjb250ZW50XG4gICAgICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgICAgICB0aGlzLmFhY0xhc3RQVFMgPSBudWxsO1xuICAgICAgICB0aGlzLmF2Y1NhbXBsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb247XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIFRTRGVtdXhlci5wcm90b3R5cGUucmVzZXRUaW1lU3RhbXAgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgLy8gZmVlZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBmcm9udCBvZiB0aGUgcGFyc2luZyBwaXBlbGluZVxuICAgIFRTRGVtdXhlci5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKGRhdGEsIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgICAgICB2YXIgc3RhcnQsIGxlbiA9IGRhdGEubGVuZ3RoLCBzdHQsIHBpZCwgYXRmLCBvZmZzZXQsIHBlcywgdW5rbm93blBJRHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb250aWd1b3VzID0gY29udGlndW91cztcbiAgICAgICAgdmFyIHBtdFBhcnNlZCA9IHRoaXMucG10UGFyc2VkLCBhdmNUcmFjayA9IHRoaXMuX2F2Y1RyYWNrLCBhdWRpb1RyYWNrID0gdGhpcy5fYXVkaW9UcmFjaywgaWQzVHJhY2sgPSB0aGlzLl9pZDNUcmFjaywgYXZjSWQgPSBhdmNUcmFjay5waWQsIGF1ZGlvSWQgPSBhdWRpb1RyYWNrLnBpZCwgaWQzSWQgPSBpZDNUcmFjay5waWQsIHBtdElkID0gdGhpcy5fcG10SWQsIGF2Y0RhdGEgPSBhdmNUcmFjay5wZXNEYXRhLCBhdWRpb0RhdGEgPSBhdWRpb1RyYWNrLnBlc0RhdGEsIGlkM0RhdGEgPSBpZDNUcmFjay5wZXNEYXRhLCBwYXJzZVBBVCA9IHRoaXMuX3BhcnNlUEFULCBwYXJzZVBNVCA9IHRoaXMuX3BhcnNlUE1ULCBwYXJzZVBFUyA9IHRoaXMuX3BhcnNlUEVTLCBwYXJzZUFWQ1BFUyA9IHRoaXMuX3BhcnNlQVZDUEVTLmJpbmQodGhpcyksIHBhcnNlQUFDUEVTID0gdGhpcy5fcGFyc2VBQUNQRVMuYmluZCh0aGlzKSwgcGFyc2VNUEVHUEVTID0gdGhpcy5fcGFyc2VNUEVHUEVTLmJpbmQodGhpcyksIHBhcnNlSUQzUEVTID0gdGhpcy5fcGFyc2VJRDNQRVMuYmluZCh0aGlzKTtcbiAgICAgICAgdmFyIHN5bmNPZmZzZXQgPSBUU0RlbXV4ZXIuX3N5bmNPZmZzZXQoZGF0YSk7XG4gICAgICAgIC8vIGRvbid0IHBhcnNlIGxhc3QgVFMgcGFja2V0IGlmIGluY29tcGxldGVcbiAgICAgICAgbGVuIC09IChsZW4gKyBzeW5jT2Zmc2V0KSAlIDE4ODtcbiAgICAgICAgLy8gbG9vcCB0aHJvdWdoIFRTIHBhY2tldHNcbiAgICAgICAgZm9yIChzdGFydCA9IHN5bmNPZmZzZXQ7IHN0YXJ0IDwgbGVuOyBzdGFydCArPSAxODgpIHtcbiAgICAgICAgICAgIGlmIChkYXRhW3N0YXJ0XSA9PT0gMHg0Nykge1xuICAgICAgICAgICAgICAgIHN0dCA9ICEhKGRhdGFbc3RhcnQgKyAxXSAmIDB4NDApO1xuICAgICAgICAgICAgICAgIC8vIHBpZCBpcyBhIDEzLWJpdCBmaWVsZCBzdGFydGluZyBhdCB0aGUgbGFzdCBiaXQgb2YgVFNbMV1cbiAgICAgICAgICAgICAgICBwaWQgPSAoKGRhdGFbc3RhcnQgKyAxXSAmIDB4MWYpIDw8IDgpICsgZGF0YVtzdGFydCArIDJdO1xuICAgICAgICAgICAgICAgIGF0ZiA9IChkYXRhW3N0YXJ0ICsgM10gJiAweDMwKSA+PiA0O1xuICAgICAgICAgICAgICAgIC8vIGlmIGFuIGFkYXB0aW9uIGZpZWxkIGlzIHByZXNlbnQsIGl0cyBsZW5ndGggaXMgc3BlY2lmaWVkIGJ5IHRoZSBmaWZ0aCBieXRlIG9mIHRoZSBUUyBwYWNrZXQgaGVhZGVyLlxuICAgICAgICAgICAgICAgIGlmIChhdGYgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IHN0YXJ0ICsgNSArIGRhdGFbc3RhcnQgKyA0XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWUgaWYgdGhlcmUgaXMgb25seSBhZGFwdGF0aW9uIGZpZWxkXG4gICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPT09IChzdGFydCArIDE4OCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBzdGFydCArIDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgYXZjSWQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF2Y0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF2Y0RhdGEpKSAmJiBwZXMucHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VBVkNQRVMocGVzLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2Y0RhdGEgPSB7IGRhdGE6IFtdLCBzaXplOiAwIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXZjRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2Y0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIDE4OCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2Y0RhdGEuc2l6ZSArPSBzdGFydCArIDE4OCAtIG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGF1ZGlvSWQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF1ZGlvRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXVkaW9EYXRhKSkgJiYgcGVzLnB0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdWRpb1RyYWNrLmlzQUFDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUFBQ1BFUyhwZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VNUEVHUEVTKHBlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9EYXRhID0geyBkYXRhOiBbXSwgc2l6ZTogMCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF1ZGlvRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgMTg4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9EYXRhLnNpemUgKz0gc3RhcnQgKyAxODggLSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBpZDNJZDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWQzRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoaWQzRGF0YSkpICYmIHBlcy5wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUlEM1BFUyhwZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDNEYXRhID0geyBkYXRhOiBbXSwgc2l6ZTogMCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkM0RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDNEYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyAxODgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDNEYXRhLnNpemUgKz0gc3RhcnQgKyAxODggLSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSBkYXRhW29mZnNldF0gKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcG10SWQgPSB0aGlzLl9wbXRJZCA9IHBhcnNlUEFUKGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBwbXRJZDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gZGF0YVtvZmZzZXRdICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZWRQSURzID0gcGFyc2VQTVQoZGF0YSwgb2Zmc2V0LCB0aGlzLnR5cGVTdXBwb3J0ZWQubXBlZyA9PT0gdHJ1ZSB8fCB0aGlzLnR5cGVTdXBwb3J0ZWQubXAzID09PSB0cnVlLCB0aGlzLnNhbXBsZUFlcyAhPSBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgdXBkYXRlIHRyYWNrIGlkIGlmIHRyYWNrIFBJRCBmb3VuZCB3aGlsZSBwYXJzaW5nIFBNVFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBhdm9pZCByZXNldHRpbmcgdGhlIFBJRCB0byAtMSBpbiBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmFjayBQSUQgdHJhbnNpZW50bHkgZGlzYXBwZWFycyBmcm9tIHRoZSBzdHJlYW1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY291bGQgaGFwcGVuIGluIGNhc2Ugb2YgdHJhbnNpZW50IG1pc3NpbmcgYXVkaW8gc2FtcGxlcyBmb3IgZXhhbXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URSB0aGlzIGlzIG9ubHkgdGhlIFBJRCBvZiB0aGUgdHJhY2sgYXMgZm91bmQgaW4gVFMsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgd2UgYXJlIG5vdCB1c2luZyB0aGlzIGZvciBNUDQgdHJhY2sgSURzLlxuICAgICAgICAgICAgICAgICAgICAgICAgYXZjSWQgPSBwYXJzZWRQSURzLmF2YztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdmNJZCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmNUcmFjay5waWQgPSBhdmNJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvSWQgPSBwYXJzZWRQSURzLmF1ZGlvO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF1ZGlvSWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9UcmFjay5waWQgPSBhdWRpb0lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvVHJhY2suaXNBQUMgPSBwYXJzZWRQSURzLmlzQUFDO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWQzSWQgPSBwYXJzZWRQSURzLmlkMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZDNJZCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDNUcmFjay5waWQgPSBpZDNJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmtub3duUElEcyAmJiAhcG10UGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygncmVwYXJzZSBmcm9tIGJlZ2lubmluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVua25vd25QSURzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugc2V0IGl0IHRvIC0xODgsIHRoZSArPSAxODggaW4gdGhlIGZvciBsb29wIHdpbGwgcmVzZXQgc3RhcnQgdG8gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3luY09mZnNldCAtIDE4ODtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBtdFBhcnNlZCA9IHRoaXMucG10UGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MWZmZjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdW5rbm93blBJRHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogZXJyb3JzXzEuRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogZXJyb3JzXzEuRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUiwgZmF0YWw6IGZhbHNlLCByZWFzb246ICdUUyBwYWNrZXQgZGlkIG5vdCBzdGFydCB3aXRoIDB4NDcnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRyeSB0byBwYXJzZSBsYXN0IFBFUyBwYWNrZXRzXG4gICAgICAgIGlmIChhdmNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdmNEYXRhKSkgJiYgcGVzLnB0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJzZUFWQ1BFUyhwZXMsIHRydWUpO1xuICAgICAgICAgICAgYXZjVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlaXRoZXIgYXZjRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICAgICAgICBhdmNUcmFjay5wZXNEYXRhID0gYXZjRGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXVkaW9EYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdWRpb0RhdGEpKSAmJiBwZXMucHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChhdWRpb1RyYWNrLmlzQUFDKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VBQUNQRVMocGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnNlTVBFR1BFUyhwZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXVkaW9UcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhdWRpb0RhdGEgJiYgYXVkaW9EYXRhLnNpemUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdsYXN0IEFBQyBQRVMgcGFja2V0IHRydW5jYXRlZCxtaWdodCBvdmVybGFwIGJldHdlZW4gZnJhZ21lbnRzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlaXRoZXIgYXVkaW9EYXRhIG51bGwgb3IgUEVTIHRydW5jYXRlZCwga2VlcCBpdCBmb3IgbmV4dCBmcmFnIHBhcnNpbmdcbiAgICAgICAgICAgIGF1ZGlvVHJhY2sucGVzRGF0YSA9IGF1ZGlvRGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWQzRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoaWQzRGF0YSkpICYmIHBlcy5wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyc2VJRDNQRVMocGVzKTtcbiAgICAgICAgICAgIGlkM1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZWl0aGVyIGlkM0RhdGEgbnVsbCBvciBQRVMgdHJ1bmNhdGVkLCBrZWVwIGl0IGZvciBuZXh0IGZyYWcgcGFyc2luZ1xuICAgICAgICAgICAgaWQzVHJhY2sucGVzRGF0YSA9IGlkM0RhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2FtcGxlQWVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucmVtdXhlci5yZW11eChhdWRpb1RyYWNrLCBhdmNUcmFjaywgaWQzVHJhY2ssIHRoaXMuX3R4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWNyeXB0QW5kUmVtdXgoYXVkaW9UcmFjaywgYXZjVHJhY2ssIGlkM1RyYWNrLCB0aGlzLl90eHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVFNEZW11eGVyLnByb3RvdHlwZS5kZWNyeXB0QW5kUmVtdXggPSBmdW5jdGlvbiAoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgICAgIGlmIChhdWRpb1RyYWNrLnNhbXBsZXMgJiYgYXVkaW9UcmFjay5pc0FBQykge1xuICAgICAgICAgICAgdmFyIGxvY2FsdGhpc18xID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuc2FtcGxlQWVzLmRlY3J5cHRBYWNTYW1wbGVzKGF1ZGlvVHJhY2suc2FtcGxlcywgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGxvY2FsdGhpc18xLmRlY3J5cHRBbmRSZW11eEF2YyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlY3J5cHRBbmRSZW11eEF2YyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUU0RlbXV4ZXIucHJvdG90eXBlLmRlY3J5cHRBbmRSZW11eEF2YyA9IGZ1bmN0aW9uIChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICAgICAgaWYgKHZpZGVvVHJhY2suc2FtcGxlcykge1xuICAgICAgICAgICAgdmFyIGxvY2FsdGhpc18yID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuc2FtcGxlQWVzLmRlY3J5cHRBdmNTYW1wbGVzKHZpZGVvVHJhY2suc2FtcGxlcywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGxvY2FsdGhpc18yLnJlbXV4ZXIucmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW11eGVyLnJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRTRGVtdXhlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faW5pdFBUUyA9IHRoaXMuX2luaXREVFMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gMDtcbiAgICB9O1xuICAgIFRTRGVtdXhlci5wcm90b3R5cGUuX3BhcnNlUEFUID0gZnVuY3Rpb24gKGRhdGEsIG9mZnNldCkge1xuICAgICAgICAvLyBza2lwIHRoZSBQU0kgaGVhZGVyIGFuZCBwYXJzZSB0aGUgZmlyc3QgUE1UIGVudHJ5XG4gICAgICAgIHJldHVybiAoZGF0YVtvZmZzZXQgKyAxMF0gJiAweDFGKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAxMV07XG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ1BNVCBQSUQ6JyAgKyB0aGlzLl9wbXRJZCk7XG4gICAgfTtcbiAgICBUU0RlbXV4ZXIucHJvdG90eXBlLl9wYXJzZVBNVCA9IGZ1bmN0aW9uIChkYXRhLCBvZmZzZXQsIG1wZWdTdXBwb3J0ZWQsIGlzU2FtcGxlQWVzKSB7XG4gICAgICAgIHZhciBzZWN0aW9uTGVuZ3RoLCB0YWJsZUVuZCwgcHJvZ3JhbUluZm9MZW5ndGgsIHBpZCwgcmVzdWx0ID0geyBhdWRpbzogLTEsIGF2YzogLTEsIGlkMzogLTEsIGlzQUFDOiB0cnVlIH07XG4gICAgICAgIHNlY3Rpb25MZW5ndGggPSAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MGYpIDw8IDggfCBkYXRhW29mZnNldCArIDJdO1xuICAgICAgICB0YWJsZUVuZCA9IG9mZnNldCArIDMgKyBzZWN0aW9uTGVuZ3RoIC0gNDtcbiAgICAgICAgLy8gdG8gZGV0ZXJtaW5lIHdoZXJlIHRoZSB0YWJsZSBpcywgd2UgaGF2ZSB0byBmaWd1cmUgb3V0IGhvd1xuICAgICAgICAvLyBsb25nIHRoZSBwcm9ncmFtIGluZm8gZGVzY3JpcHRvcnMgYXJlXG4gICAgICAgIHByb2dyYW1JbmZvTGVuZ3RoID0gKGRhdGFbb2Zmc2V0ICsgMTBdICYgMHgwZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMTFdO1xuICAgICAgICAvLyBhZHZhbmNlIHRoZSBvZmZzZXQgdG8gdGhlIGZpcnN0IGVudHJ5IGluIHRoZSBtYXBwaW5nIHRhYmxlXG4gICAgICAgIG9mZnNldCArPSAxMiArIHByb2dyYW1JbmZvTGVuZ3RoO1xuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgdGFibGVFbmQpIHtcbiAgICAgICAgICAgIHBpZCA9IChkYXRhW29mZnNldCArIDFdICYgMHgxRikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMl07XG4gICAgICAgICAgICBzd2l0Y2ggKGRhdGFbb2Zmc2V0XSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMHhjZjogLy8gU0FNUExFLUFFUyBBQUNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygndW5rb3duIHN0cmVhbSB0eXBlOicgKyBkYXRhW29mZnNldF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICAgICAgLy8gSVNPL0lFQyAxMzgxOC03IEFEVFMgQUFDIChNUEVHLTIgbG93ZXIgYml0LXJhdGUgYXVkaW8pXG4gICAgICAgICAgICAgICAgY2FzZSAweDBmOlxuICAgICAgICAgICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdBQUMgUElEOicgICsgcGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5hdWRpbyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hdWRpbyA9IHBpZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAvLyBQYWNrZXRpemVkIG1ldGFkYXRhIChJRDMpXG4gICAgICAgICAgICAgICAgY2FzZSAweDE1OlxuICAgICAgICAgICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdJRDMgUElEOicgICsgcGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pZDMgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaWQzID0gcGlkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMHhkYjogLy8gU0FNUExFLUFFUyBBVkNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygndW5rb3duIHN0cmVhbSB0eXBlOicgKyBkYXRhW29mZnNldF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICAgICAgLy8gSVRVLVQgUmVjLiBILjI2NCBhbmQgSVNPL0lFQyAxNDQ5Ni0xMCAobG93ZXIgYml0LXJhdGUgdmlkZW8pXG4gICAgICAgICAgICAgICAgY2FzZSAweDFiOlxuICAgICAgICAgICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdBVkMgUElEOicgICsgcGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5hdmMgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXZjID0gcGlkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vIElTTy9JRUMgMTExNzItMyAoTVBFRy0xIGF1ZGlvKVxuICAgICAgICAgICAgICAgIC8vIG9yIElTTy9JRUMgMTM4MTgtMyAoTVBFRy0yIGhhbHZlZCBzYW1wbGUgcmF0ZSBhdWRpbylcbiAgICAgICAgICAgICAgICBjYXNlIDB4MDM6XG4gICAgICAgICAgICAgICAgY2FzZSAweDA0OlxuICAgICAgICAgICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdNUEVHIFBJRDonICArIHBpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbXBlZ1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnTVBFRyBhdWRpbyBmb3VuZCwgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIgZm9yIG5vdycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5hdWRpbyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hdWRpbyA9IHBpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5pc0FBQyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMHgyNDpcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oJ0hFVkMgc3RyZWFtIHR5cGUgZm91bmQsIG5vdCBzdXBwb3J0ZWQgZm9yIG5vdycpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCd1bmtvd24gc3RyZWFtIHR5cGU6JyArIGRhdGFbb2Zmc2V0XSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbW92ZSB0byB0aGUgbmV4dCB0YWJsZSBlbnRyeVxuICAgICAgICAgICAgLy8gc2tpcCBwYXN0IHRoZSBlbGVtZW50YXJ5IHN0cmVhbSBkZXNjcmlwdG9ycywgaWYgcHJlc2VudFxuICAgICAgICAgICAgb2Zmc2V0ICs9ICgoZGF0YVtvZmZzZXQgKyAzXSAmIDB4MEYpIDw8IDggfCBkYXRhW29mZnNldCArIDRdKSArIDU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFRTRGVtdXhlci5wcm90b3R5cGUuX3BhcnNlUEVTID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICB2YXIgaSA9IDAsIGZyYWcsIHBlc0ZsYWdzLCBwZXNQcmVmaXgsIHBlc0xlbiwgcGVzSGRyTGVuLCBwZXNEYXRhLCBwZXNQdHMsIHBlc0R0cywgcGF5bG9hZFN0YXJ0T2Zmc2V0LCBkYXRhID0gc3RyZWFtLmRhdGE7XG4gICAgICAgIC8vIHNhZmV0eSBjaGVja1xuICAgICAgICBpZiAoIXN0cmVhbSB8fCBzdHJlYW0uc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgbWlnaHQgbmVlZCB1cCB0byAxOSBieXRlcyB0byByZWFkIFBFUyBoZWFkZXJcbiAgICAgICAgLy8gaWYgZmlyc3QgY2h1bmsgb2YgZGF0YSBpcyBsZXNzIHRoYW4gMTkgYnl0ZXMsIGxldCdzIG1lcmdlIGl0IHdpdGggZm9sbG93aW5nIG9uZXMgdW50aWwgd2UgZ2V0IDE5IGJ5dGVzXG4gICAgICAgIC8vIHVzdWFsbHkgb25seSBvbmUgbWVyZ2UgaXMgbmVlZGVkIChhbmQgdGhpcyBpcyByYXJlIC4uLilcbiAgICAgICAgd2hpbGUgKGRhdGFbMF0ubGVuZ3RoIDwgMTkgJiYgZGF0YS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgbmV3RGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGFbMF0ubGVuZ3RoICsgZGF0YVsxXS5sZW5ndGgpO1xuICAgICAgICAgICAgbmV3RGF0YS5zZXQoZGF0YVswXSk7XG4gICAgICAgICAgICBuZXdEYXRhLnNldChkYXRhWzFdLCBkYXRhWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICBkYXRhWzBdID0gbmV3RGF0YTtcbiAgICAgICAgICAgIGRhdGEuc3BsaWNlKDEsIDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJldHJpZXZlIFBUUy9EVFMgZnJvbSBmaXJzdCBmcmFnbWVudFxuICAgICAgICBmcmFnID0gZGF0YVswXTtcbiAgICAgICAgcGVzUHJlZml4ID0gKGZyYWdbMF0gPDwgMTYpICsgKGZyYWdbMV0gPDwgOCkgKyBmcmFnWzJdO1xuICAgICAgICBpZiAocGVzUHJlZml4ID09PSAxKSB7XG4gICAgICAgICAgICBwZXNMZW4gPSAoZnJhZ1s0XSA8PCA4KSArIGZyYWdbNV07XG4gICAgICAgICAgICAvLyBpZiBQRVMgcGFyc2VkIGxlbmd0aCBpcyBub3QgemVybyBhbmQgZ3JlYXRlciB0aGFuIHRvdGFsIHJlY2VpdmVkIGxlbmd0aCwgc3RvcCBwYXJzaW5nLiBQRVMgbWlnaHQgYmUgdHJ1bmNhdGVkXG4gICAgICAgICAgICAvLyBtaW51cyA2IDogUEVTIGhlYWRlciBzaXplXG4gICAgICAgICAgICBpZiAocGVzTGVuICYmIHBlc0xlbiA+IHN0cmVhbS5zaXplIC0gNikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGVzRmxhZ3MgPSBmcmFnWzddO1xuICAgICAgICAgICAgaWYgKHBlc0ZsYWdzICYgMHhDMCkge1xuICAgICAgICAgICAgICAgIC8qIFBFUyBoZWFkZXIgZGVzY3JpYmVkIGhlcmUgOiBodHRwOi8vZHZkLnNvdXJjZWZvcmdlLm5ldC9kdmRpbmZvL3Blcy1oZHIuaHRtbFxuICAgICAgICAgICAgICAgICAgICBhcyBQVFMgLyBEVFMgaXMgMzMgYml0IHdlIGNhbm5vdCB1c2UgYml0d2lzZSBvcGVyYXRvciBpbiBKUyxcbiAgICAgICAgICAgICAgICAgICAgYXMgQml0d2lzZSBvcGVyYXRvcnMgdHJlYXQgdGhlaXIgb3BlcmFuZHMgYXMgYSBzZXF1ZW5jZSBvZiAzMiBiaXRzICovXG4gICAgICAgICAgICAgICAgcGVzUHRzID0gKGZyYWdbOV0gJiAweDBFKSAqIDUzNjg3MDkxMiArIC8vIDEgPDwgMjlcbiAgICAgICAgICAgICAgICAgICAgKGZyYWdbMTBdICYgMHhGRikgKiA0MTk0MzA0ICsgLy8gMSA8PCAyMlxuICAgICAgICAgICAgICAgICAgICAoZnJhZ1sxMV0gJiAweEZFKSAqIDE2Mzg0ICsgLy8gMSA8PCAxNFxuICAgICAgICAgICAgICAgICAgICAoZnJhZ1sxMl0gJiAweEZGKSAqIDEyOCArIC8vIDEgPDwgN1xuICAgICAgICAgICAgICAgICAgICAoZnJhZ1sxM10gJiAweEZFKSAvIDI7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgZ3JlYXRlciB0aGFuIDJeMzIgLTFcbiAgICAgICAgICAgICAgICBpZiAocGVzUHRzID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWNyZW1lbnQgMl4zM1xuICAgICAgICAgICAgICAgICAgICBwZXNQdHMgLT0gODU4OTkzNDU5MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBlc0ZsYWdzICYgMHg0MCkge1xuICAgICAgICAgICAgICAgICAgICBwZXNEdHMgPSAoZnJhZ1sxNF0gJiAweDBFKSAqIDUzNjg3MDkxMiArIC8vIDEgPDwgMjlcbiAgICAgICAgICAgICAgICAgICAgICAgIChmcmFnWzE1XSAmIDB4RkYpICogNDE5NDMwNCArIC8vIDEgPDwgMjJcbiAgICAgICAgICAgICAgICAgICAgICAgIChmcmFnWzE2XSAmIDB4RkUpICogMTYzODQgKyAvLyAxIDw8IDE0XG4gICAgICAgICAgICAgICAgICAgICAgICAoZnJhZ1sxN10gJiAweEZGKSAqIDEyOCArIC8vIDEgPDwgN1xuICAgICAgICAgICAgICAgICAgICAgICAgKGZyYWdbMThdICYgMHhGRSkgLyAyO1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBncmVhdGVyIHRoYW4gMl4zMiAtMVxuICAgICAgICAgICAgICAgICAgICBpZiAocGVzRHRzID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVtZW50IDJeMzNcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlc0R0cyAtPSA4NTg5OTM0NTkyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZXNQdHMgLSBwZXNEdHMgPiA2MCAqIDkwMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybihNYXRoLnJvdW5kKChwZXNQdHMgLSBwZXNEdHMpIC8gOTAwMDApICsgXCJzIGRlbHRhIGJldHdlZW4gUFRTIGFuZCBEVFMsIGFsaWduIHRoZW1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZXNQdHMgPSBwZXNEdHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBlc0R0cyA9IHBlc1B0cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwZXNIZHJMZW4gPSBmcmFnWzhdO1xuICAgICAgICAgICAgLy8gOSBieXRlcyA6IDYgYnl0ZXMgZm9yIFBFUyBoZWFkZXIgKyAzIGJ5dGVzIGZvciBQRVMgZXh0ZW5zaW9uXG4gICAgICAgICAgICBwYXlsb2FkU3RhcnRPZmZzZXQgPSBwZXNIZHJMZW4gKyA5O1xuICAgICAgICAgICAgc3RyZWFtLnNpemUgLT0gcGF5bG9hZFN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgLy8gcmVhc3NlbWJsZSBQRVMgcGFja2V0XG4gICAgICAgICAgICBwZXNEYXRhID0gbmV3IFVpbnQ4QXJyYXkoc3RyZWFtLnNpemUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGRhdGFMZW4gPSBkYXRhLmxlbmd0aDsgaiA8IGRhdGFMZW47IGorKykge1xuICAgICAgICAgICAgICAgIGZyYWcgPSBkYXRhW2pdO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBmcmFnLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHBheWxvYWRTdGFydE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGF5bG9hZFN0YXJ0T2Zmc2V0ID4gbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmltIGZ1bGwgZnJhZyBpZiBQRVMgaGVhZGVyIGJpZ2dlciB0aGFuIGZyYWdcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRTdGFydE9mZnNldCAtPSBsZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyaW0gcGFydGlhbCBmcmFnIGlmIFBFUyBoZWFkZXIgc21hbGxlciB0aGFuIGZyYWdcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcgPSBmcmFnLnN1YmFycmF5KHBheWxvYWRTdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW4gLT0gcGF5bG9hZFN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZFN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwZXNEYXRhLnNldChmcmFnLCBpKTtcbiAgICAgICAgICAgICAgICBpICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwZXNMZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBwYXlsb2FkIHNpemUgOiByZW1vdmUgUEVTIGhlYWRlciArIFBFUyBleHRlbnNpb25cbiAgICAgICAgICAgICAgICBwZXNMZW4gLT0gcGVzSGRyTGVuICsgMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHBlc0RhdGEsIHB0czogcGVzUHRzLCBkdHM6IHBlc0R0cywgbGVuOiBwZXNMZW4gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUU0RlbXV4ZXIucHJvdG90eXBlLnB1c2hBY2Nlc1VuaXQgPSBmdW5jdGlvbiAoYXZjU2FtcGxlLCBhdmNUcmFjaykge1xuICAgICAgICBpZiAoYXZjU2FtcGxlLnVuaXRzLmxlbmd0aCAmJiBhdmNTYW1wbGUuZnJhbWUpIHtcbiAgICAgICAgICAgIHZhciBzYW1wbGVzID0gYXZjVHJhY2suc2FtcGxlcztcbiAgICAgICAgICAgIHZhciBuYlNhbXBsZXMgPSBzYW1wbGVzLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIG9ubHkgcHVzaCBBVkMgc2FtcGxlIGlmIHN0YXJ0aW5nIHdpdGggYSBrZXlmcmFtZSBpcyBub3QgbWFuZGF0b3J5IE9SXG4gICAgICAgICAgICAvLyAgICBpZiBrZXlmcmFtZSBhbHJlYWR5IGZvdW5kIGluIHRoaXMgZnJhZ21lbnQgT1JcbiAgICAgICAgICAgIC8vICAgICAgIGtleWZyYW1lIGZvdW5kIGluIGxhc3QgZnJhZ21lbnQgKHRyYWNrLnNwcykgQU5EXG4gICAgICAgICAgICAvLyAgICAgICAgICBzYW1wbGVzIGFscmVhZHkgYXBwZW5kZWQgKHdlIGFscmVhZHkgZm91bmQgYSBrZXlmcmFtZSBpbiB0aGlzIGZyYWdtZW50KSBPUiBmcmFnbWVudCBpcyBjb250aWd1b3VzXG4gICAgICAgICAgICBpZiAoIXRoaXMuY29uZmlnLmZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHkgfHxcbiAgICAgICAgICAgICAgICBhdmNTYW1wbGUua2V5ID09PSB0cnVlIHx8XG4gICAgICAgICAgICAgICAgKGF2Y1RyYWNrLnNwcyAmJiAobmJTYW1wbGVzIHx8IHRoaXMuY29udGlndW91cykpKSB7XG4gICAgICAgICAgICAgICAgYXZjU2FtcGxlLmlkID0gbmJTYW1wbGVzO1xuICAgICAgICAgICAgICAgIHNhbXBsZXMucHVzaChhdmNTYW1wbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZHJvcHBlZCBzYW1wbGVzLCB0cmFjayBpdFxuICAgICAgICAgICAgICAgIGF2Y1RyYWNrLmRyb3BwZWQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXZjU2FtcGxlLmRlYnVnLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhhdmNTYW1wbGUucHRzICsgJy8nICsgYXZjU2FtcGxlLmR0cyArICc6JyArIGF2Y1NhbXBsZS5kZWJ1Zyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRTRGVtdXhlci5wcm90b3R5cGUuX3BhcnNlQVZDUEVTID0gZnVuY3Rpb24gKHBlcywgbGFzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBsb2dnZXIubG9nKCdwYXJzZSBuZXcgUEVTJyk7XG4gICAgICAgIHZhciB0cmFjayA9IHRoaXMuX2F2Y1RyYWNrLCB1bml0cyA9IHRoaXMuX3BhcnNlQVZDTkFMdShwZXMuZGF0YSksIGRlYnVnID0gZmFsc2UsIGV4cEdvbG9tYkRlY29kZXIsIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlLCBwdXNoLCBzcHNmb3VuZCA9IGZhbHNlLCBpLCBwdXNoQWNjZXNVbml0ID0gdGhpcy5wdXNoQWNjZXNVbml0LmJpbmQodGhpcyksIGNyZWF0ZUFWQ1NhbXBsZSA9IGZ1bmN0aW9uIChrZXksIHB0cywgZHRzLCBkZWJ1Zykge1xuICAgICAgICAgICAgcmV0dXJuIHsga2V5OiBrZXksIHB0czogcHRzLCBkdHM6IGR0cywgdW5pdHM6IFtdLCBkZWJ1ZzogZGVidWcgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZnJlZSBwZXMuZGF0YSB0byBzYXZlIHVwIHNvbWUgbWVtb3J5XG4gICAgICAgIHBlcy5kYXRhID0gbnVsbDtcbiAgICAgICAgLy8gaWYgbmV3IE5BTCB1bml0cyBmb3VuZCBhbmQgbGFzdCBzYW1wbGUgc3RpbGwgdGhlcmUsIGxldCdzIHB1c2ggLi4uXG4gICAgICAgIC8vIHRoaXMgaGVscHMgcGFyc2luZyBzdHJlYW1zIHdpdGggbWlzc2luZyBBVUQgKG9ubHkgZG8gdGhpcyBpZiBBVUQgbmV2ZXIgZm91bmQpXG4gICAgICAgIGlmIChhdmNTYW1wbGUgJiYgdW5pdHMubGVuZ3RoICYmICF0cmFjay5hdWRGb3VuZCkge1xuICAgICAgICAgICAgcHVzaEFjY2VzVW5pdChhdmNTYW1wbGUsIHRyYWNrKTtcbiAgICAgICAgICAgIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlID0gY3JlYXRlQVZDU2FtcGxlKGZhbHNlLCBwZXMucHRzLCBwZXMuZHRzLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMuZm9yRWFjaChmdW5jdGlvbiAodW5pdCkge1xuICAgICAgICAgICAgc3dpdGNoICh1bml0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBORFJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXZjU2FtcGxlID0gX3RoaXMuYXZjU2FtcGxlID0gY3JlYXRlQVZDU2FtcGxlKHRydWUsIHBlcy5wdHMsIHBlcy5kdHMsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnTkRSICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXZjU2FtcGxlLmZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB1bml0LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgY2hlY2sgc2xpY2UgdHlwZSB0byBkZXRlY3QgS0YgaW4gY2FzZSBTUFMgZm91bmQgaW4gc2FtZSBwYWNrZXQgKGFueSBrZXlmcmFtZSBpcyBwcmVjZWRlZCBieSBTUFMgLi4uKVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3BzZm91bmQgJiYgZGF0YS5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXRyaWV2ZSBzbGljZSB0eXBlIGJ5IHBhcnNpbmcgYmVnaW5uaW5nIG9mIE5BTCB1bml0IChmb2xsb3cgSDI2NCBzcGVjLCBzbGljZV9oZWFkZXIgZGVmaW5pdGlvbikgdG8gZGV0ZWN0IGtleWZyYW1lIGVtYmVkZGVkIGluIE5EUlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsaWNlVHlwZSA9IG5ldyBleHBfZ29sb21iXzEuZGVmYXVsdChkYXRhKS5yZWFkU2xpY2VUeXBlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAyIDogSSBzbGljZSwgNCA6IFNJIHNsaWNlLCA3IDogSSBzbGljZSwgOTogU0kgc2xpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNJIHNsaWNlIDogQSBzbGljZSB0aGF0IGlzIGNvZGVkIHVzaW5nIGludHJhIHByZWRpY3Rpb24gb25seSBhbmQgdXNpbmcgcXVhbnRpc2F0aW9uIG9mIHRoZSBwcmVkaWN0aW9uIHNhbXBsZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbiBTSSBzbGljZSBjYW4gYmUgY29kZWQgc3VjaCB0aGF0IGl0cyBkZWNvZGVkIHNhbXBsZXMgY2FuIGJlIGNvbnN0cnVjdGVkIGlkZW50aWNhbGx5IHRvIGFuIFNQIHNsaWNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSSBzbGljZTogQSBzbGljZSB0aGF0IGlzIG5vdCBhbiBTSSBzbGljZSB0aGF0IGlzIGRlY29kZWQgdXNpbmcgaW50cmEgcHJlZGljdGlvbiBvbmx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHNsaWNlVHlwZSA9PT0gMiB8fCBzbGljZVR5cGUgPT09IDcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbGljZVR5cGUgPT09IDIgfHwgc2xpY2VUeXBlID09PSA0IHx8IHNsaWNlVHlwZSA9PT0gNyB8fCBzbGljZVR5cGUgPT09IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmNTYW1wbGUua2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAvLyBJRFJcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgUEVTIG5vdCBzdGFydGluZyB3aXRoIEFVRFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXZjU2FtcGxlID0gX3RoaXMuYXZjU2FtcGxlID0gY3JlYXRlQVZDU2FtcGxlKHRydWUsIHBlcy5wdHMsIHBlcy5kdHMsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnSURSICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXZjU2FtcGxlLmtleSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGF2Y1NhbXBsZS5mcmFtZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vIFNFSVxuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWJ1ZyAmJiBhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnU0VJICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXhwR29sb21iRGVjb2RlciA9IG5ldyBleHBfZ29sb21iXzEuZGVmYXVsdChfdGhpcy5kaXNjYXJkRVBCKHVuaXQuZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBza2lwIGZyYW1lVHlwZVxuICAgICAgICAgICAgICAgICAgICBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGF5bG9hZFR5cGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGF5bG9hZFNpemUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kT2ZDYXB0aW9ucyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICghZW5kT2ZDYXB0aW9ucyAmJiBleHBHb2xvbWJEZWNvZGVyLmJ5dGVzQXZhaWxhYmxlID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZFR5cGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRUeXBlICs9IGI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChiID09PSAweEZGKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHBheWxvYWQgc2l6ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRTaXplID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkU2l6ZSArPSBiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoYiA9PT0gMHhGRik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB0aGVyZSBjYW4gYmUgbW9yZSB0aGFuIG9uZSBwYXlsb2FkIGluIGFuIFNFSSBwYWNrZXQuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IG5lZWQgdG8gcmVhZCB0eXBlIGFuZCBzaXplIGluIGEgd2hpbGUgbG9vcCB0byBnZXQgdGhlbSBhbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkVHlwZSA9PT0gNCAmJiBleHBHb2xvbWJEZWNvZGVyLmJ5dGVzQXZhaWxhYmxlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kT2ZDYXB0aW9ucyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50cnlDb2RlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRyeUNvZGUgPT09IDE4MSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvdmlkZXJDb2RlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVVNob3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm92aWRlckNvZGUgPT09IDQ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXNlclN0cnVjdHVyZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVJbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VyU3RydWN0dXJlID09PSAweDQ3NDEzOTM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVzZXJEYXRhVHlwZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmF3IENFQS02MDggYnl0ZXMgd3JhcHBlZCBpbiBDRUEtNzA4IHBhY2tldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VyRGF0YVR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0Qnl0ZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWNvbmRCeXRlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsQ0NzID0gMzEgJiBmaXJzdEJ5dGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBieXRlQXJyYXkgPSBbZmlyc3RCeXRlLCBzZWNvbmRCeXRlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRvdGFsQ0NzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDMgYnl0ZXMgcGVyIENDXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXkucHVzaChleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheS5wdXNoKGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5LnB1c2goZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2luc2VydFNhbXBsZUluT3JkZXIoX3RoaXMuX3R4dFRyYWNrLnNhbXBsZXMsIHsgdHlwZTogMywgcHRzOiBwZXMucHRzLCBieXRlczogYnl0ZUFycmF5IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBheWxvYWRTaXplIDwgZXhwR29sb21iRGVjb2Rlci5ieXRlc0F2YWlsYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXlsb2FkU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vIFNQU1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHNwc2ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlYnVnICYmIGF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICdTUFMgJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRyYWNrLnNwcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwR29sb21iRGVjb2RlciA9IG5ldyBleHBfZ29sb21iXzEuZGVmYXVsdCh1bml0LmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFNQUygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2sud2lkdGggPSBjb25maWcud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5oZWlnaHQgPSBjb25maWcuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2sucGl4ZWxSYXRpbyA9IGNvbmZpZy5waXhlbFJhdGlvO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2suc3BzID0gW3VuaXQuZGF0YV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5kdXJhdGlvbiA9IF90aGlzLl9kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2RlY2FycmF5ID0gdW5pdC5kYXRhLnN1YmFycmF5KDEsIDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGVjc3RyaW5nID0gJ2F2YzEuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IGNvZGVjYXJyYXlbaV0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaCA9ICcwJyArIGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVjc3RyaW5nICs9IGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5jb2RlYyA9IGNvZGVjc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vIFBQU1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWJ1ZyAmJiBhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnUFBTICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmFjay5wcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrLnBwcyA9IFt1bml0LmRhdGFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vIEFVRFxuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgcHVzaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0cmFjay5hdWRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hBY2Nlc1VuaXQoYXZjU2FtcGxlLCB0cmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXZjU2FtcGxlID0gX3RoaXMuYXZjU2FtcGxlID0gY3JlYXRlQVZDU2FtcGxlKGZhbHNlLCBwZXMucHRzLCBwZXMuZHRzLCBkZWJ1ZyA/ICdBVUQgJyA6ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy8gRmlsbGVyIERhdGFcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICBwdXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICd1bmtub3duIE5BTCAnICsgdW5pdC50eXBlICsgJyAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF2Y1NhbXBsZSAmJiBwdXNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVuaXRzXzEgPSBhdmNTYW1wbGUudW5pdHM7XG4gICAgICAgICAgICAgICAgdW5pdHNfMS5wdXNoKHVuaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gaWYgbGFzdCBQRVMgcGFja2V0LCBwdXNoIHNhbXBsZXNcbiAgICAgICAgaWYgKGxhc3QgJiYgYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICBwdXNoQWNjZXNVbml0KGF2Y1NhbXBsZSwgdHJhY2spO1xuICAgICAgICAgICAgdGhpcy5hdmNTYW1wbGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUU0RlbXV4ZXIucHJvdG90eXBlLl9pbnNlcnRTYW1wbGVJbk9yZGVyID0gZnVuY3Rpb24gKGFyciwgZGF0YSkge1xuICAgICAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgICAgIGlmIChkYXRhLnB0cyA+PSBhcnJbbGVuIC0gMV0ucHRzKSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwb3MgPSBsZW4gLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEucHRzIDwgYXJyW3Bvc10ucHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIuc3BsaWNlKHBvcywgMCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFyci5wdXNoKGRhdGEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUU0RlbXV4ZXIucHJvdG90eXBlLl9nZXRMYXN0TmFsVW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlLCBsYXN0VW5pdDtcbiAgICAgICAgLy8gdHJ5IHRvIGZhbGxiYWNrIHRvIHByZXZpb3VzIHNhbXBsZSBpZiBjdXJyZW50IG9uZSBpcyBlbXB0eVxuICAgICAgICBpZiAoIWF2Y1NhbXBsZSB8fCBhdmNTYW1wbGUudW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2sgPSB0aGlzLl9hdmNUcmFjaywgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XG4gICAgICAgICAgICBhdmNTYW1wbGUgPSBzYW1wbGVzW3NhbXBsZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgdmFyIHVuaXRzID0gYXZjU2FtcGxlLnVuaXRzO1xuICAgICAgICAgICAgbGFzdFVuaXQgPSB1bml0c1t1bml0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFzdFVuaXQ7XG4gICAgfTtcbiAgICBUU0RlbXV4ZXIucHJvdG90eXBlLl9wYXJzZUFWQ05BTHUgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSBhcnJheS5ieXRlTGVuZ3RoLCB2YWx1ZSwgb3ZlcmZsb3csIHRyYWNrID0gdGhpcy5fYXZjVHJhY2ssIHN0YXRlID0gdHJhY2submFsdVN0YXRlIHx8IDAsIGxhc3RTdGF0ZSA9IHN0YXRlO1xuICAgICAgICB2YXIgdW5pdHMgPSBbXSwgdW5pdCwgdW5pdFR5cGUsIGxhc3RVbml0U3RhcnQgPSAtMSwgbGFzdFVuaXRUeXBlO1xuICAgICAgICAvLyBsb2dnZXIubG9nKCdQRVM6JyArIEhleC5oZXhEdW1wKGFycmF5KSk7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIHNwZWNpYWwgdXNlIGNhc2Ugd2hlcmUgd2UgZm91bmQgMyBvciA0LWJ5dGUgc3RhcnQgY29kZXMgZXhhY3RseSBhdCB0aGUgZW5kIG9mIHByZXZpb3VzIFBFUyBwYWNrZXRcbiAgICAgICAgICAgIGxhc3RVbml0U3RhcnQgPSAwO1xuICAgICAgICAgICAgLy8gTkFMdSB0eXBlIGlzIHZhbHVlIHJlYWQgZnJvbSBvZmZzZXQgMFxuICAgICAgICAgICAgbGFzdFVuaXRUeXBlID0gYXJyYXlbMF0gJiAweDFmO1xuICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgICAgaSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICAgIHZhbHVlID0gYXJyYXlbaSsrXTtcbiAgICAgICAgICAgIC8vIG9wdGltaXphdGlvbi4gc3RhdGUgMCBhbmQgMSBhcmUgdGhlIHByZWRvbWluYW50IGNhc2UuIGxldCdzIGhhbmRsZSB0aGVtIG91dHNpZGUgb2YgdGhlIHN3aXRjaC9jYXNlXG4gICAgICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSB2YWx1ZSA/IDAgOiAxO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSB2YWx1ZSA/IDAgOiAyO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGVyZSB3ZSBoYXZlIHN0YXRlIGVpdGhlciBlcXVhbCB0byAyIG9yIDNcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0VW5pdFN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pdCA9IHsgZGF0YTogYXJyYXkuc3ViYXJyYXkobGFzdFVuaXRTdGFydCwgaSAtIHN0YXRlIC0gMSksIHR5cGU6IGxhc3RVbml0VHlwZSB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdwdXNoaW5nIE5BTFUsIHR5cGUvc2l6ZTonICsgdW5pdC50eXBlICsgJy8nICsgdW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB1bml0cy5wdXNoKHVuaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGFzdFVuaXRTdGFydCBpcyB1bmRlZmluZWQgPT4gdGhpcyBpcyB0aGUgZmlyc3Qgc3RhcnQgY29kZSBmb3VuZCBpbiB0aGlzIFBFUyBwYWNrZXRcbiAgICAgICAgICAgICAgICAgICAgLy8gZmlyc3QgY2hlY2sgaWYgc3RhcnQgY29kZSBkZWxpbWl0ZXIgaXMgb3ZlcmxhcHBpbmcgYmV0d2VlbiAyIFBFUyBwYWNrZXRzLFxuICAgICAgICAgICAgICAgICAgICAvLyBpZSBpdCBzdGFydGVkIGluIGxhc3QgcGFja2V0IChsYXN0U3RhdGUgbm90IHplcm8pXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBlbmRlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgUEVTIHBhY2tldCAoaSA8PSA0IC0gbGFzdFN0YXRlKVxuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdFVuaXQgPSB0aGlzLl9nZXRMYXN0TmFsVW5pdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFVuaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0U3RhdGUgJiYgKGkgPD0gNCAtIGxhc3RTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCBkZWxpbWl0ZXIgb3ZlcmxhcHBpbmcgYmV0d2VlbiBQRVMgcGFja2V0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmlwIHN0YXJ0IGRlbGltaXRlciBieXRlcyBmcm9tIHRoZSBlbmQgb2YgbGFzdCBOQUwgdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGxhc3RVbml0IGhhZCBhIHN0YXRlIGRpZmZlcmVudCBmcm9tIHplcm9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFVuaXQuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaXAgbGFzdCBieXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0VW5pdC5kYXRhID0gbGFzdFVuaXQuZGF0YS5zdWJhcnJheSgwLCBsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggLSBsYXN0U3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIE5BTCB1bml0cyBhcmUgbm90IHN0YXJ0aW5nIHJpZ2h0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIFBFUyBwYWNrZXQsIHB1c2ggcHJlY2VkaW5nIGRhdGEgaW50byBwcmV2aW91cyBOQUwgdW5pdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gaSAtIHN0YXRlIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdmVyZmxvdyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdmaXJzdCBOQUxVIGZvdW5kIHdpdGggb3ZlcmZsb3c6JyArIG92ZXJmbG93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gbmV3IFVpbnQ4QXJyYXkobGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoICsgb3ZlcmZsb3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5zZXQobGFzdFVuaXQuZGF0YSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wLnNldChhcnJheS5zdWJhcnJheSgwLCBvdmVyZmxvdyksIGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFVuaXQuZGF0YSA9IHRtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBjYW4gcmVhZCB1bml0IHR5cGVcbiAgICAgICAgICAgICAgICBpZiAoaSA8IGxlbikge1xuICAgICAgICAgICAgICAgICAgICB1bml0VHlwZSA9IGFycmF5W2ldICYgMHgxZjtcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZygnZmluZCBOQUxVIEAgb2Zmc2V0OicgKyBpICsgJyx0eXBlOicgKyB1bml0VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RVbml0U3RhcnQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBsYXN0VW5pdFR5cGUgPSB1bml0VHlwZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IGVub3VnaCBieXRlIHRvIHJlYWQgdW5pdCB0eXBlLiBsZXQncyByZWFkIGl0IG9uIG5leHQgUEVTIHBhcnNpbmdcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RVbml0U3RhcnQgPj0gMCAmJiBzdGF0ZSA+PSAwKSB7XG4gICAgICAgICAgICB1bml0ID0geyBkYXRhOiBhcnJheS5zdWJhcnJheShsYXN0VW5pdFN0YXJ0LCBsZW4pLCB0eXBlOiBsYXN0VW5pdFR5cGUsIHN0YXRlOiBzdGF0ZSB9O1xuICAgICAgICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ3B1c2hpbmcgTkFMVSwgdHlwZS9zaXplL3N0YXRlOicgKyB1bml0LnR5cGUgKyAnLycgKyB1bml0LmRhdGEuYnl0ZUxlbmd0aCArICcvJyArIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBubyBOQUx1IGZvdW5kXG4gICAgICAgIGlmICh1bml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIGFwcGVuZCBwZXMuZGF0YSB0byBwcmV2aW91cyBOQUwgdW5pdFxuICAgICAgICAgICAgdmFyIGxhc3RVbml0ID0gdGhpcy5fZ2V0TGFzdE5hbFVuaXQoKTtcbiAgICAgICAgICAgIGlmIChsYXN0VW5pdCkge1xuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBuZXcgVWludDhBcnJheShsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggKyBhcnJheS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0bXAuc2V0KGxhc3RVbml0LmRhdGEsIDApO1xuICAgICAgICAgICAgICAgIHRtcC5zZXQoYXJyYXksIGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGFzdFVuaXQuZGF0YSA9IHRtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmFjay5uYWx1U3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgcmV0dXJuIHVuaXRzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogcmVtb3ZlIEVtdWxhdGlvbiBQcmV2ZW50aW9uIGJ5dGVzIGZyb20gYSBSQlNQXG4gICAgICovXG4gICAgVFNEZW11eGVyLnByb3RvdHlwZS5kaXNjYXJkRVBCID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aCwgRVBCUG9zaXRpb25zID0gW10sIGkgPSAxLCBuZXdMZW5ndGgsIG5ld0RhdGE7XG4gICAgICAgIC8vIEZpbmQgYWxsIGBFbXVsYXRpb24gUHJldmVudGlvbiBCeXRlc2BcbiAgICAgICAgd2hpbGUgKGkgPCBsZW5ndGggLSAyKSB7XG4gICAgICAgICAgICBpZiAoZGF0YVtpXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGRhdGFbaSArIDFdID09PSAwICYmXG4gICAgICAgICAgICAgICAgZGF0YVtpICsgMl0gPT09IDB4MDMpIHtcbiAgICAgICAgICAgICAgICBFUEJQb3NpdGlvbnMucHVzaChpICsgMik7XG4gICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzIHdlcmUgZm91bmQganVzdCByZXR1cm4gdGhlIG9yaWdpbmFsXG4gICAgICAgIC8vIGFycmF5XG4gICAgICAgIGlmIChFUEJQb3NpdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgYXJyYXkgdG8gaG9sZCB0aGUgTkFMIHVuaXQgZGF0YVxuICAgICAgICBuZXdMZW5ndGggPSBsZW5ndGggLSBFUEJQb3NpdGlvbnMubGVuZ3RoO1xuICAgICAgICBuZXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkobmV3TGVuZ3RoKTtcbiAgICAgICAgdmFyIHNvdXJjZUluZGV4ID0gMDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5ld0xlbmd0aDsgc291cmNlSW5kZXgrKywgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlSW5kZXggPT09IEVQQlBvc2l0aW9uc1swXSkge1xuICAgICAgICAgICAgICAgIC8vIFNraXAgdGhpcyBieXRlXG4gICAgICAgICAgICAgICAgc291cmNlSW5kZXgrKztcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhpcyBwb3NpdGlvbiBpbmRleFxuICAgICAgICAgICAgICAgIEVQQlBvc2l0aW9ucy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3RGF0YVtpXSA9IGRhdGFbc291cmNlSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEYXRhO1xuICAgIH07XG4gICAgVFNEZW11eGVyLnByb3RvdHlwZS5fcGFyc2VBQUNQRVMgPSBmdW5jdGlvbiAocGVzKSB7XG4gICAgICAgIHZhciB0cmFjayA9IHRoaXMuX2F1ZGlvVHJhY2ssIGRhdGEgPSBwZXMuZGF0YSwgcHRzID0gcGVzLnB0cywgc3RhcnRPZmZzZXQgPSAwLCBhYWNPdmVyRmxvdyA9IHRoaXMuYWFjT3ZlckZsb3csIGFhY0xhc3RQVFMgPSB0aGlzLmFhY0xhc3RQVFMsIGZyYW1lRHVyYXRpb24sIGZyYW1lSW5kZXgsIG9mZnNldCwgc3RhbXAsIGxlbjtcbiAgICAgICAgaWYgKGFhY092ZXJGbG93KSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gbmV3IFVpbnQ4QXJyYXkoYWFjT3ZlckZsb3cuYnl0ZUxlbmd0aCArIGRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB0bXAuc2V0KGFhY092ZXJGbG93LCAwKTtcbiAgICAgICAgICAgIHRtcC5zZXQoZGF0YSwgYWFjT3ZlckZsb3cuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAvLyBsb2dnZXIubG9nKGBBQUM6IGFwcGVuZCBvdmVyZmxvd2luZyAke2FhY092ZXJGbG93LmJ5dGVMZW5ndGh9IGJ5dGVzIHRvIGJlZ2lubmluZyBvZiBuZXcgUEVTYCk7XG4gICAgICAgICAgICBkYXRhID0gdG1wO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxvb2sgZm9yIEFEVFMgaGVhZGVyICgweEZGRngpXG4gICAgICAgIGZvciAob2Zmc2V0ID0gc3RhcnRPZmZzZXQsIGxlbiA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW4gLSAxOyBvZmZzZXQrKykge1xuICAgICAgICAgICAgaWYgKEFEVFMuaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIEFEVFMgaGVhZGVyIGRvZXMgbm90IHN0YXJ0IHN0cmFpZ2h0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgUEVTIHBheWxvYWQsIHJhaXNlIGFuIGVycm9yXG4gICAgICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHZhciByZWFzb24gPSB2b2lkIDAsIGZhdGFsID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICByZWFzb24gPSBcIkFBQyBQRVMgZGlkIG5vdCBzdGFydCB3aXRoIEFEVFMgaGVhZGVyLG9mZnNldDpcIiArIG9mZnNldDtcbiAgICAgICAgICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVhc29uID0gJ25vIEFEVFMgaGVhZGVyIGZvdW5kIGluIEFBQyBQRVMnO1xuICAgICAgICAgICAgICAgIGZhdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKFwicGFyc2luZyBlcnJvcjpcIiArIHJlYXNvbik7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBlcnJvcnNfMS5FcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBlcnJvcnNfMS5FcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLCBmYXRhbDogZmF0YWwsIHJlYXNvbjogcmVhc29uIH0pO1xuICAgICAgICAgICAgaWYgKGZhdGFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEFEVFMuaW5pdFRyYWNrQ29uZmlnKHRyYWNrLCB0aGlzLm9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIHRoaXMuYXVkaW9Db2RlYyk7XG4gICAgICAgIGZyYW1lSW5kZXggPSAwO1xuICAgICAgICBmcmFtZUR1cmF0aW9uID0gQURUUy5nZXRGcmFtZUR1cmF0aW9uKHRyYWNrLnNhbXBsZXJhdGUpO1xuICAgICAgICAvLyBpZiBsYXN0IEFBQyBmcmFtZSBpcyBvdmVyZmxvd2luZywgd2Ugc2hvdWxkIGVuc3VyZSB0aW1lc3RhbXBzIGFyZSBjb250aWd1b3VzOlxuICAgICAgICAvLyBmaXJzdCBzYW1wbGUgUFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBQVFMgKyBmcmFtZUR1cmF0aW9uXG4gICAgICAgIGlmIChhYWNPdmVyRmxvdyAmJiBhYWNMYXN0UFRTKSB7XG4gICAgICAgICAgICB2YXIgbmV3UFRTID0gYWFjTGFzdFBUUyArIGZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMobmV3UFRTIC0gcHRzKSA+IDEpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiQUFDOiBhbGlnbiBQVFMgZm9yIG92ZXJsYXBwaW5nIGZyYW1lcyBieSBcIiArIE1hdGgucm91bmQoKG5ld1BUUyAtIHB0cykgLyA5MCkpO1xuICAgICAgICAgICAgICAgIHB0cyA9IG5ld1BUUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzY2FuIGZvciBhYWMgc2FtcGxlc1xuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoQURUUy5pc0hlYWRlcihkYXRhLCBvZmZzZXQpICYmIChvZmZzZXQgKyA1KSA8IGxlbikge1xuICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IEFEVFMuYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZyhgJHtNYXRoLnJvdW5kKGZyYW1lLnNhbXBsZS5wdHMpfSA6IEFBQ2ApO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gZnJhbWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBzdGFtcCA9IGZyYW1lLnNhbXBsZS5wdHM7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lSW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ1VuYWJsZSB0byBwYXJzZSBBQUMgZnJhbWUnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm90aGluZyBmb3VuZCwga2VlcCBsb29raW5nXG4gICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldCA8IGxlbikge1xuICAgICAgICAgICAgYWFjT3ZlckZsb3cgPSBkYXRhLnN1YmFycmF5KG9mZnNldCwgbGVuKTtcbiAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coYEFBQzogb3ZlcmZsb3cgZGV0ZWN0ZWQ6JHtsZW4tb2Zmc2V0fWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBhYWNPdmVyRmxvdztcbiAgICAgICAgdGhpcy5hYWNMYXN0UFRTID0gc3RhbXA7XG4gICAgfTtcbiAgICBUU0RlbXV4ZXIucHJvdG90eXBlLl9wYXJzZU1QRUdQRVMgPSBmdW5jdGlvbiAocGVzKSB7XG4gICAgICAgIHZhciBkYXRhID0gcGVzLmRhdGE7XG4gICAgICAgIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdmFyIGZyYW1lSW5kZXggPSAwO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIHB0cyA9IHBlcy5wdHM7XG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChtcGVnYXVkaW9fMS5kZWZhdWx0LmlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBtcGVnYXVkaW9fMS5kZWZhdWx0LmFwcGVuZEZyYW1lKHRoaXMuX2F1ZGlvVHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGZyYW1lLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZygnVW5hYmxlIHRvIHBhcnNlIE1wZWcgYXVkaW8gZnJhbWUnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm90aGluZyBmb3VuZCwga2VlcCBsb29raW5nXG4gICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRTRGVtdXhlci5wcm90b3R5cGUuX3BhcnNlSUQzUEVTID0gZnVuY3Rpb24gKHBlcykge1xuICAgICAgICB0aGlzLl9pZDNUcmFjay5zYW1wbGVzLnB1c2gocGVzKTtcbiAgICB9O1xuICAgIHJldHVybiBUU0RlbXV4ZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVFNEZW11eGVyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2Vycm9ycy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZXJyb3JzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FcnJvclR5cGVzID0ge1xuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgbmV0d29yayBlcnJvciAobG9hZGluZyBlcnJvciAvIHRpbWVvdXQgLi4uKVxuICAgIE5FVFdPUktfRVJST1I6ICduZXR3b3JrRXJyb3InLFxuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgbWVkaWEgRXJyb3IgKHZpZGVvL3BhcnNpbmcvbWVkaWFzb3VyY2UgZXJyb3IpXG4gICAgTUVESUFfRVJST1I6ICdtZWRpYUVycm9yJyxcbiAgICAvLyBFTUUgKGVuY3J5cHRlZCBtZWRpYSBleHRlbnNpb25zKSBlcnJvcnNcbiAgICBLRVlfU1lTVEVNX0VSUk9SOiAna2V5U3lzdGVtRXJyb3InLFxuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgbXV4IEVycm9yIChkZW11eGluZy9yZW11eGluZylcbiAgICBNVVhfRVJST1I6ICdtdXhFcnJvcicsXG4gICAgLy8gSWRlbnRpZmllciBmb3IgYWxsIG90aGVyIGVycm9yc1xuICAgIE9USEVSX0VSUk9SOiAnb3RoZXJFcnJvcidcbn07XG4vKipcbiAqIEBlbnVtIHtFcnJvckRldGFpbHN9XG4gKiBAdHlwZWRlZiB7c3RyaW5nfSBFcnJvckRldGFpbFxuICovXG5leHBvcnRzLkVycm9yRGV0YWlscyA9IHtcbiAgICBLRVlfU1lTVEVNX05PX0tFWVM6ICdrZXlTeXN0ZW1Ob0tleXMnLFxuICAgIEtFWV9TWVNURU1fTk9fQUNDRVNTOiAna2V5U3lzdGVtTm9BY2Nlc3MnLFxuICAgIEtFWV9TWVNURU1fTk9fU0VTU0lPTjogJ2tleVN5c3RlbU5vU2Vzc2lvbicsXG4gICAgS0VZX1NZU1RFTV9MSUNFTlNFX1JFUVVFU1RfRkFJTEVEOiAna2V5U3lzdGVtTGljZW5zZVJlcXVlc3RGYWlsZWQnLFxuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3QgbG9hZCBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgICBNQU5JRkVTVF9MT0FEX0VSUk9SOiAnbWFuaWZlc3RMb2FkRXJyb3InLFxuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3QgbG9hZCB0aW1lb3V0IC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICAgIE1BTklGRVNUX0xPQURfVElNRU9VVDogJ21hbmlmZXN0TG9hZFRpbWVPdXQnLFxuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3QgcGFyc2luZyBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVhc29uIDogZXJyb3IgcmVhc29ufVxuICAgIE1BTklGRVNUX1BBUlNJTkdfRVJST1I6ICdtYW5pZmVzdFBhcnNpbmdFcnJvcicsXG4gICAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCB3aXRoIG9ubHkgaW5jb21wYXRpYmxlIGNvZGVjcyBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVhc29uIDogZXJyb3IgcmVhc29ufVxuICAgIE1BTklGRVNUX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1I6ICdtYW5pZmVzdEluY29tcGF0aWJsZUNvZGVjc0Vycm9yJyxcbiAgICAvLyBJZGVudGlmaWVyIGZvciBhIGxldmVsIGxvYWQgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gICAgTEVWRUxfTE9BRF9FUlJPUjogJ2xldmVsTG9hZEVycm9yJyxcbiAgICAvLyBJZGVudGlmaWVyIGZvciBhIGxldmVsIGxvYWQgdGltZW91dCAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgICBMRVZFTF9MT0FEX1RJTUVPVVQ6ICdsZXZlbExvYWRUaW1lT3V0JyxcbiAgICAvLyBJZGVudGlmaWVyIGZvciBhIGxldmVsIHN3aXRjaCBlcnJvciAtIGRhdGE6IHsgbGV2ZWwgOiBmYXVsdHkgbGV2ZWwgSWQsIGV2ZW50IDogZXJyb3IgZGVzY3JpcHRpb259XG4gICAgTEVWRUxfU1dJVENIX0VSUk9SOiAnbGV2ZWxTd2l0Y2hFcnJvcicsXG4gICAgLy8gSWRlbnRpZmllciBmb3IgYW4gYXVkaW8gdHJhY2sgbG9hZCBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgICBBVURJT19UUkFDS19MT0FEX0VSUk9SOiAnYXVkaW9UcmFja0xvYWRFcnJvcicsXG4gICAgLy8gSWRlbnRpZmllciBmb3IgYW4gYXVkaW8gdHJhY2sgbG9hZCB0aW1lb3V0IC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICAgIEFVRElPX1RSQUNLX0xPQURfVElNRU9VVDogJ2F1ZGlvVHJhY2tMb2FkVGltZU91dCcsXG4gICAgLy8gSWRlbnRpZmllciBmb3IgZnJhZ21lbnQgbG9hZCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgICBGUkFHX0xPQURfRVJST1I6ICdmcmFnTG9hZEVycm9yJyxcbiAgICAvLyBJZGVudGlmaWVyIGZvciBmcmFnbWVudCBsb2FkIHRpbWVvdXQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3R9XG4gICAgRlJBR19MT0FEX1RJTUVPVVQ6ICdmcmFnTG9hZFRpbWVPdXQnLFxuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgZnJhZ21lbnQgZGVjcnlwdGlvbiBlcnJvciBldmVudCAtIGRhdGE6IHtpZCA6IGRlbXV4ZXIgSWQsZnJhZzogZnJhZ21lbnQgb2JqZWN0LCByZWFzb24gOiBwYXJzaW5nIGVycm9yIGRlc2NyaXB0aW9uIH1cbiAgICBGUkFHX0RFQ1JZUFRfRVJST1I6ICdmcmFnRGVjcnlwdEVycm9yJyxcbiAgICAvLyBJZGVudGlmaWVyIGZvciBhIGZyYWdtZW50IHBhcnNpbmcgZXJyb3IgZXZlbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBJZCwgcmVhc29uIDogcGFyc2luZyBlcnJvciBkZXNjcmlwdGlvbiB9XG4gICAgLy8gd2lsbCBiZSByZW5hbWVkIERFTVVYX1BBUlNJTkdfRVJST1IgYW5kIHN3aXRjaGVkIHRvIE1VWF9FUlJPUiBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG4gICAgRlJBR19QQVJTSU5HX0VSUk9SOiAnZnJhZ1BhcnNpbmdFcnJvcicsXG4gICAgLy8gSWRlbnRpZmllciBmb3IgYSByZW11eCBhbGxvYyBlcnJvciBldmVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIElkLCBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBieXRlcyA6IG5iIG9mIGJ5dGVzIG9uIHdoaWNoIGFsbG9jYXRpb24gZmFpbGVkICwgcmVhc29uIDogZXJyb3IgdGV4dCB9XG4gICAgUkVNVVhfQUxMT0NfRVJST1I6ICdyZW11eEFsbG9jRXJyb3InLFxuICAgIC8vIElkZW50aWZpZXIgZm9yIGRlY3J5cHQga2V5IGxvYWQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gICAgS0VZX0xPQURfRVJST1I6ICdrZXlMb2FkRXJyb3InLFxuICAgIC8vIElkZW50aWZpZXIgZm9yIGRlY3J5cHQga2V5IGxvYWQgdGltZW91dCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cbiAgICBLRVlfTE9BRF9USU1FT1VUOiAna2V5TG9hZFRpbWVPdXQnLFxuICAgIC8vIFRyaWdnZXJlZCB3aGVuIGFuIGV4Y2VwdGlvbiBvY2N1cnMgd2hpbGUgYWRkaW5nIGEgc291cmNlQnVmZmVyIHRvIE1lZGlhU291cmNlIC0gZGF0YSA6IHsgIGVyciA6IGV4Y2VwdGlvbiAsIG1pbWVUeXBlIDogbWltZVR5cGUgfVxuICAgIEJVRkZFUl9BRERfQ09ERUNfRVJST1I6ICdidWZmZXJBZGRDb2RlY0Vycm9yJyxcbiAgICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBhcHBlbmQgZXJyb3IgLSBkYXRhOiBhcHBlbmQgZXJyb3IgZGVzY3JpcHRpb25cbiAgICBCVUZGRVJfQVBQRU5EX0VSUk9SOiAnYnVmZmVyQXBwZW5kRXJyb3InLFxuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIGFwcGVuZGluZyBlcnJvciBldmVudCAtIGRhdGE6IGFwcGVuZGluZyBlcnJvciBkZXNjcmlwdGlvblxuICAgIEJVRkZFUl9BUFBFTkRJTkdfRVJST1I6ICdidWZmZXJBcHBlbmRpbmdFcnJvcicsXG4gICAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgc3RhbGxlZCBlcnJvciBldmVudFxuICAgIEJVRkZFUl9TVEFMTEVEX0VSUk9SOiAnYnVmZmVyU3RhbGxlZEVycm9yJyxcbiAgICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBmdWxsIGV2ZW50XG4gICAgQlVGRkVSX0ZVTExfRVJST1I6ICdidWZmZXJGdWxsRXJyb3InLFxuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIHNlZWsgb3ZlciBob2xlIGV2ZW50XG4gICAgQlVGRkVSX1NFRUtfT1ZFUl9IT0xFOiAnYnVmZmVyU2Vla092ZXJIb2xlJyxcbiAgICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBudWRnZSBvbiBzdGFsbCAocGxheWJhY2sgaXMgc3R1Y2sgYWx0aG91Z2ggY3VycmVudFRpbWUgaXMgaW4gYSBidWZmZXJlZCBhcmVhKVxuICAgIEJVRkZFUl9OVURHRV9PTl9TVEFMTDogJ2J1ZmZlck51ZGdlT25TdGFsbCcsXG4gICAgLy8gSWRlbnRpZmllciBmb3IgYW4gaW50ZXJuYWwgZXhjZXB0aW9uIGhhcHBlbmluZyBpbnNpZGUgaGxzLmpzIHdoaWxlIGhhbmRsaW5nIGFuIGV2ZW50XG4gICAgSU5URVJOQUxfRVhDRVBUSU9OOiAnaW50ZXJuYWxFeGNlcHRpb24nXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2V2ZW50LWhhbmRsZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9ldmVudC1oYW5kbGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4qXG4qIEFsbCBvYmplY3RzIGluIHRoZSBldmVudCBoYW5kbGluZyBjaGFpbiBzaG91bGQgaW5oZXJpdCBmcm9tIHRoaXMgY2xhc3NcbipcbiovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbG9nZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci5qc1wiKTtcbnZhciBlcnJvcnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLmpzXCIpO1xudmFyIGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMuanNcIik7XG52YXIgRk9SQklEREVOX0VWRU5UX05BTUVTID0ge1xuICAgICdobHNFdmVudEdlbmVyaWMnOiB0cnVlLFxuICAgICdobHNIYW5kbGVyRGVzdHJveWluZyc6IHRydWUsXG4gICAgJ2hsc0hhbmRsZXJEZXN0cm95ZWQnOiB0cnVlXG59O1xudmFyIEV2ZW50SGFuZGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudEhhbmRsZXIoaGxzKSB7XG4gICAgICAgIHZhciBldmVudHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGV2ZW50c1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhscyA9IGhscztcbiAgICAgICAgdGhpcy5vbkV2ZW50ID0gdGhpcy5vbkV2ZW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlZEV2ZW50cyA9IGV2ZW50cztcbiAgICAgICAgdGhpcy51c2VHZW5lcmljSGFuZGxlciA9IHRydWU7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9uSGFuZGxlckRlc3Ryb3lpbmcoKTtcbiAgICAgICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMub25IYW5kbGVyRGVzdHJveWVkKCk7XG4gICAgfTtcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLm9uSGFuZGxlckRlc3Ryb3lpbmcgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5vbkhhbmRsZXJEZXN0cm95ZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5pc0V2ZW50SGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLmhhbmRsZWRFdmVudHMgPT09ICdvYmplY3QnICYmIHRoaXMuaGFuZGxlZEV2ZW50cy5sZW5ndGggJiYgdHlwZW9mIHRoaXMub25FdmVudCA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9O1xuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRXZlbnRIYW5kbGVyKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChGT1JCSURERU5fRVZFTlRfTkFNRVNbZXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9yYmlkZGVuIGV2ZW50LW5hbWU6ICcgKyBldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaGxzLm9uKGV2ZW50LCB0aGlzLm9uRXZlbnQpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUudW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFdmVudEhhbmRsZXIoKSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVkRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5obHMub2ZmKGV2ZW50LCB0aGlzLm9uRXZlbnQpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGFyZ3VtZW50czogZXZlbnQgKHN0cmluZyksIGRhdGEgKGFueSlcbiAgICAgKi9cbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLm9uRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgdGhpcy5vbkV2ZW50R2VuZXJpYyhldmVudCwgZGF0YSk7XG4gICAgfTtcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLm9uRXZlbnRHZW5lcmljID0gZnVuY3Rpb24gKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIHZhciBldmVudFRvRnVuY3Rpb24gPSBmdW5jdGlvbiAoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBmdW5jTmFtZSA9ICdvbicgKyBldmVudC5yZXBsYWNlKCdobHMnLCAnJyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXNbZnVuY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnQgXCIgKyBldmVudCArIFwiIGhhcyBubyBnZW5lcmljIGhhbmRsZXIgaW4gdGhpcyBcIiArIHRoaXMuY29uc3RydWN0b3IubmFtZSArIFwiIGNsYXNzICh0cmllZCBcIiArIGZ1bmNOYW1lICsgXCIpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbZnVuY05hbWVdLmJpbmQodGhpcywgZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBldmVudFRvRnVuY3Rpb24uY2FsbCh0aGlzLCBldmVudCwgZGF0YSkuY2FsbCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5lcnJvcihcIkFuIGludGVybmFsIGVycm9yIGhhcHBlbmVkIHdoaWxlIGhhbmRsaW5nIGV2ZW50IFwiICsgZXZlbnQgKyBcIi4gRXJyb3IgbWVzc2FnZTogXFxcIlwiICsgZXJyLm1lc3NhZ2UgKyBcIlxcXCIuIEhlcmUgaXMgYSBzdGFja3RyYWNlOlwiLCBlcnIpO1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IGVycm9yc18xLkVycm9yVHlwZXMuT1RIRVJfRVJST1IsIGRldGFpbHM6IGVycm9yc18xLkVycm9yRGV0YWlscy5JTlRFUk5BTF9FWENFUFRJT04sIGZhdGFsOiBmYWxzZSwgZXZlbnQ6IGV2ZW50LCBlcnI6IGVyciB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEV2ZW50SGFuZGxlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudEhhbmRsZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZXZlbnRzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9ldmVudHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEByZWFkb25seVxuICogQGVudW0ge3N0cmluZ31cbiAqL1xudmFyIEhsc0V2ZW50cyA9IHtcbiAgICAvLyBmaXJlZCBiZWZvcmUgTWVkaWFTb3VyY2UgaXMgYXR0YWNoaW5nIHRvIG1lZGlhIGVsZW1lbnQgLSBkYXRhOiB7IG1lZGlhIH1cbiAgICBNRURJQV9BVFRBQ0hJTkc6ICdobHNNZWRpYUF0dGFjaGluZycsXG4gICAgLy8gZmlyZWQgd2hlbiBNZWRpYVNvdXJjZSBoYXMgYmVlbiBzdWNjZXNmdWxseSBhdHRhY2hlZCB0byBtZWRpYSBlbGVtZW50IC0gZGF0YTogeyB9XG4gICAgTUVESUFfQVRUQUNIRUQ6ICdobHNNZWRpYUF0dGFjaGVkJyxcbiAgICAvLyBmaXJlZCBiZWZvcmUgZGV0YWNoaW5nIE1lZGlhU291cmNlIGZyb20gbWVkaWEgZWxlbWVudCAtIGRhdGE6IHsgfVxuICAgIE1FRElBX0RFVEFDSElORzogJ2hsc01lZGlhRGV0YWNoaW5nJyxcbiAgICAvLyBmaXJlZCB3aGVuIE1lZGlhU291cmNlIGhhcyBiZWVuIGRldGFjaGVkIGZyb20gbWVkaWEgZWxlbWVudCAtIGRhdGE6IHsgfVxuICAgIE1FRElBX0RFVEFDSEVEOiAnaGxzTWVkaWFEZXRhY2hlZCcsXG4gICAgLy8gZmlyZWQgd2hlbiB3ZSBidWZmZXIgaXMgZ29pbmcgdG8gYmUgcmVzZXQgLSBkYXRhOiB7IH1cbiAgICBCVUZGRVJfUkVTRVQ6ICdobHNCdWZmZXJSZXNldCcsXG4gICAgLy8gZmlyZWQgd2hlbiB3ZSBrbm93IGFib3V0IHRoZSBjb2RlY3MgdGhhdCB3ZSBuZWVkIGJ1ZmZlcnMgZm9yIHRvIHB1c2ggaW50byAtIGRhdGE6IHt0cmFja3MgOiB7IGNvbnRhaW5lciwgY29kZWMsIGxldmVsQ29kZWMsIGluaXRTZWdtZW50LCBtZXRhZGF0YSB9fVxuICAgIEJVRkZFUl9DT0RFQ1M6ICdobHNCdWZmZXJDb2RlY3MnLFxuICAgIC8vIGZpcmVkIHdoZW4gc291cmNlYnVmZmVycyBoYXZlIGJlZW4gY3JlYXRlZCAtIGRhdGE6IHsgdHJhY2tzIDogdHJhY2tzIH1cbiAgICBCVUZGRVJfQ1JFQVRFRDogJ2hsc0J1ZmZlckNyZWF0ZWQnLFxuICAgIC8vIGZpcmVkIHdoZW4gd2UgYXBwZW5kIGEgc2VnbWVudCB0byB0aGUgYnVmZmVyIC0gZGF0YTogeyBzZWdtZW50OiBzZWdtZW50IG9iamVjdCB9XG4gICAgQlVGRkVSX0FQUEVORElORzogJ2hsc0J1ZmZlckFwcGVuZGluZycsXG4gICAgLy8gZmlyZWQgd2hlbiB3ZSBhcmUgZG9uZSB3aXRoIGFwcGVuZGluZyBhIG1lZGlhIHNlZ21lbnQgdG8gdGhlIGJ1ZmZlciAtIGRhdGEgOiB7IHBhcmVudCA6IHNlZ21lbnQgcGFyZW50IHRoYXQgdHJpZ2dlcmVkIEJVRkZFUl9BUFBFTkRJTkcsIHBlbmRpbmcgOiBuYiBvZiBzZWdtZW50cyB3YWl0aW5nIGZvciBhcHBlbmRpbmcgZm9yIHRoaXMgc2VnbWVudCBwYXJlbnR9XG4gICAgQlVGRkVSX0FQUEVOREVEOiAnaGxzQnVmZmVyQXBwZW5kZWQnLFxuICAgIC8vIGZpcmVkIHdoZW4gdGhlIHN0cmVhbSBpcyBmaW5pc2hlZCBhbmQgd2Ugd2FudCB0byBub3RpZnkgdGhlIG1lZGlhIGJ1ZmZlciB0aGF0IHRoZXJlIHdpbGwgYmUgbm8gbW9yZSBkYXRhIC0gZGF0YTogeyB9XG4gICAgQlVGRkVSX0VPUzogJ2hsc0J1ZmZlckVvcycsXG4gICAgLy8gZmlyZWQgd2hlbiB0aGUgbWVkaWEgYnVmZmVyIHNob3VsZCBiZSBmbHVzaGVkIC0gZGF0YSB7IHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQgfVxuICAgIEJVRkZFUl9GTFVTSElORzogJ2hsc0J1ZmZlckZsdXNoaW5nJyxcbiAgICAvLyBmaXJlZCB3aGVuIHRoZSBtZWRpYSBidWZmZXIgaGFzIGJlZW4gZmx1c2hlZCAtIGRhdGE6IHsgfVxuICAgIEJVRkZFUl9GTFVTSEVEOiAnaGxzQnVmZmVyRmx1c2hlZCcsXG4gICAgLy8gZmlyZWQgdG8gc2lnbmFsIHRoYXQgYSBtYW5pZmVzdCBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogbWFuaWZlc3RVUkx9XG4gICAgTUFOSUZFU1RfTE9BRElORzogJ2hsc01hbmlmZXN0TG9hZGluZycsXG4gICAgLy8gZmlyZWQgYWZ0ZXIgbWFuaWZlc3QgaGFzIGJlZW4gbG9hZGVkIC0gZGF0YTogeyBsZXZlbHMgOiBbYXZhaWxhYmxlIHF1YWxpdHkgbGV2ZWxzXSwgYXVkaW9UcmFja3MgOiBbIGF2YWlsYWJsZSBhdWRpbyB0cmFja3NdLCB1cmwgOiBtYW5pZmVzdFVSTCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBtdGltZX19XG4gICAgTUFOSUZFU1RfTE9BREVEOiAnaGxzTWFuaWZlc3RMb2FkZWQnLFxuICAgIC8vIGZpcmVkIGFmdGVyIG1hbmlmZXN0IGhhcyBiZWVuIHBhcnNlZCAtIGRhdGE6IHsgbGV2ZWxzIDogW2F2YWlsYWJsZSBxdWFsaXR5IGxldmVsc10sIGZpcnN0TGV2ZWwgOiBpbmRleCBvZiBmaXJzdCBxdWFsaXR5IGxldmVsIGFwcGVhcmluZyBpbiBNYW5pZmVzdH1cbiAgICBNQU5JRkVTVF9QQVJTRUQ6ICdobHNNYW5pZmVzdFBhcnNlZCcsXG4gICAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHN3aXRjaCBpcyByZXF1ZXN0ZWQgLSBkYXRhOiB7IGxldmVsIDogaWQgb2YgbmV3IGxldmVsIH1cbiAgICBMRVZFTF9TV0lUQ0hJTkc6ICdobHNMZXZlbFN3aXRjaGluZycsXG4gICAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHN3aXRjaCBpcyBlZmZlY3RpdmUgLSBkYXRhOiB7IGxldmVsIDogaWQgb2YgbmV3IGxldmVsIH1cbiAgICBMRVZFTF9TV0lUQ0hFRDogJ2hsc0xldmVsU3dpdGNoZWQnLFxuICAgIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCBwbGF5bGlzdCBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogbGV2ZWwgVVJMLCBsZXZlbCA6IGlkIG9mIGxldmVsIGJlaW5nIGxvYWRlZH1cbiAgICBMRVZFTF9MT0FESU5HOiAnaGxzTGV2ZWxMb2FkaW5nJyxcbiAgICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgcGxheWxpc3QgbG9hZGluZyBmaW5pc2hlcyAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGxldmVsIDogaWQgb2YgbG9hZGVkIGxldmVsLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIG10aW1lfSB9XG4gICAgTEVWRUxfTE9BREVEOiAnaGxzTGV2ZWxMb2FkZWQnLFxuICAgIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCdzIGRldGFpbHMgaGF2ZSBiZWVuIHVwZGF0ZWQgYmFzZWQgb24gcHJldmlvdXMgZGV0YWlscywgYWZ0ZXIgaXQgaGFzIGJlZW4gbG9hZGVkIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgbGV2ZWwgOiBpZCBvZiB1cGRhdGVkIGxldmVsIH1cbiAgICBMRVZFTF9VUERBVEVEOiAnaGxzTGV2ZWxVcGRhdGVkJyxcbiAgICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwncyBQVFMgaW5mb3JtYXRpb24gaGFzIGJlZW4gdXBkYXRlZCBhZnRlciBwYXJzaW5nIGEgZnJhZ21lbnQgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBsZXZlbCA6IGlkIG9mIHVwZGF0ZWQgbGV2ZWwsIGRyaWZ0OiBQVFMgZHJpZnQgb2JzZXJ2ZWQgd2hlbiBwYXJzaW5nIGxhc3QgZnJhZ21lbnQgfVxuICAgIExFVkVMX1BUU19VUERBVEVEOiAnaGxzTGV2ZWxQdHNVcGRhdGVkJyxcbiAgICAvLyBmaXJlZCB0byBub3RpZnkgdGhhdCBhdWRpbyB0cmFjayBsaXN0cyBoYXMgYmVlbiB1cGRhdGVkIC0gZGF0YTogeyBhdWRpb1RyYWNrcyA6IGF1ZGlvVHJhY2tzIH1cbiAgICBBVURJT19UUkFDS1NfVVBEQVRFRDogJ2hsc0F1ZGlvVHJhY2tzVXBkYXRlZCcsXG4gICAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBzd2l0Y2hpbmcgaXMgcmVxdWVzdGVkIC0gZGF0YTogeyBpZCA6IGF1ZGlvIHRyYWNrIGlkIH1cbiAgICBBVURJT19UUkFDS19TV0lUQ0hJTkc6ICdobHNBdWRpb1RyYWNrU3dpdGNoaW5nJyxcbiAgICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIHN3aXRjaCBhY3R1YWxseSBvY2N1cnMgLSBkYXRhOiB7IGlkIDogYXVkaW8gdHJhY2sgaWQgfVxuICAgIEFVRElPX1RSQUNLX1NXSVRDSEVEOiAnaGxzQXVkaW9UcmFja1N3aXRjaGVkJyxcbiAgICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBhdWRpbyB0cmFjayBVUkwsIGlkIDogYXVkaW8gdHJhY2sgaWQgfVxuICAgIEFVRElPX1RSQUNLX0xPQURJTkc6ICdobHNBdWRpb1RyYWNrTG9hZGluZycsXG4gICAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBsb2FkaW5nIGZpbmlzaGVzIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgaWQgOiBhdWRpbyB0cmFjayBpZCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBtdGltZSB9IH1cbiAgICBBVURJT19UUkFDS19MT0FERUQ6ICdobHNBdWRpb1RyYWNrTG9hZGVkJyxcbiAgICAvLyBmaXJlZCB0byBub3RpZnkgdGhhdCBzdWJ0aXRsZSB0cmFjayBsaXN0cyBoYXMgYmVlbiB1cGRhdGVkIC0gZGF0YTogeyBzdWJ0aXRsZVRyYWNrcyA6IHN1YnRpdGxlVHJhY2tzIH1cbiAgICBTVUJUSVRMRV9UUkFDS1NfVVBEQVRFRDogJ2hsc1N1YnRpdGxlVHJhY2tzVXBkYXRlZCcsXG4gICAgLy8gZmlyZWQgd2hlbiBhbiBzdWJ0aXRsZSB0cmFjayBzd2l0Y2ggb2NjdXJzIC0gZGF0YTogeyBpZCA6IHN1YnRpdGxlIHRyYWNrIGlkIH1cbiAgICBTVUJUSVRMRV9UUkFDS19TV0lUQ0g6ICdobHNTdWJ0aXRsZVRyYWNrU3dpdGNoJyxcbiAgICAvLyBmaXJlZCB3aGVuIGEgc3VidGl0bGUgdHJhY2sgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IHVybCA6IHN1YnRpdGxlIHRyYWNrIFVSTCwgaWQgOiBzdWJ0aXRsZSB0cmFjayBpZCB9XG4gICAgU1VCVElUTEVfVFJBQ0tfTE9BRElORzogJ2hsc1N1YnRpdGxlVHJhY2tMb2FkaW5nJyxcbiAgICAvLyBmaXJlZCB3aGVuIGEgc3VidGl0bGUgdHJhY2sgbG9hZGluZyBmaW5pc2hlcyAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGlkIDogc3VidGl0bGUgdHJhY2sgaWQsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgbXRpbWUgfSB9XG4gICAgU1VCVElUTEVfVFJBQ0tfTE9BREVEOiAnaGxzU3VidGl0bGVUcmFja0xvYWRlZCcsXG4gICAgLy8gZmlyZWQgd2hlbiBhIHN1YnRpdGxlIGZyYWdtZW50IGhhcyBiZWVuIHByb2Nlc3NlZCAtIGRhdGE6IHsgc3VjY2VzcyA6IGJvb2xlYW4sIGZyYWcgOiB0aGUgcHJvY2Vzc2VkIGZyYWcgfVxuICAgIFNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VEOiAnaGxzU3VidGl0bGVGcmFnUHJvY2Vzc2VkJyxcbiAgICAvLyBmaXJlZCB3aGVuIHRoZSBmaXJzdCB0aW1lc3RhbXAgaXMgZm91bmQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgaW5pdFBUUzogaW5pdFBUUywgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XG4gICAgSU5JVF9QVFNfRk9VTkQ6ICdobHNJbml0UHRzRm91bmQnLFxuICAgIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XG4gICAgRlJBR19MT0FESU5HOiAnaGxzRnJhZ0xvYWRpbmcnLFxuICAgIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBsb2FkaW5nIGlzIHByb2dyZXNzaW5nIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCB7IHRyZXF1ZXN0LCB0Zmlyc3QsIGxvYWRlZCB9IH1cbiAgICBGUkFHX0xPQURfUFJPR1JFU1M6ICdobHNGcmFnTG9hZFByb2dyZXNzJyxcbiAgICAvLyBJZGVudGlmaWVyIGZvciBmcmFnbWVudCBsb2FkIGFib3J0aW5nIGZvciBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QgfVxuICAgIEZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRDogJ2hsc0ZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCcsXG4gICAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGxvYWRpbmcgaXMgY29tcGxldGVkIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBwYXlsb2FkIDogZnJhZ21lbnQgcGF5bG9hZCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBsZW5ndGggfSB9XG4gICAgRlJBR19MT0FERUQ6ICdobHNGcmFnTG9hZGVkJyxcbiAgICAvLyBmaXJlZCB3aGVuIGEgZnJhZ21lbnQgaGFzIGZpbmlzaGVkIGRlY3J5cHRpbmcgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBwYXlsb2FkIDogZnJhZ21lbnQgcGF5bG9hZCwgc3RhdHMgOiB7IHRzdGFydCwgdGRlY3J5cHQgfSB9XG4gICAgRlJBR19ERUNSWVBURUQ6ICdobHNGcmFnRGVjcnlwdGVkJyxcbiAgICAvLyBmaXJlZCB3aGVuIEluaXQgU2VnbWVudCBoYXMgYmVlbiBleHRyYWN0ZWQgZnJvbSBmcmFnbWVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIG1vb3YgOiBtb292IE1QNCBib3gsIGNvZGVjcyA6IGNvZGVjcyBmb3VuZCB3aGlsZSBwYXJzaW5nIGZyYWdtZW50IH1cbiAgICBGUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5UOiAnaGxzRnJhZ1BhcnNpbmdJbml0U2VnbWVudCcsXG4gICAgLy8gZmlyZWQgd2hlbiBwYXJzaW5nIHNlaSB0ZXh0IGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIHNhbXBsZXMgOiBbIHNlaSBzYW1wbGVzIHBlcyBdIH1cbiAgICBGUkFHX1BBUlNJTkdfVVNFUkRBVEE6ICdobHNGcmFnUGFyc2luZ1VzZXJkYXRhJyxcbiAgICAvLyBmaXJlZCB3aGVuIHBhcnNpbmcgaWQzIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIHNhbXBsZXMgOiBbIGlkMyBzYW1wbGVzIHBlcyBdIH1cbiAgICBGUkFHX1BBUlNJTkdfTUVUQURBVEE6ICdobHNGcmFnUGFyc2luZ01ldGFkYXRhJyxcbiAgICAvLyBmaXJlZCB3aGVuIGRhdGEgaGF2ZSBiZWVuIGV4dHJhY3RlZCBmcm9tIGZyYWdtZW50IC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCwgZGF0YTEgOiBtb29mIE1QNCBib3ggb3IgVFMgZnJhZ21lbnRzLCBkYXRhMiA6IG1kYXQgTVA0IGJveCBvciBudWxsfVxuICAgIEZSQUdfUEFSU0lOR19EQVRBOiAnaGxzRnJhZ1BhcnNpbmdEYXRhJyxcbiAgICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IHBhcnNpbmcgaXMgY29tcGxldGVkIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCB9XG4gICAgRlJBR19QQVJTRUQ6ICdobHNGcmFnUGFyc2VkJyxcbiAgICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IHJlbXV4ZWQgTVA0IGJveGVzIGhhdmUgYWxsIGJlZW4gYXBwZW5kZWQgaW50byBTb3VyY2VCdWZmZXIgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCB0cGFyc2VkLCB0YnVmZmVyZWQsIGxlbmd0aCwgYndFc3RpbWF0ZSB9IH1cbiAgICBGUkFHX0JVRkZFUkVEOiAnaGxzRnJhZ0J1ZmZlcmVkJyxcbiAgICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IG1hdGNoaW5nIHdpdGggY3VycmVudCBtZWRpYSBwb3NpdGlvbiBpcyBjaGFuZ2luZyAtIGRhdGEgOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XG4gICAgRlJBR19DSEFOR0VEOiAnaGxzRnJhZ0NoYW5nZWQnLFxuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgRlBTIGRyb3AgZXZlbnQgLSBkYXRhOiB7IGN1cmVudERyb3BwZWQsIGN1cnJlbnREZWNvZGVkLCB0b3RhbERyb3BwZWRGcmFtZXMgfVxuICAgIEZQU19EUk9QOiAnaGxzRnBzRHJvcCcsXG4gICAgLy8gdHJpZ2dlcmVkIHdoZW4gRlBTIGRyb3AgdHJpZ2dlcnMgYXV0byBsZXZlbCBjYXBwaW5nIC0gZGF0YTogeyBsZXZlbCwgZHJvcHBlZGxldmVsIH1cbiAgICBGUFNfRFJPUF9MRVZFTF9DQVBQSU5HOiAnaGxzRnBzRHJvcExldmVsQ2FwcGluZycsXG4gICAgLy8gSWRlbnRpZmllciBmb3IgYW4gZXJyb3IgZXZlbnQgLSBkYXRhOiB7IHR5cGUgOiBlcnJvciB0eXBlLCBkZXRhaWxzIDogZXJyb3IgZGV0YWlscywgZmF0YWwgOiBpZiB0cnVlLCBobHMuanMgY2Fubm90L3dpbGwgbm90IHRyeSB0byByZWNvdmVyLCBpZiBmYWxzZSwgaGxzLmpzIHdpbGwgdHJ5IHRvIHJlY292ZXIsb3RoZXIgZXJyb3Igc3BlY2lmaWMgZGF0YSB9XG4gICAgRVJST1I6ICdobHNFcnJvcicsXG4gICAgLy8gZmlyZWQgd2hlbiBobHMuanMgaW5zdGFuY2Ugc3RhcnRzIGRlc3Ryb3lpbmcuIERpZmZlcmVudCBmcm9tIE1FRElBX0RFVEFDSEVEIGFzIG9uZSBjb3VsZCB3YW50IHRvIGRldGFjaCBhbmQgcmVhdHRhY2ggYSBtZWRpYSB0byB0aGUgaW5zdGFuY2Ugb2YgaGxzLmpzIHRvIGhhbmRsZSBtaWQtcm9sbHMgZm9yIGV4YW1wbGUgLSBkYXRhOiB7IH1cbiAgICBERVNUUk9ZSU5HOiAnaGxzRGVzdHJveWluZycsXG4gICAgLy8gZmlyZWQgd2hlbiBhIGRlY3J5cHQga2V5IGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0IH1cbiAgICBLRVlfTE9BRElORzogJ2hsc0tleUxvYWRpbmcnLFxuICAgIC8vIGZpcmVkIHdoZW4gYSBkZWNyeXB0IGtleSBsb2FkaW5nIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcGF5bG9hZCA6IGtleSBwYXlsb2FkLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIGxlbmd0aCB9IH1cbiAgICBLRVlfTE9BREVEOiAnaGxzS2V5TG9hZGVkJyxcbiAgICAvLyBmaXJlZCB1cG9uIHN0cmVhbSBjb250cm9sbGVyIHN0YXRlIHRyYW5zaXRpb25zIC0gZGF0YTogeyBwcmV2aW91c1N0YXRlLCBuZXh0U3RhdGUgfVxuICAgIFNUUkVBTV9TVEFURV9UUkFOU0lUSU9OOiAnaGxzU3RyZWFtU3RhdGVUcmFuc2l0aW9uJ1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhsc0V2ZW50cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9obHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2hscy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFVSTFRvb2xraXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB1cmwtdG9vbGtpdCAqLyBcIi4vbm9kZV9tb2R1bGVzL3VybC10b29sa2l0L3NyYy91cmwtdG9vbGtpdC5qc1wiKTtcbnZhciBlcnJvcnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLmpzXCIpO1xudmFyIHBsYXlsaXN0X2xvYWRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sb2FkZXIvcGxheWxpc3QtbG9hZGVyICovIFwiLi9zcmMvbG9hZGVyL3BsYXlsaXN0LWxvYWRlci5qc1wiKTtcbnZhciBmcmFnbWVudF9sb2FkZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbG9hZGVyL2ZyYWdtZW50LWxvYWRlciAqLyBcIi4vc3JjL2xvYWRlci9mcmFnbWVudC1sb2FkZXIuanNcIik7XG52YXIga2V5X2xvYWRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sb2FkZXIva2V5LWxvYWRlciAqLyBcIi4vc3JjL2xvYWRlci9rZXktbG9hZGVyLmpzXCIpO1xudmFyIGZyYWdtZW50X3RyYWNrZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udHJvbGxlci9mcmFnbWVudC10cmFja2VyICovIFwiLi9zcmMvY29udHJvbGxlci9mcmFnbWVudC10cmFja2VyLmpzXCIpO1xudmFyIHN0cmVhbV9jb250cm9sbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvc3RyZWFtLWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL3N0cmVhbS1jb250cm9sbGVyLmpzXCIpO1xudmFyIGxldmVsX2NvbnRyb2xsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udHJvbGxlci9sZXZlbC1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9sZXZlbC1jb250cm9sbGVyLmpzXCIpO1xudmFyIGlkM190cmFja19jb250cm9sbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvaWQzLXRyYWNrLWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2lkMy10cmFjay1jb250cm9sbGVyLmpzXCIpO1xudmFyIGlzX3N1cHBvcnRlZF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1zdXBwb3J0ZWQgKi8gXCIuL3NyYy9pcy1zdXBwb3J0ZWQuanNcIik7XG52YXIgbG9nZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci5qc1wiKTtcbnZhciBjb25maWdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29uZmlnICovIFwiLi9zcmMvY29uZmlnLmpzXCIpO1xudmFyIGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMuanNcIik7XG52YXIgb2JzZXJ2ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vb2JzZXJ2ZXIgKi8gXCIuL3NyYy9vYnNlcnZlci5qc1wiKTtcbi8qKlxuICogQG1vZHVsZSBIbHNcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBIbHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEhscywgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGFuIEhMUyBjbGllbnQgdGhhdCBjYW4gYXR0YWNoIHRvIGV4YWN0bHkgb25lIGBIVE1MTWVkaWFFbGVtZW50YC5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RzIEhsc1xuICAgICAqIEBwYXJhbSB7SGxzQ29uZmlnfSBjb25maWdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBIbHMoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICB2YXIgZGVmYXVsdENvbmZpZyA9IEhscy5EZWZhdWx0Q29uZmlnO1xuICAgICAgICBpZiAoKGNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgfHwgY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCkgJiYgKGNvbmZpZy5saXZlU3luY0R1cmF0aW9uIHx8IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGhscy5qcyBjb25maWc6IGRvblxcJ3QgbWl4IHVwIGxpdmVTeW5jRHVyYXRpb25Db3VudC9saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgYW5kIGxpdmVTeW5jRHVyYXRpb24vbGl2ZU1heExhdGVuY3lEdXJhdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gZGVmYXVsdENvbmZpZykge1xuICAgICAgICAgICAgaWYgKHByb3AgaW4gY29uZmlnKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uZmlnW3Byb3BdID0gZGVmYXVsdENvbmZpZ1twcm9wXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgPD0gY29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGhscy5qcyBjb25maWc6IFwibGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50XCIgbXVzdCBiZSBndCBcImxpdmVTeW5jRHVyYXRpb25Db3VudFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uICE9PSB1bmRlZmluZWQgJiYgKGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uIDw9IGNvbmZpZy5saXZlU3luY0R1cmF0aW9uIHx8IGNvbmZpZy5saXZlU3luY0R1cmF0aW9uID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogXCJsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uXCIgbXVzdCBiZSBndCBcImxpdmVTeW5jRHVyYXRpb25cIicpO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlcl8xLmVuYWJsZUxvZ3MoY29uZmlnLmRlYnVnKTtcbiAgICAgICAgX3RoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICBfdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xuICAgICAgICAvLyBjb3JlIGNvbnRyb2xsZXJzIGFuZCBuZXR3b3JrIGxvYWRlcnNcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FickNvbnRyb2xsZXJ9IGFickNvbnRyb2xsZXJcbiAgICAgICAgICovXG4gICAgICAgIHZhciBhYnJDb250cm9sbGVyID0gX3RoaXMuYWJyQ29udHJvbGxlciA9IG5ldyBjb25maWcuYWJyQ29udHJvbGxlcihfdGhpcyk7XG4gICAgICAgIHZhciBidWZmZXJDb250cm9sbGVyID0gbmV3IGNvbmZpZy5idWZmZXJDb250cm9sbGVyKF90aGlzKTtcbiAgICAgICAgdmFyIGNhcExldmVsQ29udHJvbGxlciA9IG5ldyBjb25maWcuY2FwTGV2ZWxDb250cm9sbGVyKF90aGlzKTtcbiAgICAgICAgdmFyIGZwc0NvbnRyb2xsZXIgPSBuZXcgY29uZmlnLmZwc0NvbnRyb2xsZXIoX3RoaXMpO1xuICAgICAgICB2YXIgcGxheUxpc3RMb2FkZXIgPSBuZXcgcGxheWxpc3RfbG9hZGVyXzEuZGVmYXVsdChfdGhpcyk7XG4gICAgICAgIHZhciBmcmFnbWVudExvYWRlciA9IG5ldyBmcmFnbWVudF9sb2FkZXJfMS5kZWZhdWx0KF90aGlzKTtcbiAgICAgICAgdmFyIGtleUxvYWRlciA9IG5ldyBrZXlfbG9hZGVyXzEuZGVmYXVsdChfdGhpcyk7XG4gICAgICAgIHZhciBpZDNUcmFja0NvbnRyb2xsZXIgPSBuZXcgaWQzX3RyYWNrX2NvbnRyb2xsZXJfMS5kZWZhdWx0KF90aGlzKTtcbiAgICAgICAgLy8gbmV0d29yayBjb250cm9sbGVyc1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TGV2ZWxDb250cm9sbGVyfSBsZXZlbENvbnRyb2xsZXJcbiAgICAgICAgICovXG4gICAgICAgIHZhciBsZXZlbENvbnRyb2xsZXIgPSBfdGhpcy5sZXZlbENvbnRyb2xsZXIgPSBuZXcgbGV2ZWxfY29udHJvbGxlcl8xLmRlZmF1bHQoX3RoaXMpO1xuICAgICAgICAvLyBGSVhNRTogRnJhZ21lbnRUcmFja2VyIG11c3QgYmUgZGVmaW5lZCBiZWZvcmUgU3RyZWFtQ29udHJvbGxlciBiZWNhdXNlIHRoZSBvcmRlciBvZiBldmVudCBoYW5kbGluZyBpcyBpbXBvcnRhbnRcbiAgICAgICAgdmFyIGZyYWdtZW50VHJhY2tlciA9IG5ldyBmcmFnbWVudF90cmFja2VyXzEuRnJhZ21lbnRUcmFja2VyKF90aGlzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmVhbUNvbnRyb2xsZXJ9IHN0cmVhbUNvbnRyb2xsZXJcbiAgICAgICAgICovXG4gICAgICAgIHZhciBzdHJlYW1Db250cm9sbGVyID0gX3RoaXMuc3RyZWFtQ29udHJvbGxlciA9IG5ldyBzdHJlYW1fY29udHJvbGxlcl8xLmRlZmF1bHQoX3RoaXMsIGZyYWdtZW50VHJhY2tlcik7XG4gICAgICAgIHZhciBuZXR3b3JrQ29udHJvbGxlcnMgPSBbbGV2ZWxDb250cm9sbGVyLCBzdHJlYW1Db250cm9sbGVyXTtcbiAgICAgICAgLy8gb3B0aW9uYWwgYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXJcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB2YXIge0lDb3JlQ29tcG9uZW50IHwgQ29udHJvbGxlcn1cbiAgICAgICAgICovXG4gICAgICAgIHZhciBDb250cm9sbGVyID0gY29uZmlnLmF1ZGlvU3RyZWFtQ29udHJvbGxlcjtcbiAgICAgICAgaWYgKENvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIG5ldHdvcmtDb250cm9sbGVycy5wdXNoKG5ldyBDb250cm9sbGVyKF90aGlzLCBmcmFnbWVudFRyYWNrZXIpKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7SU5ldHdvcmtDb250cm9sbGVyW119IG5ldHdvcmtDb250cm9sbGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMubmV0d29ya0NvbnRyb2xsZXJzID0gbmV0d29ya0NvbnRyb2xsZXJzO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHZhciB7SUNvcmVDb21wb25lbnRbXX1cbiAgICAgICAgICovXG4gICAgICAgIHZhciBjb3JlQ29tcG9uZW50cyA9IFtcbiAgICAgICAgICAgIHBsYXlMaXN0TG9hZGVyLFxuICAgICAgICAgICAgZnJhZ21lbnRMb2FkZXIsXG4gICAgICAgICAgICBrZXlMb2FkZXIsXG4gICAgICAgICAgICBhYnJDb250cm9sbGVyLFxuICAgICAgICAgICAgYnVmZmVyQ29udHJvbGxlcixcbiAgICAgICAgICAgIGNhcExldmVsQ29udHJvbGxlcixcbiAgICAgICAgICAgIGZwc0NvbnRyb2xsZXIsXG4gICAgICAgICAgICBpZDNUcmFja0NvbnRyb2xsZXIsXG4gICAgICAgICAgICBmcmFnbWVudFRyYWNrZXJcbiAgICAgICAgXTtcbiAgICAgICAgLy8gb3B0aW9uYWwgYXVkaW8gdHJhY2sgYW5kIHN1YnRpdGxlIGNvbnRyb2xsZXJcbiAgICAgICAgQ29udHJvbGxlciA9IGNvbmZpZy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICAgICAgaWYgKENvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIHZhciBhdWRpb1RyYWNrQ29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyKF90aGlzKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1lbWJlciB7QXVkaW9UcmFja0NvbnRyb2xsZXJ9IGF1ZGlvVHJhY2tDb250cm9sbGVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF90aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyID0gYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgICAgICAgICBjb3JlQ29tcG9uZW50cy5wdXNoKGF1ZGlvVHJhY2tDb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBDb250cm9sbGVyID0gY29uZmlnLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgICAgICBpZiAoQ29udHJvbGxlcikge1xuICAgICAgICAgICAgdmFyIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXIoX3RoaXMpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtTdWJ0aXRsZVRyYWNrQ29udHJvbGxlcn0gc3VidGl0bGVUcmFja0NvbnRyb2xsZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX3RoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICAgICAgICAgIGNvcmVDb21wb25lbnRzLnB1c2goc3VidGl0bGVUcmFja0NvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICAgIENvbnRyb2xsZXIgPSBjb25maWcuZW1lQ29udHJvbGxlcjtcbiAgICAgICAgaWYgKENvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIHZhciBlbWVDb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXIoX3RoaXMpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtFTUVDb250cm9sbGVyfSBlbWVDb250cm9sbGVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF90aGlzLmVtZUNvbnRyb2xsZXIgPSBlbWVDb250cm9sbGVyO1xuICAgICAgICAgICAgY29yZUNvbXBvbmVudHMucHVzaChlbWVDb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvcHRpb25hbCBzdWJ0aXRsZSBjb250cm9sbGVyc1xuICAgICAgICBDb250cm9sbGVyID0gY29uZmlnLnN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcjtcbiAgICAgICAgaWYgKENvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvcmVDb21wb25lbnRzLnB1c2gobmV3IENvbnRyb2xsZXIoX3RoaXMsIGZyYWdtZW50VHJhY2tlcikpO1xuICAgICAgICB9XG4gICAgICAgIENvbnRyb2xsZXIgPSBjb25maWcudGltZWxpbmVDb250cm9sbGVyO1xuICAgICAgICBpZiAoQ29udHJvbGxlcikge1xuICAgICAgICAgICAgY29yZUNvbXBvbmVudHMucHVzaChuZXcgQ29udHJvbGxlcihfdGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtJQ29yZUNvbXBvbmVudFtdfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuY29yZUNvbXBvbmVudHMgPSBjb3JlQ29tcG9uZW50cztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGxzLCBcInZlcnNpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiMC4xMi4yXCI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIEhscy5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlzX3N1cHBvcnRlZF8xLmlzU3VwcG9ydGVkKCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGxzLCBcIkV2ZW50c1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7SGxzRXZlbnRzfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRzXzEuZGVmYXVsdDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhscywgXCJFcnJvclR5cGVzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtIbHNFcnJvclR5cGVzfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JzXzEuRXJyb3JUeXBlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhscywgXCJFcnJvckRldGFpbHNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0hsc0Vycm9yRGV0YWlsc31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yc18xLkVycm9yRGV0YWlscztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhscywgXCJEZWZhdWx0Q29uZmlnXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtIbHNDb25maWd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghSGxzLmRlZmF1bHRDb25maWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlnXzEuaGxzRGVmYXVsdENvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBIbHMuZGVmYXVsdENvbmZpZztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtIbHNDb25maWd9XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChkZWZhdWx0Q29uZmlnKSB7XG4gICAgICAgICAgICBIbHMuZGVmYXVsdENvbmZpZyA9IGRlZmF1bHRDb25maWc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIERpc3Bvc2Ugb2YgdGhlIGluc3RhbmNlXG4gICAgICovXG4gICAgSGxzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdkZXN0cm95Jyk7XG4gICAgICAgIHRoaXMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkRFU1RST1lJTkcpO1xuICAgICAgICB0aGlzLmRldGFjaE1lZGlhKCk7XG4gICAgICAgIHRoaXMuY29yZUNvbXBvbmVudHMuY29uY2F0KHRoaXMubmV0d29ya0NvbnRyb2xsZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5kZXN0cm95KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVybCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSAtMTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGFjaCBhIG1lZGlhIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0hUTUxNZWRpYUVsZW1lbnR9IG1lZGlhXG4gICAgICovXG4gICAgSGxzLnByb3RvdHlwZS5hdHRhY2hNZWRpYSA9IGZ1bmN0aW9uIChtZWRpYSkge1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdhdHRhY2hNZWRpYScpO1xuICAgICAgICB0aGlzLm1lZGlhID0gbWVkaWE7XG4gICAgICAgIHRoaXMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0Lk1FRElBX0FUVEFDSElORywgeyBtZWRpYTogbWVkaWEgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRhY2ggZnJvbSB0aGUgbWVkaWFcbiAgICAgKi9cbiAgICBIbHMucHJvdG90eXBlLmRldGFjaE1lZGlhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdkZXRhY2hNZWRpYScpO1xuICAgICAgICB0aGlzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5NRURJQV9ERVRBQ0hJTkcpO1xuICAgICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc291cmNlIFVSTC4gQ2FuIGJlIHJlbGF0aXZlIG9yIGFic29sdXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKi9cbiAgICBIbHMucHJvdG90eXBlLmxvYWRTb3VyY2UgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHVybCA9IFVSTFRvb2xraXQuYnVpbGRBYnNvbHV0ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZiwgdXJsLCB7IGFsd2F5c05vcm1hbGl6ZTogdHJ1ZSB9KTtcbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcImxvYWRTb3VyY2U6XCIgKyB1cmwpO1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgLy8gd2hlbiBhdHRhY2hpbmcgdG8gYSBzb3VyY2UgVVJMLCB0cmlnZ2VyIGEgcGxheWxpc3QgbG9hZFxuICAgICAgICB0aGlzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5NQU5JRkVTVF9MT0FESU5HLCB7IHVybDogdXJsIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RhcnQgbG9hZGluZyBkYXRhIGZyb20gdGhlIHN0cmVhbSBzb3VyY2UuXG4gICAgICogRGVwZW5kaW5nIG9uIGRlZmF1bHQgY29uZmlnLCBjbGllbnQgc3RhcnRzIGxvYWRpbmcgYXV0b21hdGljYWxseSB3aGVuIGEgc291cmNlIGlzIHNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFBvc2l0aW9uIFNldCB0aGUgc3RhcnQgcG9zaXRpb24gdG8gc3RyZWFtIGZyb21cbiAgICAgKiBAZGVmYXVsdCAtMSBOb25lIChmcm9tIGVhcmxpZXN0IHBvaW50KVxuICAgICAqL1xuICAgIEhscy5wcm90b3R5cGUuc3RhcnRMb2FkID0gZnVuY3Rpb24gKHN0YXJ0UG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHN0YXJ0UG9zaXRpb24gPT09IHZvaWQgMCkgeyBzdGFydFBvc2l0aW9uID0gLTE7IH1cbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcInN0YXJ0TG9hZChcIiArIHN0YXJ0UG9zaXRpb24gKyBcIilcIik7XG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0b3AgbG9hZGluZyBvZiBhbnkgc3RyZWFtIGRhdGEuXG4gICAgICovXG4gICAgSGxzLnByb3RvdHlwZS5zdG9wTG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnc3RvcExvYWQnKTtcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5zdG9wTG9hZCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN3YXAgdGhyb3VnaCBwb3NzaWJsZSBhdWRpbyBjb2RlY3MgaW4gdGhlIHN0cmVhbSAoZm9yIGV4YW1wbGUgdG8gc3dpdGNoIGZyb20gc3RlcmVvIHRvIDUuMSlcbiAgICAgKi9cbiAgICBIbHMucHJvdG90eXBlLnN3YXBBdWRpb0NvZGVjID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdzd2FwQXVkaW9Db2RlYycpO1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuc3dhcEF1ZGlvQ29kZWMoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIG1lZGlhLWVsZW1lbnQgZmFpbHMsIHRoaXMgYWxsb3dzIHRvIGRldGFjaCBhbmQgdGhlbiByZS1hdHRhY2ggaXRcbiAgICAgKiBhcyBvbmUgY2FsbCAoY29udmVuaWVuY2UgbWV0aG9kKS5cbiAgICAgKlxuICAgICAqIEF1dG9tYXRpYyByZWNvdmVyeSBvZiBtZWRpYS1lcnJvcnMgYnkgdGhpcyBwcm9jZXNzIGlzIGNvbmZpZ3VyYWJsZS5cbiAgICAgKi9cbiAgICBIbHMucHJvdG90eXBlLnJlY292ZXJNZWRpYUVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdyZWNvdmVyTWVkaWFFcnJvcicpO1xuICAgICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgICB0aGlzLmRldGFjaE1lZGlhKCk7XG4gICAgICAgIHRoaXMuYXR0YWNoTWVkaWEobWVkaWEpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhscy5wcm90b3R5cGUsIFwibGV2ZWxzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtRdWFsaXR5TGV2ZWxbXX1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLmxldmVscztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhscy5wcm90b3R5cGUsIFwiY3VycmVudExldmVsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGV4IG9mIHF1YWxpdHkgbGV2ZWwgY3VycmVudGx5IHBsYXllZFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmN1cnJlbnRMZXZlbDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBxdWFsaXR5IGxldmVsIGluZGV4IGltbWVkaWF0ZWx5IC5cbiAgICAgICAgICogVGhpcyB3aWxsIGZsdXNoIHRoZSBjdXJyZW50IGJ1ZmZlciB0byByZXBsYWNlIHRoZSBxdWFsaXR5IGFzYXAuXG4gICAgICAgICAqIFRoYXQgbWVhbnMgcGxheWJhY2sgd2lsbCBpbnRlcnJ1cHQgYXQgbGVhc3Qgc2hvcnRseSB0byByZS1idWZmZXIgYW5kIHJlLXN5bmMgZXZlbnR1YWxseS5cbiAgICAgICAgICogQHR5cGUge251bWJlcn0gLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0xldmVsKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwic2V0IGN1cnJlbnRMZXZlbDpcIiArIG5ld0xldmVsKTtcbiAgICAgICAgICAgIHRoaXMubG9hZExldmVsID0gbmV3TGV2ZWw7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuaW1tZWRpYXRlTGV2ZWxTd2l0Y2goKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhscy5wcm90b3R5cGUsIFwibmV4dExldmVsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGV4IG9mIG5leHQgcXVhbGl0eSBsZXZlbCBsb2FkZWQgYXMgc2NoZWR1bGVkIGJ5IHN0cmVhbSBjb250cm9sbGVyLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBxdWFsaXR5IGxldmVsIGluZGV4IGZvciBuZXh0IGxvYWRlZCBkYXRhLlxuICAgICAgICAgKiBUaGlzIHdpbGwgc3dpdGNoIHRoZSB2aWRlbyBxdWFsaXR5IGFzYXAsIHdpdGhvdXQgaW50ZXJydXB0aW5nIHBsYXliYWNrLlxuICAgICAgICAgKiBNYXkgYWJvcnQgY3VycmVudCBsb2FkaW5nIG9mIGRhdGEsIGFuZCBmbHVzaCBwYXJ0cyBvZiBidWZmZXIgKG91dHNpZGUgY3VycmVudGx5IHBsYXllZCBmcmFnbWVudCByZWdpb24pLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfSAtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3TGV2ZWwpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJzZXQgbmV4dExldmVsOlwiICsgbmV3TGV2ZWwpO1xuICAgICAgICAgICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPSBuZXdMZXZlbDtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhscy5wcm90b3R5cGUsIFwibG9hZExldmVsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiB0aGUgcXVhbGl0eSBsZXZlbCBvZiB0aGUgY3VycmVudGx5IG9yIGxhc3QgKG9mIG5vbmUgaXMgbG9hZGVkIGN1cnJlbnRseSkgc2VnbWVudFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBpbmRleCBmb3IgbmV4dCBsb2FkZWQgZGF0YSBpbiBhIGNvbnNlcnZhdGl2ZSB3YXkuXG4gICAgICAgICAqIFRoaXMgd2lsbCBzd2l0Y2ggdGhlIHF1YWxpdHkgd2l0aG91dCBmbHVzaGluZywgYnV0IGludGVycnVwdCBjdXJyZW50IGxvYWRpbmcuXG4gICAgICAgICAqIFRodXMgdGhlIG1vbWVudCB3aGVuIHRoZSBxdWFsaXR5IHN3aXRjaCB3aWxsIGFwcGVhciBpbiBlZmZlY3Qgd2lsbCBvbmx5IGJlIGFmdGVyIHRoZSBhbHJlYWR5IGV4aXN0aW5nIGJ1ZmZlci5cbiAgICAgICAgICogQHR5cGUge251bWJlcn0gbmV3TGV2ZWwgLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0xldmVsKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwic2V0IGxvYWRMZXZlbDpcIiArIG5ld0xldmVsKTtcbiAgICAgICAgICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID0gbmV3TGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIbHMucHJvdG90eXBlLCBcIm5leHRMb2FkTGV2ZWxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IG5leHQgcXVhbGl0eSBsZXZlbCBsb2FkZWRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLm5leHRMb2FkTGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBvZiBuZXh0IGxvYWRlZCBzZWdtZW50IGluIGEgZnVsbHkgXCJub24tZGVzdHJ1Y3RpdmVcIiB3YXkuXG4gICAgICAgICAqIFNhbWUgYXMgYGxvYWRMZXZlbGAgYnV0IHdpbGwgd2FpdCBmb3IgbmV4dCBzd2l0Y2ggKHVudGlsIGN1cnJlbnQgbG9hZGluZyBpcyBkb25lKS5cbiAgICAgICAgICogQHR5cGUge251bWJlcn0gbGV2ZWxcbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgICAgICB0aGlzLmxldmVsQ29udHJvbGxlci5uZXh0TG9hZExldmVsID0gbGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIbHMucHJvdG90eXBlLCBcImZpcnN0TGV2ZWxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIFwiZmlyc3QgbGV2ZWxcIjogbGlrZSBhIGRlZmF1bHQgbGV2ZWwsIGlmIG5vdCBzZXQsXG4gICAgICAgICAqIGZhbGxzIGJhY2sgdG8gaW5kZXggb2YgZmlyc3QgbGV2ZWwgcmVmZXJlbmNlZCBpbiBtYW5pZmVzdFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5sZXZlbENvbnRyb2xsZXIuZmlyc3RMZXZlbCwgdGhpcy5taW5BdXRvTGV2ZWwpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBcImZpcnN0LWxldmVsXCIsIHNlZSBnZXR0ZXIuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdMZXZlbCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcInNldCBmaXJzdExldmVsOlwiICsgbmV3TGV2ZWwpO1xuICAgICAgICAgICAgdGhpcy5sZXZlbENvbnRyb2xsZXIuZmlyc3RMZXZlbCA9IG5ld0xldmVsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGxzLnByb3RvdHlwZSwgXCJzdGFydExldmVsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiBzdGFydCBsZXZlbCAobGV2ZWwgb2YgZmlyc3QgZnJhZ21lbnQgdGhhdCB3aWxsIGJlIHBsYXllZCBiYWNrKVxuICAgICAgICAgKiBpZiBub3Qgb3ZlcnJpZGVkIGJ5IHVzZXIsIGZpcnN0IGxldmVsIGFwcGVhcmluZyBpbiBtYW5pZmVzdCB3aWxsIGJlIHVzZWQgYXMgc3RhcnQgbGV2ZWxcbiAgICAgICAgICogaWYgLTEgOiBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uLCBwbGF5YmFjayB3aWxsIHN0YXJ0IGZyb20gbGV2ZWwgbWF0Y2hpbmcgZG93bmxvYWQgYmFuZHdpZHRoXG4gICAgICAgICAqIChkZXRlcm1pbmVkIGZyb20gZG93bmxvYWQgb2YgZmlyc3Qgc2VnbWVudClcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLnN0YXJ0TGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXQgIHN0YXJ0IGxldmVsIChsZXZlbCBvZiBmaXJzdCBmcmFnbWVudCB0aGF0IHdpbGwgYmUgcGxheWVkIGJhY2spXG4gICAgICAgICAqIGlmIG5vdCBvdmVycmlkZWQgYnkgdXNlciwgZmlyc3QgbGV2ZWwgYXBwZWFyaW5nIGluIG1hbmlmZXN0IHdpbGwgYmUgdXNlZCBhcyBzdGFydCBsZXZlbFxuICAgICAgICAgKiBpZiAtMSA6IGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24sIHBsYXliYWNrIHdpbGwgc3RhcnQgZnJvbSBsZXZlbCBtYXRjaGluZyBkb3dubG9hZCBiYW5kd2lkdGhcbiAgICAgICAgICogKGRldGVybWluZWQgZnJvbSBkb3dubG9hZCBvZiBmaXJzdCBzZWdtZW50KVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfSBuZXdMZXZlbFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3TGV2ZWwpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJzZXQgc3RhcnRMZXZlbDpcIiArIG5ld0xldmVsKTtcbiAgICAgICAgICAgIHZhciBobHMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gaWYgbm90IGluIGF1dG9tYXRpYyBzdGFydCBsZXZlbCBkZXRlY3Rpb24sIGVuc3VyZSBzdGFydExldmVsIGlzIGdyZWF0ZXIgdGhhbiBtaW5BdXRvTGV2ZWxcbiAgICAgICAgICAgIGlmIChuZXdMZXZlbCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBuZXdMZXZlbCA9IE1hdGgubWF4KG5ld0xldmVsLCBobHMubWluQXV0b0xldmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhscy5sZXZlbENvbnRyb2xsZXIuc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGxzLnByb3RvdHlwZSwgXCJhdXRvTGV2ZWxDYXBwaW5nXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHVzZWQgYnkgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBhbGdvcml0aG0gKGBBQlJDb250cm9sbGVyYClcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F1dG9MZXZlbENhcHBpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYXBwaW5nL21heCBsZXZlbCB2YWx1ZSB0aGF0IHNob3VsZCBiZSB1c2VkIGJ5IGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gYWxnb3JpdGhtIChgQUJSQ29udHJvbGxlcmApXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdMZXZlbCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcInNldCBhdXRvTGV2ZWxDYXBwaW5nOlwiICsgbmV3TGV2ZWwpO1xuICAgICAgICAgICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IG5ld0xldmVsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGxzLnByb3RvdHlwZSwgXCJhdXRvTGV2ZWxFbmFibGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgd2hlbiBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGVuYWJsZWRcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPT09IC0xKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhscy5wcm90b3R5cGUsIFwibWFudWFsTGV2ZWxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogTGV2ZWwgc2V0IG1hbnVhbGx5IChpZiBhbnkpXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhscy5wcm90b3R5cGUsIFwibWluQXV0b0xldmVsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1pbiBsZXZlbCBzZWxlY3RhYmxlIGluIGF1dG8gbW9kZSBhY2NvcmRpbmcgdG8gY29uZmlnLm1pbkF1dG9CaXRyYXRlXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBobHMgPSB0aGlzLCBsZXZlbHMgPSBobHMubGV2ZWxzLCBtaW5BdXRvQml0cmF0ZSA9IGhscy5jb25maWcubWluQXV0b0JpdHJhdGUsIGxlbiA9IGxldmVscyA/IGxldmVscy5sZW5ndGggOiAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBsZXZlbE5leHRCaXRyYXRlID0gbGV2ZWxzW2ldLnJlYWxCaXRyYXRlID8gTWF0aC5tYXgobGV2ZWxzW2ldLnJlYWxCaXRyYXRlLCBsZXZlbHNbaV0uYml0cmF0ZSkgOiBsZXZlbHNbaV0uYml0cmF0ZTtcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWxOZXh0Qml0cmF0ZSA+IG1pbkF1dG9CaXRyYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGxzLnByb3RvdHlwZSwgXCJtYXhBdXRvTGV2ZWxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogbWF4IGxldmVsIHNlbGVjdGFibGUgaW4gYXV0byBtb2RlIGFjY29yZGluZyB0byBhdXRvTGV2ZWxDYXBwaW5nXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBobHMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGxldmVscyA9IGhscy5sZXZlbHM7XG4gICAgICAgICAgICB2YXIgYXV0b0xldmVsQ2FwcGluZyA9IGhscy5hdXRvTGV2ZWxDYXBwaW5nO1xuICAgICAgICAgICAgdmFyIG1heEF1dG9MZXZlbDtcbiAgICAgICAgICAgIGlmIChhdXRvTGV2ZWxDYXBwaW5nID09PSAtMSAmJiBsZXZlbHMgJiYgbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG1heEF1dG9MZXZlbCA9IGxldmVscy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWF4QXV0b0xldmVsID0gYXV0b0xldmVsQ2FwcGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXhBdXRvTGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIbHMucHJvdG90eXBlLCBcIm5leHRBdXRvTGV2ZWxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogbmV4dCBhdXRvbWF0aWNhbGx5IHNlbGVjdGVkIHF1YWxpdHkgbGV2ZWxcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGhscyA9IHRoaXM7XG4gICAgICAgICAgICAvLyBlbnN1cmUgbmV4dCBhdXRvIGxldmVsIGlzIGJldHdlZW4gIG1pbiBhbmQgbWF4IGF1dG8gbGV2ZWxcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChobHMuYWJyQ29udHJvbGxlci5uZXh0QXV0b0xldmVsLCBobHMubWluQXV0b0xldmVsKSwgaGxzLm1heEF1dG9MZXZlbCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aGlzIHNldHRlciBpcyB1c2VkIHRvIGZvcmNlIG5leHQgYXV0byBsZXZlbC5cbiAgICAgICAgICogdGhpcyBpcyB1c2VmdWwgdG8gZm9yY2UgYSBzd2l0Y2ggZG93biBpbiBhdXRvIG1vZGU6XG4gICAgICAgICAqIGluIGNhc2Ugb2YgbG9hZCBlcnJvciBvbiBsZXZlbCBOLCBobHMuanMgY2FuIHNldCBuZXh0QXV0b0xldmVsIHRvIE4tMSBmb3IgZXhhbXBsZSlcbiAgICAgICAgICogZm9yY2VkIHZhbHVlIGlzIHZhbGlkIGZvciBvbmUgZnJhZ21lbnQuIHVwb24gc3VjY2VzZnVsIGZyYWcgbG9hZGluZyBhdCBmb3JjZWQgbGV2ZWwsXG4gICAgICAgICAqIHRoaXMgdmFsdWUgd2lsbCBiZSByZXNldHRlZCB0byAtMSBieSBBQlIgY29udHJvbGxlci5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5leHRMZXZlbCkge1xuICAgICAgICAgICAgdmFyIGhscyA9IHRoaXM7XG4gICAgICAgICAgICBobHMuYWJyQ29udHJvbGxlci5uZXh0QXV0b0xldmVsID0gTWF0aC5tYXgoaGxzLm1pbkF1dG9MZXZlbCwgbmV4dExldmVsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhscy5wcm90b3R5cGUsIFwiYXVkaW9UcmFja3NcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0F1ZGlvVHJhY2tbXX1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICAgICAgICAgIHJldHVybiBhdWRpb1RyYWNrQ29udHJvbGxlciA/IGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2tzIDogW107XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIbHMucHJvdG90eXBlLCBcImF1ZGlvVHJhY2tcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogaW5kZXggb2YgdGhlIHNlbGVjdGVkIGF1ZGlvIHRyYWNrIChpbmRleCBpbiBhdWRpbyB0cmFjayBsaXN0cylcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICAgICAgICAgIHJldHVybiBhdWRpb1RyYWNrQ29udHJvbGxlciA/IGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2sgOiAtMTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNlbGVjdHMgYW4gYXVkaW8gdHJhY2ssIGJhc2VkIG9uIGl0cyBpbmRleCBpbiBhdWRpbyB0cmFjayBsaXN0c1xuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoYXVkaW9UcmFja0lkKSB7XG4gICAgICAgICAgICB2YXIgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgICAgICAgICAgaWYgKGF1ZGlvVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFjayA9IGF1ZGlvVHJhY2tJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhscy5wcm90b3R5cGUsIFwibGl2ZVN5bmNQb3NpdGlvblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7U2Vjb25kc31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5saXZlU3luY1Bvc2l0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGxzLnByb3RvdHlwZSwgXCJzdWJ0aXRsZVRyYWNrc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgYWx0ZXJuYXRlIHN1YnRpdGxlIHRyYWNrcyBsaXN0IGZyb20gcGxheWxpc3RcbiAgICAgICAgICogQHR5cGUge1N1YnRpdGxlVHJhY2tbXX1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICAgICAgICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2tzIDogW107XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIbHMucHJvdG90eXBlLCBcInN1YnRpdGxlVHJhY2tcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogaW5kZXggb2YgdGhlIHNlbGVjdGVkIHN1YnRpdGxlIHRyYWNrIChpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0cylcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICAgICAgICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2sgOiAtMTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNlbGVjdCBhbiBzdWJ0aXRsZSB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzXG4gICAgICAgICAqIEB0eXBle251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHN1YnRpdGxlVHJhY2tJZCkge1xuICAgICAgICAgICAgdmFyIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICAgICAgICAgIGlmIChzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2sgPSBzdWJ0aXRsZVRyYWNrSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIbHMucHJvdG90eXBlLCBcInN1YnRpdGxlRGlzcGxheVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICAgICAgICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlRGlzcGxheSA6IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlL2Rpc2FibGUgc3VidGl0bGUgZGlzcGxheSByZW5kZXJpbmdcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICAgICAgICAgIGlmIChzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlRGlzcGxheSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gSGxzO1xufShvYnNlcnZlcl8xLk9ic2VydmVyKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIbHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvaXMtc3VwcG9ydGVkLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9pcy1zdXBwb3J0ZWQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbWVkaWFzb3VyY2VfaGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzL21lZGlhc291cmNlLWhlbHBlciAqLyBcIi4vc3JjL3V0aWxzL21lZGlhc291cmNlLWhlbHBlci5qc1wiKTtcbmZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xuICAgIHZhciBtZWRpYVNvdXJjZSA9IG1lZGlhc291cmNlX2hlbHBlcl8xLmdldE1lZGlhU291cmNlKCk7XG4gICAgdmFyIHNvdXJjZUJ1ZmZlciA9IHdpbmRvdy5Tb3VyY2VCdWZmZXIgfHwgd2luZG93LldlYktpdFNvdXJjZUJ1ZmZlcjtcbiAgICB2YXIgaXNUeXBlU3VwcG9ydGVkID0gbWVkaWFTb3VyY2UgJiZcbiAgICAgICAgdHlwZW9mIG1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICBtZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ3ZpZGVvL21wNDsgY29kZWNzPVwiYXZjMS40MkUwMUUsbXA0YS40MC4yXCInKTtcbiAgICAvLyBpZiBTb3VyY2VCdWZmZXIgaXMgZXhwb3NlZCBlbnN1cmUgaXRzIEFQSSBpcyB2YWxpZFxuICAgIC8vIHNhZmFyaSBhbmQgb2xkIHZlcnNpb24gb2YgQ2hyb21lIGRvZSBub3QgZXhwb3NlIFNvdXJjZUJ1ZmZlciBnbG9iYWxseSBzbyBjaGVja2luZyBTb3VyY2VCdWZmZXIucHJvdG90eXBlIGlzIGltcG9zc2libGVcbiAgICB2YXIgc291cmNlQnVmZmVyVmFsaWRBUEkgPSAhc291cmNlQnVmZmVyIHx8XG4gICAgICAgIChzb3VyY2VCdWZmZXIucHJvdG90eXBlICYmXG4gICAgICAgICAgICB0eXBlb2Ygc291cmNlQnVmZmVyLnByb3RvdHlwZS5hcHBlbmRCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgIHR5cGVvZiBzb3VyY2VCdWZmZXIucHJvdG90eXBlLnJlbW92ZSA9PT0gJ2Z1bmN0aW9uJyk7XG4gICAgcmV0dXJuICEhaXNUeXBlU3VwcG9ydGVkICYmICEhc291cmNlQnVmZmVyVmFsaWRBUEk7XG59XG5leHBvcnRzLmlzU3VwcG9ydGVkID0gaXNTdXBwb3J0ZWQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbG9hZGVyL2ZyYWdtZW50LWxvYWRlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2xvYWRlci9mcmFnbWVudC1sb2FkZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihOdW1iZXIpIHtcbi8qXG4gKiBGcmFnbWVudCBMb2FkZXJcbiovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy5qc1wiKTtcbnZhciBldmVudF9oYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudC1oYW5kbGVyICovIFwiLi9zcmMvZXZlbnQtaGFuZGxlci5qc1wiKTtcbnZhciBlcnJvcnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy5qc1wiKTtcbnZhciBsb2dnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci5qc1wiKTtcbnZhciBGcmFnbWVudExvYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRnJhZ21lbnRMb2FkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRnJhZ21lbnRMb2FkZXIoaGxzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGhscywgZXZlbnRzXzEuZGVmYXVsdC5GUkFHX0xPQURJTkcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxvYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBGcmFnbWVudExvYWRlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxvYWRlcnMgPSB0aGlzLmxvYWRlcnM7XG4gICAgICAgIGZvciAodmFyIGxvYWRlck5hbWUgaW4gbG9hZGVycykge1xuICAgICAgICAgICAgdmFyIGxvYWRlciA9IGxvYWRlcnNbbG9hZGVyTmFtZV07XG4gICAgICAgICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgICAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvYWRlcnMgPSB7fTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBGcmFnbWVudExvYWRlci5wcm90b3R5cGUub25GcmFnTG9hZGluZyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLCB0eXBlID0gZnJhZy50eXBlLCBsb2FkZXJzID0gdGhpcy5sb2FkZXJzLCBjb25maWcgPSB0aGlzLmhscy5jb25maWcsIEZyYWdtZW50SUxvYWRlciA9IGNvbmZpZy5mTG9hZGVyLCBEZWZhdWx0SUxvYWRlciA9IGNvbmZpZy5sb2FkZXI7XG4gICAgICAgIC8vIHJlc2V0IGZyYWdtZW50IHN0YXRlXG4gICAgICAgIGZyYWcubG9hZGVkID0gMDtcbiAgICAgICAgdmFyIGxvYWRlciA9IGxvYWRlcnNbdHlwZV07XG4gICAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKFwiYWJvcnQgcHJldmlvdXMgZnJhZ21lbnQgbG9hZGVyIGZvciB0eXBlOiBcIiArIHR5cGUpO1xuICAgICAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgbG9hZGVyID0gbG9hZGVyc1t0eXBlXSA9IGZyYWcubG9hZGVyID1cbiAgICAgICAgICAgIGNvbmZpZy5mTG9hZGVyID8gbmV3IEZyYWdtZW50SUxvYWRlcihjb25maWcpIDogbmV3IERlZmF1bHRJTG9hZGVyKGNvbmZpZyk7XG4gICAgICAgIHZhciBsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcztcbiAgICAgICAgbG9hZGVyQ29udGV4dCA9IHsgdXJsOiBmcmFnLnVybCwgZnJhZzogZnJhZywgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInLCBwcm9ncmVzc0RhdGE6IGZhbHNlIH07XG4gICAgICAgIHZhciBzdGFydCA9IGZyYWcuYnl0ZVJhbmdlU3RhcnRPZmZzZXQsIGVuZCA9IGZyYWcuYnl0ZVJhbmdlRW5kT2Zmc2V0O1xuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHN0YXJ0KSAmJiBOdW1iZXIuaXNGaW5pdGUoZW5kKSkge1xuICAgICAgICAgICAgbG9hZGVyQ29udGV4dC5yYW5nZVN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBsb2FkZXJDb250ZXh0LnJhbmdlRW5kID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIGxvYWRlckNvbmZpZyA9IHtcbiAgICAgICAgICAgIHRpbWVvdXQ6IGNvbmZpZy5mcmFnTG9hZGluZ1RpbWVPdXQsXG4gICAgICAgICAgICBtYXhSZXRyeTogMCxcbiAgICAgICAgICAgIHJldHJ5RGVsYXk6IDAsXG4gICAgICAgICAgICBtYXhSZXRyeURlbGF5OiBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXRcbiAgICAgICAgfTtcbiAgICAgICAgbG9hZGVyQ2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgb25TdWNjZXNzOiB0aGlzLmxvYWRzdWNjZXNzLmJpbmQodGhpcyksXG4gICAgICAgICAgICBvbkVycm9yOiB0aGlzLmxvYWRlcnJvci5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgb25UaW1lb3V0OiB0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcyksXG4gICAgICAgICAgICBvblByb2dyZXNzOiB0aGlzLmxvYWRwcm9ncmVzcy5iaW5kKHRoaXMpXG4gICAgICAgIH07XG4gICAgICAgIGxvYWRlci5sb2FkKGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzKTtcbiAgICB9O1xuICAgIEZyYWdtZW50TG9hZGVyLnByb3RvdHlwZS5sb2Fkc3VjY2VzcyA9IGZ1bmN0aW9uIChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgIGlmIChuZXR3b3JrRGV0YWlscyA9PT0gdm9pZCAwKSB7IG5ldHdvcmtEZXRhaWxzID0gbnVsbDsgfVxuICAgICAgICB2YXIgcGF5bG9hZCA9IHJlc3BvbnNlLmRhdGEsIGZyYWcgPSBjb250ZXh0LmZyYWc7XG4gICAgICAgIC8vIGRldGFjaCBmcmFnbWVudCBsb2FkZXIgb24gbG9hZCBzdWNjZXNzXG4gICAgICAgIGZyYWcubG9hZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmxvYWRlcnNbZnJhZy50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkZSQUdfTE9BREVELCB7IHBheWxvYWQ6IHBheWxvYWQsIGZyYWc6IGZyYWcsIHN0YXRzOiBzdGF0cywgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzIH0pO1xuICAgIH07XG4gICAgRnJhZ21lbnRMb2FkZXIucHJvdG90eXBlLmxvYWRlcnJvciA9IGZ1bmN0aW9uIChyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgaWYgKG5ldHdvcmtEZXRhaWxzID09PSB2b2lkIDApIHsgbmV0d29ya0RldGFpbHMgPSBudWxsOyB9XG4gICAgICAgIHZhciBmcmFnID0gY29udGV4dC5mcmFnO1xuICAgICAgICB2YXIgbG9hZGVyID0gZnJhZy5sb2FkZXI7XG4gICAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZGVyc1tmcmFnLnR5cGVdID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogZXJyb3JzXzEuRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBlcnJvcnNfMS5FcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SLCBmYXRhbDogZmFsc2UsIGZyYWc6IGNvbnRleHQuZnJhZywgcmVzcG9uc2U6IHJlc3BvbnNlLCBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHMgfSk7XG4gICAgfTtcbiAgICBGcmFnbWVudExvYWRlci5wcm90b3R5cGUubG9hZHRpbWVvdXQgPSBmdW5jdGlvbiAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgIGlmIChuZXR3b3JrRGV0YWlscyA9PT0gdm9pZCAwKSB7IG5ldHdvcmtEZXRhaWxzID0gbnVsbDsgfVxuICAgICAgICB2YXIgZnJhZyA9IGNvbnRleHQuZnJhZztcbiAgICAgICAgdmFyIGxvYWRlciA9IGZyYWcubG9hZGVyO1xuICAgICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvYWRlcnNbZnJhZy50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IGVycm9yc18xLkVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogZXJyb3JzXzEuRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VULCBmYXRhbDogZmFsc2UsIGZyYWc6IGNvbnRleHQuZnJhZywgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzIH0pO1xuICAgIH07XG4gICAgLy8gZGF0YSB3aWxsIGJlIHVzZWQgZm9yIHByb2dyZXNzaXZlIHBhcnNpbmdcbiAgICBGcmFnbWVudExvYWRlci5wcm90b3R5cGUubG9hZHByb2dyZXNzID0gZnVuY3Rpb24gKHN0YXRzLCBjb250ZXh0LCBkYXRhLCBuZXR3b3JrRGV0YWlscykge1xuICAgICAgICBpZiAobmV0d29ya0RldGFpbHMgPT09IHZvaWQgMCkgeyBuZXR3b3JrRGV0YWlscyA9IG51bGw7IH1cbiAgICAgICAgdmFyIGZyYWcgPSBjb250ZXh0LmZyYWc7XG4gICAgICAgIGZyYWcubG9hZGVkID0gc3RhdHMubG9hZGVkO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRlJBR19MT0FEX1BST0dSRVNTLCB7IGZyYWc6IGZyYWcsIHN0YXRzOiBzdGF0cywgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEZyYWdtZW50TG9hZGVyO1xufShldmVudF9oYW5kbGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRnJhZ21lbnRMb2FkZXI7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci5qc1wiKVtcIk51bWJlclwiXSkpXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2xvYWRlci9mcmFnbWVudC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbG9hZGVyL2ZyYWdtZW50LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihOdW1iZXIpIHtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBVUkxUb29sa2l0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdXJsLXRvb2xraXQgKi8gXCIuL25vZGVfbW9kdWxlcy91cmwtdG9vbGtpdC9zcmMvdXJsLXRvb2xraXQuanNcIik7XG52YXIgbGV2ZWxfa2V5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xldmVsLWtleSAqLyBcIi4vc3JjL2xvYWRlci9sZXZlbC1rZXkuanNcIik7XG52YXIgRnJhZ21lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnJhZ21lbnQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5fdXJsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYnl0ZVJhbmdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZGVjcnlwdGRhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLnRhZ0xpc3QgPSBbXTtcbiAgICAgICAgdGhpcy5wcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnJhd1Byb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gICAgICAgIC8vIEhvbGRzIHRoZSB0eXBlcyBvZiBkYXRhIHRoaXMgZnJhZ21lbnQgc3VwcG9ydHNcbiAgICAgICAgdGhpcy5fZWxlbWVudGFyeVN0cmVhbXMgPSAoX2EgPSB7fSxcbiAgICAgICAgICAgIF9hW0ZyYWdtZW50LkVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT10gPSBmYWxzZSxcbiAgICAgICAgICAgIF9hW0ZyYWdtZW50LkVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFT10gPSBmYWxzZSxcbiAgICAgICAgICAgIF9hKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZyYWdtZW50LCBcIkVsZW1lbnRhcnlTdHJlYW1UeXBlc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgdHlwZWAgcHJvcGVydHkgZm9yIHRoaXMuX2VsZW1lbnRhcnlTdHJlYW1zXG4gICAgICAgICAqXG4gICAgICAgICAqIEBlbnVtXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgQVVESU86ICdhdWRpbycsXG4gICAgICAgICAgICAgICAgVklERU86ICd2aWRlbydcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGcmFnbWVudC5wcm90b3R5cGUsIFwidXJsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3VybCAmJiB0aGlzLnJlbHVybCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VybCA9IFVSTFRvb2xraXQuYnVpbGRBYnNvbHV0ZVVSTCh0aGlzLmJhc2V1cmwsIHRoaXMucmVsdXJsLCB7IGFsd2F5c05vcm1hbGl6ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91cmw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl91cmwgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZyYWdtZW50LnByb3RvdHlwZSwgXCJieXRlUmFuZ2VcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fYnl0ZVJhbmdlICYmICF0aGlzLnJhd0J5dGVSYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9ieXRlUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnl0ZVJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJ5dGVSYW5nZSA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMucmF3Qnl0ZVJhbmdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucmF3Qnl0ZVJhbmdlLnNwbGl0KCdAJywgMik7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQgPSB0aGlzLmxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVSYW5nZVswXSA9IGxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQgfHwgMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVSYW5nZVswXSA9IHBhcnNlSW50KHBhcmFtc1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ5dGVSYW5nZVsxXSA9IHBhcnNlSW50KHBhcmFtc1swXSkgKyBieXRlUmFuZ2VbMF07XG4gICAgICAgICAgICAgICAgdGhpcy5fYnl0ZVJhbmdlID0gYnl0ZVJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ5dGVSYW5nZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZyYWdtZW50LnByb3RvdHlwZSwgXCJieXRlUmFuZ2VTdGFydE9mZnNldFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ieXRlUmFuZ2VbMF07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGcmFnbWVudC5wcm90b3R5cGUsIFwiYnl0ZVJhbmdlRW5kT2Zmc2V0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ieXRlUmFuZ2VbMV07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGcmFnbWVudC5wcm90b3R5cGUsIFwiZGVjcnlwdGRhdGFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZGVjcnlwdGRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWNyeXB0ZGF0YSA9IHRoaXMuZnJhZ21lbnREZWNyeXB0ZGF0YUZyb21MZXZlbGtleSh0aGlzLmxldmVsa2V5LCB0aGlzLnNuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWNyeXB0ZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZyYWdtZW50LnByb3RvdHlwZSwgXCJlbmRQcm9ncmFtRGF0ZVRpbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHRoaXMucHJvZ3JhbURhdGVUaW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gIU51bWJlci5pc0Zpbml0ZSh0aGlzLmR1cmF0aW9uKSA/IDAgOiB0aGlzLmR1cmF0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvZ3JhbURhdGVUaW1lICsgKGR1cmF0aW9uICogMTAwMCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGcmFnbWVudC5wcm90b3R5cGUsIFwiZW5jcnlwdGVkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gISEoKHRoaXMuZGVjcnlwdGRhdGEgJiYgdGhpcy5kZWNyeXB0ZGF0YS51cmkgIT09IG51bGwpICYmICh0aGlzLmRlY3J5cHRkYXRhLmtleSA9PT0gbnVsbCkpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnRhcnlTdHJlYW1UeXBlfSB0eXBlXG4gICAgICovXG4gICAgRnJhZ21lbnQucHJvdG90eXBlLmFkZEVsZW1lbnRhcnlTdHJlYW0gPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB0aGlzLl9lbGVtZW50YXJ5U3RyZWFtc1t0eXBlXSA9IHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnRhcnlTdHJlYW1UeXBlfSB0eXBlXG4gICAgICovXG4gICAgRnJhZ21lbnQucHJvdG90eXBlLmhhc0VsZW1lbnRhcnlTdHJlYW0gPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudGFyeVN0cmVhbXNbdHlwZV0gPT09IHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZCBmb3IgcGFyc2VMZXZlbFBsYXlsaXN0IHRvIGNyZWF0ZSBhbiBpbml0aWFsaXphdGlvbiB2ZWN0b3IgZm9yIGEgZ2l2ZW4gc2VnbWVudFxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIEZyYWdtZW50LnByb3RvdHlwZS5jcmVhdGVJbml0aWFsaXphdGlvblZlY3RvciA9IGZ1bmN0aW9uIChzZWdtZW50TnVtYmVyKSB7XG4gICAgICAgIHZhciB1aW50OFZpZXcgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgIGZvciAodmFyIGkgPSAxMjsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgIHVpbnQ4Vmlld1tpXSA9IChzZWdtZW50TnVtYmVyID4+IDggKiAoMTUgLSBpKSkgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1aW50OFZpZXc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZCBmb3IgcGFyc2VMZXZlbFBsYXlsaXN0IHRvIGdldCBhIGZyYWdtZW50J3MgZGVjcnlwdGlvbiBkYXRhIGZyb20gdGhlIGN1cnJlbnRseSBwYXJzZWQgZW5jcnlwdGlvbiBrZXkgZGF0YVxuICAgICAqIEBwYXJhbSBsZXZlbGtleSAtIGEgcGxheWxpc3QncyBlbmNyeXB0aW9uIGluZm9cbiAgICAgKiBAcGFyYW0gc2VnbWVudE51bWJlciAtIHRoZSBmcmFnbWVudCdzIHNlZ21lbnQgbnVtYmVyXG4gICAgICogQHJldHVybnMgeyp9IC0gYW4gb2JqZWN0IHRvIGJlIGFwcGxpZWQgYXMgYSBmcmFnbWVudCdzIGRlY3J5cHRkYXRhXG4gICAgICovXG4gICAgRnJhZ21lbnQucHJvdG90eXBlLmZyYWdtZW50RGVjcnlwdGRhdGFGcm9tTGV2ZWxrZXkgPSBmdW5jdGlvbiAobGV2ZWxrZXksIHNlZ21lbnROdW1iZXIpIHtcbiAgICAgICAgdmFyIGRlY3J5cHRkYXRhID0gbGV2ZWxrZXk7XG4gICAgICAgIGlmIChsZXZlbGtleSAmJiBsZXZlbGtleS5tZXRob2QgJiYgbGV2ZWxrZXkudXJpICYmICFsZXZlbGtleS5pdikge1xuICAgICAgICAgICAgZGVjcnlwdGRhdGEgPSBuZXcgbGV2ZWxfa2V5XzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgZGVjcnlwdGRhdGEubWV0aG9kID0gbGV2ZWxrZXkubWV0aG9kO1xuICAgICAgICAgICAgZGVjcnlwdGRhdGEuYmFzZXVyaSA9IGxldmVsa2V5LmJhc2V1cmk7XG4gICAgICAgICAgICBkZWNyeXB0ZGF0YS5yZWx1cmkgPSBsZXZlbGtleS5yZWx1cmk7XG4gICAgICAgICAgICBkZWNyeXB0ZGF0YS5pdiA9IHRoaXMuY3JlYXRlSW5pdGlhbGl6YXRpb25WZWN0b3Ioc2VnbWVudE51bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlY3J5cHRkYXRhO1xuICAgIH07XG4gICAgcmV0dXJuIEZyYWdtZW50O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEZyYWdtZW50O1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIuanNcIilbXCJOdW1iZXJcIl0pKVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9sb2FkZXIva2V5LWxvYWRlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9sb2FkZXIva2V5LWxvYWRlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLypcbiAqIERlY3J5cHQga2V5IExvYWRlclxuKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLmpzXCIpO1xudmFyIGV2ZW50X2hhbmRsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50LWhhbmRsZXIgKi8gXCIuL3NyYy9ldmVudC1oYW5kbGVyLmpzXCIpO1xudmFyIGVycm9yc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLmpzXCIpO1xudmFyIGxvZ2dlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLmpzXCIpO1xudmFyIEtleUxvYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoS2V5TG9hZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEtleUxvYWRlcihobHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaGxzLCBldmVudHNfMS5kZWZhdWx0LktFWV9MT0FESU5HKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sb2FkZXJzID0ge307XG4gICAgICAgIF90aGlzLmRlY3J5cHRrZXkgPSBudWxsO1xuICAgICAgICBfdGhpcy5kZWNyeXB0dXJsID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBLZXlMb2FkZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGxvYWRlck5hbWUgaW4gdGhpcy5sb2FkZXJzKSB7XG4gICAgICAgICAgICB2YXIgbG9hZGVyID0gdGhpcy5sb2FkZXJzW2xvYWRlck5hbWVdO1xuICAgICAgICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICAgICAgICAgIGxvYWRlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2FkZXJzID0ge307XG4gICAgICAgIGV2ZW50X2hhbmRsZXJfMS5kZWZhdWx0LnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBLZXlMb2FkZXIucHJvdG90eXBlLm9uS2V5TG9hZGluZyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLCB0eXBlID0gZnJhZy50eXBlLCBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbdHlwZV0sIGRlY3J5cHRkYXRhID0gZnJhZy5kZWNyeXB0ZGF0YSwgdXJpID0gZGVjcnlwdGRhdGEudXJpO1xuICAgICAgICAvLyBpZiB1cmkgaXMgZGlmZmVyZW50IGZyb20gcHJldmlvdXMgb25lIG9yIGlmIGRlY3J5cHQga2V5IG5vdCByZXRyaWV2ZWQgeWV0XG4gICAgICAgIGlmICh1cmkgIT09IHRoaXMuZGVjcnlwdHVybCB8fCB0aGlzLmRlY3J5cHRrZXkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgICAgICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oXCJhYm9ydCBwcmV2aW91cyBrZXkgbG9hZGVyIGZvciB0eXBlOlwiICsgdHlwZSk7XG4gICAgICAgICAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcmFnLmxvYWRlciA9IHRoaXMubG9hZGVyc1t0eXBlXSA9IG5ldyBjb25maWcubG9hZGVyKGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLmRlY3J5cHR1cmwgPSB1cmk7XG4gICAgICAgICAgICB0aGlzLmRlY3J5cHRrZXkgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGxvYWRlckNvbnRleHQgPSB2b2lkIDAsIGxvYWRlckNvbmZpZyA9IHZvaWQgMCwgbG9hZGVyQ2FsbGJhY2tzID0gdm9pZCAwO1xuICAgICAgICAgICAgbG9hZGVyQ29udGV4dCA9IHsgdXJsOiB1cmksIGZyYWc6IGZyYWcsIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJyB9O1xuICAgICAgICAgICAgLy8gbWF4UmV0cnkgaXMgMCBzbyB0aGF0IGluc3RlYWQgb2YgcmV0cnlpbmcgdGhlIHNhbWUga2V5IG9uIHRoZSBzYW1lIHZhcmlhbnQgbXVsdGlwbGUgdGltZXMsXG4gICAgICAgICAgICAvLyBrZXktbG9hZGVyIHdpbGwgdHJpZ2dlciBhbiBlcnJvciBhbmQgcmVseSBvbiBzdHJlYW0tY29udHJvbGxlciB0byBoYW5kbGUgcmV0cnkgbG9naWMuXG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgYWxzbyBhbGlnbiByZXRyeSBsb2dpYyB3aXRoIGZyYWdtZW50LWxvYWRlclxuICAgICAgICAgICAgbG9hZGVyQ29uZmlnID0geyB0aW1lb3V0OiBjb25maWcuZnJhZ0xvYWRpbmdUaW1lT3V0LCBtYXhSZXRyeTogMCwgcmV0cnlEZWxheTogY29uZmlnLmZyYWdMb2FkaW5nUmV0cnlEZWxheSwgbWF4UmV0cnlEZWxheTogY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0IH07XG4gICAgICAgICAgICBsb2FkZXJDYWxsYmFja3MgPSB7IG9uU3VjY2VzczogdGhpcy5sb2Fkc3VjY2Vzcy5iaW5kKHRoaXMpLCBvbkVycm9yOiB0aGlzLmxvYWRlcnJvci5iaW5kKHRoaXMpLCBvblRpbWVvdXQ6IHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKSB9O1xuICAgICAgICAgICAgZnJhZy5sb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kZWNyeXB0a2V5KSB7XG4gICAgICAgICAgICAvLyB3ZSBhbHJlYWR5IGxvYWRlZCB0aGlzIGtleSwgcmV0dXJuIGl0XG4gICAgICAgICAgICBkZWNyeXB0ZGF0YS5rZXkgPSB0aGlzLmRlY3J5cHRrZXk7XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuS0VZX0xPQURFRCwgeyBmcmFnOiBmcmFnIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBLZXlMb2FkZXIucHJvdG90eXBlLmxvYWRzdWNjZXNzID0gZnVuY3Rpb24gKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCkge1xuICAgICAgICB2YXIgZnJhZyA9IGNvbnRleHQuZnJhZztcbiAgICAgICAgdGhpcy5kZWNyeXB0a2V5ID0gZnJhZy5kZWNyeXB0ZGF0YS5rZXkgPSBuZXcgVWludDhBcnJheShyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgLy8gZGV0YWNoIGZyYWdtZW50IGxvYWRlciBvbiBsb2FkIHN1Y2Nlc3NcbiAgICAgICAgZnJhZy5sb2FkZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubG9hZGVyc1tmcmFnLnR5cGVdID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuS0VZX0xPQURFRCwgeyBmcmFnOiBmcmFnIH0pO1xuICAgIH07XG4gICAgS2V5TG9hZGVyLnByb3RvdHlwZS5sb2FkZXJyb3IgPSBmdW5jdGlvbiAocmVzcG9uc2UsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGZyYWcgPSBjb250ZXh0LmZyYWcsIGxvYWRlciA9IGZyYWcubG9hZGVyO1xuICAgICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IGVycm9yc18xLkVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogZXJyb3JzXzEuRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SLCBmYXRhbDogZmFsc2UsIGZyYWc6IGZyYWcsIHJlc3BvbnNlOiByZXNwb25zZSB9KTtcbiAgICB9O1xuICAgIEtleUxvYWRlci5wcm90b3R5cGUubG9hZHRpbWVvdXQgPSBmdW5jdGlvbiAoc3RhdHMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGZyYWcgPSBjb250ZXh0LmZyYWcsIGxvYWRlciA9IGZyYWcubG9hZGVyO1xuICAgICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkVSUk9SLCB7IHR5cGU6IGVycm9yc18xLkVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogZXJyb3JzXzEuRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQsIGZhdGFsOiBmYWxzZSwgZnJhZzogZnJhZyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBLZXlMb2FkZXI7XG59KGV2ZW50X2hhbmRsZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBLZXlMb2FkZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbG9hZGVyL2xldmVsLWtleS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2xvYWRlci9sZXZlbC1rZXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFVSTFRvb2xraXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB1cmwtdG9vbGtpdCAqLyBcIi4vbm9kZV9tb2R1bGVzL3VybC10b29sa2l0L3NyYy91cmwtdG9vbGtpdC5qc1wiKTtcbnZhciBMZXZlbEtleSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMZXZlbEtleSgpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBudWxsO1xuICAgICAgICB0aGlzLmtleSA9IG51bGw7XG4gICAgICAgIHRoaXMuaXYgPSBudWxsO1xuICAgICAgICB0aGlzLl91cmkgPSBudWxsO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGV2ZWxLZXkucHJvdG90eXBlLCBcInVyaVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl91cmkgJiYgdGhpcy5yZWx1cmkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cmkgPSBVUkxUb29sa2l0LmJ1aWxkQWJzb2x1dGVVUkwodGhpcy5iYXNldXJpLCB0aGlzLnJlbHVyaSwgeyBhbHdheXNOb3JtYWxpemU6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXJpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gTGV2ZWxLZXk7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTGV2ZWxLZXk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbG9hZGVyL2xldmVsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9sb2FkZXIvbGV2ZWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKE51bWJlcikge1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIExldmVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExldmVsKGJhc2VVcmwpIHtcbiAgICAgICAgLy8gUGxlYXNlIGtlZXAgcHJvcGVydGllcyBpbiBhbHBoYWJldGljYWwgb3JkZXJcbiAgICAgICAgdGhpcy5lbmRDQyA9IDA7XG4gICAgICAgIHRoaXMuZW5kU04gPSAwO1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmluaXRTZWdtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5saXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5uZWVkU2lkeFJhbmdlcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXJ0Q0MgPSAwO1xuICAgICAgICB0aGlzLnN0YXJ0U04gPSAwO1xuICAgICAgICB0aGlzLnN0YXJ0VGltZU9mZnNldCA9IG51bGw7XG4gICAgICAgIHRoaXMudGFyZ2V0ZHVyYXRpb24gPSAwO1xuICAgICAgICB0aGlzLnRvdGFsZHVyYXRpb24gPSAwO1xuICAgICAgICB0aGlzLnR5cGUgPSBudWxsO1xuICAgICAgICB0aGlzLnVybCA9IGJhc2VVcmw7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IG51bGw7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMZXZlbC5wcm90b3R5cGUsIFwiaGFzUHJvZ3JhbURhdGVUaW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gISEodGhpcy5mcmFnbWVudHNbMF0gJiYgTnVtYmVyLmlzRmluaXRlKHRoaXMuZnJhZ21lbnRzWzBdLnByb2dyYW1EYXRlVGltZSkpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gTGV2ZWw7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTGV2ZWw7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci5qc1wiKVtcIk51bWJlclwiXSkpXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2xvYWRlci9tM3U4LXBhcnNlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbG9hZGVyL20zdTgtcGFyc2VyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihOdW1iZXIpIHtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBVUkxUb29sa2l0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdXJsLXRvb2xraXQgKi8gXCIuL25vZGVfbW9kdWxlcy91cmwtdG9vbGtpdC9zcmMvdXJsLXRvb2xraXQuanNcIik7XG52YXIgZnJhZ21lbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZnJhZ21lbnQgKi8gXCIuL3NyYy9sb2FkZXIvZnJhZ21lbnQuanNcIik7XG52YXIgbGV2ZWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGV2ZWwgKi8gXCIuL3NyYy9sb2FkZXIvbGV2ZWwuanNcIik7XG52YXIgbGV2ZWxfa2V5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xldmVsLWtleSAqLyBcIi4vc3JjL2xvYWRlci9sZXZlbC1rZXkuanNcIik7XG52YXIgYXR0cl9saXN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9hdHRyLWxpc3QgKi8gXCIuL3NyYy91dGlscy9hdHRyLWxpc3QuanNcIik7XG52YXIgbG9nZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIuanNcIik7XG52YXIgY29kZWNzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9jb2RlY3MgKi8gXCIuL3NyYy91dGlscy9jb2RlY3MuanNcIik7XG4vKipcbiAqIE0zVTggcGFyc2VyXG4gKiBAbW9kdWxlXG4gKi9cbi8vIGh0dHBzOi8vcmVnZXgxMDEuY29tIGlzIHlvdXIgZnJpZW5kXG52YXIgTUFTVEVSX1BMQVlMSVNUX1JFR0VYID0gLyNFWFQtWC1TVFJFQU0tSU5GOihbXlxcblxccl0qKVtcXHJcXG5dKyhbXlxcclxcbl0rKS9nO1xudmFyIE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWCA9IC8jRVhULVgtTUVESUE6KC4qKS9nO1xudmFyIExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QgPSBuZXcgUmVnRXhwKFtcbiAgICAvI0VYVElORjpcXHMqKFxcZCooPzpcXC5cXGQrKT8pKD86LCguKilcXHMrKT8vLnNvdXJjZSxcbiAgICAvfCg/ISMpKFtcXFMrID9dKykvLnNvdXJjZSxcbiAgICAvfCNFWFQtWC1CWVRFUkFOR0U6KiguKykvLnNvdXJjZSxcbiAgICAvfCNFWFQtWC1QUk9HUkFNLURBVEUtVElNRTooLispLy5zb3VyY2UsXG4gICAgL3wjLiovLnNvdXJjZSAvLyBBbGwgb3RoZXIgbm9uLXNlZ21lbnQgb3JpZW50ZWQgdGFncyB3aWxsIG1hdGNoIHdpdGggYWxsIGdyb3VwcyBlbXB0eVxuXS5qb2luKCcnKSwgJ2cnKTtcbnZhciBMRVZFTF9QTEFZTElTVF9SRUdFWF9TTE9XID0gLyg/Oig/OiMoRVhUTTNVKSl8KD86I0VYVC1YLShQTEFZTElTVC1UWVBFKTooLispKXwoPzojRVhULVgtKE1FRElBLVNFUVVFTkNFKTogKihcXGQrKSl8KD86I0VYVC1YLShUQVJHRVREVVJBVElPTik6ICooXFxkKykpfCg/OiNFWFQtWC0oS0VZKTooLispKXwoPzojRVhULVgtKFNUQVJUKTooLispKXwoPzojRVhULVgtKEVORExJU1QpKXwoPzojRVhULVgtKERJU0NPTlRJTlVJVFktU0VRKVVFTkNFOihcXGQrKSl8KD86I0VYVC1YLShESVMpQ09OVElOVUlUWSkpfCg/OiNFWFQtWC0oVkVSU0lPTik6KFxcZCspKXwoPzojRVhULVgtKE1BUCk6KC4rKSl8KD86KCMpKFteOl0qKTooLiopKXwoPzooIykoLiopKSg/Oi4qKVxccj9cXG4/LztcbnZhciBNUDRfUkVHRVhfU1VGRklYID0gL1xcLihtcDR8bTRzfG00dnxtNGEpJC9pO1xudmFyIE0zVThQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTTNVOFBhcnNlcigpIHtcbiAgICB9XG4gICAgTTNVOFBhcnNlci5maW5kR3JvdXAgPSBmdW5jdGlvbiAoZ3JvdXBzLCBtZWRpYUdyb3VwSWQpIHtcbiAgICAgICAgaWYgKCFncm91cHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXRjaGluZ0dyb3VwID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICAgICAgICAgIGlmIChncm91cC5pZCA9PT0gbWVkaWFHcm91cElkKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hpbmdHcm91cCA9IGdyb3VwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRjaGluZ0dyb3VwO1xuICAgIH07XG4gICAgTTNVOFBhcnNlci5jb252ZXJ0QVZDMVRvQVZDT1RJID0gZnVuY3Rpb24gKGNvZGVjKSB7XG4gICAgICAgIHZhciByZXN1bHQsIGF2Y2RhdGEgPSBjb2RlYy5zcGxpdCgnLicpO1xuICAgICAgICBpZiAoYXZjZGF0YS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhdmNkYXRhLnNoaWZ0KCkgKyAnLic7XG4gICAgICAgICAgICByZXN1bHQgKz0gcGFyc2VJbnQoYXZjZGF0YS5zaGlmdCgpKS50b1N0cmluZygxNik7XG4gICAgICAgICAgICByZXN1bHQgKz0gKCcwMDAnICsgcGFyc2VJbnQoYXZjZGF0YS5zaGlmdCgpKS50b1N0cmluZygxNikpLnN1YnN0cigtNCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjb2RlYztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTTNVOFBhcnNlci5yZXNvbHZlID0gZnVuY3Rpb24gKHVybCwgYmFzZVVybCkge1xuICAgICAgICByZXR1cm4gVVJMVG9vbGtpdC5idWlsZEFic29sdXRlVVJMKGJhc2VVcmwsIHVybCwgeyBhbHdheXNOb3JtYWxpemU6IHRydWUgfSk7XG4gICAgfTtcbiAgICBNM1U4UGFyc2VyLnBhcnNlTWFzdGVyUGxheWxpc3QgPSBmdW5jdGlvbiAoc3RyaW5nLCBiYXNldXJsKSB7XG4gICAgICAgIHZhciBsZXZlbHMgPSBbXSwgcmVzdWx0O1xuICAgICAgICBNQVNURVJfUExBWUxJU1RfUkVHRVgubGFzdEluZGV4ID0gMDtcbiAgICAgICAgZnVuY3Rpb24gc2V0Q29kZWNzKGNvZGVjcywgbGV2ZWwpIHtcbiAgICAgICAgICAgIFsndmlkZW8nLCAnYXVkaW8nXS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gY29kZWNzLmZpbHRlcihmdW5jdGlvbiAoY29kZWMpIHsgcmV0dXJuIGNvZGVjc18xLmlzQ29kZWNUeXBlKGNvZGVjLCB0eXBlKTsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlcmVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJlZmVycmVkID0gZmlsdGVyZWQuZmlsdGVyKGZ1bmN0aW9uIChjb2RlYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVjLmxhc3RJbmRleE9mKCdhdmMxJywgMCkgPT09IDAgfHwgY29kZWMubGFzdEluZGV4T2YoJ21wNGEnLCAwKSA9PT0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGxldmVsW3R5cGUgKyBcIkNvZGVjXCJdID0gcHJlZmVycmVkLmxlbmd0aCA+IDAgPyBwcmVmZXJyZWRbMF0gOiBmaWx0ZXJlZFswXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gbGlzdFxuICAgICAgICAgICAgICAgICAgICBjb2RlY3MgPSBjb2RlY3MuZmlsdGVyKGZ1bmN0aW9uIChjb2RlYykgeyByZXR1cm4gZmlsdGVyZWQuaW5kZXhPZihjb2RlYykgPT09IC0xOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldmVsLnVua25vd25Db2RlY3MgPSBjb2RlY3M7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKChyZXN1bHQgPSBNQVNURVJfUExBWUxJU1RfUkVHRVguZXhlYyhzdHJpbmcpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbGV2ZWwgPSB7fTtcbiAgICAgICAgICAgIHZhciBhdHRycyA9IGxldmVsLmF0dHJzID0gbmV3IGF0dHJfbGlzdF8xLmRlZmF1bHQocmVzdWx0WzFdKTtcbiAgICAgICAgICAgIGxldmVsLnVybCA9IE0zVThQYXJzZXIucmVzb2x2ZShyZXN1bHRbMl0sIGJhc2V1cmwpO1xuICAgICAgICAgICAgdmFyIHJlc29sdXRpb24gPSBhdHRycy5kZWNpbWFsUmVzb2x1dGlvbignUkVTT0xVVElPTicpO1xuICAgICAgICAgICAgaWYgKHJlc29sdXRpb24pIHtcbiAgICAgICAgICAgICAgICBsZXZlbC53aWR0aCA9IHJlc29sdXRpb24ud2lkdGg7XG4gICAgICAgICAgICAgICAgbGV2ZWwuaGVpZ2h0ID0gcmVzb2x1dGlvbi5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXZlbC5iaXRyYXRlID0gYXR0cnMuZGVjaW1hbEludGVnZXIoJ0FWRVJBR0UtQkFORFdJRFRIJykgfHwgYXR0cnMuZGVjaW1hbEludGVnZXIoJ0JBTkRXSURUSCcpO1xuICAgICAgICAgICAgbGV2ZWwubmFtZSA9IGF0dHJzLk5BTUU7XG4gICAgICAgICAgICBzZXRDb2RlY3MoW10uY29uY2F0KChhdHRycy5DT0RFQ1MgfHwgJycpLnNwbGl0KC9bICxdKy8pKSwgbGV2ZWwpO1xuICAgICAgICAgICAgaWYgKGxldmVsLnZpZGVvQ29kZWMgJiYgbGV2ZWwudmlkZW9Db2RlYy5pbmRleE9mKCdhdmMxJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwudmlkZW9Db2RlYyA9IE0zVThQYXJzZXIuY29udmVydEFWQzFUb0FWQ09USShsZXZlbC52aWRlb0NvZGVjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldmVscy5wdXNoKGxldmVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGV2ZWxzO1xuICAgIH07XG4gICAgTTNVOFBhcnNlci5wYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEgPSBmdW5jdGlvbiAoc3RyaW5nLCBiYXNldXJsLCB0eXBlLCBhdWRpb0dyb3Vwcykge1xuICAgICAgICBpZiAoYXVkaW9Hcm91cHMgPT09IHZvaWQgMCkgeyBhdWRpb0dyb3VwcyA9IFtdOyB9XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciBtZWRpYXMgPSBbXTtcbiAgICAgICAgdmFyIGlkID0gMDtcbiAgICAgICAgTUFTVEVSX1BMQVlMSVNUX01FRElBX1JFR0VYLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlICgocmVzdWx0ID0gTUFTVEVSX1BMQVlMSVNUX01FRElBX1JFR0VYLmV4ZWMoc3RyaW5nKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBtZWRpYSA9IHt9O1xuICAgICAgICAgICAgdmFyIGF0dHJzID0gbmV3IGF0dHJfbGlzdF8xLmRlZmF1bHQocmVzdWx0WzFdKTtcbiAgICAgICAgICAgIGlmIChhdHRycy5UWVBFID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgbWVkaWEuZ3JvdXBJZCA9IGF0dHJzWydHUk9VUC1JRCddO1xuICAgICAgICAgICAgICAgIG1lZGlhLm5hbWUgPSBhdHRycy5OQU1FO1xuICAgICAgICAgICAgICAgIG1lZGlhLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgICAgIG1lZGlhLmRlZmF1bHQgPSAoYXR0cnMuREVGQVVMVCA9PT0gJ1lFUycpO1xuICAgICAgICAgICAgICAgIG1lZGlhLmF1dG9zZWxlY3QgPSAoYXR0cnMuQVVUT1NFTEVDVCA9PT0gJ1lFUycpO1xuICAgICAgICAgICAgICAgIG1lZGlhLmZvcmNlZCA9IChhdHRycy5GT1JDRUQgPT09ICdZRVMnKTtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cnMuVVJJKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lZGlhLnVybCA9IE0zVThQYXJzZXIucmVzb2x2ZShhdHRycy5VUkksIGJhc2V1cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZWRpYS5sYW5nID0gYXR0cnMuTEFOR1VBR0U7XG4gICAgICAgICAgICAgICAgaWYgKCFtZWRpYS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lZGlhLm5hbWUgPSBtZWRpYS5sYW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXVkaW9Hcm91cHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cENvZGVjID0gTTNVOFBhcnNlci5maW5kR3JvdXAoYXVkaW9Hcm91cHMsIG1lZGlhLmdyb3VwSWQpO1xuICAgICAgICAgICAgICAgICAgICBtZWRpYS5hdWRpb0NvZGVjID0gZ3JvdXBDb2RlYyA/IGdyb3VwQ29kZWMuY29kZWMgOiBhdWRpb0dyb3Vwc1swXS5jb2RlYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWVkaWEuaWQgPSBpZCsrO1xuICAgICAgICAgICAgICAgIG1lZGlhcy5wdXNoKG1lZGlhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVkaWFzO1xuICAgIH07XG4gICAgTTNVOFBhcnNlci5wYXJzZUxldmVsUGxheWxpc3QgPSBmdW5jdGlvbiAoc3RyaW5nLCBiYXNldXJsLCBpZCwgdHlwZSwgbGV2ZWxVcmxJZCkge1xuICAgICAgICB2YXIgY3VycmVudFNOID0gMDtcbiAgICAgICAgdmFyIHRvdGFsZHVyYXRpb24gPSAwO1xuICAgICAgICB2YXIgbGV2ZWwgPSBuZXcgbGV2ZWxfMS5kZWZhdWx0KGJhc2V1cmwpO1xuICAgICAgICB2YXIgbGV2ZWxrZXkgPSBuZXcgbGV2ZWxfa2V5XzEuZGVmYXVsdCgpO1xuICAgICAgICB2YXIgY2MgPSAwO1xuICAgICAgICB2YXIgcHJldkZyYWcgPSBudWxsO1xuICAgICAgICB2YXIgZnJhZyA9IG5ldyBmcmFnbWVudF8xLmRlZmF1bHQoKTtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBmaXJzdFBkdEluZGV4ID0gbnVsbDtcbiAgICAgICAgTEVWRUxfUExBWUxJU1RfUkVHRVhfRkFTVC5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoKHJlc3VsdCA9IExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QuZXhlYyhzdHJpbmcpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gcmVzdWx0WzFdO1xuICAgICAgICAgICAgaWYgKGR1cmF0aW9uKSB7IC8vIElORlxuICAgICAgICAgICAgICAgIGZyYWcuZHVyYXRpb24gPSBwYXJzZUZsb2F0KGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgICAgICAgICAgdmFyIHRpdGxlID0gKCcgJyArIHJlc3VsdFsyXSkuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgZnJhZy50aXRsZSA9IHRpdGxlIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2godGl0bGUgPyBbJ0lORicsIGR1cmF0aW9uLCB0aXRsZV0gOiBbJ0lORicsIGR1cmF0aW9uXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXN1bHRbM10pIHsgLy8gdXJsXG4gICAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShmcmFnLmR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc24gPSBjdXJyZW50U04rKztcbiAgICAgICAgICAgICAgICAgICAgZnJhZy50eXBlID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgZnJhZy5zdGFydCA9IHRvdGFsZHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIGZyYWcubGV2ZWxrZXkgPSBsZXZlbGtleTtcbiAgICAgICAgICAgICAgICAgICAgZnJhZy5zbiA9IHNuO1xuICAgICAgICAgICAgICAgICAgICBmcmFnLmxldmVsID0gaWQ7XG4gICAgICAgICAgICAgICAgICAgIGZyYWcuY2MgPSBjYztcbiAgICAgICAgICAgICAgICAgICAgZnJhZy51cmxJZCA9IGxldmVsVXJsSWQ7XG4gICAgICAgICAgICAgICAgICAgIGZyYWcuYmFzZXVybCA9IGJhc2V1cmw7XG4gICAgICAgICAgICAgICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy85MzlcbiAgICAgICAgICAgICAgICAgICAgZnJhZy5yZWx1cmwgPSAoJyAnICsgcmVzdWx0WzNdKS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduUHJvZ3JhbURhdGVUaW1lKGZyYWcsIHByZXZGcmFnKTtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwuZnJhZ21lbnRzLnB1c2goZnJhZyk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZGcmFnID0gZnJhZztcbiAgICAgICAgICAgICAgICAgICAgdG90YWxkdXJhdGlvbiArPSBmcmFnLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICBmcmFnID0gbmV3IGZyYWdtZW50XzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdFs0XSkgeyAvLyBYLUJZVEVSQU5HRVxuICAgICAgICAgICAgICAgIGZyYWcucmF3Qnl0ZVJhbmdlID0gKCcgJyArIHJlc3VsdFs0XSkuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZGcmFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0Qnl0ZVJhbmdlRW5kT2Zmc2V0ID0gcHJldkZyYWcuYnl0ZVJhbmdlRW5kT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdEJ5dGVSYW5nZUVuZE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZy5sYXN0Qnl0ZVJhbmdlRW5kT2Zmc2V0ID0gbGFzdEJ5dGVSYW5nZUVuZE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdFs1XSkgeyAvLyBQUk9HUkFNLURBVEUtVElNRVxuICAgICAgICAgICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy85MzlcbiAgICAgICAgICAgICAgICBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSA9ICgnICcgKyByZXN1bHRbNV0pLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFsnUFJPR1JBTS1EQVRFLVRJTUUnLCBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZV0pO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdFBkdEluZGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UGR0SW5kZXggPSBsZXZlbC5mcmFnbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdFswXS5tYXRjaChMRVZFTF9QTEFZTElTVF9SRUdFWF9TTE9XKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZTEgPSAoJyAnICsgcmVzdWx0W2kgKyAxXSkuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlMiA9ICgnICcgKyByZXN1bHRbaSArIDJdKS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJlc3VsdFtpXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKHZhbHVlMiA/IFt2YWx1ZTEsIHZhbHVlMl0gOiBbdmFsdWUxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUExBWUxJU1QtVFlQRSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbC50eXBlID0gdmFsdWUxLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTUVESUEtU0VRVUVOQ0UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNOID0gbGV2ZWwuc3RhcnRTTiA9IHBhcnNlSW50KHZhbHVlMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVEFSR0VURFVSQVRJT04nOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWwudGFyZ2V0ZHVyYXRpb24gPSBwYXJzZUZsb2F0KHZhbHVlMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVkVSU0lPTic6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbC52ZXJzaW9uID0gcGFyc2VJbnQodmFsdWUxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdFWFRNM1UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0VORExJU1QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWwubGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0RJUyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goWydESVMnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnRElTQ09OVElOVUlUWS1TRVEnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2MgPSBwYXJzZUludCh2YWx1ZTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0tFWSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtcGFudG9zLWh0dHAtbGl2ZS1zdHJlYW1pbmctMDgjc2VjdGlvbi0zLjQuNFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlY3J5cHRwYXJhbXMgPSB2YWx1ZTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5QXR0cnMgPSBuZXcgYXR0cl9saXN0XzEuZGVmYXVsdChkZWNyeXB0cGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWNyeXB0bWV0aG9kID0ga2V5QXR0cnMuZW51bWVyYXRlZFN0cmluZygnTUVUSE9EJyksIGRlY3J5cHR1cmkgPSBrZXlBdHRycy5VUkksIGRlY3J5cHRpdiA9IGtleUF0dHJzLmhleGFkZWNpbWFsSW50ZWdlcignSVYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWNyeXB0bWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWxrZXkgPSBuZXcgbGV2ZWxfa2V5XzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZGVjcnlwdHVyaSkgJiYgKFsnQUVTLTEyOCcsICdTQU1QTEUtQUVTJywgJ1NBTVBMRS1BRVMtQ0VOQyddLmluZGV4T2YoZGVjcnlwdG1ldGhvZCkgPj0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWxrZXkubWV0aG9kID0gZGVjcnlwdG1ldGhvZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVVJJIHRvIGdldCB0aGUga2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsa2V5LmJhc2V1cmkgPSBiYXNldXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXZlbGtleS5yZWx1cmkgPSBkZWNyeXB0dXJpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXZlbGtleS5rZXkgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXphdGlvbiBWZWN0b3IgKElWKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXZlbGtleS5pdiA9IGRlY3J5cHRpdjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnU1RBUlQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0UGFyYW1zID0gdmFsdWUxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0QXR0cnMgPSBuZXcgYXR0cl9saXN0XzEuZGVmYXVsdChzdGFydFBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRUaW1lT2Zmc2V0ID0gc3RhcnRBdHRycy5kZWNpbWFsRmxvYXRpbmdQb2ludCgnVElNRS1PRkZTRVQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRJTUUtT0ZGU0VUIGNhbiBiZSAwXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHN0YXJ0VGltZU9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXZlbC5zdGFydFRpbWVPZmZzZXQgPSBzdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTUFQJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXBBdHRycyA9IG5ldyBhdHRyX2xpc3RfMS5kZWZhdWx0KHZhbHVlMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnLnJlbHVybCA9IG1hcEF0dHJzLlVSSTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcucmF3Qnl0ZVJhbmdlID0gbWFwQXR0cnMuQllURVJBTkdFO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZy5iYXNldXJsID0gYmFzZXVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcubGV2ZWwgPSBpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnLnNuID0gJ2luaXRTZWdtZW50JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsLmluaXRTZWdtZW50ID0gZnJhZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcgPSBuZXcgZnJhZ21lbnRfMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSA9IGxldmVsLmluaXRTZWdtZW50LnJhd1Byb2dyYW1EYXRlVGltZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oXCJsaW5lIHBhcnNlZCBidXQgbm90IGhhbmRsZWQ6IFwiICsgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmcmFnID0gcHJldkZyYWc7XG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ2ZvdW5kICcgKyBsZXZlbC5mcmFnbWVudHMubGVuZ3RoICsgJyBmcmFnbWVudHMnKTtcbiAgICAgICAgaWYgKGZyYWcgJiYgIWZyYWcucmVsdXJsKSB7XG4gICAgICAgICAgICBsZXZlbC5mcmFnbWVudHMucG9wKCk7XG4gICAgICAgICAgICB0b3RhbGR1cmF0aW9uIC09IGZyYWcuZHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgbGV2ZWwudG90YWxkdXJhdGlvbiA9IHRvdGFsZHVyYXRpb247XG4gICAgICAgIGxldmVsLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiA9IHRvdGFsZHVyYXRpb24gLyBsZXZlbC5mcmFnbWVudHMubGVuZ3RoO1xuICAgICAgICBsZXZlbC5lbmRTTiA9IGN1cnJlbnRTTiAtIDE7XG4gICAgICAgIGxldmVsLnN0YXJ0Q0MgPSBsZXZlbC5mcmFnbWVudHNbMF0gPyBsZXZlbC5mcmFnbWVudHNbMF0uY2MgOiAwO1xuICAgICAgICBsZXZlbC5lbmRDQyA9IGNjO1xuICAgICAgICBpZiAoIWxldmVsLmluaXRTZWdtZW50ICYmIGxldmVsLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBiaXQgbHVya3kgYnV0IEhMUyByZWFsbHkgaGFzIG5vIG90aGVyIHdheSB0byB0ZWxsIHVzXG4gICAgICAgICAgICAvLyBpZiB0aGUgZnJhZ21lbnRzIGFyZSBUUyBvciBNUDQsIGV4Y2VwdCBpZiB3ZSBkb3dubG9hZCB0aGVtIDovXG4gICAgICAgICAgICAvLyBidXQgdGhpcyBpcyB0byBiZSBhYmxlIHRvIGhhbmRsZSBTSURYLlxuICAgICAgICAgICAgaWYgKGxldmVsLmZyYWdtZW50cy5ldmVyeShmdW5jdGlvbiAoZnJhZykgeyByZXR1cm4gTVA0X1JFR0VYX1NVRkZJWC50ZXN0KGZyYWcucmVsdXJsKTsgfSkpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybignTVA0IGZyYWdtZW50cyBmb3VuZCBidXQgbm8gaW5pdCBzZWdtZW50IChwcm9iYWJseSBubyBNQVAsIGluY29tcGxldGUgTTNVOCksIHRyeWluZyB0byBmZXRjaCBTSURYJyk7XG4gICAgICAgICAgICAgICAgZnJhZyA9IG5ldyBmcmFnbWVudF8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBmcmFnLnJlbHVybCA9IGxldmVsLmZyYWdtZW50c1swXS5yZWx1cmw7XG4gICAgICAgICAgICAgICAgZnJhZy5iYXNldXJsID0gYmFzZXVybDtcbiAgICAgICAgICAgICAgICBmcmFnLmxldmVsID0gaWQ7XG4gICAgICAgICAgICAgICAgZnJhZy50eXBlID0gdHlwZTtcbiAgICAgICAgICAgICAgICBmcmFnLnNuID0gJ2luaXRTZWdtZW50JztcbiAgICAgICAgICAgICAgICBsZXZlbC5pbml0U2VnbWVudCA9IGZyYWc7XG4gICAgICAgICAgICAgICAgbGV2ZWwubmVlZFNpZHhSYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCYWNrZmlsbCBhbnkgbWlzc2luZyBQRFQgdmFsdWVzXG4gICAgICAgICAgIFwiSWYgdGhlIGZpcnN0IEVYVC1YLVBST0dSQU0tREFURS1USU1FIHRhZyBpbiBhIFBsYXlsaXN0IGFwcGVhcnMgYWZ0ZXJcbiAgICAgICAgICAgb25lIG9yIG1vcmUgTWVkaWEgU2VnbWVudCBVUklzLCB0aGUgY2xpZW50IFNIT1VMRCBleHRyYXBvbGF0ZVxuICAgICAgICAgICBiYWNrd2FyZCBmcm9tIHRoYXQgdGFnICh1c2luZyBFWFRJTkYgZHVyYXRpb25zIGFuZC9vciBtZWRpYVxuICAgICAgICAgICB0aW1lc3RhbXBzKSB0byBhc3NvY2lhdGUgZGF0ZXMgd2l0aCB0aG9zZSBzZWdtZW50cy5cIlxuICAgICAgICAgKiBXZSBoYXZlIGFscmVhZHkgZXh0cmFwb2xhdGVkIGZvcndhcmQsIGJ1dCBhbGwgZnJhZ21lbnRzIHVwIHRvIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBQRFQgZG8gbm90IGhhdmUgdGhlaXIgUERUc1xuICAgICAgICAgKiBjb21wdXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChmaXJzdFBkdEluZGV4KSB7XG4gICAgICAgICAgICBiYWNrZmlsbFByb2dyYW1EYXRlVGltZXMobGV2ZWwuZnJhZ21lbnRzLCBmaXJzdFBkdEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGV2ZWw7XG4gICAgfTtcbiAgICByZXR1cm4gTTNVOFBhcnNlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBNM1U4UGFyc2VyO1xuZnVuY3Rpb24gYmFja2ZpbGxQcm9ncmFtRGF0ZVRpbWVzKGZyYWdtZW50cywgc3RhcnRJbmRleCkge1xuICAgIHZhciBmcmFnUHJldiA9IGZyYWdtZW50c1tzdGFydEluZGV4XTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBmcmFnID0gZnJhZ21lbnRzW2ldO1xuICAgICAgICBmcmFnLnByb2dyYW1EYXRlVGltZSA9IGZyYWdQcmV2LnByb2dyYW1EYXRlVGltZSAtIChmcmFnLmR1cmF0aW9uICogMTAwMCk7XG4gICAgICAgIGZyYWdQcmV2ID0gZnJhZztcbiAgICB9XG59XG5mdW5jdGlvbiBhc3NpZ25Qcm9ncmFtRGF0ZVRpbWUoZnJhZywgcHJldkZyYWcpIHtcbiAgICBpZiAoZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBEYXRlLnBhcnNlKGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJldkZyYWcgJiYgcHJldkZyYWcucHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICAgIGZyYWcucHJvZ3JhbURhdGVUaW1lID0gcHJldkZyYWcuZW5kUHJvZ3JhbURhdGVUaW1lO1xuICAgIH1cbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShmcmFnLnByb2dyYW1EYXRlVGltZSkpIHtcbiAgICAgICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICAgICAgICBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gICAgfVxufVxuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIuanNcIilbXCJOdW1iZXJcIl0pKVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9sb2FkZXIvcGxheWxpc3QtbG9hZGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbG9hZGVyL3BsYXlsaXN0LWxvYWRlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKE51bWJlcikge1xuLyoqXG4gKiBQbGF5bGlzdExvYWRlciAtIGRlbGVnYXRlIGZvciBtZWRpYSBtYW5pZmVzdC9wbGF5bGlzdCBsb2FkaW5nIHRhc2tzLiBUYWtlcyBjYXJlIG9mIHBhcnNpbmcgbWVkaWEgdG8gaW50ZXJuYWwgZGF0YS1tb2RlbHMuXG4gKlxuICogT25jZSBsb2FkZWQsIGRpc3BhdGNoZXMgZXZlbnRzIHdpdGggcGFyc2VkIGRhdGEtbW9kZWxzIG9mIG1hbmlmZXN0L2xldmVscy9hdWRpby9zdWJ0aXRsZSB0cmFja3MuXG4gKlxuICogVXNlcyBsb2FkZXIocykgc2V0IGluIGNvbmZpZyB0byBkbyBhY3R1YWwgaW50ZXJuYWwgbG9hZGluZyBvZiByZXNvdXJjZSB0YXNrcy5cbiAqXG4gKiBAbW9kdWxlXG4gKlxuICovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy5qc1wiKTtcbnZhciBldmVudF9oYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudC1oYW5kbGVyICovIFwiLi9zcmMvZXZlbnQtaGFuZGxlci5qc1wiKTtcbnZhciBlcnJvcnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy5qc1wiKTtcbnZhciBsb2dnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci5qc1wiKTtcbnZhciBtcDRkZW11eGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9tcDRkZW11eGVyICovIFwiLi9zcmMvZGVtdXgvbXA0ZGVtdXhlci5qc1wiKTtcbnZhciBtM3U4X3BhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tM3U4LXBhcnNlciAqLyBcIi4vc3JjL2xvYWRlci9tM3U4LXBhcnNlci5qc1wiKTtcbnZhciBwZXJmb3JtYW5jZSA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcbi8qKlxuICogYHR5cGVgIHByb3BlcnR5IHZhbHVlcyBmb3IgdGhpcyBsb2FkZXJzJyBjb250ZXh0IG9iamVjdFxuICogQGVudW1cbiAqXG4gKi9cbnZhciBDb250ZXh0VHlwZSA9IHtcbiAgICBNQU5JRkVTVDogJ21hbmlmZXN0JyxcbiAgICBMRVZFTDogJ2xldmVsJyxcbiAgICBBVURJT19UUkFDSzogJ2F1ZGlvVHJhY2snLFxuICAgIFNVQlRJVExFX1RSQUNLOiAnc3VidGl0bGVUcmFjaydcbn07XG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbnZhciBMZXZlbFR5cGUgPSB7XG4gICAgTUFJTjogJ21haW4nLFxuICAgIEFVRElPOiAnYXVkaW8nLFxuICAgIFNVQlRJVExFOiAnc3VidGl0bGUnXG59O1xuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFBsYXlsaXN0TG9hZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQbGF5bGlzdExvYWRlciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0c1xuICAgICAqIEBwYXJhbSB7SGxzfSBobHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQbGF5bGlzdExvYWRlcihobHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaGxzLCBldmVudHNfMS5kZWZhdWx0Lk1BTklGRVNUX0xPQURJTkcsIGV2ZW50c18xLmRlZmF1bHQuTEVWRUxfTE9BRElORywgZXZlbnRzXzEuZGVmYXVsdC5BVURJT19UUkFDS19MT0FESU5HLCBldmVudHNfMS5kZWZhdWx0LlNVQlRJVExFX1RSQUNLX0xPQURJTkcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxvYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGxheWxpc3RMb2FkZXIsIFwiQ29udGV4dFR5cGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBDb250ZXh0VHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBsYXlsaXN0TG9hZGVyLCBcIkxldmVsVHlwZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIExldmVsVHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDb250ZXh0VHlwZX0gdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIFBsYXlsaXN0TG9hZGVyLmNhbkhhdmVRdWFsaXR5TGV2ZWxzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlICE9PSBDb250ZXh0VHlwZS5BVURJT19UUkFDSyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gQ29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0spO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWFwIGNvbnRleHQudHlwZSB0byBMZXZlbFR5cGVcbiAgICAgKiBAcGFyYW0ge3t0eXBlOiBDb250ZXh0VHlwZX19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJucyB7TGV2ZWxUeXBlfVxuICAgICAqL1xuICAgIFBsYXlsaXN0TG9hZGVyLm1hcENvbnRleHRUb0xldmVsVHlwZSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHZhciB0eXBlID0gY29udGV4dC50eXBlO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgQ29udGV4dFR5cGUuQVVESU9fVFJBQ0s6XG4gICAgICAgICAgICAgICAgcmV0dXJuIExldmVsVHlwZS5BVURJTztcbiAgICAgICAgICAgIGNhc2UgQ29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0s6XG4gICAgICAgICAgICAgICAgcmV0dXJuIExldmVsVHlwZS5TVUJUSVRMRTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIExldmVsVHlwZS5NQUlOO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQbGF5bGlzdExvYWRlci5nZXRSZXNwb25zZVVybCA9IGZ1bmN0aW9uIChyZXNwb25zZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgdXJsID0gcmVzcG9uc2UudXJsO1xuICAgICAgICAvLyByZXNwb25zZVVSTCBub3Qgc3VwcG9ydGVkIG9uIHNvbWUgYnJvd3NlcnMgKGl0IGlzIHVzZWQgdG8gZGV0ZWN0IFVSTCByZWRpcmVjdGlvbilcbiAgICAgICAgLy8gZGF0YS11cmkgbW9kZSBhbHNvIG5vdCBzdXBwb3J0ZWQgKGJ1dCBubyBuZWVkIHRvIGRldGVjdCByZWRpcmVjdGlvbilcbiAgICAgICAgaWYgKHVybCA9PT0gdW5kZWZpbmVkIHx8IHVybC5pbmRleE9mKCdkYXRhOicpID09PSAwKSB7XG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0byBpbml0aWFsIFVSTFxuICAgICAgICAgICAgdXJsID0gY29udGV4dC51cmw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgZGVmYXVsdHMgb3IgY29uZmlndXJlZCBsb2FkZXItdHlwZSBvdmVybG9hZHMgKHBMb2FkZXIgYW5kIGxvYWRlciBjb25maWcgcGFyYW1zKVxuICAgICAqIERlZmF1bHQgbG9hZGVyIGlzIFhIUkxvYWRlciAoc2VlIHV0aWxzKVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAgICogQHJldHVybnMge1hIUkxvYWRlcn0gb3Igb3RoZXIgY29tcGF0aWJsZSBjb25maWd1cmVkIG92ZXJsb2FkXG4gICAgICovXG4gICAgUGxheWxpc3RMb2FkZXIucHJvdG90eXBlLmNyZWF0ZUludGVybmFsTG9hZGVyID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICAgICAgdmFyIFBMb2FkZXIgPSBjb25maWcucExvYWRlcjtcbiAgICAgICAgdmFyIExvYWRlciA9IGNvbmZpZy5sb2FkZXI7XG4gICAgICAgIHZhciBJbnRlcm5hbExvYWRlciA9IFBMb2FkZXIgfHwgTG9hZGVyO1xuICAgICAgICB2YXIgbG9hZGVyID0gbmV3IEludGVybmFsTG9hZGVyKGNvbmZpZyk7XG4gICAgICAgIGNvbnRleHQubG9hZGVyID0gbG9hZGVyO1xuICAgICAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IGxvYWRlcjtcbiAgICAgICAgcmV0dXJuIGxvYWRlcjtcbiAgICB9O1xuICAgIFBsYXlsaXN0TG9hZGVyLnByb3RvdHlwZS5nZXRJbnRlcm5hbExvYWRlciA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXTtcbiAgICB9O1xuICAgIFBsYXlsaXN0TG9hZGVyLnByb3RvdHlwZS5yZXNldEludGVybmFsTG9hZGVyID0gZnVuY3Rpb24gKGNvbnRleHRUeXBlKSB7XG4gICAgICAgIGlmICh0aGlzLmxvYWRlcnNbY29udGV4dFR5cGVdKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5sb2FkZXJzW2NvbnRleHRUeXBlXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbCBgZGVzdHJveWAgb24gYWxsIGludGVybmFsIGxvYWRlciBpbnN0YW5jZXMgbWFwcGVkIChvbmUgcGVyIGNvbnRleHQgdHlwZSlcbiAgICAgKi9cbiAgICBQbGF5bGlzdExvYWRlci5wcm90b3R5cGUuZGVzdHJveUludGVybmFsTG9hZGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgY29udGV4dFR5cGUgaW4gdGhpcy5sb2FkZXJzKSB7XG4gICAgICAgICAgICB2YXIgbG9hZGVyID0gdGhpcy5sb2FkZXJzW2NvbnRleHRUeXBlXTtcbiAgICAgICAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgICAgICAgICBsb2FkZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXNldEludGVybmFsTG9hZGVyKGNvbnRleHRUeXBlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGxheWxpc3RMb2FkZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveUludGVybmFsTG9hZGVycygpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIFBsYXlsaXN0TG9hZGVyLnByb3RvdHlwZS5vbk1hbmlmZXN0TG9hZGluZyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMubG9hZChkYXRhLnVybCwgeyB0eXBlOiBDb250ZXh0VHlwZS5NQU5JRkVTVCwgbGV2ZWw6IDAsIGlkOiBudWxsIH0pO1xuICAgIH07XG4gICAgUGxheWxpc3RMb2FkZXIucHJvdG90eXBlLm9uTGV2ZWxMb2FkaW5nID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5sb2FkKGRhdGEudXJsLCB7IHR5cGU6IENvbnRleHRUeXBlLkxFVkVMLCBsZXZlbDogZGF0YS5sZXZlbCwgaWQ6IGRhdGEuaWQgfSk7XG4gICAgfTtcbiAgICBQbGF5bGlzdExvYWRlci5wcm90b3R5cGUub25BdWRpb1RyYWNrTG9hZGluZyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMubG9hZChkYXRhLnVybCwgeyB0eXBlOiBDb250ZXh0VHlwZS5BVURJT19UUkFDSywgbGV2ZWw6IG51bGwsIGlkOiBkYXRhLmlkIH0pO1xuICAgIH07XG4gICAgUGxheWxpc3RMb2FkZXIucHJvdG90eXBlLm9uU3VidGl0bGVUcmFja0xvYWRpbmcgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLmxvYWQoZGF0YS51cmwsIHsgdHlwZTogQ29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0ssIGxldmVsOiBudWxsLCBpZDogZGF0YS5pZCB9KTtcbiAgICB9O1xuICAgIFBsYXlsaXN0TG9hZGVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKHVybCwgY29udGV4dCkge1xuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIuZGVidWcoXCJMb2FkaW5nIHBsYXlsaXN0IG9mIHR5cGUgXCIgKyBjb250ZXh0LnR5cGUgKyBcIiwgbGV2ZWw6IFwiICsgY29udGV4dC5sZXZlbCArIFwiLCBpZDogXCIgKyBjb250ZXh0LmlkKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgYSBsb2FkZXIgZm9yIHRoaXMgY29udGV4dCBhbHJlYWR5IGV4aXN0c1xuICAgICAgICB2YXIgbG9hZGVyID0gdGhpcy5nZXRJbnRlcm5hbExvYWRlcihjb250ZXh0KTtcbiAgICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICAgICAgdmFyIGxvYWRlckNvbnRleHQgPSBsb2FkZXIuY29udGV4dDtcbiAgICAgICAgICAgIGlmIChsb2FkZXJDb250ZXh0ICYmIGxvYWRlckNvbnRleHQudXJsID09PSB1cmwpIHsgLy8gc2FtZSBVUkwgY2FuJ3Qgb3ZlcmxhcFxuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci50cmFjZSgncGxheWxpc3QgcmVxdWVzdCBvbmdvaW5nJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oXCJhYm9ydGluZyBwcmV2aW91cyBsb2FkZXIgZm9yIHR5cGU6IFwiICsgY29udGV4dC50eXBlKTtcbiAgICAgICAgICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF4UmV0cnksIHRpbWVvdXQsIHJldHJ5RGVsYXksIG1heFJldHJ5RGVsYXk7XG4gICAgICAgIC8vIGFwcGx5IGRpZmZlcmVudCBjb25maWdzIGZvciByZXRyaWVzIGRlcGVuZGluZyBvblxuICAgICAgICAvLyBjb250ZXh0IChtYW5pZmVzdCwgbGV2ZWwsIGF1ZGlvL3N1YnMgcGxheWxpc3QpXG4gICAgICAgIHN3aXRjaCAoY29udGV4dC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIENvbnRleHRUeXBlLk1BTklGRVNUOlxuICAgICAgICAgICAgICAgIG1heFJldHJ5ID0gY29uZmlnLm1hbmlmZXN0TG9hZGluZ01heFJldHJ5O1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBjb25maWcubWFuaWZlc3RMb2FkaW5nVGltZU91dDtcbiAgICAgICAgICAgICAgICByZXRyeURlbGF5ID0gY29uZmlnLm1hbmlmZXN0TG9hZGluZ1JldHJ5RGVsYXk7XG4gICAgICAgICAgICAgICAgbWF4UmV0cnlEZWxheSA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENvbnRleHRUeXBlLkxFVkVMOlxuICAgICAgICAgICAgICAgIC8vIERpc2FibGUgaW50ZXJuYWwgbG9hZGVyIHJldHJ5IGxvZ2ljLCBzaW5jZSB3ZSBhcmUgbWFuYWdpbmcgcmV0cmllcyBpbiBMZXZlbCBDb250cm9sbGVyXG4gICAgICAgICAgICAgICAgbWF4UmV0cnkgPSAwO1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBjb25maWcubGV2ZWxMb2FkaW5nVGltZU91dDtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIEludHJvZHVjZSByZXRyeSBzZXR0aW5ncyBmb3IgYXVkaW8tdHJhY2sgYW5kIHN1YnRpdGxlLXRyYWNrLCBpdCBzaG91bGQgbm90IHVzZSBsZXZlbCByZXRyeSBjb25maWdcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbWF4UmV0cnkgPSBjb25maWcubGV2ZWxMb2FkaW5nTWF4UmV0cnk7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IGNvbmZpZy5sZXZlbExvYWRpbmdUaW1lT3V0O1xuICAgICAgICAgICAgICAgIHJldHJ5RGVsYXkgPSBjb25maWcubGV2ZWxMb2FkaW5nUmV0cnlEZWxheTtcbiAgICAgICAgICAgICAgICBtYXhSZXRyeURlbGF5ID0gY29uZmlnLmxldmVsTG9hZGluZ01heFJldHJ5VGltZW91dDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsb2FkZXIgPSB0aGlzLmNyZWF0ZUludGVybmFsTG9hZGVyKGNvbnRleHQpO1xuICAgICAgICBjb250ZXh0LnVybCA9IHVybDtcbiAgICAgICAgY29udGV4dC5yZXNwb25zZVR5cGUgPSBjb250ZXh0LnJlc3BvbnNlVHlwZSB8fCAnJzsgLy8gRklYTUU6IChzaG91bGQgbm90IGJlIG5lY2Vzc2FyeSB0byBkbyB0aGlzKVxuICAgICAgICB2YXIgbG9hZGVyQ29uZmlnID0ge1xuICAgICAgICAgICAgdGltZW91dDogdGltZW91dCxcbiAgICAgICAgICAgIG1heFJldHJ5OiBtYXhSZXRyeSxcbiAgICAgICAgICAgIHJldHJ5RGVsYXk6IHJldHJ5RGVsYXksXG4gICAgICAgICAgICBtYXhSZXRyeURlbGF5OiBtYXhSZXRyeURlbGF5XG4gICAgICAgIH07XG4gICAgICAgIHZhciBsb2FkZXJDYWxsYmFja3MgPSB7XG4gICAgICAgICAgICBvblN1Y2Nlc3M6IHRoaXMubG9hZHN1Y2Nlc3MuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIG9uRXJyb3I6IHRoaXMubG9hZGVycm9yLmJpbmQodGhpcyksXG4gICAgICAgICAgICBvblRpbWVvdXQ6IHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKVxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIuZGVidWcoXCJDYWxsaW5nIGludGVybmFsIGxvYWRlciBkZWxlZ2F0ZSBmb3IgVVJMOiBcIiArIHVybCk7XG4gICAgICAgIGxvYWRlci5sb2FkKGNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBQbGF5bGlzdExvYWRlci5wcm90b3R5cGUubG9hZHN1Y2Nlc3MgPSBmdW5jdGlvbiAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgICAgICBpZiAobmV0d29ya0RldGFpbHMgPT09IHZvaWQgMCkgeyBuZXR3b3JrRGV0YWlscyA9IG51bGw7IH1cbiAgICAgICAgaWYgKGNvbnRleHQuaXNTaWR4UmVxdWVzdCkge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlU2lkeFJlcXVlc3QocmVzcG9uc2UsIGNvbnRleHQpO1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlUGxheWxpc3RMb2FkZWQocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldEludGVybmFsTG9hZGVyKGNvbnRleHQudHlwZSk7XG4gICAgICAgIHZhciBzdHJpbmcgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICBzdGF0cy50bG9hZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAvLyBzdGF0cy5tdGltZSA9IG5ldyBEYXRlKHRhcmdldC5nZXRSZXNwb25zZUhlYWRlcignTGFzdC1Nb2RpZmllZCcpKTtcbiAgICAgICAgLy8gVmFsaWRhdGUgaWYgaXQgaXMgYW4gTTNVOCBhdCBhbGxcbiAgICAgICAgaWYgKHN0cmluZy5pbmRleE9mKCcjRVhUTTNVJykgIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yKHJlc3BvbnNlLCBjb250ZXh0LCAnbm8gRVhUTTNVIGRlbGltaXRlcicsIG5ldHdvcmtEZXRhaWxzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiBjaHVuay1saXN0IG9yIG1hc3Rlci4gaGFuZGxlIGVtcHR5IGNodW5rIGxpc3QgY2FzZSAoZmlyc3QgRVhUSU5GIG5vdCBzaWduYWxlZCwgYnV0IFRBUkdFVERVUkFUSU9OIHByZXNlbnQpXG4gICAgICAgIGlmIChzdHJpbmcuaW5kZXhPZignI0VYVElORjonKSA+IDAgfHwgc3RyaW5nLmluZGV4T2YoJyNFWFQtWC1UQVJHRVREVVJBVElPTjonKSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZVRyYWNrT3JMZXZlbFBsYXlsaXN0KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlTWFzdGVyUGxheWxpc3QocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBsYXlsaXN0TG9hZGVyLnByb3RvdHlwZS5sb2FkZXJyb3IgPSBmdW5jdGlvbiAocmVzcG9uc2UsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgIGlmIChuZXR3b3JrRGV0YWlscyA9PT0gdm9pZCAwKSB7IG5ldHdvcmtEZXRhaWxzID0gbnVsbDsgfVxuICAgICAgICB0aGlzLl9oYW5kbGVOZXR3b3JrRXJyb3IoY29udGV4dCwgbmV0d29ya0RldGFpbHMsIGZhbHNlLCByZXNwb25zZSk7XG4gICAgfTtcbiAgICBQbGF5bGlzdExvYWRlci5wcm90b3R5cGUubG9hZHRpbWVvdXQgPSBmdW5jdGlvbiAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgIGlmIChuZXR3b3JrRGV0YWlscyA9PT0gdm9pZCAwKSB7IG5ldHdvcmtEZXRhaWxzID0gbnVsbDsgfVxuICAgICAgICB0aGlzLl9oYW5kbGVOZXR3b3JrRXJyb3IoY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHRydWUpO1xuICAgIH07XG4gICAgUGxheWxpc3RMb2FkZXIucHJvdG90eXBlLl9oYW5kbGVNYXN0ZXJQbGF5bGlzdCA9IGZ1bmN0aW9uIChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgICAgdmFyIHN0cmluZyA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIHZhciB1cmwgPSBQbGF5bGlzdExvYWRlci5nZXRSZXNwb25zZVVybChyZXNwb25zZSwgY29udGV4dCk7XG4gICAgICAgIHZhciBsZXZlbHMgPSBtM3U4X3BhcnNlcl8xLmRlZmF1bHQucGFyc2VNYXN0ZXJQbGF5bGlzdChzdHJpbmcsIHVybCk7XG4gICAgICAgIGlmICghbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IocmVzcG9uc2UsIGNvbnRleHQsICdubyBsZXZlbCBmb3VuZCBpbiBtYW5pZmVzdCcsIG5ldHdvcmtEZXRhaWxzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBtdWx0aSBsZXZlbCBwbGF5bGlzdCwgcGFyc2UgbGV2ZWwgaW5mb1xuICAgICAgICB2YXIgYXVkaW9Hcm91cHMgPSBsZXZlbHMubWFwKGZ1bmN0aW9uIChsZXZlbCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIGlkOiBsZXZlbC5hdHRycy5BVURJTyxcbiAgICAgICAgICAgIGNvZGVjOiBsZXZlbC5hdWRpb0NvZGVjXG4gICAgICAgIH0pOyB9KTtcbiAgICAgICAgdmFyIGF1ZGlvVHJhY2tzID0gbTN1OF9wYXJzZXJfMS5kZWZhdWx0LnBhcnNlTWFzdGVyUGxheWxpc3RNZWRpYShzdHJpbmcsIHVybCwgJ0FVRElPJywgYXVkaW9Hcm91cHMpO1xuICAgICAgICB2YXIgc3VidGl0bGVzID0gbTN1OF9wYXJzZXJfMS5kZWZhdWx0LnBhcnNlTWFzdGVyUGxheWxpc3RNZWRpYShzdHJpbmcsIHVybCwgJ1NVQlRJVExFUycpO1xuICAgICAgICBpZiAoYXVkaW9UcmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIGZvdW5kIGFuIGF1ZGlvIHRyYWNrIGVtYmVkZGVkIGluIG1haW4gcGxheWxpc3QgKGF1ZGlvIHRyYWNrIHdpdGhvdXQgVVJJIGF0dHJpYnV0ZSlcbiAgICAgICAgICAgIHZhciBlbWJlZGRlZEF1ZGlvRm91bmRfMSA9IGZhbHNlO1xuICAgICAgICAgICAgYXVkaW9UcmFja3MuZm9yRWFjaChmdW5jdGlvbiAoYXVkaW9UcmFjaykge1xuICAgICAgICAgICAgICAgIGlmICghYXVkaW9UcmFjay51cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1iZWRkZWRBdWRpb0ZvdW5kXzEgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gaWYgbm8gZW1iZWRkZWQgYXVkaW8gdHJhY2sgZGVmaW5lZCwgYnV0IGF1ZGlvIGNvZGVjIHNpZ25hbGVkIGluIHF1YWxpdHkgbGV2ZWwsXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHNpZ25hbCB0aGlzIG1haW4gYXVkaW8gdHJhY2sgdGhpcyBjb3VsZCBoYXBwZW4gd2l0aCBwbGF5bGlzdHMgd2l0aFxuICAgICAgICAgICAgLy8gYWx0IGF1ZGlvIHJlbmRpdGlvbiBpbiB3aGljaCBxdWFsaXR5IGxldmVscyAobWFpbilcbiAgICAgICAgICAgIC8vIGNvbnRhaW5zIGJvdGggYXVkaW8rdmlkZW8uIGJ1dCB3aXRoIG1peGVkIGF1ZGlvIHRyYWNrIG5vdCBzaWduYWxlZFxuICAgICAgICAgICAgaWYgKGVtYmVkZGVkQXVkaW9Gb3VuZF8xID09PSBmYWxzZSAmJiBsZXZlbHNbMF0uYXVkaW9Db2RlYyAmJiAhbGV2ZWxzWzBdLmF0dHJzLkFVRElPKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnYXVkaW8gY29kZWMgc2lnbmFsZWQgaW4gcXVhbGl0eSBsZXZlbCwgYnV0IG5vIGVtYmVkZGVkIGF1ZGlvIHRyYWNrIHNpZ25hbGVkLCBjcmVhdGUgb25lJyk7XG4gICAgICAgICAgICAgICAgYXVkaW9UcmFja3MudW5zaGlmdCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdtYWluJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ21haW4nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5NQU5JRkVTVF9MT0FERUQsIHtcbiAgICAgICAgICAgIGxldmVsczogbGV2ZWxzLFxuICAgICAgICAgICAgYXVkaW9UcmFja3M6IGF1ZGlvVHJhY2tzLFxuICAgICAgICAgICAgc3VidGl0bGVzOiBzdWJ0aXRsZXMsXG4gICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgIHN0YXRzOiBzdGF0cyxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlsc1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBsYXlsaXN0TG9hZGVyLnByb3RvdHlwZS5faGFuZGxlVHJhY2tPckxldmVsUGxheWxpc3QgPSBmdW5jdGlvbiAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICAgIHZhciBpZCA9IGNvbnRleHQuaWQsIGxldmVsID0gY29udGV4dC5sZXZlbCwgdHlwZSA9IGNvbnRleHQudHlwZTtcbiAgICAgICAgdmFyIHVybCA9IFBsYXlsaXN0TG9hZGVyLmdldFJlc3BvbnNlVXJsKHJlc3BvbnNlLCBjb250ZXh0KTtcbiAgICAgICAgdmFyIGxldmVsVXJsSWQgPSBOdW1iZXIuaXNGaW5pdGUoaWQpID8gaWQgOiAwO1xuICAgICAgICB2YXIgbGV2ZWxJZCA9IE51bWJlci5pc0Zpbml0ZShsZXZlbCkgPyBsZXZlbCA6IGxldmVsVXJsSWQ7XG4gICAgICAgIHZhciBsZXZlbFR5cGUgPSBQbGF5bGlzdExvYWRlci5tYXBDb250ZXh0VG9MZXZlbFR5cGUoY29udGV4dCk7XG4gICAgICAgIHZhciBsZXZlbERldGFpbHMgPSBtM3U4X3BhcnNlcl8xLmRlZmF1bHQucGFyc2VMZXZlbFBsYXlsaXN0KHJlc3BvbnNlLmRhdGEsIHVybCwgbGV2ZWxJZCwgbGV2ZWxUeXBlLCBsZXZlbFVybElkKTtcbiAgICAgICAgLy8gc2V0IHN0YXRzIG9uIGxldmVsIHN0cnVjdHVyZVxuICAgICAgICBsZXZlbERldGFpbHMudGxvYWQgPSBzdGF0cy50bG9hZDtcbiAgICAgICAgLy8gV2UgaGF2ZSBkb25lIG91ciBmaXJzdCByZXF1ZXN0IChNYW5pZmVzdC10eXBlKSBhbmQgcmVjZWl2ZVxuICAgICAgICAvLyBub3QgYSBtYXN0ZXIgcGxheWxpc3QgYnV0IGEgY2h1bmstbGlzdCAodHJhY2svbGV2ZWwpXG4gICAgICAgIC8vIFdlIGZpcmUgdGhlIG1hbmlmZXN0LWxvYWRlZCBldmVudCBhbnl3YXkgd2l0aCB0aGUgcGFyc2VkIGxldmVsLWRldGFpbHNcbiAgICAgICAgLy8gYnkgY3JlYXRpbmcgYSBzaW5nbGUtbGV2ZWwgc3RydWN0dXJlIGZvciBpdC5cbiAgICAgICAgaWYgKHR5cGUgPT09IENvbnRleHRUeXBlLk1BTklGRVNUKSB7XG4gICAgICAgICAgICB2YXIgc2luZ2xlTGV2ZWwgPSB7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5NQU5JRkVTVF9MT0FERUQsIHtcbiAgICAgICAgICAgICAgICBsZXZlbHM6IFtzaW5nbGVMZXZlbF0sXG4gICAgICAgICAgICAgICAgYXVkaW9UcmFja3M6IFtdLFxuICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgIHN0YXRzOiBzdGF0cyxcbiAgICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNhdmUgcGFyc2luZyB0aW1lXG4gICAgICAgIHN0YXRzLnRwYXJzZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgLy8gaW4gY2FzZSB3ZSBuZWVkIFNJRFggcmFuZ2VzXG4gICAgICAgIC8vIHJldHVybiBlYXJseSBhZnRlciBjYWxsaW5nIGxvYWQgZm9yXG4gICAgICAgIC8vIHRoZSBTSURYIGJveC5cbiAgICAgICAgaWYgKGxldmVsRGV0YWlscy5uZWVkU2lkeFJhbmdlcykge1xuICAgICAgICAgICAgdmFyIHNpZHhVcmwgPSBsZXZlbERldGFpbHMuaW5pdFNlZ21lbnQudXJsO1xuICAgICAgICAgICAgdGhpcy5sb2FkKHNpZHhVcmwsIHtcbiAgICAgICAgICAgICAgICBpc1NpZHhSZXF1ZXN0OiB0cnVlLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgICAgICAgICAgIGxldmVsRGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICByYW5nZVN0YXJ0OiAwLFxuICAgICAgICAgICAgICAgIHJhbmdlRW5kOiAyMDQ4LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXh0ZW5kIHRoZSBjb250ZXh0IHdpdGggdGhlIG5ldyBsZXZlbERldGFpbHMgcHJvcGVydHlcbiAgICAgICAgY29udGV4dC5sZXZlbERldGFpbHMgPSBsZXZlbERldGFpbHM7XG4gICAgICAgIHRoaXMuX2hhbmRsZVBsYXlsaXN0TG9hZGVkKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpO1xuICAgIH07XG4gICAgUGxheWxpc3RMb2FkZXIucHJvdG90eXBlLl9oYW5kbGVTaWR4UmVxdWVzdCA9IGZ1bmN0aW9uIChyZXNwb25zZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgc2lkeEluZm8gPSBtcDRkZW11eGVyXzEuZGVmYXVsdC5wYXJzZVNlZ21lbnRJbmRleChuZXcgVWludDhBcnJheShyZXNwb25zZS5kYXRhKSk7XG4gICAgICAgIC8vIGlmIHByb3ZpZGVkIGZyYWdtZW50IGRvZXMgbm90IGNvbnRhaW4gc2lkeCwgZWFybHkgcmV0dXJuXG4gICAgICAgIGlmICghc2lkeEluZm8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2lkeFJlZmVyZW5jZXMgPSBzaWR4SW5mby5yZWZlcmVuY2VzO1xuICAgICAgICB2YXIgbGV2ZWxEZXRhaWxzID0gY29udGV4dC5sZXZlbERldGFpbHM7XG4gICAgICAgIHNpZHhSZWZlcmVuY2VzLmZvckVhY2goZnVuY3Rpb24gKHNlZ21lbnRSZWYsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgc2VnUmVmSW5mbyA9IHNlZ21lbnRSZWYuaW5mbztcbiAgICAgICAgICAgIHZhciBmcmFnID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoZnJhZy5ieXRlUmFuZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZnJhZy5yYXdCeXRlUmFuZ2UgPSBTdHJpbmcoMSArIHNlZ1JlZkluZm8uZW5kIC0gc2VnUmVmSW5mby5zdGFydCkgKyAnQCcgKyBTdHJpbmcoc2VnUmVmSW5mby5zdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsZXZlbERldGFpbHMuaW5pdFNlZ21lbnQucmF3Qnl0ZVJhbmdlID0gU3RyaW5nKHNpZHhJbmZvLm1vb3ZFbmRPZmZzZXQpICsgJ0AwJztcbiAgICB9O1xuICAgIFBsYXlsaXN0TG9hZGVyLnByb3RvdHlwZS5faGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IgPSBmdW5jdGlvbiAocmVzcG9uc2UsIGNvbnRleHQsIHJlYXNvbiwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkVSUk9SLCB7XG4gICAgICAgICAgICB0eXBlOiBlcnJvcnNfMS5FcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBlcnJvcnNfMS5FcnJvckRldGFpbHMuTUFOSUZFU1RfUEFSU0lOR19FUlJPUixcbiAgICAgICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICAgICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgICAgICAgICByZWFzb246IHJlYXNvbixcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlsc1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBsYXlsaXN0TG9hZGVyLnByb3RvdHlwZS5faGFuZGxlTmV0d29ya0Vycm9yID0gZnVuY3Rpb24gKGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCB0aW1lb3V0LCByZXNwb25zZSkge1xuICAgICAgICBpZiAodGltZW91dCA9PT0gdm9pZCAwKSB7IHRpbWVvdXQgPSBmYWxzZTsgfVxuICAgICAgICBpZiAocmVzcG9uc2UgPT09IHZvaWQgMCkgeyByZXNwb25zZSA9IG51bGw7IH1cbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmluZm8oXCJBIG5ldHdvcmsgZXJyb3Igb2NjdXJlZCB3aGlsZSBsb2FkaW5nIGEgXCIgKyBjb250ZXh0LnR5cGUgKyBcIi10eXBlIHBsYXlsaXN0XCIpO1xuICAgICAgICB2YXIgZGV0YWlscztcbiAgICAgICAgdmFyIGZhdGFsO1xuICAgICAgICB2YXIgbG9hZGVyID0gdGhpcy5nZXRJbnRlcm5hbExvYWRlcihjb250ZXh0KTtcbiAgICAgICAgc3dpdGNoIChjb250ZXh0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgQ29udGV4dFR5cGUuTUFOSUZFU1Q6XG4gICAgICAgICAgICAgICAgZGV0YWlscyA9ICh0aW1lb3V0ID8gZXJyb3JzXzEuRXJyb3JEZXRhaWxzLk1BTklGRVNUX0xPQURfVElNRU9VVCA6IGVycm9yc18xLkVycm9yRGV0YWlscy5NQU5JRkVTVF9MT0FEX0VSUk9SKTtcbiAgICAgICAgICAgICAgICBmYXRhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENvbnRleHRUeXBlLkxFVkVMOlxuICAgICAgICAgICAgICAgIGRldGFpbHMgPSAodGltZW91dCA/IGVycm9yc18xLkVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQgOiBlcnJvcnNfMS5FcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUik7XG4gICAgICAgICAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ29udGV4dFR5cGUuQVVESU9fVFJBQ0s6XG4gICAgICAgICAgICAgICAgZGV0YWlscyA9ICh0aW1lb3V0ID8gZXJyb3JzXzEuRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfVElNRU9VVCA6IGVycm9yc18xLkVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SKTtcbiAgICAgICAgICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBkZXRhaWxzID0gLi4uP1xuICAgICAgICAgICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dC50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3JEYXRhID0ge1xuICAgICAgICAgICAgdHlwZTogZXJyb3JzXzEuRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogZGV0YWlscyxcbiAgICAgICAgICAgIGZhdGFsOiBmYXRhbCxcbiAgICAgICAgICAgIHVybDogbG9hZGVyLnVybCxcbiAgICAgICAgICAgIGxvYWRlcjogbG9hZGVyLFxuICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlsc1xuICAgICAgICB9O1xuICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGVycm9yRGF0YS5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwgZXJyb3JEYXRhKTtcbiAgICB9O1xuICAgIFBsYXlsaXN0TG9hZGVyLnByb3RvdHlwZS5faGFuZGxlUGxheWxpc3RMb2FkZWQgPSBmdW5jdGlvbiAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgICAgICB2YXIgdHlwZSA9IGNvbnRleHQudHlwZSwgbGV2ZWwgPSBjb250ZXh0LmxldmVsLCBpZCA9IGNvbnRleHQuaWQsIGxldmVsRGV0YWlscyA9IGNvbnRleHQubGV2ZWxEZXRhaWxzO1xuICAgICAgICBpZiAoIWxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IocmVzcG9uc2UsIGNvbnRleHQsICdpbnZhbGlkIHRhcmdldCBkdXJhdGlvbicsIG5ldHdvcmtEZXRhaWxzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FuSGF2ZUxldmVscyA9IFBsYXlsaXN0TG9hZGVyLmNhbkhhdmVRdWFsaXR5TGV2ZWxzKGNvbnRleHQudHlwZSk7XG4gICAgICAgIGlmIChjYW5IYXZlTGV2ZWxzKSB7XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuTEVWRUxfTE9BREVELCB7XG4gICAgICAgICAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICAgICAgICAgIGxldmVsOiBsZXZlbCB8fCAwLFxuICAgICAgICAgICAgICAgIGlkOiBpZCB8fCAwLFxuICAgICAgICAgICAgICAgIHN0YXRzOiBzdGF0cyxcbiAgICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250ZXh0VHlwZS5BVURJT19UUkFDSzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkFVRElPX1RSQUNLX0xPQURFRCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHM6IHN0YXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuU1VCVElUTEVfVFJBQ0tfTE9BREVELCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0czogc3RhdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUGxheWxpc3RMb2FkZXI7XG59KGV2ZW50X2hhbmRsZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBQbGF5bGlzdExvYWRlcjtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLmpzXCIpW1wiTnVtYmVyXCJdKSlcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvb2JzZXJ2ZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvb2JzZXJ2ZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV2ZW50ZW1pdHRlcjNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGV2ZW50ZW1pdHRlcjMgKi8gXCIuL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzXCIpO1xuLyoqXG4gKiBAY2xhc3NcbiAqXG4gKiBTaW1wbGUgYWRhcHRlciBzdWItY2xhc3Mgb2YgTm9kZWpzLWxpa2UgRXZlbnRFbWl0dGVyLlxuICpcbiAqIFdlIHNpbXBseSB3YW50IHRvIHBhc3MgYWxvbmcgdGhlIGV2ZW50LW5hbWUgaXRzZWxmXG4gKiBpbiBldmVyeSBjYWxsIHRvIGEgaGFuZGxlciwgd2hpY2ggaXMgdGhlIHB1cnBvc2Ugb2Ygb3VyIGB0cmlnZ2VyYCBtZXRob2RcbiAqIGV4dGVuZGluZyB0aGUgc3RhbmRhcmQgQVBJLlxuICpcbiAqL1xudmFyIE9ic2VydmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPYnNlcnZlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPYnNlcnZlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgICAqIEBwYXJhbSB7YW55fSBkYXRhXG4gICAgICovXG4gICAgT2JzZXJ2ZXIucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGRhdGFbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIFtldmVudCwgZXZlbnRdLmNvbmNhdChkYXRhKSk7XG4gICAgfTtcbiAgICByZXR1cm4gT2JzZXJ2ZXI7XG59KGV2ZW50ZW1pdHRlcjNfMS5FdmVudEVtaXR0ZXIpKTtcbmV4cG9ydHMuT2JzZXJ2ZXIgPSBPYnNlcnZlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcG9seWZpbGxzL251bWJlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ2V0X3NlbGZfc2NvcGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2dldC1zZWxmLXNjb3BlICovIFwiLi9zcmMvdXRpbHMvZ2V0LXNlbGYtc2NvcGUuanNcIik7XG52YXIgc2VsZiA9IGdldF9zZWxmX3Njb3BlXzEuZ2V0U2VsZlNjb3BlKCk7XG52YXIgTnVtYmVyID0gc2VsZi5OdW1iZXI7XG5leHBvcnRzLk51bWJlciA9IE51bWJlcjtcbi8vIFRPRE86IGdldCByaWQgb2YgZ2xvYmFsIHBvbHlmaWxscyBhbmQgcmVwbGFjZSB0aGVtIHdpdGggd3JhcHBlcnMgKFwicG9ueWZpbGxzXCIpXG5OdW1iZXIuaXNGaW5pdGUgPSBOdW1iZXIuaXNGaW5pdGUgfHwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsdWUpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9yZW11eC9hYWMtaGVscGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcmVtdXgvYWFjLWhlbHBlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqICBBQUMgaGVscGVyXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBBQUMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQUFDKCkge1xuICAgIH1cbiAgICBBQUMuZ2V0U2lsZW50RnJhbWUgPSBmdW5jdGlvbiAoY29kZWMsIGNoYW5uZWxDb3VudCkge1xuICAgICAgICBzd2l0Y2ggKGNvZGVjKSB7XG4gICAgICAgICAgICBjYXNlICdtcDRhLjQwLjInOlxuICAgICAgICAgICAgICAgIGlmIChjaGFubmVsQ291bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIzLCAweDgwXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MjEsIDB4MDAsIDB4NDksIDB4OTAsIDB4MDIsIDB4MTksIDB4MDAsIDB4MjMsIDB4ODBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4ZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgwLCAweDJjLCAweDgwLCAweDA4LCAweDAyLCAweDM4XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODIsIDB4MzAsIDB4MDQsIDB4OTksIDB4MDAsIDB4MjEsIDB4OTAsIDB4MDIsIDB4MzhdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MiwgMHgzMCwgMHgwNCwgMHg5OSwgMHgwMCwgMHgyMSwgMHg5MCwgMHgwMiwgMHgwMCwgMHhiMiwgMHgwMCwgMHgyMCwgMHgwOCwgMHhlMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIGhhbmRsZSBIRS1BQUMgYmVsb3cgKG1wNGEuNDAuNSAvIG1wNGEuNDAuMjkpXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChjaGFubmVsQ291bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmZtcGVnIC15IC1mIGxhdmZpIC1pIFwiYWV2YWxzcmM9MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGUgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgJzE2LzEgXCIweCV4LFwiIFwiXFxuXCInIC12IG91dHB1dC5hYWNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDEsIDB4NDAsIDB4MjIsIDB4ODAsIDB4YTMsIDB4NGUsIDB4ZTYsIDB4ODAsIDB4YmEsIDB4OCwgMHgwLCAweDAsIDB4MCwgMHgxYywgMHg2LCAweGYxLCAweGMxLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTB8MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGVfdjIgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgJzE2LzEgXCIweCV4LFwiIFwiXFxuXCInIC12IG91dHB1dC5hYWNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDEsIDB4NDAsIDB4MjIsIDB4ODAsIDB4YTMsIDB4NWUsIDB4ZTYsIDB4ODAsIDB4YmEsIDB4OCwgMHgwLCAweDAsIDB4MCwgMHgwLCAweDk1LCAweDAsIDB4NiwgMHhmMSwgMHhhMSwgMHhhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wfDB8MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGVfdjIgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgJzE2LzEgXCIweCV4LFwiIFwiXFxuXCInIC12IG91dHB1dC5hYWNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDEsIDB4NDAsIDB4MjIsIDB4ODAsIDB4YTMsIDB4NWUsIDB4ZTYsIDB4ODAsIDB4YmEsIDB4OCwgMHgwLCAweDAsIDB4MCwgMHgwLCAweDk1LCAweDAsIDB4NiwgMHhmMSwgMHhhMSwgMHhhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIEFBQztcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBBQUM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvcmVtdXgvbXA0LWdlbmVyYXRvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3JlbXV4L21wNC1nZW5lcmF0b3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBHZW5lcmF0ZSBNUDQgQm94XG4qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFVJTlQzMl9NQVggPSBNYXRoLnBvdygyLCAzMikgLSAxO1xudmFyIE1QNCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNUDQoKSB7XG4gICAgfVxuICAgIE1QNC5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBNUDQudHlwZXMgPSB7XG4gICAgICAgICAgICBhdmMxOiBbXSxcbiAgICAgICAgICAgIGF2Y0M6IFtdLFxuICAgICAgICAgICAgYnRydDogW10sXG4gICAgICAgICAgICBkaW5mOiBbXSxcbiAgICAgICAgICAgIGRyZWY6IFtdLFxuICAgICAgICAgICAgZXNkczogW10sXG4gICAgICAgICAgICBmdHlwOiBbXSxcbiAgICAgICAgICAgIGhkbHI6IFtdLFxuICAgICAgICAgICAgbWRhdDogW10sXG4gICAgICAgICAgICBtZGhkOiBbXSxcbiAgICAgICAgICAgIG1kaWE6IFtdLFxuICAgICAgICAgICAgbWZoZDogW10sXG4gICAgICAgICAgICBtaW5mOiBbXSxcbiAgICAgICAgICAgIG1vb2Y6IFtdLFxuICAgICAgICAgICAgbW9vdjogW10sXG4gICAgICAgICAgICBtcDRhOiBbXSxcbiAgICAgICAgICAgICcubXAzJzogW10sXG4gICAgICAgICAgICBtdmV4OiBbXSxcbiAgICAgICAgICAgIG12aGQ6IFtdLFxuICAgICAgICAgICAgcGFzcDogW10sXG4gICAgICAgICAgICBzZHRwOiBbXSxcbiAgICAgICAgICAgIHN0Ymw6IFtdLFxuICAgICAgICAgICAgc3RjbzogW10sXG4gICAgICAgICAgICBzdHNjOiBbXSxcbiAgICAgICAgICAgIHN0c2Q6IFtdLFxuICAgICAgICAgICAgc3RzejogW10sXG4gICAgICAgICAgICBzdHRzOiBbXSxcbiAgICAgICAgICAgIHRmZHQ6IFtdLFxuICAgICAgICAgICAgdGZoZDogW10sXG4gICAgICAgICAgICB0cmFmOiBbXSxcbiAgICAgICAgICAgIHRyYWs6IFtdLFxuICAgICAgICAgICAgdHJ1bjogW10sXG4gICAgICAgICAgICB0cmV4OiBbXSxcbiAgICAgICAgICAgIHRraGQ6IFtdLFxuICAgICAgICAgICAgdm1oZDogW10sXG4gICAgICAgICAgICBzbWhkOiBbXVxuICAgICAgICB9O1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpIGluIE1QNC50eXBlcykge1xuICAgICAgICAgICAgaWYgKE1QNC50eXBlcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgIE1QNC50eXBlc1tpXSA9IFtcbiAgICAgICAgICAgICAgICAgICAgaS5jaGFyQ29kZUF0KDApLFxuICAgICAgICAgICAgICAgICAgICBpLmNoYXJDb2RlQXQoMSksXG4gICAgICAgICAgICAgICAgICAgIGkuY2hhckNvZGVBdCgyKSxcbiAgICAgICAgICAgICAgICAgICAgaS5jaGFyQ29kZUF0KDMpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdmlkZW9IZGxyID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHg3NiwgMHg2OSwgMHg2NCwgMHg2NSxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4NTYsIDB4NjksIDB4NjQsIDB4NjUsXG4gICAgICAgICAgICAweDZmLCAweDQ4LCAweDYxLCAweDZlLFxuICAgICAgICAgICAgMHg2NCwgMHg2YywgMHg2NSwgMHg3MiwgMHgwMCAvLyBuYW1lOiAnVmlkZW9IYW5kbGVyJ1xuICAgICAgICBdKTtcbiAgICAgICAgdmFyIGF1ZGlvSGRsciA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4NzMsIDB4NmYsIDB4NzUsIDB4NmUsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDUzLCAweDZmLCAweDc1LCAweDZlLFxuICAgICAgICAgICAgMHg2NCwgMHg0OCwgMHg2MSwgMHg2ZSxcbiAgICAgICAgICAgIDB4NjQsIDB4NmMsIDB4NjUsIDB4NzIsIDB4MDAgLy8gbmFtZTogJ1NvdW5kSGFuZGxlcidcbiAgICAgICAgXSk7XG4gICAgICAgIE1QNC5IRExSX1RZUEVTID0ge1xuICAgICAgICAgICAgJ3ZpZGVvJzogdmlkZW9IZGxyLFxuICAgICAgICAgICAgJ2F1ZGlvJzogYXVkaW9IZGxyXG4gICAgICAgIH07XG4gICAgICAgIHZhciBkcmVmID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAxLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwYyxcbiAgICAgICAgICAgIDB4NzUsIDB4NzIsIDB4NmMsIDB4MjAsXG4gICAgICAgICAgICAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMSAvLyBlbnRyeV9mbGFnc1xuICAgICAgICBdKTtcbiAgICAgICAgdmFyIHN0Y28gPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLy8gZW50cnlfY291bnRcbiAgICAgICAgXSk7XG4gICAgICAgIE1QNC5TVFRTID0gTVA0LlNUU0MgPSBNUDQuU1RDTyA9IHN0Y287XG4gICAgICAgIE1QNC5TVFNaID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBzYW1wbGVfY291bnRcbiAgICAgICAgXSk7XG4gICAgICAgIE1QNC5WTUhEID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDEsXG4gICAgICAgICAgICAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwIC8vIG9wY29sb3JcbiAgICAgICAgXSk7XG4gICAgICAgIE1QNC5TTUhEID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCAvLyByZXNlcnZlZFxuICAgICAgICBdKTtcbiAgICAgICAgTVA0LlNUU0QgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDFcbiAgICAgICAgXSk7IC8vIGVudHJ5X2NvdW50XG4gICAgICAgIHZhciBtYWpvckJyYW5kID0gbmV3IFVpbnQ4QXJyYXkoWzEwNSwgMTE1LCAxMTEsIDEwOV0pOyAvLyBpc29tXG4gICAgICAgIHZhciBhdmMxQnJhbmQgPSBuZXcgVWludDhBcnJheShbOTcsIDExOCwgOTksIDQ5XSk7IC8vIGF2YzFcbiAgICAgICAgdmFyIG1pbm9yVmVyc2lvbiA9IG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAxXSk7XG4gICAgICAgIE1QNC5GVFlQID0gTVA0LmJveChNUDQudHlwZXMuZnR5cCwgbWFqb3JCcmFuZCwgbWlub3JWZXJzaW9uLCBtYWpvckJyYW5kLCBhdmMxQnJhbmQpO1xuICAgICAgICBNUDQuRElORiA9IE1QNC5ib3goTVA0LnR5cGVzLmRpbmYsIE1QNC5ib3goTVA0LnR5cGVzLmRyZWYsIGRyZWYpKTtcbiAgICB9O1xuICAgIE1QNC5ib3ggPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgcGF5bG9hZCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIHNpemUgPSA4LCBpID0gcGF5bG9hZC5sZW5ndGgsIGxlbiA9IGksIHJlc3VsdDtcbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSB0b3RhbCBzaXplIHdlIG5lZWQgdG8gYWxsb2NhdGVcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgc2l6ZSArPSBwYXlsb2FkW2ldLmJ5dGVMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgICAgIHJlc3VsdFswXSA9IChzaXplID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIHJlc3VsdFsxXSA9IChzaXplID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIHJlc3VsdFsyXSA9IChzaXplID4+IDgpICYgMHhmZjtcbiAgICAgICAgcmVzdWx0WzNdID0gc2l6ZSAmIDB4ZmY7XG4gICAgICAgIHJlc3VsdC5zZXQodHlwZSwgNCk7XG4gICAgICAgIC8vIGNvcHkgdGhlIHBheWxvYWQgaW50byB0aGUgcmVzdWx0XG4gICAgICAgIGZvciAoaSA9IDAsIHNpemUgPSA4OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGNvcHkgcGF5bG9hZFtpXSBhcnJheSBAIG9mZnNldCBzaXplXG4gICAgICAgICAgICByZXN1bHQuc2V0KHBheWxvYWRbaV0sIHNpemUpO1xuICAgICAgICAgICAgc2l6ZSArPSBwYXlsb2FkW2ldLmJ5dGVMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE1QNC5oZGxyID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLmhkbHIsIE1QNC5IRExSX1RZUEVTW3R5cGVdKTtcbiAgICB9O1xuICAgIE1QNC5tZGF0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kYXQsIGRhdGEpO1xuICAgIH07XG4gICAgTVA0Lm1kaGQgPSBmdW5jdGlvbiAodGltZXNjYWxlLCBkdXJhdGlvbikge1xuICAgICAgICBkdXJhdGlvbiAqPSB0aW1lc2NhbGU7XG4gICAgICAgIHZhciB1cHBlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICAgICAgdmFyIGxvd2VyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWRoZCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMSxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAyLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMyxcbiAgICAgICAgICAgICh0aW1lc2NhbGUgPj4gMjQpICYgMHhGRixcbiAgICAgICAgICAgICh0aW1lc2NhbGUgPj4gMTYpICYgMHhGRixcbiAgICAgICAgICAgICh0aW1lc2NhbGUgPj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgdGltZXNjYWxlICYgMHhGRixcbiAgICAgICAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAyNCksXG4gICAgICAgICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gMTYpICYgMHhGRixcbiAgICAgICAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICB1cHBlcldvcmREdXJhdGlvbiAmIDB4RkYsXG4gICAgICAgICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gMjQpLFxuICAgICAgICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDE2KSAmIDB4RkYsXG4gICAgICAgICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgbG93ZXJXb3JkRHVyYXRpb24gJiAweEZGLFxuICAgICAgICAgICAgMHg1NSwgMHhjNCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDBcbiAgICAgICAgXSkpO1xuICAgIH07XG4gICAgTVA0Lm1kaWEgPSBmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kaWEsIE1QNC5tZGhkKHRyYWNrLnRpbWVzY2FsZSwgdHJhY2suZHVyYXRpb24pLCBNUDQuaGRscih0cmFjay50eXBlKSwgTVA0Lm1pbmYodHJhY2spKTtcbiAgICB9O1xuICAgIE1QNC5tZmhkID0gZnVuY3Rpb24gKHNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZmhkLCBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIChzZXF1ZW5jZU51bWJlciA+PiAyNCksXG4gICAgICAgICAgICAoc2VxdWVuY2VOdW1iZXIgPj4gMTYpICYgMHhGRixcbiAgICAgICAgICAgIChzZXF1ZW5jZU51bWJlciA+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICBzZXF1ZW5jZU51bWJlciAmIDB4RkYgLy8gc2VxdWVuY2VfbnVtYmVyXG4gICAgICAgIF0pKTtcbiAgICB9O1xuICAgIE1QNC5taW5mID0gZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWluZiwgTVA0LmJveChNUDQudHlwZXMuc21oZCwgTVA0LlNNSEQpLCBNUDQuRElORiwgTVA0LnN0YmwodHJhY2spKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5taW5mLCBNUDQuYm94KE1QNC50eXBlcy52bWhkLCBNUDQuVk1IRCksIE1QNC5ESU5GLCBNUDQuc3RibCh0cmFjaykpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNUDQubW9vZiA9IGZ1bmN0aW9uIChzbiwgYmFzZU1lZGlhRGVjb2RlVGltZSwgdHJhY2spIHtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1vb2YsIE1QNC5tZmhkKHNuKSwgTVA0LnRyYWYodHJhY2ssIGJhc2VNZWRpYURlY29kZVRpbWUpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgKiBAcGFyYW0gdHJhY2tzLi4uIChvcHRpb25hbCkge2FycmF5fSB0aGUgdHJhY2tzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1vdmllXG4gICAqL1xuICAgIE1QNC5tb292ID0gZnVuY3Rpb24gKHRyYWNrcykge1xuICAgICAgICB2YXIgaSA9IHRyYWNrcy5sZW5ndGgsIGJveGVzID0gW107XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGJveGVzW2ldID0gTVA0LnRyYWsodHJhY2tzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTVA0LmJveC5hcHBseShudWxsLCBbTVA0LnR5cGVzLm1vb3YsIE1QNC5tdmhkKHRyYWNrc1swXS50aW1lc2NhbGUsIHRyYWNrc1swXS5kdXJhdGlvbildLmNvbmNhdChib3hlcykuY29uY2F0KE1QNC5tdmV4KHRyYWNrcykpKTtcbiAgICB9O1xuICAgIE1QNC5tdmV4ID0gZnVuY3Rpb24gKHRyYWNrcykge1xuICAgICAgICB2YXIgaSA9IHRyYWNrcy5sZW5ndGgsIGJveGVzID0gW107XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGJveGVzW2ldID0gTVA0LnRyZXgodHJhY2tzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTVA0LmJveC5hcHBseShudWxsLCBbTVA0LnR5cGVzLm12ZXhdLmNvbmNhdChib3hlcykpO1xuICAgIH07XG4gICAgTVA0Lm12aGQgPSBmdW5jdGlvbiAodGltZXNjYWxlLCBkdXJhdGlvbikge1xuICAgICAgICBkdXJhdGlvbiAqPSB0aW1lc2NhbGU7XG4gICAgICAgIHZhciB1cHBlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICAgICAgdmFyIGxvd2VyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgICAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAxLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAzLFxuICAgICAgICAgICAgKHRpbWVzY2FsZSA+PiAyNCkgJiAweEZGLFxuICAgICAgICAgICAgKHRpbWVzY2FsZSA+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgKHRpbWVzY2FsZSA+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICB0aW1lc2NhbGUgJiAweEZGLFxuICAgICAgICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDI0KSxcbiAgICAgICAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDgpICYgMHhGRixcbiAgICAgICAgICAgIHVwcGVyV29yZER1cmF0aW9uICYgMHhGRixcbiAgICAgICAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiAyNCksXG4gICAgICAgICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gMTYpICYgMHhGRixcbiAgICAgICAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICBsb3dlcldvcmREdXJhdGlvbiAmIDB4RkYsXG4gICAgICAgICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMSwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHg0MCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYgLy8gbmV4dF90cmFja19JRFxuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm12aGQsIGJ5dGVzKTtcbiAgICB9O1xuICAgIE1QNC5zZHRwID0gZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIHZhciBzYW1wbGVzID0gdHJhY2suc2FtcGxlcyB8fCBbXSwgYnl0ZXMgPSBuZXcgVWludDhBcnJheSg0ICsgc2FtcGxlcy5sZW5ndGgpLCBmbGFncywgaTtcbiAgICAgICAgLy8gbGVhdmUgdGhlIGZ1bGwgYm94IGhlYWRlciAoNCBieXRlcykgYWxsIHplcm9cbiAgICAgICAgLy8gd3JpdGUgdGhlIHNhbXBsZSB0YWJsZVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZmxhZ3MgPSBzYW1wbGVzW2ldLmZsYWdzO1xuICAgICAgICAgICAgYnl0ZXNbaSArIDRdID0gKGZsYWdzLmRlcGVuZHNPbiA8PCA0KSB8XG4gICAgICAgICAgICAgICAgKGZsYWdzLmlzRGVwZW5kZWRPbiA8PCAyKSB8XG4gICAgICAgICAgICAgICAgKGZsYWdzLmhhc1JlZHVuZGFuY3kpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zZHRwLCBieXRlcyk7XG4gICAgfTtcbiAgICBNUDQuc3RibCA9IGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RibCwgTVA0LnN0c2QodHJhY2spLCBNUDQuYm94KE1QNC50eXBlcy5zdHRzLCBNUDQuU1RUUyksIE1QNC5ib3goTVA0LnR5cGVzLnN0c2MsIE1QNC5TVFNDKSwgTVA0LmJveChNUDQudHlwZXMuc3RzeiwgTVA0LlNUU1opLCBNUDQuYm94KE1QNC50eXBlcy5zdGNvLCBNUDQuU1RDTykpO1xuICAgIH07XG4gICAgTVA0LmF2YzEgPSBmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgdmFyIHNwcyA9IFtdLCBwcHMgPSBbXSwgaSwgZGF0YSwgbGVuO1xuICAgICAgICAvLyBhc3NlbWJsZSB0aGUgU1BTc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdHJhY2suc3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkYXRhID0gdHJhY2suc3BzW2ldO1xuICAgICAgICAgICAgbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgc3BzLnB1c2goKGxlbiA+Pj4gOCkgJiAweEZGKTtcbiAgICAgICAgICAgIHNwcy5wdXNoKChsZW4gJiAweEZGKSk7XG4gICAgICAgICAgICAvLyBTUFNcbiAgICAgICAgICAgIHNwcyA9IHNwcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFzc2VtYmxlIHRoZSBQUFNzXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0cmFjay5wcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRhdGEgPSB0cmFjay5wcHNbaV07XG4gICAgICAgICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBwcHMucHVzaCgobGVuID4+PiA4KSAmIDB4RkYpO1xuICAgICAgICAgICAgcHBzLnB1c2goKGxlbiAmIDB4RkYpKTtcbiAgICAgICAgICAgIHBwcyA9IHBwcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdmNjID0gTVA0LmJveChNUDQudHlwZXMuYXZjQywgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMSxcbiAgICAgICAgICAgIHNwc1szXSxcbiAgICAgICAgICAgIHNwc1s0XSxcbiAgICAgICAgICAgIHNwc1s1XSxcbiAgICAgICAgICAgIDB4ZmMgfCAzLFxuICAgICAgICAgICAgMHhFMCB8IHRyYWNrLnNwcy5sZW5ndGggLy8gM2JpdCByZXNlcnZlZCAoMTExKSArIG51bU9mU2VxdWVuY2VQYXJhbWV0ZXJTZXRzXG4gICAgICAgIF0uY29uY2F0KHNwcykuY29uY2F0KFtcbiAgICAgICAgICAgIHRyYWNrLnBwcy5sZW5ndGggLy8gbnVtT2ZQaWN0dXJlUGFyYW1ldGVyU2V0c1xuICAgICAgICBdKS5jb25jYXQocHBzKSkpLCAvLyBcIlBQU1wiXG4gICAgICAgIHdpZHRoID0gdHJhY2sud2lkdGgsIGhlaWdodCA9IHRyYWNrLmhlaWdodCwgaFNwYWNpbmcgPSB0cmFjay5waXhlbFJhdGlvWzBdLCB2U3BhY2luZyA9IHRyYWNrLnBpeGVsUmF0aW9bMV07XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5hdmMxLCBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDEsXG4gICAgICAgICAgICAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgICh3aWR0aCA+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICB3aWR0aCAmIDB4ZmYsXG4gICAgICAgICAgICAoaGVpZ2h0ID4+IDgpICYgMHhGRixcbiAgICAgICAgICAgIGhlaWdodCAmIDB4ZmYsXG4gICAgICAgICAgICAweDAwLCAweDQ4LCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHg0OCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAxLFxuICAgICAgICAgICAgMHgxMixcbiAgICAgICAgICAgIDB4NjQsIDB4NjEsIDB4NjksIDB4NkMsXG4gICAgICAgICAgICAweDc5LCAweDZELCAweDZGLCAweDc0LFxuICAgICAgICAgICAgMHg2OSwgMHg2RiwgMHg2RSwgMHgyRixcbiAgICAgICAgICAgIDB4NjgsIDB4NkMsIDB4NzMsIDB4MkUsXG4gICAgICAgICAgICAweDZBLCAweDczLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgxOCxcbiAgICAgICAgICAgIDB4MTEsIDB4MTFcbiAgICAgICAgXSksIC8vIHByZV9kZWZpbmVkID0gLTFcbiAgICAgICAgYXZjYywgTVA0LmJveChNUDQudHlwZXMuYnRydCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMCwgMHgxYywgMHg5YywgMHg4MCxcbiAgICAgICAgICAgIDB4MDAsIDB4MmQsIDB4YzYsIDB4YzAsXG4gICAgICAgICAgICAweDAwLCAweDJkLCAweGM2LCAweGMwXG4gICAgICAgIF0pKSwgLy8gYXZnQml0cmF0ZVxuICAgICAgICBNUDQuYm94KE1QNC50eXBlcy5wYXNwLCBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAoaFNwYWNpbmcgPj4gMjQpLFxuICAgICAgICAgICAgKGhTcGFjaW5nID4+IDE2KSAmIDB4RkYsXG4gICAgICAgICAgICAoaFNwYWNpbmcgPj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgaFNwYWNpbmcgJiAweEZGLFxuICAgICAgICAgICAgKHZTcGFjaW5nID4+IDI0KSxcbiAgICAgICAgICAgICh2U3BhY2luZyA+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgKHZTcGFjaW5nID4+IDgpICYgMHhGRixcbiAgICAgICAgICAgIHZTcGFjaW5nICYgMHhGRlxuICAgICAgICBdKSkpO1xuICAgIH07XG4gICAgTVA0LmVzZHMgPSBmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgdmFyIGNvbmZpZ2xlbiA9IHRyYWNrLmNvbmZpZy5sZW5ndGg7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDMsXG4gICAgICAgICAgICAweDE3ICsgY29uZmlnbGVuLFxuICAgICAgICAgICAgMHgwMCwgMHgwMSxcbiAgICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgICAweDA0LFxuICAgICAgICAgICAgMHgwZiArIGNvbmZpZ2xlbixcbiAgICAgICAgICAgIDB4NDAsXG4gICAgICAgICAgICAweDE1LFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwNSAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAgICAgXS5jb25jYXQoW2NvbmZpZ2xlbl0pLmNvbmNhdCh0cmFjay5jb25maWcpLmNvbmNhdChbMHgwNiwgMHgwMSwgMHgwMl0pKTsgLy8gR0FTcGVjaWZpY0NvbmZpZykpOyAvLyBsZW5ndGggKyBhdWRpbyBjb25maWcgZGVzY3JpcHRvclxuICAgIH07XG4gICAgTVA0Lm1wNGEgPSBmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgdmFyIHNhbXBsZXJhdGUgPSB0cmFjay5zYW1wbGVyYXRlO1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubXA0YSwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAxLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCB0cmFjay5jaGFubmVsQ291bnQsXG4gICAgICAgICAgICAweDAwLCAweDEwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIChzYW1wbGVyYXRlID4+IDgpICYgMHhGRixcbiAgICAgICAgICAgIHNhbXBsZXJhdGUgJiAweGZmLFxuICAgICAgICAgICAgMHgwMCwgMHgwMFxuICAgICAgICBdKSwgTVA0LmJveChNUDQudHlwZXMuZXNkcywgTVA0LmVzZHModHJhY2spKSk7XG4gICAgfTtcbiAgICBNUDQubXAzID0gZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIHZhciBzYW1wbGVyYXRlID0gdHJhY2suc2FtcGxlcmF0ZTtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzWycubXAzJ10sIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMSxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgdHJhY2suY2hhbm5lbENvdW50LFxuICAgICAgICAgICAgMHgwMCwgMHgxMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAoc2FtcGxlcmF0ZSA+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICBzYW1wbGVyYXRlICYgMHhmZixcbiAgICAgICAgICAgIDB4MDAsIDB4MDBcbiAgICAgICAgXSkpO1xuICAgIH07XG4gICAgTVA0LnN0c2QgPSBmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgaWYgKHRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgIGlmICghdHJhY2suaXNBQUMgJiYgdHJhY2suY29kZWMgPT09ICdtcDMnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQubXAzKHRyYWNrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5tcDRhKHRyYWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5hdmMxKHRyYWNrKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1QNC50a2hkID0gZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIHZhciBpZCA9IHRyYWNrLmlkLCBkdXJhdGlvbiA9IHRyYWNrLmR1cmF0aW9uICogdHJhY2sudGltZXNjYWxlLCB3aWR0aCA9IHRyYWNrLndpZHRoLCBoZWlnaHQgPSB0cmFjay5oZWlnaHQsIHVwcGVyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAvIChVSU5UMzJfTUFYICsgMSkpLCBsb3dlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gJSAoVUlOVDMyX01BWCArIDEpKTtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRraGQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDEsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDA3LFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMixcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsXG4gICAgICAgICAgICAoaWQgPj4gMjQpICYgMHhGRixcbiAgICAgICAgICAgIChpZCA+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgKGlkID4+IDgpICYgMHhGRixcbiAgICAgICAgICAgIGlkICYgMHhGRixcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gMjQpLFxuICAgICAgICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDE2KSAmIDB4RkYsXG4gICAgICAgICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgdXBwZXJXb3JkRHVyYXRpb24gJiAweEZGLFxuICAgICAgICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDI0KSxcbiAgICAgICAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDgpICYgMHhGRixcbiAgICAgICAgICAgIGxvd2VyV29yZER1cmF0aW9uICYgMHhGRixcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHg0MCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgICh3aWR0aCA+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICB3aWR0aCAmIDB4RkYsXG4gICAgICAgICAgICAweDAwLCAweDAwLFxuICAgICAgICAgICAgKGhlaWdodCA+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICBoZWlnaHQgJiAweEZGLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCAvLyBoZWlnaHRcbiAgICAgICAgXSkpO1xuICAgIH07XG4gICAgTVA0LnRyYWYgPSBmdW5jdGlvbiAodHJhY2ssIGJhc2VNZWRpYURlY29kZVRpbWUpIHtcbiAgICAgICAgdmFyIHNhbXBsZURlcGVuZGVuY3lUYWJsZSA9IE1QNC5zZHRwKHRyYWNrKSwgaWQgPSB0cmFjay5pZCwgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAvIChVSU5UMzJfTUFYICsgMSkpLCBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmFmLCBNUDQuYm94KE1QNC50eXBlcy50ZmhkLCBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIChpZCA+PiAyNCksXG4gICAgICAgICAgICAoaWQgPj4gMTYpICYgMFhGRixcbiAgICAgICAgICAgIChpZCA+PiA4KSAmIDBYRkYsXG4gICAgICAgICAgICAoaWQgJiAweEZGKSAvLyB0cmFja19JRFxuICAgICAgICBdKSksIE1QNC5ib3goTVA0LnR5cGVzLnRmZHQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDEsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgKHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMjQpLFxuICAgICAgICAgICAgKHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMTYpICYgMFhGRixcbiAgICAgICAgICAgICh1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDgpICYgMFhGRixcbiAgICAgICAgICAgICh1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lICYgMHhGRiksXG4gICAgICAgICAgICAobG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAyNCksXG4gICAgICAgICAgICAobG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAxNikgJiAwWEZGLFxuICAgICAgICAgICAgKGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gOCkgJiAwWEZGLFxuICAgICAgICAgICAgKGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgJiAweEZGKVxuICAgICAgICBdKSksIE1QNC50cnVuKHRyYWNrLCBzYW1wbGVEZXBlbmRlbmN5VGFibGUubGVuZ3RoICtcbiAgICAgICAgICAgIDE2ICsgLy8gdGZoZFxuICAgICAgICAgICAgMjAgKyAvLyB0ZmR0XG4gICAgICAgICAgICA4ICsgLy8gdHJhZiBoZWFkZXJcbiAgICAgICAgICAgIDE2ICsgLy8gbWZoZFxuICAgICAgICAgICAgOCArIC8vIG1vb2YgaGVhZGVyXG4gICAgICAgICAgICA4KSwgLy8gbWRhdCBoZWFkZXJcbiAgICAgICAgc2FtcGxlRGVwZW5kZW5jeVRhYmxlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgdHJhY2sgYm94LlxuICAgICAqIEBwYXJhbSB0cmFjayB7b2JqZWN0fSBhIHRyYWNrIGRlZmluaXRpb25cbiAgICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fSB0aGUgdHJhY2sgYm94XG4gICAgICovXG4gICAgTVA0LnRyYWsgPSBmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgdHJhY2suZHVyYXRpb24gPSB0cmFjay5kdXJhdGlvbiB8fCAweGZmZmZmZmZmO1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJhaywgTVA0LnRraGQodHJhY2spLCBNUDQubWRpYSh0cmFjaykpO1xuICAgIH07XG4gICAgTVA0LnRyZXggPSBmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgdmFyIGlkID0gdHJhY2suaWQ7XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmV4LCBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIChpZCA+PiAyNCksXG4gICAgICAgICAgICAoaWQgPj4gMTYpICYgMFhGRixcbiAgICAgICAgICAgIChpZCA+PiA4KSAmIDBYRkYsXG4gICAgICAgICAgICAoaWQgJiAweEZGKSxcbiAgICAgICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsXG4gICAgICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDEgLy8gZGVmYXVsdF9zYW1wbGVfZmxhZ3NcbiAgICAgICAgXSkpO1xuICAgIH07XG4gICAgTVA0LnRydW4gPSBmdW5jdGlvbiAodHJhY2ssIG9mZnNldCkge1xuICAgICAgICB2YXIgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXMgfHwgW10sIGxlbiA9IHNhbXBsZXMubGVuZ3RoLCBhcnJheWxlbiA9IDEyICsgKDE2ICogbGVuKSwgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheWxlbiksIGksIHNhbXBsZSwgZHVyYXRpb24sIHNpemUsIGZsYWdzLCBjdHM7XG4gICAgICAgIG9mZnNldCArPSA4ICsgYXJyYXlsZW47XG4gICAgICAgIGFycmF5LnNldChbXG4gICAgICAgICAgICAweDAwLFxuICAgICAgICAgICAgMHgwMCwgMHgwZiwgMHgwMSxcbiAgICAgICAgICAgIChsZW4gPj4+IDI0KSAmIDB4RkYsXG4gICAgICAgICAgICAobGVuID4+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgKGxlbiA+Pj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgbGVuICYgMHhGRixcbiAgICAgICAgICAgIChvZmZzZXQgPj4+IDI0KSAmIDB4RkYsXG4gICAgICAgICAgICAob2Zmc2V0ID4+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgKG9mZnNldCA+Pj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgb2Zmc2V0ICYgMHhGRiAvLyBkYXRhX29mZnNldFxuICAgICAgICBdLCAwKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBzYW1wbGUgPSBzYW1wbGVzW2ldO1xuICAgICAgICAgICAgZHVyYXRpb24gPSBzYW1wbGUuZHVyYXRpb247XG4gICAgICAgICAgICBzaXplID0gc2FtcGxlLnNpemU7XG4gICAgICAgICAgICBmbGFncyA9IHNhbXBsZS5mbGFncztcbiAgICAgICAgICAgIGN0cyA9IHNhbXBsZS5jdHM7XG4gICAgICAgICAgICBhcnJheS5zZXQoW1xuICAgICAgICAgICAgICAgIChkdXJhdGlvbiA+Pj4gMjQpICYgMHhGRixcbiAgICAgICAgICAgICAgICAoZHVyYXRpb24gPj4+IDE2KSAmIDB4RkYsXG4gICAgICAgICAgICAgICAgKGR1cmF0aW9uID4+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICAgICAgZHVyYXRpb24gJiAweEZGLFxuICAgICAgICAgICAgICAgIChzaXplID4+PiAyNCkgJiAweEZGLFxuICAgICAgICAgICAgICAgIChzaXplID4+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgICAgIChzaXplID4+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICAgICAgc2l6ZSAmIDB4RkYsXG4gICAgICAgICAgICAgICAgKGZsYWdzLmlzTGVhZGluZyA8PCAyKSB8IGZsYWdzLmRlcGVuZHNPbixcbiAgICAgICAgICAgICAgICAoZmxhZ3MuaXNEZXBlbmRlZE9uIDw8IDYpIHxcbiAgICAgICAgICAgICAgICAgICAgKGZsYWdzLmhhc1JlZHVuZGFuY3kgPDwgNCkgfFxuICAgICAgICAgICAgICAgICAgICAoZmxhZ3MucGFkZGluZ1ZhbHVlIDw8IDEpIHxcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuaXNOb25TeW5jLFxuICAgICAgICAgICAgICAgIGZsYWdzLmRlZ3JhZFByaW8gJiAweEYwIDw8IDgsXG4gICAgICAgICAgICAgICAgZmxhZ3MuZGVncmFkUHJpbyAmIDB4MEYsXG4gICAgICAgICAgICAgICAgKGN0cyA+Pj4gMjQpICYgMHhGRixcbiAgICAgICAgICAgICAgICAoY3RzID4+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgICAgIChjdHMgPj4+IDgpICYgMHhGRixcbiAgICAgICAgICAgICAgICBjdHMgJiAweEZGIC8vIHNhbXBsZV9jb21wb3NpdGlvbl90aW1lX29mZnNldFxuICAgICAgICAgICAgXSwgMTIgKyAxNiAqIGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cnVuLCBhcnJheSk7XG4gICAgfTtcbiAgICBNUDQuaW5pdFNlZ21lbnQgPSBmdW5jdGlvbiAodHJhY2tzKSB7XG4gICAgICAgIGlmICghTVA0LnR5cGVzKSB7XG4gICAgICAgICAgICBNUDQuaW5pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtb3ZpZSA9IE1QNC5tb292KHRyYWNrcyksIHJlc3VsdDtcbiAgICAgICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoTVA0LkZUWVAuYnl0ZUxlbmd0aCArIG1vdmllLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXN1bHQuc2V0KE1QNC5GVFlQKTtcbiAgICAgICAgcmVzdWx0LnNldChtb3ZpZSwgTVA0LkZUWVAuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gTVA0O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IE1QNDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9yZW11eC9tcDQtcmVtdXhlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9yZW11eC9tcDQtcmVtdXhlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBmTVA0IHJlbXV4ZXJcbiovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYWFjX2hlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9hYWMtaGVscGVyICovIFwiLi9zcmMvcmVtdXgvYWFjLWhlbHBlci5qc1wiKTtcbnZhciBtcDRfZ2VuZXJhdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21wNC1nZW5lcmF0b3IgKi8gXCIuL3NyYy9yZW11eC9tcDQtZ2VuZXJhdG9yLmpzXCIpO1xudmFyIGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLmpzXCIpO1xudmFyIGVycm9yc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLmpzXCIpO1xudmFyIGxvZ2dlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLmpzXCIpO1xuLy8gMTAgc2Vjb25kc1xudmFyIE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gPSAxMCAqIDEwMDA7XG52YXIgTVA0UmVtdXhlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNUDRSZW11eGVyKG9ic2VydmVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQsIHZlbmRvcikge1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB0eXBlU3VwcG9ydGVkO1xuICAgICAgICB2YXIgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICAgICAgdGhpcy5pc1NhZmFyaSA9IHZlbmRvciAmJiB2ZW5kb3IuaW5kZXhPZignQXBwbGUnKSA+IC0xICYmIHVzZXJBZ2VudCAmJiAhdXNlckFnZW50Lm1hdGNoKCdDcmlPUycpO1xuICAgICAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XG4gICAgfVxuICAgIE1QNFJlbXV4ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgfTtcbiAgICBNUDRSZW11eGVyLnByb3RvdHlwZS5yZXNldFRpbWVTdGFtcCA9IGZ1bmN0aW9uIChkZWZhdWx0VGltZVN0YW1wKSB7XG4gICAgICAgIHRoaXMuX2luaXRQVFMgPSB0aGlzLl9pbml0RFRTID0gZGVmYXVsdFRpbWVTdGFtcDtcbiAgICB9O1xuICAgIE1QNFJlbXV4ZXIucHJvdG90eXBlLnJlc2V0SW5pdFNlZ21lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIE1QNFJlbXV4ZXIucHJvdG90eXBlLnJlbXV4ID0gZnVuY3Rpb24gKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgICAgICAvLyBnZW5lcmF0ZSBJbml0IFNlZ21lbnQgaWYgbmVlZGVkXG4gICAgICAgIGlmICghdGhpcy5JU0dlbmVyYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLklTR2VuZXJhdGVkKSB7XG4gICAgICAgICAgICB2YXIgbmJBdWRpb1NhbXBsZXMgPSBhdWRpb1RyYWNrLnNhbXBsZXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIG5iVmlkZW9TYW1wbGVzID0gdmlkZW9UcmFjay5zYW1wbGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBhdWRpb1RpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuICAgICAgICAgICAgdmFyIHZpZGVvVGltZU9mZnNldCA9IHRpbWVPZmZzZXQ7XG4gICAgICAgICAgICBpZiAobmJBdWRpb1NhbXBsZXMgJiYgbmJWaWRlb1NhbXBsZXMpIHtcbiAgICAgICAgICAgICAgICAvLyB0aW1lT2Zmc2V0IGlzIGV4cGVjdGVkIHRvIGJlIHRoZSBvZmZzZXQgb2YgdGhlIGZpcnN0IHRpbWVzdGFtcCBvZiB0aGlzIGZyYWdtZW50IChmaXJzdCBEVFMpXG4gICAgICAgICAgICAgICAgLy8gaWYgZmlyc3QgYXVkaW8gRFRTIGlzIG5vdCBhbGlnbmVkIHdpdGggZmlyc3QgdmlkZW8gRFRTIHRoZW4gd2UgbmVlZCB0byB0YWtlIHRoYXQgaW50byBhY2NvdW50XG4gICAgICAgICAgICAgICAgLy8gd2hlbiBwcm92aWRpbmcgdGltZU9mZnNldCB0byByZW11eEF1ZGlvIC8gcmVtdXhWaWRlby4gaWYgd2UgZG9uJ3QgZG8gdGhhdCwgdGhlcmUgbWlnaHQgYmUgYSBwZXJtYW5lbnQgLyBzbWFsbFxuICAgICAgICAgICAgICAgIC8vIGRyaWZ0IGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvIHN0cmVhbXNcbiAgICAgICAgICAgICAgICB2YXIgYXVkaW92aWRlb0RlbHRhRHRzID0gKGF1ZGlvVHJhY2suc2FtcGxlc1swXS5wdHMgLSB2aWRlb1RyYWNrLnNhbXBsZXNbMF0ucHRzKSAvIHZpZGVvVHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgICAgICAgICAgYXVkaW9UaW1lT2Zmc2V0ICs9IE1hdGgubWF4KDAsIGF1ZGlvdmlkZW9EZWx0YUR0cyk7XG4gICAgICAgICAgICAgICAgdmlkZW9UaW1lT2Zmc2V0ICs9IE1hdGgubWF4KDAsIC1hdWRpb3ZpZGVvRGVsdGFEdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHVycG9zZWZ1bGx5IHJlbXV4aW5nIGF1ZGlvIGJlZm9yZSB2aWRlbywgc28gdGhhdCByZW11eFZpZGVvIGNhbiB1c2UgbmV4dEF1ZGlvUHRzLCB3aGljaCBpc1xuICAgICAgICAgICAgLy8gY2FsY3VsYXRlZCBpbiByZW11eEF1ZGlvLlxuICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZygnbmIgQUFDIHNhbXBsZXM6JyArIGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKG5iQXVkaW9TYW1wbGVzKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgaW5pdFNlZ21lbnQgd2FzIGdlbmVyYXRlZCB3aXRob3V0IHZpZGVvIHNhbXBsZXMsIHJlZ2VuZXJhdGUgaXQgYWdhaW5cbiAgICAgICAgICAgICAgICBpZiAoIWF1ZGlvVHJhY2sudGltZXNjYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKCdyZWdlbmVyYXRlIEluaXRTZWdtZW50IGFzIGF1ZGlvIGRldGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVJUyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGF1ZGlvRGF0YSA9IHRoaXMucmVtdXhBdWRpbyhhdWRpb1RyYWNrLCBhdWRpb1RpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZygnbmIgQVZDIHNhbXBsZXM6JyArIHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChuYlZpZGVvU2FtcGxlcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXVkaW9UcmFja0xlbmd0aCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF1ZGlvRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9UcmFja0xlbmd0aCA9IGF1ZGlvRGF0YS5lbmRQVFMgLSBhdWRpb0RhdGEuc3RhcnRQVFM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaW5pdFNlZ21lbnQgd2FzIGdlbmVyYXRlZCB3aXRob3V0IHZpZGVvIHNhbXBsZXMsIHJlZ2VuZXJhdGUgaXQgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2aWRlb1RyYWNrLnRpbWVzY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oJ3JlZ2VuZXJhdGUgSW5pdFNlZ21lbnQgYXMgdmlkZW8gZGV0ZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVJUyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbXV4VmlkZW8odmlkZW9UcmFjaywgdmlkZW9UaW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhdWRpb1RyYWNrTGVuZ3RoLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ25iIEFWQyBzYW1wbGVzOicgKyB2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAobmJWaWRlb1NhbXBsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZpZGVvRGF0YSA9IHRoaXMucmVtdXhWaWRlbyh2aWRlb1RyYWNrLCB2aWRlb1RpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIDAsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aWRlb0RhdGEgJiYgYXVkaW9UcmFjay5jb2RlYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW11eEVtcHR5QXVkaW8oYXVkaW9UcmFjaywgYXVkaW9UaW1lT2Zmc2V0LCBjb250aWd1b3VzLCB2aWRlb0RhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ25iIElEMyBzYW1wbGVzOicgKyBhdWRpb1RyYWNrLnNhbXBsZXMubGVuZ3RoKTtcbiAgICAgICAgaWYgKGlkM1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnJlbXV4SUQzKGlkM1RyYWNrLCB0aW1lT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb2dnZXIubG9nKCduYiBJRDMgc2FtcGxlczonICsgYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aCk7XG4gICAgICAgIGlmICh0ZXh0VHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucmVtdXhUZXh0KHRleHRUcmFjaywgdGltZU9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm90aWZ5IGVuZCBvZiBwYXJzaW5nXG4gICAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkZSQUdfUEFSU0VEKTtcbiAgICB9O1xuICAgIE1QNFJlbXV4ZXIucHJvdG90eXBlLmdlbmVyYXRlSVMgPSBmdW5jdGlvbiAoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCkge1xuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyLCBhdWRpb1NhbXBsZXMgPSBhdWRpb1RyYWNrLnNhbXBsZXMsIHZpZGVvU2FtcGxlcyA9IHZpZGVvVHJhY2suc2FtcGxlcywgdHlwZVN1cHBvcnRlZCA9IHRoaXMudHlwZVN1cHBvcnRlZCwgY29udGFpbmVyID0gJ2F1ZGlvL21wNCcsIHRyYWNrcyA9IHt9LCBkYXRhID0geyB0cmFja3M6IHRyYWNrcyB9LCBjb21wdXRlUFRTRFRTID0gKHRoaXMuX2luaXRQVFMgPT09IHVuZGVmaW5lZCksIGluaXRQVFMsIGluaXREVFM7XG4gICAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgICAgICBpbml0UFRTID0gaW5pdERUUyA9IEluZmluaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdWRpb1RyYWNrLmNvbmZpZyAmJiBhdWRpb1NhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBsZXQncyB1c2UgYXVkaW8gc2FtcGxpbmcgcmF0ZSBhcyBNUDQgdGltZSBzY2FsZS5cbiAgICAgICAgICAgIC8vIHJhdGlvbmFsZSBpcyB0aGF0IHRoZXJlIGlzIGEgaW50ZWdlciBuYiBvZiBhdWRpbyBmcmFtZXMgcGVyIGF1ZGlvIHNhbXBsZSAoMTAyNCBmb3IgQUFDKVxuICAgICAgICAgICAgLy8gdXNpbmcgYXVkaW8gc2FtcGxpbmcgcmF0ZSBoZXJlIGhlbHBzIGhhdmluZyBhbiBpbnRlZ2VyIE1QNCBmcmFtZSBkdXJhdGlvblxuICAgICAgICAgICAgLy8gdGhpcyBhdm9pZHMgcG90ZW50aWFsIHJvdW5kaW5nIGlzc3VlIGFuZCBBViBzeW5jIGlzc3VlXG4gICAgICAgICAgICBhdWRpb1RyYWNrLnRpbWVzY2FsZSA9IGF1ZGlvVHJhY2suc2FtcGxlcmF0ZTtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJhdWRpbyBzYW1wbGluZyByYXRlIDogXCIgKyBhdWRpb1RyYWNrLnNhbXBsZXJhdGUpO1xuICAgICAgICAgICAgaWYgKCFhdWRpb1RyYWNrLmlzQUFDKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVTdXBwb3J0ZWQubXBlZykgeyAvLyBDaHJvbWUgYW5kIFNhZmFyaVxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIgPSAnYXVkaW8vbXBlZyc7XG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvVHJhY2suY29kZWMgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZVN1cHBvcnRlZC5tcDMpIHsgLy8gRmlyZWZveFxuICAgICAgICAgICAgICAgICAgICBhdWRpb1RyYWNrLmNvZGVjID0gJ21wMyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2tzLmF1ZGlvID0ge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICAgICAgICAgIGNvZGVjOiBhdWRpb1RyYWNrLmNvZGVjLFxuICAgICAgICAgICAgICAgIGluaXRTZWdtZW50OiAhYXVkaW9UcmFjay5pc0FBQyAmJiB0eXBlU3VwcG9ydGVkLm1wZWcgPyBuZXcgVWludDhBcnJheSgpIDogbXA0X2dlbmVyYXRvcl8xLmRlZmF1bHQuaW5pdFNlZ21lbnQoW2F1ZGlvVHJhY2tdKSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnQ6IGF1ZGlvVHJhY2suY2hhbm5lbENvdW50XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtZW1iZXIgZmlyc3QgUFRTIG9mIHRoaXMgZGVtdXhpbmcgY29udGV4dC4gZm9yIGF1ZGlvLCBQVFMgPSBEVFNcbiAgICAgICAgICAgICAgICBpbml0UFRTID0gaW5pdERUUyA9IGF1ZGlvU2FtcGxlc1swXS5wdHMgLSBhdWRpb1RyYWNrLmlucHV0VGltZVNjYWxlICogdGltZU9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmlkZW9UcmFjay5zcHMgJiYgdmlkZW9UcmFjay5wcHMgJiYgdmlkZW9TYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gbGV0J3MgdXNlIGlucHV0IHRpbWUgc2NhbGUgYXMgTVA0IHZpZGVvIHRpbWVzY2FsZVxuICAgICAgICAgICAgLy8gd2UgdXNlIGlucHV0IHRpbWUgc2NhbGUgc3RyYWlnaHQgYXdheSB0byBhdm9pZCByb3VuZGluZyBpc3N1ZXMgb24gZnJhbWUgZHVyYXRpb24gLyBjdHMgY29tcHV0YXRpb25cbiAgICAgICAgICAgIHZhciBpbnB1dFRpbWVTY2FsZSA9IHZpZGVvVHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgICAgICB2aWRlb1RyYWNrLnRpbWVzY2FsZSA9IGlucHV0VGltZVNjYWxlO1xuICAgICAgICAgICAgdHJhY2tzLnZpZGVvID0ge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogJ3ZpZGVvL21wNCcsXG4gICAgICAgICAgICAgICAgY29kZWM6IHZpZGVvVHJhY2suY29kZWMsXG4gICAgICAgICAgICAgICAgaW5pdFNlZ21lbnQ6IG1wNF9nZW5lcmF0b3JfMS5kZWZhdWx0LmluaXRTZWdtZW50KFt2aWRlb1RyYWNrXSksXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHZpZGVvVHJhY2sud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogdmlkZW9UcmFjay5oZWlnaHRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgICAgICAgICAgICBpbml0UFRTID0gTWF0aC5taW4oaW5pdFBUUywgdmlkZW9TYW1wbGVzWzBdLnB0cyAtIGlucHV0VGltZVNjYWxlICogdGltZU9mZnNldCk7XG4gICAgICAgICAgICAgICAgaW5pdERUUyA9IE1hdGgubWluKGluaXREVFMsIHZpZGVvU2FtcGxlc1swXS5kdHMgLSBpbnB1dFRpbWVTY2FsZSAqIHRpbWVPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LklOSVRfUFRTX0ZPVU5ELCB7IGluaXRQVFM6IGluaXRQVFMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRyYWNrcykubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYnNlcnZlci50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCwgZGF0YSk7XG4gICAgICAgICAgICB0aGlzLklTR2VuZXJhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdFBUUyA9IGluaXRQVFM7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdERUUyA9IGluaXREVFM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYnNlcnZlci50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogZXJyb3JzXzEuRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogZXJyb3JzXzEuRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUiwgZmF0YWw6IGZhbHNlLCByZWFzb246ICdubyBhdWRpby92aWRlbyBzYW1wbGVzIGZvdW5kJyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTVA0UmVtdXhlci5wcm90b3R5cGUucmVtdXhWaWRlbyA9IGZ1bmN0aW9uICh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYXVkaW9UcmFja0xlbmd0aCwgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSA4O1xuICAgICAgICB2YXIgbXA0U2FtcGxlRHVyYXRpb247XG4gICAgICAgIHZhciBtZGF0O1xuICAgICAgICB2YXIgbW9vZjtcbiAgICAgICAgdmFyIGZpcnN0UFRTO1xuICAgICAgICB2YXIgZmlyc3REVFM7XG4gICAgICAgIHZhciBsYXN0UFRTO1xuICAgICAgICB2YXIgbGFzdERUUztcbiAgICAgICAgdmFyIHRpbWVTY2FsZSA9IHRyYWNrLnRpbWVzY2FsZTtcbiAgICAgICAgdmFyIGlucHV0U2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XG4gICAgICAgIHZhciBvdXRwdXRTYW1wbGVzID0gW107XG4gICAgICAgIHZhciBuYlNhbXBsZXMgPSBpbnB1dFNhbXBsZXMubGVuZ3RoO1xuICAgICAgICB2YXIgcHRzTm9ybWFsaXplID0gdGhpcy5fUFRTTm9ybWFsaXplO1xuICAgICAgICB2YXIgaW5pdFBUUyA9IHRoaXMuX2luaXRQVFM7XG4gICAgICAgIC8vIGlmIHBhcnNlZCBmcmFnbWVudCBpcyBjb250aWd1b3VzIHdpdGggbGFzdCBvbmUsIGxldCdzIHVzZSBsYXN0IERUUyB2YWx1ZSBhcyByZWZlcmVuY2VcbiAgICAgICAgdmFyIG5leHRBdmNEdHMgPSB0aGlzLm5leHRBdmNEdHM7XG4gICAgICAgIHZhciBpc1NhZmFyaSA9IHRoaXMuaXNTYWZhcmk7XG4gICAgICAgIGlmIChuYlNhbXBsZXMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTYWZhcmkgZG9lcyBub3QgbGlrZSBvdmVybGFwcGluZyBEVFMgb24gY29uc2VjdXRpdmUgZnJhZ21lbnRzLiBsZXQncyB1c2UgbmV4dEF2Y0R0cyB0byBvdmVyY29tZSB0aGlzIGlmIGZyYWdtZW50cyBhcmUgY29uc2VjdXRpdmVcbiAgICAgICAgaWYgKGlzU2FmYXJpKSB7XG4gICAgICAgICAgICAvLyBhbHNvIGNvbnNpZGVyIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBhcyBiZWluZyBjb250aWd1b3VzIChldmVuIGlmIGEgbGV2ZWwgc3dpdGNoIG9jY3VycyksXG4gICAgICAgICAgICAvLyBmb3Igc2FrZSBvZiBjbGFyaXR5OlxuICAgICAgICAgICAgLy8gY29uc2VjdXRpdmUgZnJhZ21lbnRzIGFyZSBmcmFncyB3aXRoXG4gICAgICAgICAgICAvLyAgLSBsZXNzIHRoYW4gMTAwbXMgZ2FwcyBiZXR3ZWVuIG5ldyB0aW1lIG9mZnNldCAoaWYgYWNjdXJhdGUpIGFuZCBuZXh0IGV4cGVjdGVkIFBUUyBPUlxuICAgICAgICAgICAgLy8gIC0gbGVzcyB0aGFuIDIwMCBtcyBQVFMgZ2FwcyAodGltZVNjYWxlLzUpXG4gICAgICAgICAgICBjb250aWd1b3VzIHw9IChpbnB1dFNhbXBsZXMubGVuZ3RoICYmIG5leHRBdmNEdHMgJiZcbiAgICAgICAgICAgICAgICAoKGFjY3VyYXRlVGltZU9mZnNldCAmJiBNYXRoLmFicyh0aW1lT2Zmc2V0IC0gbmV4dEF2Y0R0cyAvIHRpbWVTY2FsZSkgPCAwLjEpIHx8XG4gICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKChpbnB1dFNhbXBsZXNbMF0ucHRzIC0gbmV4dEF2Y0R0cyAtIGluaXRQVFMpKSA8IHRpbWVTY2FsZSAvIDUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnRpZ3VvdXMpIHtcbiAgICAgICAgICAgIC8vIGlmIG5vdCBjb250aWd1b3VzLCBsZXQncyB1c2UgdGFyZ2V0IHRpbWVPZmZzZXRcbiAgICAgICAgICAgIG5leHRBdmNEdHMgPSB0aW1lT2Zmc2V0ICogdGltZVNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBUUyBpcyBjb2RlZCBvbiAzM2JpdHMsIGFuZCBjYW4gbG9vcCBmcm9tIC0yXjMyIHRvIDJeMzJcbiAgICAgICAgLy8gcHRzTm9ybWFsaXplIHdpbGwgbWFrZSBQVFMvRFRTIHZhbHVlIG1vbm90b25pYywgd2UgdXNlIGxhc3Qga25vd24gRFRTIHZhbHVlIGFzIHJlZmVyZW5jZSB2YWx1ZVxuICAgICAgICBpbnB1dFNhbXBsZXMuZm9yRWFjaChmdW5jdGlvbiAoc2FtcGxlKSB7XG4gICAgICAgICAgICBzYW1wbGUucHRzID0gcHRzTm9ybWFsaXplKHNhbXBsZS5wdHMgLSBpbml0UFRTLCBuZXh0QXZjRHRzKTtcbiAgICAgICAgICAgIHNhbXBsZS5kdHMgPSBwdHNOb3JtYWxpemUoc2FtcGxlLmR0cyAtIGluaXRQVFMsIG5leHRBdmNEdHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gc29ydCB2aWRlbyBzYW1wbGVzIGJ5IERUUyB0aGVuIFBUUyB0aGVuIGRlbXV4IGlkIG9yZGVyXG4gICAgICAgIGlucHV0U2FtcGxlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICB2YXIgZGVsdGFkdHMgPSBhLmR0cyAtIGIuZHRzO1xuICAgICAgICAgICAgdmFyIGRlbHRhcHRzID0gYS5wdHMgLSBiLnB0cztcbiAgICAgICAgICAgIHJldHVybiBkZWx0YWR0cyB8fCAoZGVsdGFwdHMgfHwgKGEuaWQgLSBiLmlkKSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBoYW5kbGUgYnJva2VuIHN0cmVhbXMgd2l0aCBQVFMgPCBEVFMsIHRvbGVyYW5jZSB1cCAyMDBtcyAoMTgwMDAgaW4gOTBrSHogdGltZXNjYWxlKVxuICAgICAgICB2YXIgUFRTRFRTc2hpZnQgPSBpbnB1dFNhbXBsZXMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7IHJldHVybiBNYXRoLm1heChNYXRoLm1pbihwcmV2LCBjdXJyLnB0cyAtIGN1cnIuZHRzKSwgLTE4MDAwKTsgfSwgMCk7XG4gICAgICAgIGlmIChQVFNEVFNzaGlmdCA8IDApIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKFwiUFRTIDwgRFRTIGRldGVjdGVkIGluIHZpZGVvIHNhbXBsZXMsIHNoaWZ0aW5nIERUUyBieSBcIiArIE1hdGgucm91bmQoUFRTRFRTc2hpZnQgLyA5MCkgKyBcIiBtcyB0byBvdmVyY29tZSB0aGlzIGlzc3VlXCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dFNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpbnB1dFNhbXBsZXNbaV0uZHRzICs9IFBUU0RUU3NoaWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbXB1dGUgZmlyc3QgRFRTIGFuZCBsYXN0IERUUywgbm9ybWFsaXplIHRoZW0gYWdhaW5zdCByZWZlcmVuY2UgdmFsdWVcbiAgICAgICAgdmFyIHNhbXBsZSA9IGlucHV0U2FtcGxlc1swXTtcbiAgICAgICAgZmlyc3REVFMgPSBNYXRoLm1heChzYW1wbGUuZHRzLCAwKTtcbiAgICAgICAgZmlyc3RQVFMgPSBNYXRoLm1heChzYW1wbGUucHRzLCAwKTtcbiAgICAgICAgLy8gY2hlY2sgdGltZXN0YW1wIGNvbnRpbnVpdHkgYWNjcm9zcyBjb25zZWN1dGl2ZSBmcmFnbWVudHMgKHRoaXMgaXMgdG8gcmVtb3ZlIGludGVyLWZyYWdtZW50IGdhcC9ob2xlKVxuICAgICAgICB2YXIgZGVsdGEgPSBNYXRoLnJvdW5kKChmaXJzdERUUyAtIG5leHRBdmNEdHMpIC8gOTApO1xuICAgICAgICAvLyBpZiBmcmFnbWVudCBhcmUgY29udGlndW91cywgZGV0ZWN0IGhvbGUvb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHNcbiAgICAgICAgaWYgKGNvbnRpZ3VvdXMpIHtcbiAgICAgICAgICAgIGlmIChkZWx0YSkge1xuICAgICAgICAgICAgICAgIGlmIChkZWx0YSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZyhcIkFWQzpcIiArIGRlbHRhICsgXCIgbXMgaG9sZSBiZXR3ZWVuIGZyYWdtZW50cyBkZXRlY3RlZCxmaWxsaW5nIGl0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkZWx0YSA8IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJBVkM6XCIgKyAoLWRlbHRhKSArIFwiIG1zIG92ZXJsYXBwaW5nIGJldHdlZW4gZnJhZ21lbnRzIGRldGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgaG9sZS9nYXAgOiBzZXQgRFRTIHRvIG5leHQgZXhwZWN0ZWQgRFRTXG4gICAgICAgICAgICAgICAgZmlyc3REVFMgPSBuZXh0QXZjRHRzO1xuICAgICAgICAgICAgICAgIGlucHV0U2FtcGxlc1swXS5kdHMgPSBmaXJzdERUUztcbiAgICAgICAgICAgICAgICAvLyBvZmZzZXQgUFRTIGFzIHdlbGwsIGVuc3VyZSB0aGF0IFBUUyBpcyBzbWFsbGVyIG9yIGVxdWFsIHRoYW4gbmV3IERUU1xuICAgICAgICAgICAgICAgIGZpcnN0UFRTID0gTWF0aC5tYXgoZmlyc3RQVFMgLSBkZWx0YSwgbmV4dEF2Y0R0cyk7XG4gICAgICAgICAgICAgICAgaW5wdXRTYW1wbGVzWzBdLnB0cyA9IGZpcnN0UFRTO1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJWaWRlby9QVFMvRFRTIGFkanVzdGVkOiBcIiArIE1hdGgucm91bmQoZmlyc3RQVFMgLyA5MCkgKyBcIi9cIiArIE1hdGgucm91bmQoZmlyc3REVFMgLyA5MCkgKyBcIixkZWx0YTpcIiArIGRlbHRhICsgXCIgbXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29tcHV0ZSBsYXN0UFRTL2xhc3REVFNcbiAgICAgICAgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2lucHV0U2FtcGxlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgbGFzdERUUyA9IE1hdGgubWF4KHNhbXBsZS5kdHMsIDApO1xuICAgICAgICBsYXN0UFRTID0gTWF0aC5tYXgoc2FtcGxlLnB0cywgMCwgbGFzdERUUyk7XG4gICAgICAgIC8vIG9uIFNhZmFyaSBsZXQncyBzaWduYWwgdGhlIHNhbWUgc2FtcGxlIGR1cmF0aW9uIGZvciBhbGwgc2FtcGxlc1xuICAgICAgICAvLyBzYW1wbGUgZHVyYXRpb24gKGFzIGV4cGVjdGVkIGJ5IHRydW4gTVA0IGJveGVzKSwgc2hvdWxkIGJlIHRoZSBkZWx0YSBiZXR3ZWVuIHNhbXBsZSBEVFNcbiAgICAgICAgLy8gc2V0IHRoaXMgY29uc3RhbnQgZHVyYXRpb24gYXMgYmVpbmcgdGhlIGF2ZyBkZWx0YSBiZXR3ZWVuIGNvbnNlY3V0aXZlIERUUy5cbiAgICAgICAgaWYgKGlzU2FmYXJpKSB7XG4gICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IE1hdGgucm91bmQoKGxhc3REVFMgLSBmaXJzdERUUykgLyAoaW5wdXRTYW1wbGVzLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmJOYWx1ID0gMCwgbmFsdUxlbiA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmJTYW1wbGVzOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgdG90YWwvYXZjIHNhbXBsZSBsZW5ndGggYW5kIG5iIG9mIE5BTCB1bml0c1xuICAgICAgICAgICAgdmFyIHNhbXBsZV8xID0gaW5wdXRTYW1wbGVzW2ldLCB1bml0cyA9IHNhbXBsZV8xLnVuaXRzLCBuYlVuaXRzID0gdW5pdHMubGVuZ3RoLCBzYW1wbGVMZW4gPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuYlVuaXRzOyBqKyspIHtcbiAgICAgICAgICAgICAgICBzYW1wbGVMZW4gKz0gdW5pdHNbal0uZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYWx1TGVuICs9IHNhbXBsZUxlbjtcbiAgICAgICAgICAgIG5iTmFsdSArPSBuYlVuaXRzO1xuICAgICAgICAgICAgc2FtcGxlXzEubGVuZ3RoID0gc2FtcGxlTGVuO1xuICAgICAgICAgICAgLy8gbm9ybWFsaXplIFBUUy9EVFNcbiAgICAgICAgICAgIGlmIChpc1NhZmFyaSkge1xuICAgICAgICAgICAgICAgIC8vIHNhbXBsZSBEVFMgaXMgY29tcHV0ZWQgdXNpbmcgYSBjb25zdGFudCBkZWNvZGluZyBvZmZzZXQgKG1wNFNhbXBsZUR1cmF0aW9uKSBiZXR3ZWVuIHNhbXBsZXNcbiAgICAgICAgICAgICAgICBzYW1wbGVfMS5kdHMgPSBmaXJzdERUUyArIGkgKiBtcDRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBzYW1wbGUgbW9ub3RvbmljIERUU1xuICAgICAgICAgICAgICAgIHNhbXBsZV8xLmR0cyA9IE1hdGgubWF4KHNhbXBsZV8xLmR0cywgZmlyc3REVFMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZW5zdXJlIHRoYXQgY29tcHV0ZWQgdmFsdWUgaXMgZ3JlYXRlciBvciBlcXVhbCB0aGFuIHNhbXBsZSBEVFNcbiAgICAgICAgICAgIHNhbXBsZV8xLnB0cyA9IE1hdGgubWF4KHNhbXBsZV8xLnB0cywgc2FtcGxlXzEuZHRzKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjb25jYXRlbmF0ZSB0aGUgdmlkZW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0IGluIHBsYWNlXG4gICAgICAgICAgKG5lZWQgOCBtb3JlIGJ5dGVzIHRvIGZpbGwgbGVuZ3RoIGFuZCBtcGRhdCB0eXBlKSAqL1xuICAgICAgICB2YXIgbWRhdFNpemUgPSBuYWx1TGVuICsgKDQgKiBuYk5hbHUpICsgODtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1kYXQgPSBuZXcgVWludDhBcnJheShtZGF0U2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRVJST1IsIHsgdHlwZTogZXJyb3JzXzEuRXJyb3JUeXBlcy5NVVhfRVJST1IsIGRldGFpbHM6IGVycm9yc18xLkVycm9yRGV0YWlscy5SRU1VWF9BTExPQ19FUlJPUiwgZmF0YWw6IGZhbHNlLCBieXRlczogbWRhdFNpemUsIHJlYXNvbjogXCJmYWlsIGFsbG9jYXRpbmcgdmlkZW8gbWRhdCBcIiArIG1kYXRTaXplIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KG1kYXQuYnVmZmVyKTtcbiAgICAgICAgdmlldy5zZXRVaW50MzIoMCwgbWRhdFNpemUpO1xuICAgICAgICBtZGF0LnNldChtcDRfZ2VuZXJhdG9yXzEuZGVmYXVsdC50eXBlcy5tZGF0LCA0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xuICAgICAgICAgICAgdmFyIGF2Y1NhbXBsZSA9IGlucHV0U2FtcGxlc1tpXSwgYXZjU2FtcGxlVW5pdHMgPSBhdmNTYW1wbGUudW5pdHMsIG1wNFNhbXBsZUxlbmd0aCA9IDAsIGNvbXBvc2l0aW9uVGltZU9mZnNldCA9IHZvaWQgMDtcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgTkFMVSBiaXRzdHJlYW0gdG8gTVA0IGZvcm1hdCAocHJlcGVuZCBOQUxVIHdpdGggc2l6ZSBmaWVsZClcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBuYlVuaXRzID0gYXZjU2FtcGxlVW5pdHMubGVuZ3RoOyBqIDwgbmJVbml0czsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVuaXQgPSBhdmNTYW1wbGVVbml0c1tqXSwgdW5pdERhdGEgPSB1bml0LmRhdGEsIHVuaXREYXRhTGVuID0gdW5pdC5kYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCB1bml0RGF0YUxlbik7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgICAgbWRhdC5zZXQodW5pdERhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHVuaXREYXRhTGVuO1xuICAgICAgICAgICAgICAgIG1wNFNhbXBsZUxlbmd0aCArPSA0ICsgdW5pdERhdGFMZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzU2FmYXJpKSB7XG4gICAgICAgICAgICAgICAgLy8gZXhwZWN0ZWQgc2FtcGxlIGR1cmF0aW9uIGlzIHRoZSBEZWNvZGluZyBUaW1lc3RhbXAgZGlmZiBvZiBjb25zZWN1dGl2ZSBzYW1wbGVzXG4gICAgICAgICAgICAgICAgaWYgKGkgPCBuYlNhbXBsZXMgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gaW5wdXRTYW1wbGVzW2kgKyAxXS5kdHMgLSBhdmNTYW1wbGUuZHRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnLCBsYXN0RnJhbWVEdXJhdGlvbiA9IGF2Y1NhbXBsZS5kdHMgLSBpbnB1dFNhbXBsZXNbaSA+IDAgPyBpIC0gMSA6IGldLmR0cztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5zdHJldGNoU2hvcnRWaWRlb1RyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBzb21lIGNhc2VzLCBhIHNlZ21lbnQncyBhdWRpbyB0cmFjayBkdXJhdGlvbiBtYXkgZXhjZWVkIHRoZSB2aWRlbyB0cmFjayBkdXJhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHdlJ3ZlIGFscmVhZHkgcmVtdXhlZCBhdWRpbywgYW5kIHdlIGtub3cgaG93IGxvbmcgdGhlIGF1ZGlvIHRyYWNrIGlzLCB3ZSBsb29rIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWUgaWYgdGhlIGRlbHRhIHRvIHRoZSBuZXh0IHNlZ21lbnQgaXMgbG9uZ2VyIHRoYW4gbWF4QnVmZmVySG9sZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHNvLCBwbGF5YmFjayB3b3VsZCBwb3RlbnRpYWxseSBnZXQgc3R1Y2ssIHNvIHdlIGFydGlmaWNpYWxseSBpbmZsYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZHVyYXRpb24gb2YgdGhlIGxhc3QgZnJhbWUgdG8gbWluaW1pemUgYW55IHBvdGVudGlhbCBnYXAgYmV0d2VlbiBzZWdtZW50cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhCdWZmZXJIb2xlID0gY29uZmlnLm1heEJ1ZmZlckhvbGUsIGdhcFRvbGVyYW5jZSA9IE1hdGguZmxvb3IobWF4QnVmZmVySG9sZSAqIHRpbWVTY2FsZSksIGRlbHRhVG9GcmFtZUVuZCA9IChhdWRpb1RyYWNrTGVuZ3RoID8gZmlyc3RQVFMgKyBhdWRpb1RyYWNrTGVuZ3RoICogdGltZVNjYWxlIDogdGhpcy5uZXh0QXVkaW9QdHMpIC0gYXZjU2FtcGxlLnB0cztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWx0YVRvRnJhbWVFbmQgPiBnYXBUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBzdWJ0cmFjdCBsYXN0RnJhbWVEdXJhdGlvbiBmcm9tIGRlbHRhVG9GcmFtZUVuZCB0byB0cnkgdG8gcHJldmVudCBhbnkgdmlkZW9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmcmFtZSBvdmVybGFwLiBtYXhCdWZmZXJIb2xlIHNob3VsZCBiZSA+PiBsYXN0RnJhbWVEdXJhdGlvbiBhbnl3YXkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBkZWx0YVRvRnJhbWVFbmQgLSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobXA0U2FtcGxlRHVyYXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coXCJJdCBpcyBhcHByb3hpbWF0ZWx5IFwiICsgZGVsdGFUb0ZyYW1lRW5kIC8gOTAgKyBcIiBtcyB0byB0aGUgbmV4dCBzZWdtZW50OyB1c2luZyBkdXJhdGlvbiBcIiArIG1wNFNhbXBsZUR1cmF0aW9uIC8gOTAgKyBcIiBtcyBmb3IgdGhlIGxhc3QgdmlkZW8gZnJhbWUuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29tcG9zaXRpb25UaW1lT2Zmc2V0ID0gTWF0aC5yb3VuZChhdmNTYW1wbGUucHRzIC0gYXZjU2FtcGxlLmR0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21wb3NpdGlvblRpbWVPZmZzZXQgPSBNYXRoLm1heCgwLCBtcDRTYW1wbGVEdXJhdGlvbiAqIE1hdGgucm91bmQoKGF2Y1NhbXBsZS5wdHMgLSBhdmNTYW1wbGUuZHRzKSAvIG1wNFNhbXBsZUR1cmF0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnUFRTL0RUUy9pbml0RFRTL25vcm1QVFMvbm9ybURUUy9yZWxhdGl2ZSBQVFMgOiAke2F2Y1NhbXBsZS5wdHN9LyR7YXZjU2FtcGxlLmR0c30vJHtpbml0RFRTfS8ke3B0c25vcm19LyR7ZHRzbm9ybX0vJHsoYXZjU2FtcGxlLnB0cy80Mjk0OTY3Mjk2KS50b0ZpeGVkKDMpfScpO1xuICAgICAgICAgICAgb3V0cHV0U2FtcGxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzaXplOiBtcDRTYW1wbGVMZW5ndGgsXG4gICAgICAgICAgICAgICAgLy8gY29uc3RhbnQgZHVyYXRpb25cbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogbXA0U2FtcGxlRHVyYXRpb24sXG4gICAgICAgICAgICAgICAgY3RzOiBjb21wb3NpdGlvblRpbWVPZmZzZXQsXG4gICAgICAgICAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICAgICAgICAgICAgaXNMZWFkaW5nOiAwLFxuICAgICAgICAgICAgICAgICAgICBpc0RlcGVuZGVkT246IDAsXG4gICAgICAgICAgICAgICAgICAgIGhhc1JlZHVuZGFuY3k6IDAsXG4gICAgICAgICAgICAgICAgICAgIGRlZ3JhZFByaW86IDAsXG4gICAgICAgICAgICAgICAgICAgIGRlcGVuZHNPbjogYXZjU2FtcGxlLmtleSA/IDIgOiAxLFxuICAgICAgICAgICAgICAgICAgICBpc05vblN5bmM6IGF2Y1NhbXBsZS5rZXkgPyAwIDogMVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5leHQgQVZDIHNhbXBsZSBEVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIERUUyArIGxhc3Qgc2FtcGxlIGR1cmF0aW9uIChpbiBQRVMgdGltZXNjYWxlKVxuICAgICAgICB0aGlzLm5leHRBdmNEdHMgPSBsYXN0RFRTICsgbXA0U2FtcGxlRHVyYXRpb247XG4gICAgICAgIHZhciBkcm9wcGVkID0gdHJhY2suZHJvcHBlZDtcbiAgICAgICAgdHJhY2subGVuID0gMDtcbiAgICAgICAgdHJhY2submJOYWx1ID0gMDtcbiAgICAgICAgdHJhY2suZHJvcHBlZCA9IDA7XG4gICAgICAgIGlmIChvdXRwdXRTYW1wbGVzLmxlbmd0aCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignY2hyb21lJykgPiAtMSkge1xuICAgICAgICAgICAgdmFyIGZsYWdzID0gb3V0cHV0U2FtcGxlc1swXS5mbGFncztcbiAgICAgICAgICAgIC8vIGNocm9tZSB3b3JrYXJvdW5kLCBtYXJrIGZpcnN0IHNhbXBsZSBhcyBiZWluZyBhIFJhbmRvbSBBY2Nlc3MgUG9pbnQgdG8gYXZvaWQgc291cmNlYnVmZmVyIGFwcGVuZCBpc3N1ZVxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTIyOTQxMlxuICAgICAgICAgICAgZmxhZ3MuZGVwZW5kc09uID0gMjtcbiAgICAgICAgICAgIGZsYWdzLmlzTm9uU3luYyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2suc2FtcGxlcyA9IG91dHB1dFNhbXBsZXM7XG4gICAgICAgIG1vb2YgPSBtcDRfZ2VuZXJhdG9yXzEuZGVmYXVsdC5tb29mKHRyYWNrLnNlcXVlbmNlTnVtYmVyKyssIGZpcnN0RFRTLCB0cmFjayk7XG4gICAgICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBkYXRhMTogbW9vZixcbiAgICAgICAgICAgIGRhdGEyOiBtZGF0LFxuICAgICAgICAgICAgc3RhcnRQVFM6IGZpcnN0UFRTIC8gdGltZVNjYWxlLFxuICAgICAgICAgICAgZW5kUFRTOiAobGFzdFBUUyArIG1wNFNhbXBsZUR1cmF0aW9uKSAvIHRpbWVTY2FsZSxcbiAgICAgICAgICAgIHN0YXJ0RFRTOiBmaXJzdERUUyAvIHRpbWVTY2FsZSxcbiAgICAgICAgICAgIGVuZERUUzogdGhpcy5uZXh0QXZjRHRzIC8gdGltZVNjYWxlLFxuICAgICAgICAgICAgdHlwZTogJ3ZpZGVvJyxcbiAgICAgICAgICAgIGhhc0F1ZGlvOiBmYWxzZSxcbiAgICAgICAgICAgIGhhc1ZpZGVvOiB0cnVlLFxuICAgICAgICAgICAgbmI6IG91dHB1dFNhbXBsZXMubGVuZ3RoLFxuICAgICAgICAgICAgZHJvcHBlZDogZHJvcHBlZFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5GUkFHX1BBUlNJTkdfREFUQSwgZGF0YSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG4gICAgTVA0UmVtdXhlci5wcm90b3R5cGUucmVtdXhBdWRpbyA9IGZ1bmN0aW9uICh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgICAgIHZhciBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgICB2YXIgbXA0dGltZVNjYWxlID0gdHJhY2sudGltZXNjYWxlO1xuICAgICAgICB2YXIgc2NhbGVGYWN0b3IgPSBpbnB1dFRpbWVTY2FsZSAvIG1wNHRpbWVTY2FsZTtcbiAgICAgICAgdmFyIG1wNFNhbXBsZUR1cmF0aW9uID0gdHJhY2suaXNBQUMgPyAxMDI0IDogMTE1MjtcbiAgICAgICAgdmFyIGlucHV0U2FtcGxlRHVyYXRpb24gPSBtcDRTYW1wbGVEdXJhdGlvbiAqIHNjYWxlRmFjdG9yO1xuICAgICAgICB2YXIgcHRzTm9ybWFsaXplID0gdGhpcy5fUFRTTm9ybWFsaXplO1xuICAgICAgICB2YXIgaW5pdFBUUyA9IHRoaXMuX2luaXRQVFM7XG4gICAgICAgIHZhciByYXdNUEVHID0gIXRyYWNrLmlzQUFDICYmIHRoaXMudHlwZVN1cHBvcnRlZC5tcGVnO1xuICAgICAgICB2YXIgb2Zmc2V0LCBtcDRTYW1wbGUsIGZpbGxGcmFtZSwgbWRhdCwgbW9vZiwgZmlyc3RQVFMsIGxhc3RQVFMsIGlucHV0U2FtcGxlcyA9IHRyYWNrLnNhbXBsZXMsIG91dHB1dFNhbXBsZXMgPSBbXSwgbmV4dEF1ZGlvUHRzID0gdGhpcy5uZXh0QXVkaW9QdHM7XG4gICAgICAgIC8vIGZvciBhdWRpbyBzYW1wbGVzLCBhbHNvIGNvbnNpZGVyIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBhcyBiZWluZyBjb250aWd1b3VzIChldmVuIGlmIGEgbGV2ZWwgc3dpdGNoIG9jY3VycyksXG4gICAgICAgIC8vIGZvciBzYWtlIG9mIGNsYXJpdHk6XG4gICAgICAgIC8vIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBhcmUgZnJhZ3Mgd2l0aFxuICAgICAgICAvLyAgLSBsZXNzIHRoYW4gMTAwbXMgZ2FwcyBiZXR3ZWVuIG5ldyB0aW1lIG9mZnNldCAoaWYgYWNjdXJhdGUpIGFuZCBuZXh0IGV4cGVjdGVkIFBUUyBPUlxuICAgICAgICAvLyAgLSBsZXNzIHRoYW4gMjAgYXVkaW8gZnJhbWVzIGRpc3RhbmNlXG4gICAgICAgIC8vIGNvbnRpZ3VvdXMgZnJhZ21lbnRzIGFyZSBjb25zZWN1dGl2ZSBmcmFnbWVudHMgZnJvbSBzYW1lIHF1YWxpdHkgbGV2ZWwgKHNhbWUgbGV2ZWwsIG5ldyBTTiA9IG9sZCBTTiArIDEpXG4gICAgICAgIC8vIHRoaXMgaGVscHMgZW5zdXJpbmcgYXVkaW8gY29udGludWl0eVxuICAgICAgICAvLyBhbmQgdGhpcyBhbHNvIGF2b2lkcyBhdWRpbyBnbGl0Y2hlcy9jdXQgd2hlbiBzd2l0Y2hpbmcgcXVhbGl0eSwgb3IgcmVwb3J0aW5nIHdyb25nIGR1cmF0aW9uIG9uIGZpcnN0IGF1ZGlvIGZyYW1lXG4gICAgICAgIGNvbnRpZ3VvdXMgfD0gKGlucHV0U2FtcGxlcy5sZW5ndGggJiYgbmV4dEF1ZGlvUHRzICYmXG4gICAgICAgICAgICAoKGFjY3VyYXRlVGltZU9mZnNldCAmJiBNYXRoLmFicyh0aW1lT2Zmc2V0IC0gbmV4dEF1ZGlvUHRzIC8gaW5wdXRUaW1lU2NhbGUpIDwgMC4xKSB8fFxuICAgICAgICAgICAgICAgIE1hdGguYWJzKChpbnB1dFNhbXBsZXNbMF0ucHRzIC0gbmV4dEF1ZGlvUHRzIC0gaW5pdFBUUykpIDwgMjAgKiBpbnB1dFNhbXBsZUR1cmF0aW9uKSk7XG4gICAgICAgIC8vIGNvbXB1dGUgbm9ybWFsaXplZCBQVFNcbiAgICAgICAgaW5wdXRTYW1wbGVzLmZvckVhY2goZnVuY3Rpb24gKHNhbXBsZSkge1xuICAgICAgICAgICAgc2FtcGxlLnB0cyA9IHNhbXBsZS5kdHMgPSBwdHNOb3JtYWxpemUoc2FtcGxlLnB0cyAtIGluaXRQVFMsIHRpbWVPZmZzZXQgKiBpbnB1dFRpbWVTY2FsZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBmaWx0ZXIgb3V0IHNhbXBsZSB3aXRoIG5lZ2F0aXZlIFBUUyB0aGF0IGFyZSBub3QgcGxheWFibGUgYW55d2F5XG4gICAgICAgIC8vIGlmIHdlIGRvbid0IHJlbW92ZSB0aGVzZSBuZWdhdGl2ZSBzYW1wbGVzLCB0aGV5IHdpbGwgc2hpZnQgYWxsIGF1ZGlvIHNhbXBsZXMgZm9yd2FyZC5cbiAgICAgICAgLy8gbGVhZGluZyB0byBhdWRpbyBvdmVybGFwIGJldHdlZW4gY3VycmVudCAvIG5leHQgZnJhZ21lbnRcbiAgICAgICAgaW5wdXRTYW1wbGVzID0gaW5wdXRTYW1wbGVzLmZpbHRlcihmdW5jdGlvbiAoc2FtcGxlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlLnB0cyA+PSAwO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gaW4gY2FzZSBhbGwgc2FtcGxlcyBoYXZlIG5lZ2F0aXZlIFBUUywgYW5kIGhhdmUgYmVlbiBmaWx0ZXJlZCBvdXQsIHJldHVybiBub3dcbiAgICAgICAgaWYgKGlucHV0U2FtcGxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnRpZ3VvdXMpIHtcbiAgICAgICAgICAgIGlmICghYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgZnJhZyBhcmUgbW90IGNvbnRpZ3VvdXMgYW5kIGlmIHdlIGNhbnQgdHJ1c3QgdGltZSBvZmZzZXQsIGxldCdzIHVzZSBmaXJzdCBzYW1wbGUgUFRTIGFzIG5leHQgYXVkaW8gUFRTXG4gICAgICAgICAgICAgICAgbmV4dEF1ZGlvUHRzID0gaW5wdXRTYW1wbGVzWzBdLnB0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRpbWVPZmZzZXQgaXMgYWNjdXJhdGUsIGxldCdzIHVzZSBpdCBhcyBwcmVkaWN0ZWQgbmV4dCBhdWRpbyBQVFNcbiAgICAgICAgICAgICAgICBuZXh0QXVkaW9QdHMgPSB0aW1lT2Zmc2V0ICogaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGF1ZGlvIHRyYWNrIGlzIG1pc3Npbmcgc2FtcGxlcywgdGhlIGZyYW1lcyBzZWVtIHRvIGdldCBcImxlZnQtc2hpZnRlZFwiIHdpdGhpbiB0aGVcbiAgICAgICAgLy8gcmVzdWx0aW5nIG1wNCBzZWdtZW50LCBjYXVzaW5nIHN5bmMgaXNzdWVzIGFuZCBsZWF2aW5nIGdhcHMgYXQgdGhlIGVuZCBvZiB0aGUgYXVkaW8gc2VnbWVudC5cbiAgICAgICAgLy8gSW4gYW4gZWZmb3J0IHRvIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZywgd2UgaW5qZWN0IGZyYW1lcyBoZXJlIHdoZXJlIHRoZXJlIGFyZSBnYXBzLlxuICAgICAgICAvLyBXaGVuIHBvc3NpYmxlLCB3ZSBpbmplY3QgYSBzaWxlbnQgZnJhbWU7IHdoZW4gdGhhdCdzIG5vdCBwb3NzaWJsZSwgd2UgZHVwbGljYXRlIHRoZSBsYXN0XG4gICAgICAgIC8vIGZyYW1lLlxuICAgICAgICBpZiAodHJhY2suaXNBQUMpIHtcbiAgICAgICAgICAgIHZhciBtYXhBdWRpb0ZyYW1lc0RyaWZ0ID0gdGhpcy5jb25maWcubWF4QXVkaW9GcmFtZXNEcmlmdDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuZXh0UHRzID0gbmV4dEF1ZGlvUHRzOyBpIDwgaW5wdXRTYW1wbGVzLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAvLyBGaXJzdCwgbGV0J3Mgc2VlIGhvdyBmYXIgb2ZmIHRoaXMgZnJhbWUgaXMgZnJvbSB3aGVyZSB3ZSBleHBlY3QgaXQgdG8gYmVcbiAgICAgICAgICAgICAgICB2YXIgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldLCBkZWx0YTtcbiAgICAgICAgICAgICAgICB2YXIgcHRzID0gc2FtcGxlLnB0cztcbiAgICAgICAgICAgICAgICBkZWx0YSA9IHB0cyAtIG5leHRQdHM7XG4gICAgICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gTWF0aC5hYnMoMTAwMCAqIGRlbHRhIC8gaW5wdXRUaW1lU2NhbGUpO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIG92ZXJsYXBwaW5nIGJ5IG1vcmUgdGhhbiBhIGR1cmF0aW9uLCBkcm9wIHRoaXMgc2FtcGxlXG4gICAgICAgICAgICAgICAgaWYgKGRlbHRhIDw9IC1tYXhBdWRpb0ZyYW1lc0RyaWZ0ICogaW5wdXRTYW1wbGVEdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybihcIkRyb3BwaW5nIDEgYXVkaW8gZnJhbWUgQCBcIiArIChuZXh0UHRzIC8gaW5wdXRUaW1lU2NhbGUpLnRvRml4ZWQoMykgKyBcInMgZHVlIHRvIFwiICsgTWF0aC5yb3VuZChkdXJhdGlvbikgKyBcIiBtcyBvdmVybGFwLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRTYW1wbGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2subGVuIC09IHNhbXBsZS51bml0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgdG91Y2ggbmV4dFB0c05vcm0gb3IgaVxuICAgICAgICAgICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBicmFjZS1zdHlsZVxuICAgICAgICAgICAgICAgIC8vIEluc2VydCBtaXNzaW5nIGZyYW1lcyBpZjpcbiAgICAgICAgICAgICAgICAvLyAxOiBXZSdyZSBtb3JlIHRoYW4gbWF4QXVkaW9GcmFtZXNEcmlmdCBmcmFtZSBhd2F5XG4gICAgICAgICAgICAgICAgLy8gMjogTm90IG1vcmUgdGhhbiBNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OIGF3YXlcbiAgICAgICAgICAgICAgICAvLyAzOiBjdXJyZW50VGltZSAoYWthIG5leHRQdHNOb3JtKSBpcyBub3QgMFxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlbHRhID49IG1heEF1ZGlvRnJhbWVzRHJpZnQgKiBpbnB1dFNhbXBsZUR1cmF0aW9uICYmIGR1cmF0aW9uIDwgTUFYX1NJTEVOVF9GUkFNRV9EVVJBVElPTiAmJiBuZXh0UHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtaXNzaW5nID0gTWF0aC5yb3VuZChkZWx0YSAvIGlucHV0U2FtcGxlRHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybihcIkluamVjdGluZyBcIiArIG1pc3NpbmcgKyBcIiBhdWRpbyBmcmFtZSBAIFwiICsgKG5leHRQdHMgLyBpbnB1dFRpbWVTY2FsZSkudG9GaXhlZCgzKSArIFwicyBkdWUgdG8gXCIgKyBNYXRoLnJvdW5kKDEwMDAgKiBkZWx0YSAvIGlucHV0VGltZVNjYWxlKSArIFwiIG1zIGdhcC5cIik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWlzc2luZzsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U3RhbXAgPSBNYXRoLm1heChuZXh0UHRzLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxGcmFtZSA9IGFhY19oZWxwZXJfMS5kZWZhdWx0LmdldFNpbGVudEZyYW1lKHRyYWNrLm1hbmlmZXN0Q29kZWMgfHwgdHJhY2suY29kZWMsIHRyYWNrLmNoYW5uZWxDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGxGcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci5sb2coJ1VuYWJsZSB0byBnZXQgc2lsZW50IGZyYW1lIGZvciBnaXZlbiBhdWRpbyBjb2RlYzsgZHVwbGljYXRpbmcgbGFzdCBmcmFtZSBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxGcmFtZSA9IHNhbXBsZS51bml0LnN1YmFycmF5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFNhbXBsZXMuc3BsaWNlKGksIDAsIHsgdW5pdDogZmlsbEZyYW1lLCBwdHM6IG5ld1N0YW1wLCBkdHM6IG5ld1N0YW1wIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2subGVuICs9IGZpbGxGcmFtZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0UHRzICs9IGlucHV0U2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRqdXN0IHNhbXBsZSB0byBuZXh0IGV4cGVjdGVkIHB0c1xuICAgICAgICAgICAgICAgICAgICBzYW1wbGUucHRzID0gc2FtcGxlLmR0cyA9IG5leHRQdHM7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBqdXN0IGFkanVzdCBwdHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRlbHRhKSA+ICgwLjEgKiBpbnB1dFNhbXBsZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZyhgSW52YWxpZCBmcmFtZSBkZWx0YSAke01hdGgucm91bmQoZGVsdGEgKyBpbnB1dFNhbXBsZUR1cmF0aW9uKX0gYXQgUFRTICR7TWF0aC5yb3VuZChwdHMgLyA5MCl9IChzaG91bGQgYmUgJHtNYXRoLnJvdW5kKGlucHV0U2FtcGxlRHVyYXRpb24pfSkuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlLnB0cyA9IHNhbXBsZS5kdHMgPSBuZXh0UHRzO1xuICAgICAgICAgICAgICAgICAgICBuZXh0UHRzICs9IGlucHV0U2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIG5iU2FtcGxlc18xID0gaW5wdXRTYW1wbGVzLmxlbmd0aDsgaiA8IG5iU2FtcGxlc18xOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBhdWRpb1NhbXBsZSA9IGlucHV0U2FtcGxlc1tqXTtcbiAgICAgICAgICAgIHZhciB1bml0ID0gYXVkaW9TYW1wbGUudW5pdDtcbiAgICAgICAgICAgIHZhciBwdHMgPSBhdWRpb1NhbXBsZS5wdHM7XG4gICAgICAgICAgICAvLyBsb2dnZXIubG9nKGBBdWRpby9QVFM6JHtNYXRoLnJvdW5kKHB0cy85MCl9YCk7XG4gICAgICAgICAgICAvLyBpZiBub3QgZmlyc3Qgc2FtcGxlXG4gICAgICAgICAgICBpZiAobGFzdFBUUyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbXA0U2FtcGxlLmR1cmF0aW9uID0gTWF0aC5yb3VuZCgocHRzIC0gbGFzdFBUUykgLyBzY2FsZUZhY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGFfMSA9IE1hdGgucm91bmQoMTAwMCAqIChwdHMgLSBuZXh0QXVkaW9QdHMpIC8gaW5wdXRUaW1lU2NhbGUpLCBudW1NaXNzaW5nRnJhbWVzID0gMDtcbiAgICAgICAgICAgICAgICAvLyBpZiBmcmFnbWVudCBhcmUgY29udGlndW91cywgZGV0ZWN0IGhvbGUvb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHNcbiAgICAgICAgICAgICAgICAvLyBjb250aWd1b3VzIGZyYWdtZW50cyBhcmUgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGZyb20gc2FtZSBxdWFsaXR5IGxldmVsIChzYW1lIGxldmVsLCBuZXcgU04gPSBvbGQgU04gKyAxKVxuICAgICAgICAgICAgICAgIGlmIChjb250aWd1b3VzICYmIHRyYWNrLmlzQUFDKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxvZyBkZWx0YVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVsdGFfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbHRhXzEgPiAwICYmIGRlbHRhXzEgPCBNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtTWlzc2luZ0ZyYW1lcyA9IE1hdGgucm91bmQoKHB0cyAtIG5leHRBdWRpb1B0cykgLyBpbnB1dFNhbXBsZUR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKGRlbHRhXzEgKyBcIiBtcyBob2xlIGJldHdlZW4gQUFDIHNhbXBsZXMgZGV0ZWN0ZWQsZmlsbGluZyBpdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVtTWlzc2luZ0ZyYW1lcyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbEZyYW1lID0gYWFjX2hlbHBlcl8xLmRlZmF1bHQuZ2V0U2lsZW50RnJhbWUodHJhY2subWFuaWZlc3RDb2RlYyB8fCB0cmFjay5jb2RlYywgdHJhY2suY2hhbm5lbENvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxsRnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxGcmFtZSA9IHVuaXQuc3ViYXJyYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5sZW4gKz0gbnVtTWlzc2luZ0ZyYW1lcyAqIGZpbGxGcmFtZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgZnJhbWUgb3ZlcmxhcCwgb3ZlcmxhcHBpbmcgZm9yIG1vcmUgdGhhbiBoYWxmIGEgZnJhbWUgZHVyYWlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGVsdGFfMSA8IC0xMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRyb3Agb3ZlcmxhcHBpbmcgYXVkaW8gZnJhbWVzLi4uIGJyb3dzZXIgd2lsbCBkZWFsIHdpdGggaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiZHJvcCBvdmVybGFwcGluZyBBQUMgc2FtcGxlLCBleHBlY3RlZC9wYXJzZWQvZGVsdGE6XCIgKyAobmV4dEF1ZGlvUHRzIC8gaW5wdXRUaW1lU2NhbGUpLnRvRml4ZWQoMykgKyBcInMvXCIgKyAocHRzIC8gaW5wdXRUaW1lU2NhbGUpLnRvRml4ZWQoMykgKyBcInMvXCIgKyAoLWRlbHRhXzEpICsgXCJtc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5sZW4gLT0gdW5pdC5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IFBUUy9EVFMgdG8gZXhwZWN0ZWQgUFRTL0RUU1xuICAgICAgICAgICAgICAgICAgICAgICAgcHRzID0gbmV4dEF1ZGlvUHRzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJlbWVtYmVyIGZpcnN0IFBUUyBvZiBvdXIgYXVkaW9TYW1wbGVzXG4gICAgICAgICAgICAgICAgZmlyc3RQVFMgPSBwdHM7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrLmxlbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLyogY29uY2F0ZW5hdGUgdGhlIGF1ZGlvIGRhdGEgYW5kIGNvbnN0cnVjdCB0aGUgbWRhdCBpbiBwbGFjZVxuICAgICAgICAgICAgICAgICAgICAgIChuZWVkIDggbW9yZSBieXRlcyB0byBmaWxsIGxlbmd0aCBhbmQgbWRhdCB0eXBlKSAqL1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWRhdFNpemUgPSByYXdNUEVHID8gdHJhY2subGVuIDogdHJhY2subGVuICsgODtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gcmF3TVBFRyA/IDAgOiA4O1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWRhdCA9IG5ldyBVaW50OEFycmF5KG1kYXRTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5FUlJPUiwgeyB0eXBlOiBlcnJvcnNfMS5FcnJvclR5cGVzLk1VWF9FUlJPUiwgZGV0YWlsczogZXJyb3JzXzEuRXJyb3JEZXRhaWxzLlJFTVVYX0FMTE9DX0VSUk9SLCBmYXRhbDogZmFsc2UsIGJ5dGVzOiBtZGF0U2l6ZSwgcmVhc29uOiBcImZhaWwgYWxsb2NhdGluZyBhdWRpbyBtZGF0IFwiICsgbWRhdFNpemUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyYXdNUEVHKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhtZGF0LmJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LnNldFVpbnQzMigwLCBtZGF0U2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZGF0LnNldChtcDRfZ2VuZXJhdG9yXzEuZGVmYXVsdC50eXBlcy5tZGF0LCA0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gYXVkaW8gc2FtcGxlc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTWlzc2luZ0ZyYW1lczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxGcmFtZSA9IGFhY19oZWxwZXJfMS5kZWZhdWx0LmdldFNpbGVudEZyYW1lKHRyYWNrLm1hbmlmZXN0Q29kZWMgfHwgdHJhY2suY29kZWMsIHRyYWNrLmNoYW5uZWxDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmlsbEZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdVbmFibGUgdG8gZ2V0IHNpbGVudCBmcmFtZSBmb3IgZ2l2ZW4gYXVkaW8gY29kZWM7IGR1cGxpY2F0aW5nIHRoaXMgZnJhbWUgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxGcmFtZSA9IHVuaXQuc3ViYXJyYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZGF0LnNldChmaWxsRnJhbWUsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSBmaWxsRnJhbWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgbXA0U2FtcGxlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogZmlsbEZyYW1lLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHM6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogMTAyNCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNMZWFkaW5nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRGVwZW5kZWRPbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNSZWR1bmRhbmN5OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZ3JhZFByaW86IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwZW5kc09uOiAxXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFNhbXBsZXMucHVzaChtcDRTYW1wbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1kYXQuc2V0KHVuaXQsIG9mZnNldCk7XG4gICAgICAgICAgICB2YXIgdW5pdExlbiA9IHVuaXQuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIG9mZnNldCArPSB1bml0TGVuO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1BUUy9EVFMvaW5pdERUUy9ub3JtUFRTL25vcm1EVFMvcmVsYXRpdmUgUFRTIDogJHthdWRpb1NhbXBsZS5wdHN9LyR7YXVkaW9TYW1wbGUuZHRzfS8ke2luaXREVFN9LyR7cHRzbm9ybX0vJHtkdHNub3JtfS8keyhhdWRpb1NhbXBsZS5wdHMvNDI5NDk2NzI5NikudG9GaXhlZCgzKX0nKTtcbiAgICAgICAgICAgIG1wNFNhbXBsZSA9IHtcbiAgICAgICAgICAgICAgICBzaXplOiB1bml0TGVuLFxuICAgICAgICAgICAgICAgIGN0czogMCxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICAgICAgICBmbGFnczoge1xuICAgICAgICAgICAgICAgICAgICBpc0xlYWRpbmc6IDAsXG4gICAgICAgICAgICAgICAgICAgIGlzRGVwZW5kZWRPbjogMCxcbiAgICAgICAgICAgICAgICAgICAgaGFzUmVkdW5kYW5jeTogMCxcbiAgICAgICAgICAgICAgICAgICAgZGVncmFkUHJpbzogMCxcbiAgICAgICAgICAgICAgICAgICAgZGVwZW5kc09uOiAxXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG91dHB1dFNhbXBsZXMucHVzaChtcDRTYW1wbGUpO1xuICAgICAgICAgICAgbGFzdFBUUyA9IHB0cztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGFzdFNhbXBsZUR1cmF0aW9uID0gMDtcbiAgICAgICAgdmFyIG5iU2FtcGxlcyA9IG91dHB1dFNhbXBsZXMubGVuZ3RoO1xuICAgICAgICAvLyBzZXQgbGFzdCBzYW1wbGUgZHVyYXRpb24gYXMgYmVpbmcgaWRlbnRpY2FsIHRvIHByZXZpb3VzIHNhbXBsZVxuICAgICAgICBpZiAobmJTYW1wbGVzID49IDIpIHtcbiAgICAgICAgICAgIGxhc3RTYW1wbGVEdXJhdGlvbiA9IG91dHB1dFNhbXBsZXNbbmJTYW1wbGVzIC0gMl0uZHVyYXRpb247XG4gICAgICAgICAgICBtcDRTYW1wbGUuZHVyYXRpb24gPSBsYXN0U2FtcGxlRHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5iU2FtcGxlcykge1xuICAgICAgICAgICAgLy8gbmV4dCBhdWRpbyBzYW1wbGUgUFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBQVFMgKyBkdXJhdGlvblxuICAgICAgICAgICAgdGhpcy5uZXh0QXVkaW9QdHMgPSBuZXh0QXVkaW9QdHMgPSBsYXN0UFRTICsgc2NhbGVGYWN0b3IgKiBsYXN0U2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdBdWRpby9QVFMvUFRTZW5kOicgKyBhdWRpb1NhbXBsZS5wdHMudG9GaXhlZCgwKSArICcvJyArIHRoaXMubmV4dEFhY0R0cy50b0ZpeGVkKDApKTtcbiAgICAgICAgICAgIHRyYWNrLmxlbiA9IDA7XG4gICAgICAgICAgICB0cmFjay5zYW1wbGVzID0gb3V0cHV0U2FtcGxlcztcbiAgICAgICAgICAgIGlmIChyYXdNUEVHKSB7XG4gICAgICAgICAgICAgICAgbW9vZiA9IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb29mID0gbXA0X2dlbmVyYXRvcl8xLmRlZmF1bHQubW9vZih0cmFjay5zZXF1ZW5jZU51bWJlcisrLCBmaXJzdFBUUyAvIHNjYWxlRmFjdG9yLCB0cmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjay5zYW1wbGVzID0gW107XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBmaXJzdFBUUyAvIGlucHV0VGltZVNjYWxlO1xuICAgICAgICAgICAgdmFyIGVuZCA9IG5leHRBdWRpb1B0cyAvIGlucHV0VGltZVNjYWxlO1xuICAgICAgICAgICAgdmFyIGF1ZGlvRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBkYXRhMTogbW9vZixcbiAgICAgICAgICAgICAgICBkYXRhMjogbWRhdCxcbiAgICAgICAgICAgICAgICBzdGFydFBUUzogc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kUFRTOiBlbmQsXG4gICAgICAgICAgICAgICAgc3RhcnREVFM6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZERUUzogZW5kLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICAgICAgICAgICAgaGFzQXVkaW86IHRydWUsXG4gICAgICAgICAgICAgICAgaGFzVmlkZW86IGZhbHNlLFxuICAgICAgICAgICAgICAgIG5iOiBuYlNhbXBsZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5GUkFHX1BBUlNJTkdfREFUQSwgYXVkaW9EYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBhdWRpb0RhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBNUDRSZW11eGVyLnByb3RvdHlwZS5yZW11eEVtcHR5QXVkaW8gPSBmdW5jdGlvbiAodHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIHZpZGVvRGF0YSkge1xuICAgICAgICB2YXIgaW5wdXRUaW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZSwgbXA0dGltZVNjYWxlID0gdHJhY2suc2FtcGxlcmF0ZSA/IHRyYWNrLnNhbXBsZXJhdGUgOiBpbnB1dFRpbWVTY2FsZSwgc2NhbGVGYWN0b3IgPSBpbnB1dFRpbWVTY2FsZSAvIG1wNHRpbWVTY2FsZSwgbmV4dEF1ZGlvUHRzID0gdGhpcy5uZXh0QXVkaW9QdHMsIFxuICAgICAgICAvLyBzeW5jIHdpdGggdmlkZW8ncyB0aW1lc3RhbXBcbiAgICAgICAgc3RhcnREVFMgPSAobmV4dEF1ZGlvUHRzICE9PSB1bmRlZmluZWQgPyBuZXh0QXVkaW9QdHMgOiB2aWRlb0RhdGEuc3RhcnREVFMgKiBpbnB1dFRpbWVTY2FsZSkgKyB0aGlzLl9pbml0RFRTLCBlbmREVFMgPSB2aWRlb0RhdGEuZW5kRFRTICogaW5wdXRUaW1lU2NhbGUgKyB0aGlzLl9pbml0RFRTLCBcbiAgICAgICAgLy8gb25lIHNhbXBsZSdzIGR1cmF0aW9uIHZhbHVlXG4gICAgICAgIHNhbXBsZUR1cmF0aW9uID0gMTAyNCwgZnJhbWVEdXJhdGlvbiA9IHNjYWxlRmFjdG9yICogc2FtcGxlRHVyYXRpb24sIFxuICAgICAgICAvLyBzYW1wbGVzIGNvdW50IG9mIHRoaXMgc2VnbWVudCdzIGR1cmF0aW9uXG4gICAgICAgIG5iU2FtcGxlcyA9IE1hdGguY2VpbCgoZW5kRFRTIC0gc3RhcnREVFMpIC8gZnJhbWVEdXJhdGlvbiksIFxuICAgICAgICAvLyBzaWxlbnQgZnJhbWVcbiAgICAgICAgc2lsZW50RnJhbWUgPSBhYWNfaGVscGVyXzEuZGVmYXVsdC5nZXRTaWxlbnRGcmFtZSh0cmFjay5tYW5pZmVzdENvZGVjIHx8IHRyYWNrLmNvZGVjLCB0cmFjay5jaGFubmVsQ291bnQpO1xuICAgICAgICBsb2dnZXJfMS5sb2dnZXIud2FybigncmVtdXggZW1wdHkgQXVkaW8nKTtcbiAgICAgICAgLy8gQ2FuJ3QgcmVtdXggaWYgd2UgY2FuJ3QgZ2VuZXJhdGUgYSBzaWxlbnQgZnJhbWUuLi5cbiAgICAgICAgaWYgKCFzaWxlbnRGcmFtZSkge1xuICAgICAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLnRyYWNlKCdVbmFibGUgdG8gcmVtdXhFbXB0eUF1ZGlvIHNpbmNlIHdlIHdlcmUgdW5hYmxlIHRvIGdldCBhIHNpbGVudCBmcmFtZSBmb3IgZ2l2ZW4gYXVkaW8gY29kZWMhJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNhbXBsZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0YW1wID0gc3RhcnREVFMgKyBpICogZnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICAgIHNhbXBsZXMucHVzaCh7IHVuaXQ6IHNpbGVudEZyYW1lLCBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wIH0pO1xuICAgICAgICAgICAgdHJhY2subGVuICs9IHNpbGVudEZyYW1lLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0cmFjay5zYW1wbGVzID0gc2FtcGxlcztcbiAgICAgICAgdGhpcy5yZW11eEF1ZGlvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzKTtcbiAgICB9O1xuICAgIE1QNFJlbXV4ZXIucHJvdG90eXBlLnJlbXV4SUQzID0gZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB0cmFjay5zYW1wbGVzLmxlbmd0aCwgc2FtcGxlO1xuICAgICAgICB2YXIgaW5wdXRUaW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgICAgdmFyIGluaXRQVFMgPSB0aGlzLl9pbml0UFRTO1xuICAgICAgICB2YXIgaW5pdERUUyA9IHRoaXMuX2luaXREVFM7XG4gICAgICAgIC8vIGNvbnN1bWUgc2FtcGxlc1xuICAgICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgc2FtcGxlID0gdHJhY2suc2FtcGxlc1tpbmRleF07XG4gICAgICAgICAgICAgICAgLy8gc2V0dGluZyBpZDMgcHRzLCBkdHMgdG8gcmVsYXRpdmUgdGltZVxuICAgICAgICAgICAgICAgIC8vIHVzaW5nIHRoaXMuX2luaXRQVFMgYW5kIHRoaXMuX2luaXREVFMgdG8gY2FsY3VsYXRlIHJlbGF0aXZlIHRpbWVcbiAgICAgICAgICAgICAgICBzYW1wbGUucHRzID0gKChzYW1wbGUucHRzIC0gaW5pdFBUUykgLyBpbnB1dFRpbWVTY2FsZSk7XG4gICAgICAgICAgICAgICAgc2FtcGxlLmR0cyA9ICgoc2FtcGxlLmR0cyAtIGluaXREVFMpIC8gaW5wdXRUaW1lU2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKGV2ZW50c18xLmRlZmF1bHQuRlJBR19QQVJTSU5HX01FVEFEQVRBLCB7XG4gICAgICAgICAgICAgICAgc2FtcGxlczogdHJhY2suc2FtcGxlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICAgIH07XG4gICAgTVA0UmVtdXhlci5wcm90b3R5cGUucmVtdXhUZXh0ID0gZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIHRyYWNrLnNhbXBsZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIChhLnB0cyAtIGIucHRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsZW5ndGggPSB0cmFjay5zYW1wbGVzLmxlbmd0aCwgc2FtcGxlO1xuICAgICAgICB2YXIgaW5wdXRUaW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgICAgdmFyIGluaXRQVFMgPSB0aGlzLl9pbml0UFRTO1xuICAgICAgICAvLyBjb25zdW1lIHNhbXBsZXNcbiAgICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHNhbXBsZSA9IHRyYWNrLnNhbXBsZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIC8vIHNldHRpbmcgdGV4dCBwdHMsIGR0cyB0byByZWxhdGl2ZSB0aW1lXG4gICAgICAgICAgICAgICAgLy8gdXNpbmcgdGhpcy5faW5pdFBUUyBhbmQgdGhpcy5faW5pdERUUyB0byBjYWxjdWxhdGUgcmVsYXRpdmUgdGltZVxuICAgICAgICAgICAgICAgIHNhbXBsZS5wdHMgPSAoKHNhbXBsZS5wdHMgLSBpbml0UFRTKSAvIGlucHV0VGltZVNjYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkZSQUdfUEFSU0lOR19VU0VSREFUQSwge1xuICAgICAgICAgICAgICAgIHNhbXBsZXM6IHRyYWNrLnNhbXBsZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICB9O1xuICAgIE1QNFJlbXV4ZXIucHJvdG90eXBlLl9QVFNOb3JtYWxpemUgPSBmdW5jdGlvbiAodmFsdWUsIHJlZmVyZW5jZSkge1xuICAgICAgICB2YXIgb2Zmc2V0O1xuICAgICAgICBpZiAocmVmZXJlbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmZXJlbmNlIDwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIC0gMl4zM1xuICAgICAgICAgICAgb2Zmc2V0ID0gLTg1ODk5MzQ1OTI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyArIDJeMzNcbiAgICAgICAgICAgIG9mZnNldCA9IDg1ODk5MzQ1OTI7XG4gICAgICAgIH1cbiAgICAgICAgLyogUFRTIGlzIDMzYml0IChmcm9tIDAgdG8gMl4zMyAtMSlcbiAgICAgICAgICBpZiBkaWZmIGJldHdlZW4gdmFsdWUgYW5kIHJlZmVyZW5jZSBpcyBiaWdnZXIgdGhhbiBoYWxmIG9mIHRoZSBhbXBsaXR1ZGUgKDJeMzIpIHRoZW4gaXQgbWVhbnMgdGhhdFxuICAgICAgICAgIFBUUyBsb29waW5nIG9jY3VyZWQuIGZpbGwgdGhlIGdhcCAqL1xuICAgICAgICB3aGlsZSAoTWF0aC5hYnModmFsdWUgLSByZWZlcmVuY2UpID4gNDI5NDk2NzI5Nikge1xuICAgICAgICAgICAgdmFsdWUgKz0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiBNUDRSZW11eGVyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IE1QNFJlbXV4ZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvcmVtdXgvcGFzc3Rocm91Z2gtcmVtdXhlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3JlbXV4L3Bhc3N0aHJvdWdoLXJlbXV4ZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBwYXNzdGhyb3VnaCByZW11eGVyXG4qL1xudmFyIGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLmpzXCIpO1xudmFyIFBhc3NUaHJvdWdoUmVtdXhlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXNzVGhyb3VnaFJlbXV4ZXIob2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIH1cbiAgICBQYXNzVGhyb3VnaFJlbXV4ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgfTtcbiAgICBQYXNzVGhyb3VnaFJlbXV4ZXIucHJvdG90eXBlLnJlc2V0VGltZVN0YW1wID0gZnVuY3Rpb24gKCkge1xuICAgIH07XG4gICAgUGFzc1Rocm91Z2hSZW11eGVyLnByb3RvdHlwZS5yZXNldEluaXRTZWdtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIH07XG4gICAgUGFzc1Rocm91Z2hSZW11eGVyLnByb3RvdHlwZS5yZW11eCA9IGZ1bmN0aW9uIChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIHJhd0RhdGEpIHtcbiAgICAgICAgdmFyIG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcjtcbiAgICAgICAgdmFyIHN0cmVhbVR5cGUgPSAnJztcbiAgICAgICAgaWYgKGF1ZGlvVHJhY2spIHtcbiAgICAgICAgICAgIHN0cmVhbVR5cGUgKz0gJ2F1ZGlvJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlkZW9UcmFjaykge1xuICAgICAgICAgICAgc3RyZWFtVHlwZSArPSAndmlkZW8nO1xuICAgICAgICB9XG4gICAgICAgIG9ic2VydmVyLnRyaWdnZXIoZXZlbnRzXzEuZGVmYXVsdC5GUkFHX1BBUlNJTkdfREFUQSwge1xuICAgICAgICAgICAgZGF0YTE6IHJhd0RhdGEsXG4gICAgICAgICAgICBzdGFydFBUUzogdGltZU9mZnNldCxcbiAgICAgICAgICAgIHN0YXJ0RFRTOiB0aW1lT2Zmc2V0LFxuICAgICAgICAgICAgdHlwZTogc3RyZWFtVHlwZSxcbiAgICAgICAgICAgIGhhc0F1ZGlvOiAhIWF1ZGlvVHJhY2ssXG4gICAgICAgICAgICBoYXNWaWRlbzogISF2aWRlb1RyYWNrLFxuICAgICAgICAgICAgbmI6IDEsXG4gICAgICAgICAgICBkcm9wcGVkOiAwXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBub3RpZnkgZW5kIG9mIHBhcnNpbmdcbiAgICAgICAgb2JzZXJ2ZXIudHJpZ2dlcihldmVudHNfMS5kZWZhdWx0LkZSQUdfUEFSU0VEKTtcbiAgICB9O1xuICAgIHJldHVybiBQYXNzVGhyb3VnaFJlbXV4ZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUGFzc1Rocm91Z2hSZW11eGVyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3Rhc2stbG9vcC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdGFzay1sb29wLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXZlbnRfaGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ldmVudC1oYW5kbGVyICovIFwiLi9zcmMvZXZlbnQtaGFuZGxlci5qc1wiKTtcbi8qKlxuICogU3ViLWNsYXNzIHNwZWNpYWxpemF0aW9uIG9mIEV2ZW50SGFuZGxlciBiYXNlIGNsYXNzLlxuICpcbiAqIFRhc2tMb29wIGFsbG93cyB0byBzY2hlZHVsZSBhIHRhc2sgZnVuY3Rpb24gYmVpbmcgY2FsbGVkIChvcHRpb25uYWx5IHJlcGVhdGVkbHkpIG9uIHRoZSBtYWluIGxvb3AsXG4gKiBzY2hlZHVsZWQgYXN5bmNocm9uZW91c2x5LCBhdm9pZGluZyByZWN1cnNpdmUgY2FsbHMgaW4gdGhlIHNhbWUgdGljay5cbiAqXG4gKiBUaGUgdGFzayBpdHNlbGYgaXMgaW1wbGVtZW50ZWQgaW4gYGRvVGlja2AuIEl0IGNhbiBiZSByZXF1ZXN0ZWQgYW5kIGNhbGxlZCBmb3Igc2luZ2xlIGV4ZWN1dGlvblxuICogdXNpbmcgdGhlIGB0aWNrYCBtZXRob2QuXG4gKlxuICogSXQgd2lsbCBiZSBhc3N1cmVkIHRoYXQgdGhlIHRhc2sgZXhlY3V0aW9uIG1ldGhvZCAoYHRpY2tgKSBvbmx5IGdldHMgY2FsbGVkIG9uY2UgcGVyIG1haW4gbG9vcCBcInRpY2tcIixcbiAqIG5vIG1hdHRlciBob3cgb2Z0ZW4gaXQgZ2V0cyByZXF1ZXN0ZWQgZm9yIGV4ZWN1dGlvbi4gRXhlY3V0aW9uIGluIGZ1cnRoZXIgdGlja3Mgd2lsbCBiZSBzY2hlZHVsZWQgYWNjb3JkaW5nbHkuXG4gKlxuICogSWYgZnVydGhlciBleGVjdXRpb24gcmVxdWVzdHMgaGF2ZSBhbHJlYWR5IGJlZW4gc2NoZWR1bGVkIG9uIHRoZSBuZXh0IHRpY2ssIGl0IGNhbiBiZSBjaGVja2VkIHdpdGggYGhhc05leHRUaWNrYCxcbiAqIGFuZCBjYW5jZWxsZWQgd2l0aCBgY2xlYXJOZXh0VGlja2AuXG4gKlxuICogVGhlIHRhc2sgY2FuIGJlIHNjaGVkdWxlZCBhcyBhbiBpbnRlcnZhbCByZXBlYXRlZGx5IHdpdGggYSBwZXJpb2QgYXMgcGFyYW1ldGVyIChzZWUgYHNldEludGVydmFsYCwgYGNsZWFySW50ZXJ2YWxgKS5cbiAqXG4gKiBTdWItY2xhc3NlcyBuZWVkIHRvIGltcGxlbWVudCB0aGUgYGRvVGlja2AgbWV0aG9kIHdoaWNoIHdpbGwgZWZmZWN0aXZlbHkgaGF2ZSB0aGUgdGFzayBleGVjdXRpb24gcm91dGluZS5cbiAqXG4gKiBGdXJ0aGVyIGV4cGxhbmF0aW9uczpcbiAqXG4gKiBUaGUgYmFzZWNsYXNzIGhhcyBhIGB0aWNrYCBtZXRob2QgdGhhdCB3aWxsIHNjaGVkdWxlIHRoZSBkb1RpY2sgY2FsbC4gSXQgbWF5IGJlIGNhbGxlZCBzeW5jaHJvbmVvdXNseVxuICogb25seSBmb3IgYSBzdGFjay1kZXB0aCBvZiBvbmUuIE9uIHJlLWVudHJhbnQgY2FsbHMsIHN1Yi1zZXF1ZW50IGNhbGxzIGFyZSBzY2hlZHVsZWQgZm9yIG5leHQgbWFpbiBsb29wIHRpY2tzLlxuICpcbiAqIFdoZW4gdGhlIHRhc2sgZXhlY3V0aW9uIChgdGlja2AgbWV0aG9kKSBpcyBjYWxsZWQgaW4gcmUtZW50cmFudCB3YXkgdGhpcyBpcyBkZXRlY3RlZCBhbmRcbiAqIHdlIGFyZSBsaW1pdGluZyB0aGUgdGFzayBleGVjdXRpb24gcGVyIGNhbGwgc3RhY2sgdG8gZXhhY3RseSBvbmUsIGJ1dCBzY2hlZHVsaW5nL3Bvc3QtcG9uaW5nIGZ1cnRoZXJcbiAqIHRhc2sgcHJvY2Vzc2luZyBvbiB0aGUgbmV4dCBtYWluIGxvb3AgaXRlcmF0aW9uIChhbHNvIGtub3duIGFzIFwibmV4dCB0aWNrXCIgaW4gdGhlIE5vZGUvSlMgcnVudGltZSBsaW5nbykuXG4gKi9cbnZhciBUYXNrTG9vcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFza0xvb3AsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFza0xvb3AoaGxzKSB7XG4gICAgICAgIHZhciBldmVudHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGV2ZW50c1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgW2hsc10uY29uY2F0KGV2ZW50cykpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl90aWNrSW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICBfdGhpcy5fdGlja1RpbWVyID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX3RpY2tDYWxsQ291bnQgPSAwO1xuICAgICAgICBfdGhpcy5fYm91bmRUaWNrID0gX3RoaXMudGljay5iaW5kKF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBUYXNrTG9vcC5wcm90b3R5cGUub25IYW5kbGVyRGVzdHJveWluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gY2xlYXIgYWxsIHRpbWVycyBiZWZvcmUgdW5yZWdpc3RlcmluZyBmcm9tIGV2ZW50IGJ1c1xuICAgICAgICB0aGlzLmNsZWFyTmV4dFRpY2soKTtcbiAgICAgICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBUYXNrTG9vcC5wcm90b3R5cGUuaGFzSW50ZXJ2YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX3RpY2tJbnRlcnZhbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIFRhc2tMb29wLnByb3RvdHlwZS5oYXNOZXh0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fdGlja1RpbWVyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbGxpcyBJbnRlcnZhbCB0aW1lIChtcylcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSB3aGVuIGludGVydmFsIGhhcyBiZWVuIHNjaGVkdWxlZCwgZmFsc2Ugd2hlbiBhbHJlYWR5IHNjaGVkdWxlZCAobm8gZWZmZWN0KVxuICAgICAqL1xuICAgIFRhc2tMb29wLnByb3RvdHlwZS5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uIChtaWxsaXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90aWNrSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3RpY2tJbnRlcnZhbCA9IHNldEludGVydmFsKHRoaXMuX2JvdW5kVGljaywgbWlsbGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIHdoZW4gaW50ZXJ2YWwgd2FzIGNsZWFyZWQsIGZhbHNlIHdoZW4gbm9uZSB3YXMgc2V0IChubyBlZmZlY3QpXG4gICAgICovXG4gICAgVGFza0xvb3AucHJvdG90eXBlLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl90aWNrSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fdGlja0ludGVydmFsKTtcbiAgICAgICAgICAgIHRoaXMuX3RpY2tJbnRlcnZhbCA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSB3aGVuIHRpbWVvdXQgd2FzIGNsZWFyZWQsIGZhbHNlIHdoZW4gbm9uZSB3YXMgc2V0IChubyBlZmZlY3QpXG4gICAgICovXG4gICAgVGFza0xvb3AucHJvdG90eXBlLmNsZWFyTmV4dFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl90aWNrVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aWNrVGltZXIpO1xuICAgICAgICAgICAgdGhpcy5fdGlja1RpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdpbGwgY2FsbCB0aGUgc3ViY2xhc3MgZG9UaWNrIGltcGxlbWVudGF0aW9uIGluIHRoaXMgbWFpbiBsb29wIHRpY2tcbiAgICAgKiBvciBpbiB0aGUgbmV4dCBvbmUgKHZpYSBzZXRUaW1lb3V0KCwwKSkgaW4gY2FzZSBpdCBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZFxuICAgICAqIGluIHRoaXMgdGljayAoaW4gY2FzZSB0aGlzIGlzIGEgcmUtZW50cmFudCBjYWxsKS5cbiAgICAgKi9cbiAgICBUYXNrTG9vcC5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdGlja0NhbGxDb3VudCsrO1xuICAgICAgICBpZiAodGhpcy5fdGlja0NhbGxDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5kb1RpY2soKTtcbiAgICAgICAgICAgIC8vIHJlLWVudHJhbnQgY2FsbCB0byB0aWNrIGZyb20gcHJldmlvdXMgZG9UaWNrIGNhbGwgc3RhY2tcbiAgICAgICAgICAgIC8vIC0+IHNjaGVkdWxlIGEgY2FsbCBvbiB0aGUgbmV4dCBtYWluIGxvb3AgaXRlcmF0aW9uIHRvIHByb2Nlc3MgdGhpcyB0YXNrIHByb2Nlc3NpbmcgcmVxdWVzdFxuICAgICAgICAgICAgaWYgKHRoaXMuX3RpY2tDYWxsQ291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIG9ubHkgb25lIHRpbWVyIGV4aXN0cyBhdCBhbnkgdGltZSBhdCBtYXhcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyTmV4dFRpY2soKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90aWNrVGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuX2JvdW5kVGljaywgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90aWNrQ2FsbENvdW50ID0gMDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9yIHN1YmNsYXNzIHRvIGltcGxlbWVudCB0YXNrIGxvZ2ljXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgVGFza0xvb3AucHJvdG90eXBlLmRvVGljayA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICByZXR1cm4gVGFza0xvb3A7XG59KGV2ZW50X2hhbmRsZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBUYXNrTG9vcDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9hdHRyLWxpc3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2F0dHItbGlzdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oTnVtYmVyKSB7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgREVDSU1BTF9SRVNPTFVUSU9OX1JFR0VYID0gL14oXFxkKyl4KFxcZCspJC87IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbnZhciBBVFRSX0xJU1RfUkVHRVggPSAvXFxzKiguKz8pXFxzKj0oKD86XFxcIi4qP1xcXCIpfC4qPykoPzosfCQpL2c7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbi8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20va2Fub25naWwvbm9kZS1tM3U4cGFyc2UvYmxvYi9tYXN0ZXIvYXR0cmxpc3QuanNcbnZhciBBdHRyTGlzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdHRyTGlzdChhdHRycykge1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYXR0cnMgPSBBdHRyTGlzdC5wYXJzZUF0dHJMaXN0KGF0dHJzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBhdHRyIGluIGF0dHJzKSB7XG4gICAgICAgICAgICBpZiAoYXR0cnMuaGFzT3duUHJvcGVydHkoYXR0cikpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2F0dHJdID0gYXR0cnNbYXR0cl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgQXR0ckxpc3QucHJvdG90eXBlLmRlY2ltYWxJbnRlZ2VyID0gZnVuY3Rpb24gKGF0dHJOYW1lKSB7XG4gICAgICAgIHZhciBpbnRWYWx1ZSA9IHBhcnNlSW50KHRoaXNbYXR0ck5hbWVdLCAxMCk7XG4gICAgICAgIGlmIChpbnRWYWx1ZSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludFZhbHVlO1xuICAgIH07XG4gICAgQXR0ckxpc3QucHJvdG90eXBlLmhleGFkZWNpbWFsSW50ZWdlciA9IGZ1bmN0aW9uIChhdHRyTmFtZSkge1xuICAgICAgICBpZiAodGhpc1thdHRyTmFtZV0pIHtcbiAgICAgICAgICAgIHZhciBzdHJpbmdWYWx1ZSA9ICh0aGlzW2F0dHJOYW1lXSB8fCAnMHgnKS5zbGljZSgyKTtcbiAgICAgICAgICAgIHN0cmluZ1ZhbHVlID0gKChzdHJpbmdWYWx1ZS5sZW5ndGggJiAxKSA/ICcwJyA6ICcnKSArIHN0cmluZ1ZhbHVlO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbmV3IFVpbnQ4QXJyYXkoc3RyaW5nVmFsdWUubGVuZ3RoIC8gMik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ1ZhbHVlLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhbHVlW2ldID0gcGFyc2VJbnQoc3RyaW5nVmFsdWUuc2xpY2UoaSAqIDIsIGkgKiAyICsgMiksIDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBdHRyTGlzdC5wcm90b3R5cGUuaGV4YWRlY2ltYWxJbnRlZ2VyQXNOdW1iZXIgPSBmdW5jdGlvbiAoYXR0ck5hbWUpIHtcbiAgICAgICAgdmFyIGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDE2KTtcbiAgICAgICAgaWYgKGludFZhbHVlID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50VmFsdWU7XG4gICAgfTtcbiAgICBBdHRyTGlzdC5wcm90b3R5cGUuZGVjaW1hbEZsb2F0aW5nUG9pbnQgPSBmdW5jdGlvbiAoYXR0ck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpc1thdHRyTmFtZV0pO1xuICAgIH07XG4gICAgQXR0ckxpc3QucHJvdG90eXBlLmVudW1lcmF0ZWRTdHJpbmcgPSBmdW5jdGlvbiAoYXR0ck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbYXR0ck5hbWVdO1xuICAgIH07XG4gICAgQXR0ckxpc3QucHJvdG90eXBlLmRlY2ltYWxSZXNvbHV0aW9uID0gZnVuY3Rpb24gKGF0dHJOYW1lKSB7XG4gICAgICAgIHZhciByZXMgPSBERUNJTUFMX1JFU09MVVRJT05fUkVHRVguZXhlYyh0aGlzW2F0dHJOYW1lXSk7XG4gICAgICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBwYXJzZUludChyZXNbMV0sIDEwKSxcbiAgICAgICAgICAgIGhlaWdodDogcGFyc2VJbnQocmVzWzJdLCAxMClcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEF0dHJMaXN0LnBhcnNlQXR0ckxpc3QgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgdmFyIG1hdGNoLCBhdHRycyA9IHt9O1xuICAgICAgICBBVFRSX0xJU1RfUkVHRVgubGFzdEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IEFUVFJfTElTVF9SRUdFWC5leGVjKGlucHV0KSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG1hdGNoWzJdLCBxdW90ZSA9ICdcIic7XG4gICAgICAgICAgICBpZiAodmFsdWUuaW5kZXhPZihxdW90ZSkgPT09IDAgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZS5sYXN0SW5kZXhPZihxdW90ZSkgPT09ICh2YWx1ZS5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXR0cnNbbWF0Y2hbMV1dID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgIH07XG4gICAgcmV0dXJuIEF0dHJMaXN0O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEF0dHJMaXN0O1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIuanNcIilbXCJOdW1iZXJcIl0pKVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9iaW5hcnktc2VhcmNoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvYmluYXJ5LXNlYXJjaC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQmluYXJ5U2VhcmNoID0ge1xuICAgIC8qKlxuICAgICAgICogU2VhcmNoZXMgZm9yIGFuIGl0ZW0gaW4gYW4gYXJyYXkgd2hpY2ggbWF0Y2hlcyBhIGNlcnRhaW4gY29uZGl0aW9uLlxuICAgICAgICogVGhpcyByZXF1aXJlcyB0aGUgY29uZGl0aW9uIHRvIG9ubHkgbWF0Y2ggb25lIGl0ZW0gaW4gdGhlIGFycmF5LFxuICAgICAgICogYW5kIGZvciB0aGUgYXJyYXkgdG8gYmUgb3JkZXJlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJpc29uRnVuY3Rpb25cbiAgICAgICAqICAgICAgQ2FsbGVkIGFuZCBwcm92aWRlZCBhIGNhbmRpZGF0ZSBpdGVtIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgICAgICAqICAgICAgU2hvdWxkIHJldHVybjpcbiAgICAgICAqICAgICAgICAgID4gLTEgaWYgdGhlIGl0ZW0gc2hvdWxkIGJlIGxvY2F0ZWQgYXQgYSBsb3dlciBpbmRleCB0aGFuIHRoZSBwcm92aWRlZCBpdGVtLlxuICAgICAgICogICAgICAgICAgPiAxIGlmIHRoZSBpdGVtIHNob3VsZCBiZSBsb2NhdGVkIGF0IGEgaGlnaGVyIGluZGV4IHRoYW4gdGhlIHByb3ZpZGVkIGl0ZW0uXG4gICAgICAgKiAgICAgICAgICA+IDAgaWYgdGhlIGl0ZW0gaXMgdGhlIGl0ZW0geW91J3JlIGxvb2tpbmcgZm9yLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4geyp9IFRoZSBvYmplY3QgaWYgaXQgaXMgZm91bmQgb3IgbnVsbCBvdGhlcndpc2UuXG4gICAgICAgKi9cbiAgICBzZWFyY2g6IGZ1bmN0aW9uIChsaXN0LCBjb21wYXJpc29uRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIG1pbkluZGV4ID0gMDtcbiAgICAgICAgdmFyIG1heEluZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gbnVsbDtcbiAgICAgICAgdmFyIGN1cnJlbnRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgd2hpbGUgKG1pbkluZGV4IDw9IG1heEluZGV4KSB7XG4gICAgICAgICAgICBjdXJyZW50SW5kZXggPSAobWluSW5kZXggKyBtYXhJbmRleCkgLyAyIHwgMDtcbiAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50ID0gbGlzdFtjdXJyZW50SW5kZXhdO1xuICAgICAgICAgICAgdmFyIGNvbXBhcmlzb25SZXN1bHQgPSBjb21wYXJpc29uRnVuY3Rpb24oY3VycmVudEVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGNvbXBhcmlzb25SZXN1bHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgbWluSW5kZXggPSBjdXJyZW50SW5kZXggKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29tcGFyaXNvblJlc3VsdCA8IDApIHtcbiAgICAgICAgICAgICAgICBtYXhJbmRleCA9IGN1cnJlbnRJbmRleCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJpbmFyeVNlYXJjaDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9idWZmZXItaGVscGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvYnVmZmVyLWhlbHBlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIEBtb2R1bGUgQnVmZmVySGVscGVyXG4gKlxuICogUHJvdmlkaW5nIG1ldGhvZHMgZGVhbGluZyB3aXRoIGJ1ZmZlciBsZW5ndGggcmV0cmlldmFsIGZvciBleGFtcGxlLlxuICpcbiAqIEluIGdlbmVyYWwsIGEgaGVscGVyIGFyb3VuZCBIVE1MNSBNZWRpYUVsZW1lbnQgVGltZVJhbmdlcyBnYXRoZXJlZCBmcm9tIGBidWZmZXJlZGAgcHJvcGVydHkuXG4gKlxuICogQWxzbyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MTWVkaWFFbGVtZW50L2J1ZmZlcmVkXG4qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEJ1ZmZlckhlbHBlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCdWZmZXJIZWxwZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGlmIGBtZWRpYWAncyBidWZmZXJlZCBpbmNsdWRlIGBwb3NpdGlvbmBcbiAgICAgKiBAcGFyYW0ge0hUTUxNZWRpYUVsZW1lbnR8U291cmNlQnVmZmVyfSBtZWRpYVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkID0gZnVuY3Rpb24gKG1lZGlhLCBwb3NpdGlvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmZlcmVkID0gbWVkaWEuYnVmZmVyZWQ7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPj0gYnVmZmVyZWQuc3RhcnQoaSkgJiYgcG9zaXRpb24gPD0gYnVmZmVyZWQuZW5kKGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gY2F0Y2hcbiAgICAgICAgICAgIC8vIEludmFsaWRTdGF0ZUVycm9yOiBGYWlsZWQgdG8gcmVhZCB0aGUgJ2J1ZmZlcmVkJyBwcm9wZXJ0eSBmcm9tICdTb3VyY2VCdWZmZXInOlxuICAgICAgICAgICAgLy8gVGhpcyBTb3VyY2VCdWZmZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQgbWVkaWEgc291cmNlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgQnVmZmVySGVscGVyLmJ1ZmZlckluZm8gPSBmdW5jdGlvbiAobWVkaWEsIHBvcywgbWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmJ1ZmZlcmVkID0gbWVkaWEuYnVmZmVyZWQsIGJ1ZmZlcmVkID0gW10sIGkgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJlZC5wdXNoKHsgc3RhcnQ6IHZidWZmZXJlZC5zdGFydChpKSwgZW5kOiB2YnVmZmVyZWQuZW5kKGkpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJlZEluZm8oYnVmZmVyZWQsIHBvcywgbWF4SG9sZUR1cmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gY2F0Y2hcbiAgICAgICAgICAgIC8vIEludmFsaWRTdGF0ZUVycm9yOiBGYWlsZWQgdG8gcmVhZCB0aGUgJ2J1ZmZlcmVkJyBwcm9wZXJ0eSBmcm9tICdTb3VyY2VCdWZmZXInOlxuICAgICAgICAgICAgLy8gVGhpcyBTb3VyY2VCdWZmZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQgbWVkaWEgc291cmNlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbGVuOiAwLCBzdGFydDogcG9zLCBlbmQ6IHBvcywgbmV4dFN0YXJ0OiB1bmRlZmluZWQgfTtcbiAgICB9O1xuICAgIEJ1ZmZlckhlbHBlci5idWZmZXJlZEluZm8gPSBmdW5jdGlvbiAoYnVmZmVyZWQsIHBvcywgbWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBidWZmZXJlZDIgPSBbXSwgXG4gICAgICAgIC8vIGJ1ZmZlclN0YXJ0IGFuZCBidWZmZXJFbmQgYXJlIGJ1ZmZlciBib3VuZGFyaWVzIGFyb3VuZCBjdXJyZW50IHZpZGVvIHBvc2l0aW9uXG4gICAgICAgIGJ1ZmZlckxlbiwgYnVmZmVyU3RhcnQsIGJ1ZmZlckVuZCwgYnVmZmVyU3RhcnROZXh0LCBpO1xuICAgICAgICAvLyBzb3J0IG9uIGJ1ZmZlci5zdGFydC9zbWFsbGVyIGVuZCAoSUUgZG9lcyBub3QgYWx3YXlzIHJldHVybiBzb3J0ZWQgYnVmZmVyZWQgcmFuZ2UpXG4gICAgICAgIGJ1ZmZlcmVkLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBkaWZmID0gYS5zdGFydCAtIGIuc3RhcnQ7XG4gICAgICAgICAgICBpZiAoZGlmZikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGIuZW5kIC0gYS5lbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB0aGVyZSBtaWdodCBiZSBzb21lIHNtYWxsIGhvbGVzIGJldHdlZW4gYnVmZmVyIHRpbWUgcmFuZ2VcbiAgICAgICAgLy8gY29uc2lkZXIgdGhhdCBob2xlcyBzbWFsbGVyIHRoYW4gbWF4SG9sZUR1cmF0aW9uIGFyZSBpcnJlbGV2YW50IGFuZCBidWlsZCBhbm90aGVyXG4gICAgICAgIC8vIGJ1ZmZlciB0aW1lIHJhbmdlIHJlcHJlc2VudGF0aW9ucyB0aGF0IGRpc2NhcmRzIHRob3NlIGhvbGVzXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJ1ZjJsZW4gPSBidWZmZXJlZDIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGJ1ZjJsZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgYnVmMmVuZCA9IGJ1ZmZlcmVkMltidWYybGVuIC0gMV0uZW5kO1xuICAgICAgICAgICAgICAgIC8vIGlmIHNtYWxsIGhvbGUgKHZhbHVlIGJldHdlZW4gMCBvciBtYXhIb2xlRHVyYXRpb24gKSBvciBvdmVybGFwcGluZyAobmVnYXRpdmUpXG4gICAgICAgICAgICAgICAgaWYgKChidWZmZXJlZFtpXS5zdGFydCAtIGJ1ZjJlbmQpIDwgbWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1lcmdlIG92ZXJsYXBwaW5nIHRpbWUgcmFuZ2VzXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBsYXN0UmFuZ2UuZW5kIG9ubHkgaWYgc21hbGxlciB0aGFuIGl0ZW0uZW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIGUuZy4gIFsgMSwgMTVdIHdpdGggIFsgMiw4XSA9PiBbIDEsMTVdIChubyBuZWVkIHRvIG1vZGlmeSBsYXN0UmFuZ2UuZW5kKVxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVyZWFzIFsgMSwgOF0gd2l0aCAgWyAyLDE1XSA9PiBbIDEsMTVdICggbGFzdFJhbmdlIHNob3VsZCBzd2l0Y2ggZnJvbSBbMSw4XSB0byBbMSwxNV0pXG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXJlZFtpXS5lbmQgPiBidWYyZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJlZDJbYnVmMmxlbiAtIDFdLmVuZCA9IGJ1ZmZlcmVkW2ldLmVuZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYmlnIGhvbGVcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyZWQyLnB1c2goYnVmZmVyZWRbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGZpcnN0IHZhbHVlXG4gICAgICAgICAgICAgICAgYnVmZmVyZWQyLnB1c2goYnVmZmVyZWRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDAsIGJ1ZmZlckxlbiA9IDAsIGJ1ZmZlclN0YXJ0ID0gYnVmZmVyRW5kID0gcG9zOyBpIDwgYnVmZmVyZWQyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBidWZmZXJlZDJbaV0uc3RhcnQsIGVuZCA9IGJ1ZmZlcmVkMltpXS5lbmQ7XG4gICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdidWYgc3RhcnQvZW5kOicgKyBidWZmZXJlZC5zdGFydChpKSArICcvJyArIGJ1ZmZlcmVkLmVuZChpKSk7XG4gICAgICAgICAgICBpZiAoKHBvcyArIG1heEhvbGVEdXJhdGlvbikgPj0gc3RhcnQgJiYgcG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gcGxheSBwb3NpdGlvbiBpcyBpbnNpZGUgdGhpcyBidWZmZXIgVGltZVJhbmdlLCByZXRyaWV2ZSBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uIGFuZCBidWZmZXIgbGVuZ3RoXG4gICAgICAgICAgICAgICAgYnVmZmVyU3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICBidWZmZXJFbmQgPSBlbmQ7XG4gICAgICAgICAgICAgICAgYnVmZmVyTGVuID0gYnVmZmVyRW5kIC0gcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKHBvcyArIG1heEhvbGVEdXJhdGlvbikgPCBzdGFydCkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlclN0YXJ0TmV4dCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxlbjogYnVmZmVyTGVuLCBzdGFydDogYnVmZmVyU3RhcnQsIGVuZDogYnVmZmVyRW5kLCBuZXh0U3RhcnQ6IGJ1ZmZlclN0YXJ0TmV4dCB9O1xuICAgIH07XG4gICAgcmV0dXJuIEJ1ZmZlckhlbHBlcjtcbn0oKSk7XG5leHBvcnRzLkJ1ZmZlckhlbHBlciA9IEJ1ZmZlckhlbHBlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9jZWEtNjA4LXBhcnNlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy9jZWEtNjA4LXBhcnNlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKlxuICogVGhpcyBjb2RlIHdhcyBwb3J0ZWQgZnJvbSB0aGUgZGFzaC5qcyBwcm9qZWN0IGF0OlxuICogICBodHRwczovL2dpdGh1Yi5jb20vRGFzaC1JbmR1c3RyeS1Gb3J1bS9kYXNoLmpzL2Jsb2IvZGV2ZWxvcG1lbnQvZXh0ZXJuYWxzL2NlYTYwOC1wYXJzZXIuanNcbiAqICAgaHR0cHM6Ly9naXRodWIuY29tL0Rhc2gtSW5kdXN0cnktRm9ydW0vZGFzaC5qcy9jb21taXQvODI2OWIyNmE3NjFlMDg1M2JiMjFkNzg3ODBlZDk0NTE0NGVjZGQ0ZCNkaWZmLTcxYmMyOTVhMmQ2YjZiNzA5M2ExZDMyOTBkNTNhNGIyXG4gKlxuICogVGhlIG9yaWdpbmFsIGNvcHlyaWdodCBhcHBlYXJzIGJlbG93OlxuICpcbiAqIFRoZSBjb3B5cmlnaHQgaW4gdGhpcyBzb2Z0d2FyZSBpcyBiZWluZyBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGUgQlNEIExpY2Vuc2UsXG4gKiBpbmNsdWRlZCBiZWxvdy4gVGhpcyBzb2Z0d2FyZSBtYXkgYmUgc3ViamVjdCB0byBvdGhlciB0aGlyZCBwYXJ0eSBhbmQgY29udHJpYnV0b3JcbiAqIHJpZ2h0cywgaW5jbHVkaW5nIHBhdGVudCByaWdodHMsIGFuZCBubyBzdWNoIHJpZ2h0cyBhcmUgZ3JhbnRlZCB1bmRlciB0aGlzIGxpY2Vuc2UuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LTIwMTYsIERBU0ggSW5kdXN0cnkgRm9ydW0uXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG4gKiBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKiAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gKiAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3JcbiAqICBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogIDIuIE5laXRoZXIgdGhlIG5hbWUgb2YgRGFzaCBJbmR1c3RyeSBGb3J1bSBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiAqICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBBUyBJUyBBTkQgQU5ZXG4gKiAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuICogIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC5cbiAqICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULFxuICogIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVRcbiAqICBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksXG4gKiAgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuICogIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiAgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cbi8qKlxuICAgICAqICBFeGNlcHRpb25zIGZyb20gcmVndWxhciBBU0NJSS4gQ29kZVBvaW50cyBhcmUgbWFwcGVkIHRvIFVURi0xNiBjb2Rlc1xuICAgICAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzID0ge1xuICAgIDB4MmE6IDB4ZTEsXG4gICAgMHg1YzogMHhlOSxcbiAgICAweDVlOiAweGVkLFxuICAgIDB4NWY6IDB4ZjMsXG4gICAgMHg2MDogMHhmYSxcbiAgICAweDdiOiAweGU3LFxuICAgIDB4N2M6IDB4ZjcsXG4gICAgMHg3ZDogMHhkMSxcbiAgICAweDdlOiAweGYxLFxuICAgIDB4N2Y6IDB4MjU4OCxcbiAgICAvLyBUSElTIEJMT0NLIElOQ0xVREVTIFRIRSAxNiBFWFRFTkRFRCAoVFdPLUJZVEUpIExJTkUgMjEgQ0hBUkFDVEVSU1xuICAgIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMSBBTkQgTE9XIEJFVFdFRU4gMHgzMCBBTkQgMHgzRlxuICAgIC8vIFRISVMgTUVBTlMgVEhBVCBcXHg1MCBNVVNUIEJFIEFEREVEIFRPIFRIRSBWQUxVRVNcbiAgICAweDgwOiAweGFlLFxuICAgIDB4ODE6IDB4YjAsXG4gICAgMHg4MjogMHhiZCxcbiAgICAweDgzOiAweGJmLFxuICAgIDB4ODQ6IDB4MjEyMixcbiAgICAweDg1OiAweGEyLFxuICAgIDB4ODY6IDB4YTMsXG4gICAgMHg4NzogMHgyNjZhLFxuICAgIDB4ODg6IDB4ZTAsXG4gICAgMHg4OTogMHgyMCxcbiAgICAweDhhOiAweGU4LFxuICAgIDB4OGI6IDB4ZTIsXG4gICAgMHg4YzogMHhlYSxcbiAgICAweDhkOiAweGVlLFxuICAgIDB4OGU6IDB4ZjQsXG4gICAgMHg4ZjogMHhmYixcbiAgICAvLyBUSElTIEJMT0NLIElOQ0xVREVTIFRIRSAzMiBFWFRFTkRFRCAoVFdPLUJZVEUpIExJTkUgMjEgQ0hBUkFDVEVSU1xuICAgIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMiBBTkQgTE9XIEJFVFdFRU4gMHgyMCBBTkQgMHgzRlxuICAgIDB4OTA6IDB4YzEsXG4gICAgMHg5MTogMHhjOSxcbiAgICAweDkyOiAweGQzLFxuICAgIDB4OTM6IDB4ZGEsXG4gICAgMHg5NDogMHhkYyxcbiAgICAweDk1OiAweGZjLFxuICAgIDB4OTY6IDB4MjAxOCxcbiAgICAweDk3OiAweGExLFxuICAgIDB4OTg6IDB4MmEsXG4gICAgMHg5OTogMHgyMDE5LFxuICAgIDB4OWE6IDB4MjUwMSxcbiAgICAweDliOiAweGE5LFxuICAgIDB4OWM6IDB4MjEyMCxcbiAgICAweDlkOiAweDIwMjIsXG4gICAgMHg5ZTogMHgyMDFjLFxuICAgIDB4OWY6IDB4MjAxZCxcbiAgICAweGEwOiAweGMwLFxuICAgIDB4YTE6IDB4YzIsXG4gICAgMHhhMjogMHhjNyxcbiAgICAweGEzOiAweGM4LFxuICAgIDB4YTQ6IDB4Y2EsXG4gICAgMHhhNTogMHhjYixcbiAgICAweGE2OiAweGViLFxuICAgIDB4YTc6IDB4Y2UsXG4gICAgMHhhODogMHhjZixcbiAgICAweGE5OiAweGVmLFxuICAgIDB4YWE6IDB4ZDQsXG4gICAgMHhhYjogMHhkOSxcbiAgICAweGFjOiAweGY5LFxuICAgIDB4YWQ6IDB4ZGIsXG4gICAgMHhhZTogMHhhYixcbiAgICAweGFmOiAweGJiLFxuICAgIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDMyIEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gICAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDEzIEFORCBMT1cgQkVUV0VFTiAweDIwIEFORCAweDNGXG4gICAgMHhiMDogMHhjMyxcbiAgICAweGIxOiAweGUzLFxuICAgIDB4YjI6IDB4Y2QsXG4gICAgMHhiMzogMHhjYyxcbiAgICAweGI0OiAweGVjLFxuICAgIDB4YjU6IDB4ZDIsXG4gICAgMHhiNjogMHhmMixcbiAgICAweGI3OiAweGQ1LFxuICAgIDB4Yjg6IDB4ZjUsXG4gICAgMHhiOTogMHg3YixcbiAgICAweGJhOiAweDdkLFxuICAgIDB4YmI6IDB4NWMsXG4gICAgMHhiYzogMHg1ZSxcbiAgICAweGJkOiAweDVmLFxuICAgIDB4YmU6IDB4N2MsXG4gICAgMHhiZjogMHgyMjNjLFxuICAgIDB4YzA6IDB4YzQsXG4gICAgMHhjMTogMHhlNCxcbiAgICAweGMyOiAweGQ2LFxuICAgIDB4YzM6IDB4ZjYsXG4gICAgMHhjNDogMHhkZixcbiAgICAweGM1OiAweGE1LFxuICAgIDB4YzY6IDB4YTQsXG4gICAgMHhjNzogMHgyNTAzLFxuICAgIDB4Yzg6IDB4YzUsXG4gICAgMHhjOTogMHhlNSxcbiAgICAweGNhOiAweGQ4LFxuICAgIDB4Y2I6IDB4ZjgsXG4gICAgMHhjYzogMHgyNTBmLFxuICAgIDB4Y2Q6IDB4MjUxMyxcbiAgICAweGNlOiAweDI1MTcsXG4gICAgMHhjZjogMHgyNTFiIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB1cCBhbmQgbGVmdFxufTtcbi8qKlxuICogVXRpbHNcbiAqL1xudmFyIGdldENoYXJGb3JCeXRlID0gZnVuY3Rpb24gKGJ5dGUpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBieXRlO1xuICAgIGlmIChzcGVjaWFsQ2VhNjA4Q2hhcnNDb2Rlcy5oYXNPd25Qcm9wZXJ0eShieXRlKSkge1xuICAgICAgICBjaGFyQ29kZSA9IHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzW2J5dGVdO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG59O1xudmFyIE5SX1JPV1MgPSAxNSwgTlJfQ09MUyA9IDEwMDtcbi8vIFRhYmxlcyB0byBsb29rIHVwIHJvdyBmcm9tIFBBQyBkYXRhXG52YXIgcm93c0xvd0NoMSA9IHsgMHgxMTogMSwgMHgxMjogMywgMHgxNTogNSwgMHgxNjogNywgMHgxNzogOSwgMHgxMDogMTEsIDB4MTM6IDEyLCAweDE0OiAxNCB9O1xudmFyIHJvd3NIaWdoQ2gxID0geyAweDExOiAyLCAweDEyOiA0LCAweDE1OiA2LCAweDE2OiA4LCAweDE3OiAxMCwgMHgxMzogMTMsIDB4MTQ6IDE1IH07XG52YXIgcm93c0xvd0NoMiA9IHsgMHgxOTogMSwgMHgxQTogMywgMHgxRDogNSwgMHgxRTogNywgMHgxRjogOSwgMHgxODogMTEsIDB4MUI6IDEyLCAweDFDOiAxNCB9O1xudmFyIHJvd3NIaWdoQ2gyID0geyAweDE5OiAyLCAweDFBOiA0LCAweDFEOiA2LCAweDFFOiA4LCAweDFGOiAxMCwgMHgxQjogMTMsIDB4MUM6IDE1IH07XG52YXIgYmFja2dyb3VuZENvbG9ycyA9IFsnd2hpdGUnLCAnZ3JlZW4nLCAnYmx1ZScsICdjeWFuJywgJ3JlZCcsICd5ZWxsb3cnLCAnbWFnZW50YScsICdibGFjaycsICd0cmFuc3BhcmVudCddO1xuLyoqXG4gKiBTaW1wbGUgbG9nZ2VyIGNsYXNzIHRvIGJlIGFibGUgdG8gd3JpdGUgd2l0aCB0aW1lLXN0YW1wcyBhbmQgZmlsdGVyIG9uIGxldmVsLlxuICovXG52YXIgbG9nZ2VyID0ge1xuICAgIHZlcmJvc2VGaWx0ZXI6IHsgJ0RBVEEnOiAzLCAnREVCVUcnOiAzLCAnSU5GTyc6IDIsICdXQVJOSU5HJzogMiwgJ1RFWFQnOiAxLCAnRVJST1InOiAwIH0sXG4gICAgdGltZTogbnVsbCxcbiAgICB2ZXJib3NlTGV2ZWw6IDAsXG4gICAgc2V0VGltZTogZnVuY3Rpb24gKG5ld1RpbWUpIHtcbiAgICAgICAgdGhpcy50aW1lID0gbmV3VGltZTtcbiAgICB9LFxuICAgIGxvZzogZnVuY3Rpb24gKHNldmVyaXR5LCBtc2cpIHtcbiAgICAgICAgdmFyIG1pbkxldmVsID0gdGhpcy52ZXJib3NlRmlsdGVyW3NldmVyaXR5XTtcbiAgICAgICAgaWYgKHRoaXMudmVyYm9zZUxldmVsID49IG1pbkxldmVsKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnRpbWUgKyAnIFsnICsgc2V2ZXJpdHkgKyAnXSAnICsgbXNnKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG52YXIgbnVtQXJyYXlUb0hleEFycmF5ID0gZnVuY3Rpb24gKG51bUFycmF5KSB7XG4gICAgdmFyIGhleEFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1BcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgICBoZXhBcnJheS5wdXNoKG51bUFycmF5W2pdLnRvU3RyaW5nKDE2KSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhBcnJheTtcbn07XG52YXIgUGVuU3RhdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGVuU3RhdGUoZm9yZWdyb3VuZCwgdW5kZXJsaW5lLCBpdGFsaWNzLCBiYWNrZ3JvdW5kLCBmbGFzaCkge1xuICAgICAgICB0aGlzLmZvcmVncm91bmQgPSBmb3JlZ3JvdW5kIHx8ICd3aGl0ZSc7XG4gICAgICAgIHRoaXMudW5kZXJsaW5lID0gdW5kZXJsaW5lIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLml0YWxpY3MgPSBpdGFsaWNzIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kIHx8ICdibGFjayc7XG4gICAgICAgIHRoaXMuZmxhc2ggPSBmbGFzaCB8fCBmYWxzZTtcbiAgICB9XG4gICAgUGVuU3RhdGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZvcmVncm91bmQgPSAnd2hpdGUnO1xuICAgICAgICB0aGlzLnVuZGVybGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLml0YWxpY3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gJ2JsYWNrJztcbiAgICAgICAgdGhpcy5mbGFzaCA9IGZhbHNlO1xuICAgIH07XG4gICAgUGVuU3RhdGUucHJvdG90eXBlLnNldFN0eWxlcyA9IGZ1bmN0aW9uIChzdHlsZXMpIHtcbiAgICAgICAgdmFyIGF0dHJpYnMgPSBbJ2ZvcmVncm91bmQnLCAndW5kZXJsaW5lJywgJ2l0YWxpY3MnLCAnYmFja2dyb3VuZCcsICdmbGFzaCddO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGF0dHJpYnNbaV07XG4gICAgICAgICAgICBpZiAoc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlKSkge1xuICAgICAgICAgICAgICAgIHRoaXNbc3R5bGVdID0gc3R5bGVzW3N0eWxlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUGVuU3RhdGUucHJvdG90eXBlLmlzRGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZvcmVncm91bmQgPT09ICd3aGl0ZScgJiYgIXRoaXMudW5kZXJsaW5lICYmICF0aGlzLml0YWxpY3MgJiZcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZCA9PT0gJ2JsYWNrJyAmJiAhdGhpcy5mbGFzaCk7XG4gICAgfTtcbiAgICBQZW5TdGF0ZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAoKHRoaXMuZm9yZWdyb3VuZCA9PT0gb3RoZXIuZm9yZWdyb3VuZCkgJiZcbiAgICAgICAgICAgICh0aGlzLnVuZGVybGluZSA9PT0gb3RoZXIudW5kZXJsaW5lKSAmJlxuICAgICAgICAgICAgKHRoaXMuaXRhbGljcyA9PT0gb3RoZXIuaXRhbGljcykgJiZcbiAgICAgICAgICAgICh0aGlzLmJhY2tncm91bmQgPT09IG90aGVyLmJhY2tncm91bmQpICYmXG4gICAgICAgICAgICAodGhpcy5mbGFzaCA9PT0gb3RoZXIuZmxhc2gpKTtcbiAgICB9O1xuICAgIFBlblN0YXRlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKG5ld1BlblN0YXRlKSB7XG4gICAgICAgIHRoaXMuZm9yZWdyb3VuZCA9IG5ld1BlblN0YXRlLmZvcmVncm91bmQ7XG4gICAgICAgIHRoaXMudW5kZXJsaW5lID0gbmV3UGVuU3RhdGUudW5kZXJsaW5lO1xuICAgICAgICB0aGlzLml0YWxpY3MgPSBuZXdQZW5TdGF0ZS5pdGFsaWNzO1xuICAgICAgICB0aGlzLmJhY2tncm91bmQgPSBuZXdQZW5TdGF0ZS5iYWNrZ3JvdW5kO1xuICAgICAgICB0aGlzLmZsYXNoID0gbmV3UGVuU3RhdGUuZmxhc2g7XG4gICAgfTtcbiAgICBQZW5TdGF0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoJ2NvbG9yPScgKyB0aGlzLmZvcmVncm91bmQgKyAnLCB1bmRlcmxpbmU9JyArIHRoaXMudW5kZXJsaW5lICsgJywgaXRhbGljcz0nICsgdGhpcy5pdGFsaWNzICtcbiAgICAgICAgICAgICcsIGJhY2tncm91bmQ9JyArIHRoaXMuYmFja2dyb3VuZCArICcsIGZsYXNoPScgKyB0aGlzLmZsYXNoKTtcbiAgICB9O1xuICAgIHJldHVybiBQZW5TdGF0ZTtcbn0oKSk7XG4vKipcbiAqIFVuaWNvZGUgY2hhcmFjdGVyIHdpdGggc3R5bGluZyBhbmQgYmFja2dyb3VuZC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgU3R5bGVkVW5pY29kZUNoYXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3R5bGVkVW5pY29kZUNoYXIodWNoYXIsIGZvcmVncm91bmQsIHVuZGVybGluZSwgaXRhbGljcywgYmFja2dyb3VuZCwgZmxhc2gpIHtcbiAgICAgICAgdGhpcy51Y2hhciA9IHVjaGFyIHx8ICcgJzsgLy8gdW5pY29kZSBjaGFyYWN0ZXJcbiAgICAgICAgdGhpcy5wZW5TdGF0ZSA9IG5ldyBQZW5TdGF0ZShmb3JlZ3JvdW5kLCB1bmRlcmxpbmUsIGl0YWxpY3MsIGJhY2tncm91bmQsIGZsYXNoKTtcbiAgICB9XG4gICAgU3R5bGVkVW5pY29kZUNoYXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVjaGFyID0gJyAnO1xuICAgICAgICB0aGlzLnBlblN0YXRlLnJlc2V0KCk7XG4gICAgfTtcbiAgICBTdHlsZWRVbmljb2RlQ2hhci5wcm90b3R5cGUuc2V0Q2hhciA9IGZ1bmN0aW9uICh1Y2hhciwgbmV3UGVuU3RhdGUpIHtcbiAgICAgICAgdGhpcy51Y2hhciA9IHVjaGFyO1xuICAgICAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3UGVuU3RhdGUpO1xuICAgIH07XG4gICAgU3R5bGVkVW5pY29kZUNoYXIucHJvdG90eXBlLnNldFBlblN0YXRlID0gZnVuY3Rpb24gKG5ld1BlblN0YXRlKSB7XG4gICAgICAgIHRoaXMucGVuU3RhdGUuY29weShuZXdQZW5TdGF0ZSk7XG4gICAgfTtcbiAgICBTdHlsZWRVbmljb2RlQ2hhci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVjaGFyID09PSBvdGhlci51Y2hhciAmJiB0aGlzLnBlblN0YXRlLmVxdWFscyhvdGhlci5wZW5TdGF0ZSk7XG4gICAgfTtcbiAgICBTdHlsZWRVbmljb2RlQ2hhci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIChuZXdDaGFyKSB7XG4gICAgICAgIHRoaXMudWNoYXIgPSBuZXdDaGFyLnVjaGFyO1xuICAgICAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3Q2hhci5wZW5TdGF0ZSk7XG4gICAgfTtcbiAgICBTdHlsZWRVbmljb2RlQ2hhci5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudWNoYXIgPT09ICcgJyAmJiB0aGlzLnBlblN0YXRlLmlzRGVmYXVsdCgpO1xuICAgIH07XG4gICAgcmV0dXJuIFN0eWxlZFVuaWNvZGVDaGFyO1xufSgpKTtcbi8qKlxuICogQ0VBLTYwOCByb3cgY29uc2lzdGluZyBvZiBOUl9DT0xTIGluc3RhbmNlcyBvZiBTdHlsZWRVbmljb2RlQ2hhci5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgUm93ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJvdygpIHtcbiAgICAgICAgdGhpcy5jaGFycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jaGFycy5wdXNoKG5ldyBTdHlsZWRVbmljb2RlQ2hhcigpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuY3VyclBlblN0YXRlID0gbmV3IFBlblN0YXRlKCk7XG4gICAgfVxuICAgIFJvdy5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHZhciBlcXVhbCA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2hhcnNbaV0uZXF1YWxzKG90aGVyLmNoYXJzW2ldKSkge1xuICAgICAgICAgICAgICAgIGVxdWFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVxdWFsO1xuICAgIH07XG4gICAgUm93LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmNoYXJzW2ldLmNvcHkob3RoZXIuY2hhcnNbaV0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSb3cucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbXB0eSA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2hhcnNbaV0uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW1wdHk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgICAqICBTZXQgdGhlIGN1cnNvciB0byBhIHZhbGlkIGNvbHVtbi5cbiAgICAgICAqL1xuICAgIFJvdy5wcm90b3R5cGUuc2V0Q3Vyc29yID0gZnVuY3Rpb24gKGFic1Bvcykge1xuICAgICAgICBpZiAodGhpcy5wb3MgIT09IGFic1Bvcykge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBhYnNQb3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9zIDwgMCkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnRVJST1InLCAnTmVnYXRpdmUgY3Vyc29yIHBvc2l0aW9uICcgKyB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wb3MgPiBOUl9DT0xTKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdFUlJPUicsICdUb28gbGFyZ2UgY3Vyc29yIHBvc2l0aW9uICcgKyB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IE5SX0NPTFM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAgICogTW92ZSB0aGUgY3Vyc29yIHJlbGF0aXZlIHRvIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgKi9cbiAgICBSb3cucHJvdG90eXBlLm1vdmVDdXJzb3IgPSBmdW5jdGlvbiAocmVsUG9zKSB7XG4gICAgICAgIHZhciBuZXdQb3MgPSB0aGlzLnBvcyArIHJlbFBvcztcbiAgICAgICAgaWYgKHJlbFBvcyA+IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnBvcyArIDE7IGkgPCBuZXdQb3MgKyAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJzW2ldLnNldFBlblN0YXRlKHRoaXMuY3VyclBlblN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEN1cnNvcihuZXdQb3MpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICAgKiBCYWNrc3BhY2UsIG1vdmUgb25lIHN0ZXAgYmFjayBhbmQgY2xlYXIgY2hhcmFjdGVyLlxuICAgICAgICovXG4gICAgUm93LnByb3RvdHlwZS5iYWNrU3BhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubW92ZUN1cnNvcigtMSk7XG4gICAgICAgIHRoaXMuY2hhcnNbdGhpcy5wb3NdLnNldENoYXIoJyAnLCB0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gICAgfTtcbiAgICBSb3cucHJvdG90eXBlLmluc2VydENoYXIgPSBmdW5jdGlvbiAoYnl0ZSkge1xuICAgICAgICBpZiAoYnl0ZSA+PSAweDkwKSB7IC8vIEV4dGVuZGVkIGNoYXJcbiAgICAgICAgICAgIHRoaXMuYmFja1NwYWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYXIgPSBnZXRDaGFyRm9yQnl0ZShieXRlKTtcbiAgICAgICAgaWYgKHRoaXMucG9zID49IE5SX0NPTFMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0VSUk9SJywgJ0Nhbm5vdCBpbnNlcnQgJyArIGJ5dGUudG9TdHJpbmcoMTYpICtcbiAgICAgICAgICAgICAgICAnICgnICsgY2hhciArICcpIGF0IHBvc2l0aW9uICcgKyB0aGlzLnBvcyArICcuIFNraXBwaW5nIGl0IScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhcnNbdGhpcy5wb3NdLnNldENoYXIoY2hhciwgdGhpcy5jdXJyUGVuU3RhdGUpO1xuICAgICAgICB0aGlzLm1vdmVDdXJzb3IoMSk7XG4gICAgfTtcbiAgICBSb3cucHJvdG90eXBlLmNsZWFyRnJvbVBvcyA9IGZ1bmN0aW9uIChzdGFydFBvcykge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gc3RhcnRQb3M7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuY2hhcnNbaV0ucmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm93LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jbGVhckZyb21Qb3MoMCk7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5jdXJyUGVuU3RhdGUucmVzZXQoKTtcbiAgICB9O1xuICAgIFJvdy5wcm90b3R5cGUuY2xlYXJUb0VuZE9mUm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsZWFyRnJvbVBvcyh0aGlzLnBvcyk7XG4gICAgfTtcbiAgICBSb3cucHJvdG90eXBlLmdldFRleHRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGFycyA9IFtdO1xuICAgICAgICB2YXIgZW1wdHkgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoYXIgPSB0aGlzLmNoYXJzW2ldLnVjaGFyO1xuICAgICAgICAgICAgaWYgKGNoYXIgIT09ICcgJykge1xuICAgICAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFycy5wdXNoKGNoYXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSb3cucHJvdG90eXBlLnNldFBlblN0eWxlcyA9IGZ1bmN0aW9uIChzdHlsZXMpIHtcbiAgICAgICAgdGhpcy5jdXJyUGVuU3RhdGUuc2V0U3R5bGVzKHN0eWxlcyk7XG4gICAgICAgIHZhciBjdXJyQ2hhciA9IHRoaXMuY2hhcnNbdGhpcy5wb3NdO1xuICAgICAgICBjdXJyQ2hhci5zZXRQZW5TdGF0ZSh0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gUm93O1xufSgpKTtcbi8qKlxuICogS2VlcCBhIENFQS02MDggc2NyZWVuIG9mIDMyeDE1IHN0eWxlZCBjaGFyYWN0ZXJzXG4gKiBAY29uc3RydWN0b3JcbiovXG52YXIgQ2FwdGlvblNjcmVlbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYXB0aW9uU2NyZWVuKCkge1xuICAgICAgICB0aGlzLnJvd3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucm93cy5wdXNoKG5ldyBSb3coKSk7XG4gICAgICAgIH0gLy8gTm90ZSB0aGF0IHdlIHVzZSB6ZXJvLWJhc2VkIG51bWJlcmluZyAoMC0xNClcbiAgICAgICAgdGhpcy5jdXJyUm93ID0gTlJfUk9XUyAtIDE7XG4gICAgICAgIHRoaXMubnJSb2xsVXBSb3dzID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cbiAgICBDYXB0aW9uU2NyZWVuLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucm93c1tpXS5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VyclJvdyA9IE5SX1JPV1MgLSAxO1xuICAgIH07XG4gICAgQ2FwdGlvblNjcmVlbi5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHZhciBlcXVhbCA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucm93c1tpXS5lcXVhbHMob3RoZXIucm93c1tpXSkpIHtcbiAgICAgICAgICAgICAgICBlcXVhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcXVhbDtcbiAgICB9O1xuICAgIENhcHRpb25TY3JlZW4ucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucm93c1tpXS5jb3B5KG90aGVyLnJvd3NbaV0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDYXB0aW9uU2NyZWVuLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZW1wdHkgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJvd3NbaV0uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW1wdHk7XG4gICAgfTtcbiAgICBDYXB0aW9uU2NyZWVuLnByb3RvdHlwZS5iYWNrU3BhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICAgICAgcm93LmJhY2tTcGFjZSgpO1xuICAgIH07XG4gICAgQ2FwdGlvblNjcmVlbi5wcm90b3R5cGUuY2xlYXJUb0VuZE9mUm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgICAgIHJvdy5jbGVhclRvRW5kT2ZSb3coKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAgICogSW5zZXJ0IGEgY2hhcmFjdGVyICh3aXRob3V0IHN0eWxpbmcpIGluIHRoZSBjdXJyZW50IHJvdy5cbiAgICAgICAqL1xuICAgIENhcHRpb25TY3JlZW4ucHJvdG90eXBlLmluc2VydENoYXIgPSBmdW5jdGlvbiAoY2hhcikge1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgICAgIHJvdy5pbnNlcnRDaGFyKGNoYXIpO1xuICAgIH07XG4gICAgQ2FwdGlvblNjcmVlbi5wcm90b3R5cGUuc2V0UGVuID0gZnVuY3Rpb24gKHN0eWxlcykge1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgICAgIHJvdy5zZXRQZW5TdHlsZXMoc3R5bGVzKTtcbiAgICB9O1xuICAgIENhcHRpb25TY3JlZW4ucHJvdG90eXBlLm1vdmVDdXJzb3IgPSBmdW5jdGlvbiAocmVsUG9zKSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICAgICAgcm93Lm1vdmVDdXJzb3IocmVsUG9zKTtcbiAgICB9O1xuICAgIENhcHRpb25TY3JlZW4ucHJvdG90eXBlLnNldEN1cnNvciA9IGZ1bmN0aW9uIChhYnNQb3MpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdzZXRDdXJzb3I6ICcgKyBhYnNQb3MpO1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgICAgIHJvdy5zZXRDdXJzb3IoYWJzUG9zKTtcbiAgICB9O1xuICAgIENhcHRpb25TY3JlZW4ucHJvdG90eXBlLnNldFBBQyA9IGZ1bmN0aW9uIChwYWNEYXRhKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAncGFjRGF0YSA9ICcgKyBKU09OLnN0cmluZ2lmeShwYWNEYXRhKSk7XG4gICAgICAgIHZhciBuZXdSb3cgPSBwYWNEYXRhLnJvdyAtIDE7XG4gICAgICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyAmJiBuZXdSb3cgPCB0aGlzLm5yUm9sbFVwUm93cyAtIDEpIHtcbiAgICAgICAgICAgIG5ld1JvdyA9IHRoaXMubnJSb2xsVXBSb3dzIC0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhpcyBvbmx5IGFmZmVjdHMgUm9sbC11cCBDYXB0aW9ucyBieSBjaGVja2luZyB0aGlzLm5yUm9sbFVwUm93c1xuICAgICAgICBpZiAodGhpcy5uclJvbGxVcFJvd3MgJiYgdGhpcy5jdXJyUm93ICE9PSBuZXdSb3cpIHtcbiAgICAgICAgICAgIC8vIGNsZWFyIGFsbCByb3dzIGZpcnN0XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucm93c1tpXS5jbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29weSB0aGlzLm5yUm9sbFVwUm93cyByb3dzIGZyb20gbGFzdE91dHB1dFNjcmVlbiBhbmQgcGxhY2UgaXQgaW4gdGhlIG5ld1JvdyBsb2NhdGlvblxuICAgICAgICAgICAgLy8gdG9wUm93SW5kZXggLSB0aGUgc3RhcnQgb2Ygcm93cyB0byBjb3B5IChpbmNsdXNpdmUgaW5kZXgpXG4gICAgICAgICAgICB2YXIgdG9wUm93SW5kZXggPSB0aGlzLmN1cnJSb3cgKyAxIC0gKHRoaXMubnJSb2xsVXBSb3dzKTtcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgY29weSBpZiB0aGUgbGFzdCBwb3NpdGlvbiB3YXMgYWxyZWFkeSBzaG93bi5cbiAgICAgICAgICAgIC8vIFdlIHVzZSB0aGUgY3VlU3RhcnRUaW1lIHZhbHVlIHRvIGNoZWNrIHRoaXMuXG4gICAgICAgICAgICB2YXIgbGFzdE91dHB1dFNjcmVlbiA9IHRoaXMubGFzdE91dHB1dFNjcmVlbjtcbiAgICAgICAgICAgIGlmIChsYXN0T3V0cHV0U2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZMaW5lVGltZSA9IGxhc3RPdXRwdXRTY3JlZW4ucm93c1t0b3BSb3dJbmRleF0uY3VlU3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2TGluZVRpbWUgJiYgcHJldkxpbmVUaW1lIDwgbG9nZ2VyLnRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm5yUm9sbFVwUm93czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd3NbbmV3Um93IC0gdGhpcy5uclJvbGxVcFJvd3MgKyBpICsgMV0uY29weShsYXN0T3V0cHV0U2NyZWVuLnJvd3NbdG9wUm93SW5kZXggKyBpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyUm93ID0gbmV3Um93O1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgICAgIGlmIChwYWNEYXRhLmluZGVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGluZGVudCA9IHBhY0RhdGEuaW5kZW50O1xuICAgICAgICAgICAgdmFyIHByZXZQb3MgPSBNYXRoLm1heChpbmRlbnQgLSAxLCAwKTtcbiAgICAgICAgICAgIHJvdy5zZXRDdXJzb3IocGFjRGF0YS5pbmRlbnQpO1xuICAgICAgICAgICAgcGFjRGF0YS5jb2xvciA9IHJvdy5jaGFyc1twcmV2UG9zXS5wZW5TdGF0ZS5mb3JlZ3JvdW5kO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHlsZXMgPSB7IGZvcmVncm91bmQ6IHBhY0RhdGEuY29sb3IsIHVuZGVybGluZTogcGFjRGF0YS51bmRlcmxpbmUsIGl0YWxpY3M6IHBhY0RhdGEuaXRhbGljcywgYmFja2dyb3VuZDogJ2JsYWNrJywgZmxhc2g6IGZhbHNlIH07XG4gICAgICAgIHRoaXMuc2V0UGVuKHN0eWxlcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgICAqIFNldCBiYWNrZ3JvdW5kL2V4dHJhIGZvcmVncm91bmQsIGJ1dCBmaXJzdCBkbyBiYWNrX3NwYWNlLCBhbmQgdGhlbiBpbnNlcnQgc3BhY2UgKGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KS5cbiAgICAgICAqL1xuICAgIENhcHRpb25TY3JlZW4ucHJvdG90eXBlLnNldEJrZ0RhdGEgPSBmdW5jdGlvbiAoYmtnRGF0YSkge1xuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ2JrZ0RhdGEgPSAnICsgSlNPTi5zdHJpbmdpZnkoYmtnRGF0YSkpO1xuICAgICAgICB0aGlzLmJhY2tTcGFjZSgpO1xuICAgICAgICB0aGlzLnNldFBlbihia2dEYXRhKTtcbiAgICAgICAgdGhpcy5pbnNlcnRDaGFyKDB4MjApOyAvLyBTcGFjZVxuICAgIH07XG4gICAgQ2FwdGlvblNjcmVlbi5wcm90b3R5cGUuc2V0Um9sbFVwUm93cyA9IGZ1bmN0aW9uIChuclJvd3MpIHtcbiAgICAgICAgdGhpcy5uclJvbGxVcFJvd3MgPSBuclJvd3M7XG4gICAgfTtcbiAgICBDYXB0aW9uU2NyZWVuLnByb3RvdHlwZS5yb2xsVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnREVCVUcnLCAncm9sbF91cCBidXQgbnJSb2xsVXBSb3dzIG5vdCBzZXQgeWV0Jyk7XG4gICAgICAgICAgICByZXR1cm47IC8vIE5vdCBwcm9wZXJseSBzZXR1cFxuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5sb2coJ1RFWFQnLCB0aGlzLmdldERpc3BsYXlUZXh0KCkpO1xuICAgICAgICB2YXIgdG9wUm93SW5kZXggPSB0aGlzLmN1cnJSb3cgKyAxIC0gdGhpcy5uclJvbGxVcFJvd3M7XG4gICAgICAgIHZhciB0b3BSb3cgPSB0aGlzLnJvd3Muc3BsaWNlKHRvcFJvd0luZGV4LCAxKVswXTtcbiAgICAgICAgdG9wUm93LmNsZWFyKCk7XG4gICAgICAgIHRoaXMucm93cy5zcGxpY2UodGhpcy5jdXJyUm93LCAwLCB0b3BSb3cpO1xuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JvbGxpbmcgdXAnKTtcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnVEVYVCcsIHRoaXMuZ2V0X2Rpc3BsYXlfdGV4dCgpKVxuICAgIH07XG4gICAgLyoqXG4gICAgICAqIEdldCBhbGwgbm9uLWVtcHR5IHJvd3Mgd2l0aCBhcyB1bmljb2RlIHRleHQuXG4gICAgICAqL1xuICAgIENhcHRpb25TY3JlZW4ucHJvdG90eXBlLmdldERpc3BsYXlUZXh0ID0gZnVuY3Rpb24gKGFzT25lUm93KSB7XG4gICAgICAgIGFzT25lUm93ID0gYXNPbmVSb3cgfHwgZmFsc2U7XG4gICAgICAgIHZhciBkaXNwbGF5VGV4dCA9IFtdO1xuICAgICAgICB2YXIgdGV4dCA9ICcnO1xuICAgICAgICB2YXIgcm93TnIgPSAtMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByb3dUZXh0ID0gdGhpcy5yb3dzW2ldLmdldFRleHRTdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChyb3dUZXh0KSB7XG4gICAgICAgICAgICAgICAgcm93TnIgPSBpICsgMTtcbiAgICAgICAgICAgICAgICBpZiAoYXNPbmVSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheVRleHQucHVzaCgnUm93ICcgKyByb3dOciArICc6IFxcJycgKyByb3dUZXh0ICsgJ1xcJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheVRleHQucHVzaChyb3dUZXh0LnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkaXNwbGF5VGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoYXNPbmVSb3cpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gJ1snICsgZGlzcGxheVRleHQuam9pbignIHwgJykgKyAnXSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZGlzcGxheVRleHQuam9pbignXFxuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcbiAgICBDYXB0aW9uU2NyZWVuLnByb3RvdHlwZS5nZXRUZXh0QW5kRm9ybWF0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dzO1xuICAgIH07XG4gICAgcmV0dXJuIENhcHRpb25TY3JlZW47XG59KCkpO1xuLy8gdmFyIG1vZGVzID0gWydNT0RFX1JPTEwtVVAnLCAnTU9ERV9QT1AtT04nLCAnTU9ERV9QQUlOVC1PTicsICdNT0RFX1RFWFQnXTtcbnZhciBDZWE2MDhDaGFubmVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENlYTYwOENoYW5uZWwoY2hhbm5lbE51bWJlciwgb3V0cHV0RmlsdGVyKSB7XG4gICAgICAgIHRoaXMuY2hOciA9IGNoYW5uZWxOdW1iZXI7XG4gICAgICAgIHRoaXMub3V0cHV0RmlsdGVyID0gb3V0cHV0RmlsdGVyO1xuICAgICAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLnZlcmJvc2UgPSAwO1xuICAgICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeSA9IG5ldyBDYXB0aW9uU2NyZWVuKCk7XG4gICAgICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5ID0gbmV3IENhcHRpb25TY3JlZW4oKTtcbiAgICAgICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuID0gbmV3IENhcHRpb25TY3JlZW4oKTtcbiAgICAgICAgdGhpcy5jdXJyUm9sbFVwUm93ID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkucm93c1tOUl9ST1dTIC0gMV07XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsOyAvLyBLZWVwcyB0cmFjayBvZiB3aGVyZSBhIGN1ZSBzdGFydGVkLlxuICAgIH1cbiAgICBDZWE2MDhDaGFubmVsLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcbiAgICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcbiAgICAgICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuY3VyclJvbGxVcFJvdyA9IHRoaXMuZGlzcGxheWVkTWVtb3J5LnJvd3NbTlJfUk9XUyAtIDFdO1xuICAgICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0Q3VlRW5kVGltZSA9IG51bGw7XG4gICAgfTtcbiAgICBDZWE2MDhDaGFubmVsLnByb3RvdHlwZS5nZXRIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRwdXRGaWx0ZXI7XG4gICAgfTtcbiAgICBDZWE2MDhDaGFubmVsLnByb3RvdHlwZS5zZXRIYW5kbGVyID0gZnVuY3Rpb24gKG5ld0hhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIgPSBuZXdIYW5kbGVyO1xuICAgIH07XG4gICAgQ2VhNjA4Q2hhbm5lbC5wcm90b3R5cGUuc2V0UEFDID0gZnVuY3Rpb24gKHBhY0RhdGEpIHtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQQUMocGFjRGF0YSk7XG4gICAgfTtcbiAgICBDZWE2MDhDaGFubmVsLnByb3RvdHlwZS5zZXRCa2dEYXRhID0gZnVuY3Rpb24gKGJrZ0RhdGEpIHtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5zZXRCa2dEYXRhKGJrZ0RhdGEpO1xuICAgIH07XG4gICAgQ2VhNjA4Q2hhbm5lbC5wcm90b3R5cGUuc2V0TW9kZSA9IGZ1bmN0aW9uIChuZXdNb2RlKSB7XG4gICAgICAgIGlmIChuZXdNb2RlID09PSB0aGlzLm1vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGUgPSBuZXdNb2RlO1xuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ01PREU9JyArIG5ld01vZGUpO1xuICAgICAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9QT1AtT04nKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgICAgICAgICB0aGlzLndyaXRlU2NyZWVuLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kZSAhPT0gJ01PREVfUk9MTC1VUCcpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5Lm5yUm9sbFVwUm93cyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5uclJvbGxVcFJvd3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gICAgfTtcbiAgICBDZWE2MDhDaGFubmVsLnByb3RvdHlwZS5pbnNlcnRDaGFycyA9IGZ1bmN0aW9uIChjaGFycykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlU2NyZWVuLmluc2VydENoYXIoY2hhcnNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY3JlZW4gPSB0aGlzLndyaXRlU2NyZWVuID09PSB0aGlzLmRpc3BsYXllZE1lbW9yeSA/ICdESVNQJyA6ICdOT05fRElTUCc7XG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCBzY3JlZW4gKyAnOiAnICsgdGhpcy53cml0ZVNjcmVlbi5nZXREaXNwbGF5VGV4dCh0cnVlKSk7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BBSU5ULU9OJyB8fCB0aGlzLm1vZGUgPT09ICdNT0RFX1JPTEwtVVAnKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdURVhUJywgJ0RJU1BMQVlFRDogJyArIHRoaXMuZGlzcGxheWVkTWVtb3J5LmdldERpc3BsYXlUZXh0KHRydWUpKTtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDZWE2MDhDaGFubmVsLnByb3RvdHlwZS5jY1JDTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdSQ0wgLSBSZXN1bWUgQ2FwdGlvbiBMb2FkaW5nJyk7XG4gICAgICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9QT1AtT04nKTtcbiAgICB9O1xuICAgIENlYTYwOENoYW5uZWwucHJvdG90eXBlLmNjQlMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnQlMgLSBCYWNrU3BhY2UnKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfVEVYVCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlU2NyZWVuLmJhY2tTcGFjZSgpO1xuICAgICAgICBpZiAodGhpcy53cml0ZVNjcmVlbiA9PT0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkpIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDZWE2MDhDaGFubmVsLnByb3RvdHlwZS5jY0FPRiA9IGZ1bmN0aW9uICgpIHtcbiAgICB9O1xuICAgIENlYTYwOENoYW5uZWwucHJvdG90eXBlLmNjQU9OID0gZnVuY3Rpb24gKCkge1xuICAgIH07XG4gICAgQ2VhNjA4Q2hhbm5lbC5wcm90b3R5cGUuY2NERVIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnREVSLSBEZWxldGUgdG8gRW5kIG9mIFJvdycpO1xuICAgICAgICB0aGlzLndyaXRlU2NyZWVuLmNsZWFyVG9FbmRPZlJvdygpO1xuICAgICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcbiAgICB9O1xuICAgIENlYTYwOENoYW5uZWwucHJvdG90eXBlLmNjUlUgPSBmdW5jdGlvbiAobnJSb3dzKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnUlUoJyArIG5yUm93cyArICcpIC0gUm9sbCBVcCcpO1xuICAgICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9ST0xMLVVQJyk7XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0Um9sbFVwUm93cyhuclJvd3MpO1xuICAgIH07XG4gICAgQ2VhNjA4Q2hhbm5lbC5wcm90b3R5cGUuY2NGT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnRk9OIC0gRmxhc2ggT24nKTtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQZW4oeyBmbGFzaDogdHJ1ZSB9KTtcbiAgICB9O1xuICAgIENlYTYwOENoYW5uZWwucHJvdG90eXBlLmNjUkRDID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JEQyAtIFJlc3VtZSBEaXJlY3QgQ2FwdGlvbmluZycpO1xuICAgICAgICB0aGlzLnNldE1vZGUoJ01PREVfUEFJTlQtT04nKTtcbiAgICB9O1xuICAgIENlYTYwOENoYW5uZWwucHJvdG90eXBlLmNjVFIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnVFInKTtcbiAgICAgICAgdGhpcy5zZXRNb2RlKCdNT0RFX1RFWFQnKTtcbiAgICB9O1xuICAgIENlYTYwOENoYW5uZWwucHJvdG90eXBlLmNjUlREID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JURCcpO1xuICAgICAgICB0aGlzLnNldE1vZGUoJ01PREVfVEVYVCcpO1xuICAgIH07XG4gICAgQ2VhNjA4Q2hhbm5lbC5wcm90b3R5cGUuY2NFRE0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnRURNIC0gRXJhc2UgRGlzcGxheWVkIE1lbW9yeScpO1xuICAgICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUodHJ1ZSk7XG4gICAgfTtcbiAgICBDZWE2MDhDaGFubmVsLnByb3RvdHlwZS5jY0NSID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXIubG9nKCdDUiAtIENhcnJpYWdlIFJldHVybicpO1xuICAgICAgICB0aGlzLndyaXRlU2NyZWVuLnJvbGxVcCgpO1xuICAgICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUodHJ1ZSk7XG4gICAgfTtcbiAgICBDZWE2MDhDaGFubmVsLnByb3RvdHlwZS5jY0VOTSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdFTk0gLSBFcmFzZSBOb24tZGlzcGxheWVkIE1lbW9yeScpO1xuICAgICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgIH07XG4gICAgQ2VhNjA4Q2hhbm5lbC5wcm90b3R5cGUuY2NFT0MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnRU9DIC0gRW5kIE9mIENhcHRpb24nKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfUE9QLU9OJykge1xuICAgICAgICAgICAgdmFyIHRtcCA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5ID0gdG1wO1xuICAgICAgICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMubm9uRGlzcGxheWVkTWVtb3J5O1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnVEVYVCcsICdESVNQOiAnICsgdGhpcy5kaXNwbGF5ZWRNZW1vcnkuZ2V0RGlzcGxheVRleHQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKHRydWUpO1xuICAgIH07XG4gICAgQ2VhNjA4Q2hhbm5lbC5wcm90b3R5cGUuY2NUTyA9IGZ1bmN0aW9uIChuckNvbHMpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdUTygnICsgbnJDb2xzICsgJykgLSBUYWIgT2Zmc2V0Jyk7XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4ubW92ZUN1cnNvcihuckNvbHMpO1xuICAgIH07XG4gICAgQ2VhNjA4Q2hhbm5lbC5wcm90b3R5cGUuY2NNSURST1cgPSBmdW5jdGlvbiAoc2Vjb25kQnl0ZSkge1xuICAgICAgICB2YXIgc3R5bGVzID0geyBmbGFzaDogZmFsc2UgfTtcbiAgICAgICAgc3R5bGVzLnVuZGVybGluZSA9IHNlY29uZEJ5dGUgJSAyID09PSAxO1xuICAgICAgICBzdHlsZXMuaXRhbGljcyA9IHNlY29uZEJ5dGUgPj0gMHgyZTtcbiAgICAgICAgaWYgKCFzdHlsZXMuaXRhbGljcykge1xuICAgICAgICAgICAgdmFyIGNvbG9ySW5kZXggPSBNYXRoLmZsb29yKHNlY29uZEJ5dGUgLyAyKSAtIDB4MTA7XG4gICAgICAgICAgICB2YXIgY29sb3JzID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJ107XG4gICAgICAgICAgICBzdHlsZXMuZm9yZWdyb3VuZCA9IGNvbG9yc1tjb2xvckluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlcy5mb3JlZ3JvdW5kID0gJ3doaXRlJztcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIubG9nKCdJTkZPJywgJ01JRFJPVzogJyArIEpTT04uc3RyaW5naWZ5KHN0eWxlcykpO1xuICAgICAgICB0aGlzLndyaXRlU2NyZWVuLnNldFBlbihzdHlsZXMpO1xuICAgIH07XG4gICAgQ2VhNjA4Q2hhbm5lbC5wcm90b3R5cGUub3V0cHV0RGF0YVVwZGF0ZSA9IGZ1bmN0aW9uIChkaXNwYXRjaCkge1xuICAgICAgICBpZiAoZGlzcGF0Y2ggPT09IHZvaWQgMCkgeyBkaXNwYXRjaCA9IGZhbHNlOyB9XG4gICAgICAgIHZhciB0ID0gbG9nZ2VyLnRpbWU7XG4gICAgICAgIGlmICh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdWVTdGFydFRpbWUgPT09IG51bGwgJiYgIXRoaXMuZGlzcGxheWVkTWVtb3J5LmlzRW1wdHkoKSkgeyAvLyBTdGFydCBvZiBhIG5ldyBjdWVcbiAgICAgICAgICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGlzcGxheWVkTWVtb3J5LmVxdWFscyh0aGlzLmxhc3RPdXRwdXRTY3JlZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSh0aGlzLmN1ZVN0YXJ0VGltZSwgdCwgdGhpcy5sYXN0T3V0cHV0U2NyZWVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXNwYXRjaCA9PT0gdHJ1ZSAmJiB0aGlzLm91dHB1dEZpbHRlci5kaXNwYXRjaEN1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLmRpc3BhdGNoQ3VlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkgPyBudWxsIDogdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4uY29weSh0aGlzLmRpc3BsYXllZE1lbW9yeSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENlYTYwOENoYW5uZWwucHJvdG90eXBlLmN1ZVNwbGl0QXRUaW1lID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZGlzcGxheWVkTWVtb3J5LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKHRoaXMuY3VlU3RhcnRUaW1lLCB0LCB0aGlzLmRpc3BsYXllZE1lbW9yeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENlYTYwOENoYW5uZWw7XG59KCkpO1xudmFyIENlYTYwOFBhcnNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDZWE2MDhQYXJzZXIoZmllbGQsIG91dDEsIG91dDIpIHtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkIHx8IDE7XG4gICAgICAgIHRoaXMub3V0cHV0cyA9IFtvdXQxLCBvdXQyXTtcbiAgICAgICAgdGhpcy5jaGFubmVscyA9IFtuZXcgQ2VhNjA4Q2hhbm5lbCgxLCBvdXQxKSwgbmV3IENlYTYwOENoYW5uZWwoMiwgb3V0MildO1xuICAgICAgICB0aGlzLmN1cnJDaE5yID0gLTE7IC8vIFdpbGwgYmUgMSBvciAyXG4gICAgICAgIHRoaXMubGFzdENtZEEgPSBudWxsOyAvLyBGaXJzdCBieXRlIG9mIGxhc3QgY29tbWFuZFxuICAgICAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDsgLy8gU2Vjb25kIGJ5dGUgb2YgbGFzdCBjb21tYW5kXG4gICAgICAgIHRoaXMuYnVmZmVyZWREYXRhID0gW107XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0VGltZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZGF0YUNvdW50ZXJzID0geyAncGFkZGluZyc6IDAsICdjaGFyJzogMCwgJ2NtZCc6IDAsICdvdGhlcic6IDAgfTtcbiAgICB9XG4gICAgQ2VhNjA4UGFyc2VyLnByb3RvdHlwZS5nZXRIYW5kbGVyID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzW2luZGV4XS5nZXRIYW5kbGVyKCk7XG4gICAgfTtcbiAgICBDZWE2MDhQYXJzZXIucHJvdG90eXBlLnNldEhhbmRsZXIgPSBmdW5jdGlvbiAoaW5kZXgsIG5ld0hhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsc1tpbmRleF0uc2V0SGFuZGxlcihuZXdIYW5kbGVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAgICogQWRkIGRhdGEgZm9yIHRpbWUgdCBpbiBmb3JtcyBvZiBsaXN0IG9mIGJ5dGVzICh1bnNpZ25lZCBpbnRzKS4gVGhlIGJ5dGVzIGFyZSB0cmVhdGVkIGFzIHBhaXJzLlxuICAgICAgICovXG4gICAgQ2VhNjA4UGFyc2VyLnByb3RvdHlwZS5hZGREYXRhID0gZnVuY3Rpb24gKHQsIGJ5dGVMaXN0KSB7XG4gICAgICAgIHZhciBjbWRGb3VuZCwgYSwgYiwgY2hhcnNGb3VuZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhc3RUaW1lID0gdDtcbiAgICAgICAgbG9nZ2VyLnNldFRpbWUodCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZUxpc3QubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGEgPSBieXRlTGlzdFtpXSAmIDB4N2Y7XG4gICAgICAgICAgICBiID0gYnl0ZUxpc3RbaSArIDFdICYgMHg3ZjtcbiAgICAgICAgICAgIGlmIChhID09PSAwICYmIGIgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFDb3VudGVycy5wYWRkaW5nICs9IDI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdEQVRBJywgJ1snICsgbnVtQXJyYXlUb0hleEFycmF5KFtieXRlTGlzdFtpXSwgYnl0ZUxpc3RbaSArIDFdXSkgKyAnXSAtPiAoJyArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICsgJyknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZUNtZChhLCBiKTtcbiAgICAgICAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgICAgICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VNaWRyb3coYSwgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlUEFDKGEsIGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICAgICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZUJhY2tncm91bmRBdHRyaWJ1dGVzKGEsIGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICAgICAgICAgIGNoYXJzRm91bmQgPSB0aGlzLnBhcnNlQ2hhcnMoYSwgYik7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJzRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VyckNoTnIgJiYgdGhpcy5jdXJyQ2hOciA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbdGhpcy5jdXJyQ2hOciAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5pbnNlcnRDaGFycyhjaGFyc0ZvdW5kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ1dBUk5JTkcnLCAnTm8gY2hhbm5lbCBmb3VuZCB5ZXQuIFRFWFQtTU9ERT8nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbWRGb3VuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNvdW50ZXJzLmNtZCArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhcnNGb3VuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNvdW50ZXJzLmNoYXIgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNvdW50ZXJzLm90aGVyICs9IDI7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnV0FSTklORycsICdDb3VsZG5cXCd0IHBhcnNlIGNsZWFuZWQgZGF0YSAnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgK1xuICAgICAgICAgICAgICAgICAgICAnIG9yaWc6ICcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2J5dGVMaXN0W2ldLCBieXRlTGlzdFtpICsgMV1dKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAgICogUGFyc2UgQ29tbWFuZC5cbiAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUZWxscyBpZiBhIGNvbW1hbmQgd2FzIGZvdW5kXG4gICAgICAgKi9cbiAgICBDZWE2MDhQYXJzZXIucHJvdG90eXBlLnBhcnNlQ21kID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIGNoTnIgPSBudWxsO1xuICAgICAgICB2YXIgY29uZDEgPSAoYSA9PT0gMHgxNCB8fCBhID09PSAweDFDKSAmJiAoYiA+PSAweDIwICYmIGIgPD0gMHgyRik7XG4gICAgICAgIHZhciBjb25kMiA9IChhID09PSAweDE3IHx8IGEgPT09IDB4MUYpICYmIChiID49IDB4MjEgJiYgYiA8PSAweDIzKTtcbiAgICAgICAgaWYgKCEoY29uZDEgfHwgY29uZDIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEgPT09IHRoaXMubGFzdENtZEEgJiYgYiA9PT0gdGhpcy5sYXN0Q21kQikge1xuICAgICAgICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDsgLy8gUmVwZWF0ZWQgY29tbWFuZHMgYXJlIGRyb3BwZWQgKG9uY2UpXG4gICAgICAgICAgICBsb2dnZXIubG9nKCdERUJVRycsICdSZXBlYXRlZCBjb21tYW5kICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKSBpcyBkcm9wcGVkJyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYSA9PT0gMHgxNCB8fCBhID09PSAweDE3KSB7XG4gICAgICAgICAgICBjaE5yID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoTnIgPSAyO1xuICAgICAgICB9IC8vIChhID09PSAweDFDIHx8IGE9PT0gMHgxZilcbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnIgLSAxXTtcbiAgICAgICAgaWYgKGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxQykge1xuICAgICAgICAgICAgaWYgKGIgPT09IDB4MjApIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjUkNMKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiID09PSAweDIxKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY0JTKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiID09PSAweDIyKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY0FPRigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYiA9PT0gMHgyMykge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NBT04oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGIgPT09IDB4MjQpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjREVSKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiID09PSAweDI1KSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY1JVKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYiA9PT0gMHgyNikge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSVSgzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGIgPT09IDB4MjcpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjUlUoNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiID09PSAweDI4KSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY0ZPTigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYiA9PT0gMHgyOSkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NSREMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGIgPT09IDB4MkEpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjVFIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGIgPT09IDB4MkIpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjUlREKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiID09PSAweDJDKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jY0VETSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYiA9PT0gMHgyRCkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NDUigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYiA9PT0gMHgyRSkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2NFTk0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGIgPT09IDB4MkYpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmNjRU9DKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIGEgPT0gMHgxNyB8fCBhID09IDB4MUZcbiAgICAgICAgICAgIGNoYW5uZWwuY2NUTyhiIC0gMHgyMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0Q21kQSA9IGE7XG4gICAgICAgIHRoaXMubGFzdENtZEIgPSBiO1xuICAgICAgICB0aGlzLmN1cnJDaE5yID0gY2hOcjtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgICAqIFBhcnNlIG1pZHJvdyBzdHlsaW5nIGNvbW1hbmRcbiAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgICovXG4gICAgQ2VhNjA4UGFyc2VyLnByb3RvdHlwZS5wYXJzZU1pZHJvdyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBjaE5yID0gbnVsbDtcbiAgICAgICAgaWYgKCgoYSA9PT0gMHgxMSkgfHwgKGEgPT09IDB4MTkpKSAmJiBiID49IDB4MjAgJiYgYiA8PSAweDJmKSB7XG4gICAgICAgICAgICBpZiAoYSA9PT0gMHgxMSkge1xuICAgICAgICAgICAgICAgIGNoTnIgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hOciA9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hOciAhPT0gdGhpcy5jdXJyQ2hOcikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ0VSUk9SJywgJ01pc21hdGNoIGNoYW5uZWwgaW4gbWlkcm93IHBhcnNpbmcnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOciAtIDFdO1xuICAgICAgICAgICAgY2hhbm5lbC5jY01JRFJPVyhiKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0RFQlVHJywgJ01JRFJPVyAoJyArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICsgJyknKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAgICogUGFyc2UgUHJlYWJsZSBBY2Nlc3MgQ29kZXMgKFRhYmxlIDUzKS5cbiAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUZWxscyBpZiBQQUMgZm91bmRcbiAgICAgICAqL1xuICAgIENlYTYwOFBhcnNlci5wcm90b3R5cGUucGFyc2VQQUMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgY2hOciA9IG51bGw7XG4gICAgICAgIHZhciByb3cgPSBudWxsO1xuICAgICAgICB2YXIgY2FzZTEgPSAoKGEgPj0gMHgxMSAmJiBhIDw9IDB4MTcpIHx8IChhID49IDB4MTkgJiYgYSA8PSAweDFGKSkgJiYgKGIgPj0gMHg0MCAmJiBiIDw9IDB4N0YpO1xuICAgICAgICB2YXIgY2FzZTIgPSAoYSA9PT0gMHgxMCB8fCBhID09PSAweDE4KSAmJiAoYiA+PSAweDQwICYmIGIgPD0gMHg1Rik7XG4gICAgICAgIGlmICghKGNhc2UxIHx8IGNhc2UyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhID09PSB0aGlzLmxhc3RDbWRBICYmIGIgPT09IHRoaXMubGFzdENtZEIpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdENtZEEgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5sYXN0Q21kQiA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gUmVwZWF0ZWQgY29tbWFuZHMgYXJlIGRyb3BwZWQgKG9uY2UpXG4gICAgICAgIH1cbiAgICAgICAgY2hOciA9IChhIDw9IDB4MTcpID8gMSA6IDI7XG4gICAgICAgIGlmIChiID49IDB4NDAgJiYgYiA8PSAweDVGKSB7XG4gICAgICAgICAgICByb3cgPSAoY2hOciA9PT0gMSkgPyByb3dzTG93Q2gxW2FdIDogcm93c0xvd0NoMlthXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gMHg2MCA8PSBiIDw9IDB4N0ZcbiAgICAgICAgICAgIHJvdyA9IChjaE5yID09PSAxKSA/IHJvd3NIaWdoQ2gxW2FdIDogcm93c0hpZ2hDaDJbYV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhY0RhdGEgPSB0aGlzLmludGVycHJldFBBQyhyb3csIGIpO1xuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOciAtIDFdO1xuICAgICAgICBjaGFubmVsLnNldFBBQyhwYWNEYXRhKTtcbiAgICAgICAgdGhpcy5sYXN0Q21kQSA9IGE7XG4gICAgICAgIHRoaXMubGFzdENtZEIgPSBiO1xuICAgICAgICB0aGlzLmN1cnJDaE5yID0gY2hOcjtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgICAqIEludGVycHJldCB0aGUgc2Vjb25kIGJ5dGUgb2YgdGhlIHBhYywgYW5kIHJldHVybiB0aGUgaW5mb3JtYXRpb24uXG4gICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBwYWNEYXRhIHdpdGggc3R5bGUgcGFyYW1ldGVycy5cbiAgICAgICAqL1xuICAgIENlYTYwOFBhcnNlci5wcm90b3R5cGUuaW50ZXJwcmV0UEFDID0gZnVuY3Rpb24gKHJvdywgYnl0ZSkge1xuICAgICAgICB2YXIgcGFjSW5kZXggPSBieXRlO1xuICAgICAgICB2YXIgcGFjRGF0YSA9IHsgY29sb3I6IG51bGwsIGl0YWxpY3M6IGZhbHNlLCBpbmRlbnQ6IG51bGwsIHVuZGVybGluZTogZmFsc2UsIHJvdzogcm93IH07XG4gICAgICAgIGlmIChieXRlID4gMHg1Rikge1xuICAgICAgICAgICAgcGFjSW5kZXggPSBieXRlIC0gMHg2MDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhY0luZGV4ID0gYnl0ZSAtIDB4NDA7XG4gICAgICAgIH1cbiAgICAgICAgcGFjRGF0YS51bmRlcmxpbmUgPSAocGFjSW5kZXggJiAxKSA9PT0gMTtcbiAgICAgICAgaWYgKHBhY0luZGV4IDw9IDB4ZCkge1xuICAgICAgICAgICAgcGFjRGF0YS5jb2xvciA9IFsnd2hpdGUnLCAnZ3JlZW4nLCAnYmx1ZScsICdjeWFuJywgJ3JlZCcsICd5ZWxsb3cnLCAnbWFnZW50YScsICd3aGl0ZSddW01hdGguZmxvb3IocGFjSW5kZXggLyAyKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFjSW5kZXggPD0gMHhmKSB7XG4gICAgICAgICAgICBwYWNEYXRhLml0YWxpY3MgPSB0cnVlO1xuICAgICAgICAgICAgcGFjRGF0YS5jb2xvciA9ICd3aGl0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYWNEYXRhLmluZGVudCA9IChNYXRoLmZsb29yKChwYWNJbmRleCAtIDB4MTApIC8gMikpICogNDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFjRGF0YTsgLy8gTm90ZSB0aGF0IHJvdyBoYXMgemVybyBvZmZzZXQuIFRoZSBzcGVjIHVzZXMgMS5cbiAgICB9O1xuICAgIC8qKlxuICAgICAgICogUGFyc2UgY2hhcmFjdGVycy5cbiAgICAgICAqIEByZXR1cm5zIEFuIGFycmF5IHdpdGggMSB0byAyIGNvZGVzIGNvcnJlc3BvbmRpbmcgdG8gY2hhcnMsIGlmIGZvdW5kLiBudWxsIG90aGVyd2lzZS5cbiAgICAgICAqL1xuICAgIENlYTYwOFBhcnNlci5wcm90b3R5cGUucGFyc2VDaGFycyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBjaGFubmVsTnIgPSBudWxsLCBjaGFyQ29kZXMgPSBudWxsLCBjaGFyQ29kZTEgPSBudWxsO1xuICAgICAgICBpZiAoYSA+PSAweDE5KSB7XG4gICAgICAgICAgICBjaGFubmVsTnIgPSAyO1xuICAgICAgICAgICAgY2hhckNvZGUxID0gYSAtIDg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFubmVsTnIgPSAxO1xuICAgICAgICAgICAgY2hhckNvZGUxID0gYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhckNvZGUxID49IDB4MTEgJiYgY2hhckNvZGUxIDw9IDB4MTMpIHtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2hhcmFjdGVyXG4gICAgICAgICAgICB2YXIgb25lQ29kZSA9IGI7XG4gICAgICAgICAgICBpZiAoY2hhckNvZGUxID09PSAweDExKSB7XG4gICAgICAgICAgICAgICAgb25lQ29kZSA9IGIgKyAweDUwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhckNvZGUxID09PSAweDEyKSB7XG4gICAgICAgICAgICAgICAgb25lQ29kZSA9IGIgKyAweDcwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb25lQ29kZSA9IGIgKyAweDkwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdTcGVjaWFsIGNoYXIgXFwnJyArIGdldENoYXJGb3JCeXRlKG9uZUNvZGUpICsgJ1xcJyBpbiBjaGFubmVsICcgKyBjaGFubmVsTnIpO1xuICAgICAgICAgICAgY2hhckNvZGVzID0gW29uZUNvZGVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEgPj0gMHgyMCAmJiBhIDw9IDB4N2YpIHtcbiAgICAgICAgICAgIGNoYXJDb2RlcyA9IChiID09PSAwKSA/IFthXSA6IFthLCBiXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhckNvZGVzKSB7XG4gICAgICAgICAgICB2YXIgaGV4Q29kZXMgPSBudW1BcnJheVRvSGV4QXJyYXkoY2hhckNvZGVzKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0RFQlVHJywgJ0NoYXIgY29kZXMgPSAgJyArIGhleENvZGVzLmpvaW4oJywnKSk7XG4gICAgICAgICAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFyQ29kZXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgICogUGFyc2UgZXh0ZW5kZWQgYmFja2dyb3VuZCBhdHRyaWJ1dGVzIGFzIHdlbGwgYXMgbmV3IGZvcmVncm91bmQgY29sb3IgYmxhY2suXG4gICAgICAqIEByZXR1cm5ze0Jvb2xlYW59IFRlbGxzIGlmIGJhY2tncm91bmQgYXR0cmlidXRlcyBhcmUgZm91bmRcbiAgICAgICovXG4gICAgQ2VhNjA4UGFyc2VyLnByb3RvdHlwZS5wYXJzZUJhY2tncm91bmRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIGJrZ0RhdGEsIGluZGV4LCBjaE5yLCBjaGFubmVsO1xuICAgICAgICB2YXIgY2FzZTEgPSAoYSA9PT0gMHgxMCB8fCBhID09PSAweDE4KSAmJiAoYiA+PSAweDIwICYmIGIgPD0gMHgyZik7XG4gICAgICAgIHZhciBjYXNlMiA9IChhID09PSAweDE3IHx8IGEgPT09IDB4MWYpICYmIChiID49IDB4MmQgJiYgYiA8PSAweDJmKTtcbiAgICAgICAgaWYgKCEoY2FzZTEgfHwgY2FzZTIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYmtnRGF0YSA9IHt9O1xuICAgICAgICBpZiAoYSA9PT0gMHgxMCB8fCBhID09PSAweDE4KSB7XG4gICAgICAgICAgICBpbmRleCA9IE1hdGguZmxvb3IoKGIgLSAweDIwKSAvIDIpO1xuICAgICAgICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZENvbG9yc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoYiAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBia2dEYXRhLmJhY2tncm91bmQgPSBia2dEYXRhLmJhY2tncm91bmQgKyAnX3NlbWknO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIgPT09IDB4MmQpIHtcbiAgICAgICAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBia2dEYXRhLmZvcmVncm91bmQgPSAnYmxhY2snO1xuICAgICAgICAgICAgaWYgKGIgPT09IDB4MmYpIHtcbiAgICAgICAgICAgICAgICBia2dEYXRhLnVuZGVybGluZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hOciA9IChhIDwgMHgxOCkgPyAxIDogMjtcbiAgICAgICAgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOciAtIDFdO1xuICAgICAgICBjaGFubmVsLnNldEJrZ0RhdGEoYmtnRGF0YSk7XG4gICAgICAgIHRoaXMubGFzdENtZEEgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgICAqIFJlc2V0IHN0YXRlIG9mIHBhcnNlciBhbmQgaXRzIGNoYW5uZWxzLlxuICAgICAgICovXG4gICAgQ2VhNjA4UGFyc2VyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoYW5uZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsc1tpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHNbaV0ucmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0Q21kQiA9IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgICAqIFRyaWdnZXIgdGhlIGdlbmVyYXRpb24gb2YgYSBjdWUsIGFuZCB0aGUgc3RhcnQgb2YgYSBuZXcgb25lIGlmIGRpc3BsYXlTY3JlZW5zIGFyZSBub3QgZW1wdHkuXG4gICAgICAgKi9cbiAgICBDZWE2MDhQYXJzZXIucHJvdG90eXBlLmN1ZVNwbGl0QXRUaW1lID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoYW5uZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsc1tpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHNbaV0uY3VlU3BsaXRBdFRpbWUodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDZWE2MDhQYXJzZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2VhNjA4UGFyc2VyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2NvZGVjcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvY29kZWNzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gZnJvbSBodHRwOi8vbXA0cmEub3JnL2NvZGVjcy5odG1sXG52YXIgc2FtcGxlRW50cnlDb2Rlc0lTTyA9IHtcbiAgICBhdWRpbzoge1xuICAgICAgICAnYTNkcyc6IHRydWUsXG4gICAgICAgICdhYy0zJzogdHJ1ZSxcbiAgICAgICAgJ2FjLTQnOiB0cnVlLFxuICAgICAgICAnYWxhYyc6IHRydWUsXG4gICAgICAgICdhbGF3JzogdHJ1ZSxcbiAgICAgICAgJ2RyYTEnOiB0cnVlLFxuICAgICAgICAnZHRzKyc6IHRydWUsXG4gICAgICAgICdkdHMtJzogdHJ1ZSxcbiAgICAgICAgJ2R0c2MnOiB0cnVlLFxuICAgICAgICAnZHRzZSc6IHRydWUsXG4gICAgICAgICdkdHNoJzogdHJ1ZSxcbiAgICAgICAgJ2VjLTMnOiB0cnVlLFxuICAgICAgICAnZW5jYSc6IHRydWUsXG4gICAgICAgICdnNzE5JzogdHJ1ZSxcbiAgICAgICAgJ2c3MjYnOiB0cnVlLFxuICAgICAgICAnbTRhZSc6IHRydWUsXG4gICAgICAgICdtaGExJzogdHJ1ZSxcbiAgICAgICAgJ21oYTInOiB0cnVlLFxuICAgICAgICAnbWhtMSc6IHRydWUsXG4gICAgICAgICdtaG0yJzogdHJ1ZSxcbiAgICAgICAgJ21scGEnOiB0cnVlLFxuICAgICAgICAnbXA0YSc6IHRydWUsXG4gICAgICAgICdyYXcgJzogdHJ1ZSxcbiAgICAgICAgJ09wdXMnOiB0cnVlLFxuICAgICAgICAnc2Ftcic6IHRydWUsXG4gICAgICAgICdzYXdiJzogdHJ1ZSxcbiAgICAgICAgJ3Nhd3AnOiB0cnVlLFxuICAgICAgICAnc2V2Yyc6IHRydWUsXG4gICAgICAgICdzcWNwJzogdHJ1ZSxcbiAgICAgICAgJ3NzbXYnOiB0cnVlLFxuICAgICAgICAndHdvcyc6IHRydWUsXG4gICAgICAgICd1bGF3JzogdHJ1ZVxuICAgIH0sXG4gICAgdmlkZW86IHtcbiAgICAgICAgJ2F2YzEnOiB0cnVlLFxuICAgICAgICAnYXZjMic6IHRydWUsXG4gICAgICAgICdhdmMzJzogdHJ1ZSxcbiAgICAgICAgJ2F2YzQnOiB0cnVlLFxuICAgICAgICAnYXZjcCc6IHRydWUsXG4gICAgICAgICdkcmFjJzogdHJ1ZSxcbiAgICAgICAgJ2R2YXYnOiB0cnVlLFxuICAgICAgICAnZHZoZSc6IHRydWUsXG4gICAgICAgICdlbmN2JzogdHJ1ZSxcbiAgICAgICAgJ2hldjEnOiB0cnVlLFxuICAgICAgICAnaHZjMSc6IHRydWUsXG4gICAgICAgICdtanAyJzogdHJ1ZSxcbiAgICAgICAgJ21wNHYnOiB0cnVlLFxuICAgICAgICAnbXZjMSc6IHRydWUsXG4gICAgICAgICdtdmMyJzogdHJ1ZSxcbiAgICAgICAgJ212YzMnOiB0cnVlLFxuICAgICAgICAnbXZjNCc6IHRydWUsXG4gICAgICAgICdyZXN2JzogdHJ1ZSxcbiAgICAgICAgJ3J2NjAnOiB0cnVlLFxuICAgICAgICAnczI2Myc6IHRydWUsXG4gICAgICAgICdzdmMxJzogdHJ1ZSxcbiAgICAgICAgJ3N2YzInOiB0cnVlLFxuICAgICAgICAndmMtMSc6IHRydWUsXG4gICAgICAgICd2cDA4JzogdHJ1ZSxcbiAgICAgICAgJ3ZwMDknOiB0cnVlXG4gICAgfVxufTtcbmZ1bmN0aW9uIGlzQ29kZWNUeXBlKGNvZGVjLCB0eXBlKSB7XG4gICAgdmFyIHR5cGVDb2RlcyA9IHNhbXBsZUVudHJ5Q29kZXNJU09bdHlwZV07XG4gICAgcmV0dXJuICEhdHlwZUNvZGVzICYmIHR5cGVDb2Rlc1tjb2RlYy5zbGljZSgwLCA0KV0gPT09IHRydWU7XG59XG5leHBvcnRzLmlzQ29kZWNUeXBlID0gaXNDb2RlY1R5cGU7XG5mdW5jdGlvbiBpc0NvZGVjU3VwcG9ydGVkSW5NcDQoY29kZWMsIHR5cGUpIHtcbiAgICByZXR1cm4gd2luZG93Lk1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgodHlwZSB8fCAndmlkZW8nKSArIFwiL21wNDtjb2RlY3M9XFxcIlwiICsgY29kZWMgKyBcIlxcXCJcIik7XG59XG5leHBvcnRzLmlzQ29kZWNTdXBwb3J0ZWRJbk1wNCA9IGlzQ29kZWNTdXBwb3J0ZWRJbk1wNDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9jdWVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvY3Vlcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdnR0cGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Z0dHBhcnNlciAqLyBcIi4vc3JjL3V0aWxzL3Z0dHBhcnNlci5qc1wiKTtcbmZ1bmN0aW9uIG5ld0N1ZSh0cmFjaywgc3RhcnRUaW1lLCBlbmRUaW1lLCBjYXB0aW9uU2NyZWVuKSB7XG4gICAgdmFyIHJvdztcbiAgICB2YXIgY3VlO1xuICAgIHZhciBpbmRlbnRpbmc7XG4gICAgdmFyIGluZGVudDtcbiAgICB2YXIgdGV4dDtcbiAgICB2YXIgVlRUQ3VlID0gd2luZG93LlZUVEN1ZSB8fCB3aW5kb3cuVGV4dFRyYWNrQ3VlO1xuICAgIGZvciAodmFyIHIgPSAwOyByIDwgY2FwdGlvblNjcmVlbi5yb3dzLmxlbmd0aDsgcisrKSB7XG4gICAgICAgIHJvdyA9IGNhcHRpb25TY3JlZW4ucm93c1tyXTtcbiAgICAgICAgaW5kZW50aW5nID0gdHJ1ZTtcbiAgICAgICAgaW5kZW50ID0gMDtcbiAgICAgICAgdGV4dCA9ICcnO1xuICAgICAgICBpZiAoIXJvdy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgcm93LmNoYXJzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdy5jaGFyc1tjXS51Y2hhci5tYXRjaCgvXFxzLykgJiYgaW5kZW50aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCArPSByb3cuY2hhcnNbY10udWNoYXI7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRvIGJlIHVzZWQgZm9yIGNsZWFuaW5nLXVwIG9ycGhhbmVkIHJvbGwtdXAgY2FwdGlvbnNcbiAgICAgICAgICAgIHJvdy5jdWVTdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gICAgICAgICAgICAvLyBHaXZlIGEgc2xpZ2h0IGJ1bXAgdG8gdGhlIGVuZFRpbWUgaWYgaXQncyBlcXVhbCB0byBzdGFydFRpbWUgdG8gYXZvaWQgYSBTeW50YXhFcnJvciBpbiBJRVxuICAgICAgICAgICAgaWYgKHN0YXJ0VGltZSA9PT0gZW5kVGltZSkge1xuICAgICAgICAgICAgICAgIGVuZFRpbWUgKz0gMC4wMDAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VlID0gbmV3IFZUVEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsIHZ0dHBhcnNlcl8xLmZpeExpbmVCcmVha3ModGV4dC50cmltKCkpKTtcbiAgICAgICAgICAgIGlmIChpbmRlbnQgPj0gMTYpIHtcbiAgICAgICAgICAgICAgICBpbmRlbnQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZGVudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVlRUQ3VlLmxpbmUgZ2V0J3MgZmxha2V5IHdoZW4gdXNpbmcgY29udHJvbHMsIHNvIGxldCdzIG5vdyBpbmNsdWRlIGxpbmUgMTMmMTRcbiAgICAgICAgICAgIC8vIGFsc28sIGRyb3AgbGluZSAxIHNpbmNlIGl0J3MgdG8gY2xvc2UgdG8gdGhlIHRvcFxuICAgICAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0ZpcmVmb3hcXC8vKSkge1xuICAgICAgICAgICAgICAgIGN1ZS5saW5lID0gciArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdWUubGluZSA9IChyID4gNyA/IHIgLSAyIDogciArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VlLmFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgLy8gQ2xhbXAgdGhlIHBvc2l0aW9uIGJldHdlZW4gMCBhbmQgMTAwIC0gaWYgb3V0IG9mIHRoZXNlIGJvdW5kcywgRmlyZWZveCB0aHJvd3MgYW4gZXhjZXB0aW9uIGFuZCBjYXB0aW9ucyBicmVha1xuICAgICAgICAgICAgY3VlLnBvc2l0aW9uID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMTAwLCAxMDAgKiAoaW5kZW50IC8gMzIpICsgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0ZpcmVmb3hcXC8vKSA/IDUwIDogMCkpKTtcbiAgICAgICAgICAgIHRyYWNrLmFkZEN1ZShjdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5uZXdDdWUgPSBuZXdDdWU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvZGlzY29udGludWl0aWVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy9kaXNjb250aW51aXRpZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKE51bWJlcikge1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGJpbmFyeV9zZWFyY2hfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYmluYXJ5LXNlYXJjaCAqLyBcIi4vc3JjL3V0aWxzL2JpbmFyeS1zZWFyY2guanNcIik7XG52YXIgbG9nZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIuanNcIik7XG5mdW5jdGlvbiBmaW5kRmlyc3RGcmFnV2l0aENDKGZyYWdtZW50cywgY2MpIHtcbiAgICB2YXIgZmlyc3RGcmFnID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYWdtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgY3VycmVudEZyYWcgPSBmcmFnbWVudHNbaV07XG4gICAgICAgIGlmIChjdXJyZW50RnJhZyAmJiBjdXJyZW50RnJhZy5jYyA9PT0gY2MpIHtcbiAgICAgICAgICAgIGZpcnN0RnJhZyA9IGN1cnJlbnRGcmFnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0RnJhZztcbn1cbmV4cG9ydHMuZmluZEZpcnN0RnJhZ1dpdGhDQyA9IGZpbmRGaXJzdEZyYWdXaXRoQ0M7XG5mdW5jdGlvbiBmaW5kRnJhZ1dpdGhDQyhmcmFnbWVudHMsIENDKSB7XG4gICAgcmV0dXJuIGJpbmFyeV9zZWFyY2hfMS5kZWZhdWx0LnNlYXJjaChmcmFnbWVudHMsIGZ1bmN0aW9uIChjYW5kaWRhdGUpIHtcbiAgICAgICAgaWYgKGNhbmRpZGF0ZS5jYyA8IENDKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjYW5kaWRhdGUuY2MgPiBDQykge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuZmluZEZyYWdXaXRoQ0MgPSBmaW5kRnJhZ1dpdGhDQztcbmZ1bmN0aW9uIHNob3VsZEFsaWduT25EaXNjb250aW51aXRpZXMobGFzdEZyYWcsIGxhc3RMZXZlbCwgZGV0YWlscykge1xuICAgIHZhciBzaG91bGRBbGlnbiA9IGZhbHNlO1xuICAgIGlmIChsYXN0TGV2ZWwgJiYgbGFzdExldmVsLmRldGFpbHMgJiYgZGV0YWlscykge1xuICAgICAgICBpZiAoZGV0YWlscy5lbmRDQyA+IGRldGFpbHMuc3RhcnRDQyB8fCAobGFzdEZyYWcgJiYgbGFzdEZyYWcuY2MgPCBkZXRhaWxzLnN0YXJ0Q0MpKSB7XG4gICAgICAgICAgICBzaG91bGRBbGlnbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNob3VsZEFsaWduO1xufVxuZXhwb3J0cy5zaG91bGRBbGlnbk9uRGlzY29udGludWl0aWVzID0gc2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllcztcbi8vIEZpbmQgdGhlIGZpcnN0IGZyYWcgaW4gdGhlIHByZXZpb3VzIGxldmVsIHdoaWNoIG1hdGNoZXMgdGhlIENDIG9mIHRoZSBmaXJzdCBmcmFnIG9mIHRoZSBuZXcgbGV2ZWxcbmZ1bmN0aW9uIGZpbmREaXNjb250aW51b3VzUmVmZXJlbmNlRnJhZyhwcmV2RGV0YWlscywgY3VyRGV0YWlscykge1xuICAgIHZhciBwcmV2RnJhZ3MgPSBwcmV2RGV0YWlscy5mcmFnbWVudHM7XG4gICAgdmFyIGN1ckZyYWdzID0gY3VyRGV0YWlscy5mcmFnbWVudHM7XG4gICAgaWYgKCFjdXJGcmFncy5sZW5ndGggfHwgIXByZXZGcmFncy5sZW5ndGgpIHtcbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnTm8gZnJhZ21lbnRzIHRvIGFsaWduJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHByZXZTdGFydEZyYWcgPSBmaW5kRmlyc3RGcmFnV2l0aENDKHByZXZGcmFncywgY3VyRnJhZ3NbMF0uY2MpO1xuICAgIGlmICghcHJldlN0YXJ0RnJhZyB8fCAocHJldlN0YXJ0RnJhZyAmJiAhcHJldlN0YXJ0RnJhZy5zdGFydFBUUykpIHtcbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLmxvZygnTm8gZnJhZyBpbiBwcmV2aW91cyBsZXZlbCB0byBhbGlnbiBvbicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBwcmV2U3RhcnRGcmFnO1xufVxuZXhwb3J0cy5maW5kRGlzY29udGludW91c1JlZmVyZW5jZUZyYWcgPSBmaW5kRGlzY29udGludW91c1JlZmVyZW5jZUZyYWc7XG5mdW5jdGlvbiBhZGp1c3RQdHMoc2xpZGluZywgZGV0YWlscykge1xuICAgIGRldGFpbHMuZnJhZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGZyYWcpIHtcbiAgICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGZyYWcuc3RhcnQgKyBzbGlkaW5nO1xuICAgICAgICAgICAgZnJhZy5zdGFydCA9IGZyYWcuc3RhcnRQVFMgPSBzdGFydDtcbiAgICAgICAgICAgIGZyYWcuZW5kUFRTID0gc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZGV0YWlscy5QVFNLbm93biA9IHRydWU7XG59XG5leHBvcnRzLmFkanVzdFB0cyA9IGFkanVzdFB0cztcbi8qKlxuICogVXNpbmcgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIGxhc3QgbGV2ZWwsIHRoaXMgZnVuY3Rpb24gY29tcHV0ZXMgUFRTJyBvZiB0aGUgbmV3IGZyYWdtZW50cyBzbyB0aGF0IHRoZXkgZm9ybSBhXG4gKiBjb250aWd1b3VzIHN0cmVhbSB3aXRoIHRoZSBsYXN0IGZyYWdtZW50cy5cbiAqIFRoZSBQVFMgb2YgYSBmcmFnbWVudCBsZXRzIEhscy5qcyBrbm93IHdoZXJlIGl0IGZpdHMgaW50byBhIHN0cmVhbSAtIGJ5IGtub3dpbmcgZXZlcnkgUFRTLCB3ZSBrbm93IHdoaWNoIGZyYWdtZW50IHRvXG4gKiBkb3dubG9hZCBhdCBhbnkgZ2l2ZW4gdGltZS4gUFRTIGlzIG5vcm1hbGx5IGNvbXB1dGVkIHdoZW4gdGhlIGZyYWdtZW50IGlzIGRlbXV4ZWQsIHNvIHRha2luZyB0aGlzIHN0ZXAgc2F2ZXMgdXMgdGltZVxuICogYW5kIGFuIGV4dHJhIGRvd25sb2FkLlxuICogQHBhcmFtIGxhc3RGcmFnXG4gKiBAcGFyYW0gbGFzdExldmVsXG4gKiBAcGFyYW0gZGV0YWlsc1xuICovXG5mdW5jdGlvbiBhbGlnblN0cmVhbShsYXN0RnJhZywgbGFzdExldmVsLCBkZXRhaWxzKSB7XG4gICAgYWxpZ25EaXNjb250aW51aXRpZXMobGFzdEZyYWcsIGRldGFpbHMsIGxhc3RMZXZlbCk7XG4gICAgaWYgKCFkZXRhaWxzLlBUU0tub3duICYmIGxhc3RMZXZlbCkge1xuICAgICAgICAvLyBJZiB0aGUgUFRTIHdhc24ndCBmaWd1cmVkIG91dCB2aWEgZGlzY29udGludWl0eSBzZXF1ZW5jZSB0aGF0IG1lYW5zIHRoZXJlIHdhcyBubyBDQyBpbmNyZWFzZSB3aXRoaW4gdGhlIGxldmVsLlxuICAgICAgICAvLyBBbGlnbmluZyB2aWEgUHJvZ3JhbSBEYXRlIFRpbWUgc2hvdWxkIHRoZXJlZm9yZSBiZSByZWxpYWJsZSwgc2luY2UgUERUIHNob3VsZCBiZSB0aGUgc2FtZSB3aXRoaW4gdGhlIHNhbWVcbiAgICAgICAgLy8gZGlzY29udGludWl0eSBzZXF1ZW5jZS5cbiAgICAgICAgYWxpZ25QRFQoZGV0YWlscywgbGFzdExldmVsLmRldGFpbHMpO1xuICAgIH1cbn1cbmV4cG9ydHMuYWxpZ25TdHJlYW0gPSBhbGlnblN0cmVhbTtcbi8qKlxuICogQ29tcHV0ZXMgdGhlIFBUUyBpZiBhIG5ldyBsZXZlbCdzIGZyYWdtZW50cyB1c2luZyB0aGUgUFRTIG9mIGEgZnJhZ21lbnQgaW4gdGhlIGxhc3QgbGV2ZWwgd2hpY2ggc2hhcmVzIHRoZSBzYW1lXG4gKiBkaXNjb250aW51aXR5IHNlcXVlbmNlLlxuICogQHBhcmFtIGxhc3RMZXZlbCAtIFRoZSBkZXRhaWxzIG9mIHRoZSBsYXN0IGxvYWRlZCBsZXZlbFxuICogQHBhcmFtIGRldGFpbHMgLSBUaGUgZGV0YWlscyBvZiB0aGUgbmV3IGxldmVsXG4gKi9cbmZ1bmN0aW9uIGFsaWduRGlzY29udGludWl0aWVzKGxhc3RGcmFnLCBkZXRhaWxzLCBsYXN0TGV2ZWwpIHtcbiAgICBpZiAoc2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllcyhsYXN0RnJhZywgbGFzdExldmVsLCBkZXRhaWxzKSkge1xuICAgICAgICB2YXIgcmVmZXJlbmNlRnJhZyA9IGZpbmREaXNjb250aW51b3VzUmVmZXJlbmNlRnJhZyhsYXN0TGV2ZWwuZGV0YWlscywgZGV0YWlscyk7XG4gICAgICAgIGlmIChyZWZlcmVuY2VGcmFnKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKCdBZGp1c3RpbmcgUFRTIHVzaW5nIGxhc3QgbGV2ZWwgZHVlIHRvIENDIGluY3JlYXNlIHdpdGhpbiBjdXJyZW50IGxldmVsJyk7XG4gICAgICAgICAgICBhZGp1c3RQdHMocmVmZXJlbmNlRnJhZy5zdGFydCwgZGV0YWlscyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmFsaWduRGlzY29udGludWl0aWVzID0gYWxpZ25EaXNjb250aW51aXRpZXM7XG4vKipcbiAqIENvbXB1dGVzIHRoZSBQVFMgb2YgYSBuZXcgbGV2ZWwncyBmcmFnbWVudHMgdXNpbmcgdGhlIGRpZmZlcmVuY2UgaW4gUHJvZ3JhbSBEYXRlIFRpbWUgZnJvbSB0aGUgbGFzdCBsZXZlbC5cbiAqIEBwYXJhbSBkZXRhaWxzIC0gVGhlIGRldGFpbHMgb2YgdGhlIG5ldyBsZXZlbFxuICogQHBhcmFtIGxhc3REZXRhaWxzIC0gVGhlIGRldGFpbHMgb2YgdGhlIGxhc3QgbG9hZGVkIGxldmVsXG4gKi9cbmZ1bmN0aW9uIGFsaWduUERUKGRldGFpbHMsIGxhc3REZXRhaWxzKSB7XG4gICAgaWYgKGxhc3REZXRhaWxzICYmIGxhc3REZXRhaWxzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFkZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSB8fCAhbGFzdERldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgbGFzdCBsZXZlbCBzbGlkaW5nIGlzIDEwMDAgYW5kIGl0cyBmaXJzdCBmcmFnIFBST0dSQU0tREFURS1USU1FIGlzIDIwMTctMDgtMjAgMToxMDowMCBBTVxuICAgICAgICAvLyBhbmQgaWYgbmV3IGRldGFpbHMgZmlyc3QgZnJhZyBQUk9HUkFNIERBVEUtVElNRSBpcyAyMDE3LTA4LTIwIDE6MTA6MDggQU1cbiAgICAgICAgLy8gdGhlbiB3ZSBjYW4gZGVkdWNlIHRoYXQgcGxheWxpc3QgQiBzbGlkaW5nIGlzIDEwMDArOCA9IDEwMDhzXG4gICAgICAgIHZhciBsYXN0UERUID0gbGFzdERldGFpbHMuZnJhZ21lbnRzWzBdLnByb2dyYW1EYXRlVGltZTtcbiAgICAgICAgdmFyIG5ld1BEVCA9IGRldGFpbHMuZnJhZ21lbnRzWzBdLnByb2dyYW1EYXRlVGltZTtcbiAgICAgICAgLy8gZGF0ZSBkaWZmIGlzIGluIG1zLiBmcmFnLnN0YXJ0IGlzIGluIHNlY29uZHNcbiAgICAgICAgdmFyIHNsaWRpbmcgPSAobmV3UERUIC0gbGFzdFBEVCkgLyAxMDAwICsgbGFzdERldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHNsaWRpbmcpKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIubG9nKFwiYWRqdXN0aW5nIFBUUyB1c2luZyBwcm9ncmFtRGF0ZVRpbWUgZGVsdGEsIHNsaWRpbmc6XCIgKyBzbGlkaW5nLnRvRml4ZWQoMykpO1xuICAgICAgICAgICAgYWRqdXN0UHRzKHNsaWRpbmcsIGRldGFpbHMpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5hbGlnblBEVCA9IGFsaWduUERUO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIuanNcIilbXCJOdW1iZXJcIl0pKVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9ld21hLWJhbmR3aWR0aC1lc3RpbWF0b3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2V3bWEtYmFuZHdpZHRoLWVzdGltYXRvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gKiBFV01BIEJhbmR3aWR0aCBFc3RpbWF0b3JcbiAqICAtIGhlYXZpbHkgaW5zcGlyZWQgZnJvbSBzaGFrYS1wbGF5ZXJcbiAqIFRyYWNrcyBiYW5kd2lkdGggc2FtcGxlcyBhbmQgZXN0aW1hdGVzIGF2YWlsYWJsZSBiYW5kd2lkdGguXG4gKiBCYXNlZCBvbiB0aGUgbWluaW11bSBvZiB0d28gZXhwb25lbnRpYWxseS13ZWlnaHRlZCBtb3ZpbmcgYXZlcmFnZXMgd2l0aFxuICogZGlmZmVyZW50IGhhbGYtbGl2ZXMuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBld21hXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9ld21hICovIFwiLi9zcmMvdXRpbHMvZXdtYS5qc1wiKTtcbnZhciBFd21hQmFuZFdpZHRoRXN0aW1hdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV3bWFCYW5kV2lkdGhFc3RpbWF0b3IoaGxzLCBzbG93LCBmYXN0LCBkZWZhdWx0RXN0aW1hdGUpIHtcbiAgICAgICAgdGhpcy5obHMgPSBobHM7XG4gICAgICAgIHRoaXMuZGVmYXVsdEVzdGltYXRlXyA9IGRlZmF1bHRFc3RpbWF0ZTtcbiAgICAgICAgdGhpcy5taW5XZWlnaHRfID0gMC4wMDE7XG4gICAgICAgIHRoaXMubWluRGVsYXlNc18gPSA1MDtcbiAgICAgICAgdGhpcy5zbG93XyA9IG5ldyBld21hXzEuZGVmYXVsdChzbG93KTtcbiAgICAgICAgdGhpcy5mYXN0XyA9IG5ldyBld21hXzEuZGVmYXVsdChmYXN0KTtcbiAgICB9XG4gICAgRXdtYUJhbmRXaWR0aEVzdGltYXRvci5wcm90b3R5cGUuc2FtcGxlID0gZnVuY3Rpb24gKGR1cmF0aW9uTXMsIG51bUJ5dGVzKSB7XG4gICAgICAgIGR1cmF0aW9uTXMgPSBNYXRoLm1heChkdXJhdGlvbk1zLCB0aGlzLm1pbkRlbGF5TXNfKTtcbiAgICAgICAgdmFyIGJhbmR3aWR0aCA9IDgwMDAgKiBudW1CeXRlcyAvIGR1cmF0aW9uTXMsIFxuICAgICAgICAvLyBjb25zb2xlLmxvZygnaW5zdGFudCBidzonKyBNYXRoLnJvdW5kKGJhbmR3aWR0aCkpO1xuICAgICAgICAvLyB3ZSB3ZWlnaHQgc2FtcGxlIHVzaW5nIGxvYWRpbmcgZHVyYXRpb24uLi4uXG4gICAgICAgIHdlaWdodCA9IGR1cmF0aW9uTXMgLyAxMDAwO1xuICAgICAgICB0aGlzLmZhc3RfLnNhbXBsZSh3ZWlnaHQsIGJhbmR3aWR0aCk7XG4gICAgICAgIHRoaXMuc2xvd18uc2FtcGxlKHdlaWdodCwgYmFuZHdpZHRoKTtcbiAgICB9O1xuICAgIEV3bWFCYW5kV2lkdGhFc3RpbWF0b3IucHJvdG90eXBlLmNhbkVzdGltYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZmFzdCA9IHRoaXMuZmFzdF87XG4gICAgICAgIHJldHVybiAoZmFzdCAmJiBmYXN0LmdldFRvdGFsV2VpZ2h0KCkgPj0gdGhpcy5taW5XZWlnaHRfKTtcbiAgICB9O1xuICAgIEV3bWFCYW5kV2lkdGhFc3RpbWF0b3IucHJvdG90eXBlLmdldEVzdGltYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jYW5Fc3RpbWF0ZSgpKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnc2xvdyBlc3RpbWF0ZTonKyBNYXRoLnJvdW5kKHRoaXMuc2xvd18uZ2V0RXN0aW1hdGUoKSkpO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2Zhc3QgZXN0aW1hdGU6JysgTWF0aC5yb3VuZCh0aGlzLmZhc3RfLmdldEVzdGltYXRlKCkpKTtcbiAgICAgICAgICAgIC8vIFRha2UgdGhlIG1pbmltdW0gb2YgdGhlc2UgdHdvIGVzdGltYXRlcy4gIFRoaXMgc2hvdWxkIGhhdmUgdGhlIGVmZmVjdCBvZlxuICAgICAgICAgICAgLy8gYWRhcHRpbmcgZG93biBxdWlja2x5LCBidXQgdXAgbW9yZSBzbG93bHkuXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5mYXN0Xy5nZXRFc3RpbWF0ZSgpLCB0aGlzLnNsb3dfLmdldEVzdGltYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdEVzdGltYXRlXztcbiAgICAgICAgfVxuICAgIH07XG4gICAgRXdtYUJhbmRXaWR0aEVzdGltYXRvci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB9O1xuICAgIHJldHVybiBFd21hQmFuZFdpZHRoRXN0aW1hdG9yO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEV3bWFCYW5kV2lkdGhFc3RpbWF0b3I7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvZXdtYS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2V3bWEuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLypcbiAqIGNvbXB1dGUgYW4gRXhwb25lbnRpYWwgV2VpZ2h0ZWQgbW92aW5nIGF2ZXJhZ2VcbiAqIC0gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW92aW5nX2F2ZXJhZ2UjRXhwb25lbnRpYWxfbW92aW5nX2F2ZXJhZ2VcbiAqICAtIGhlYXZpbHkgaW5zcGlyZWQgZnJvbSBzaGFrYS1wbGF5ZXJcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEVXTUEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLy8gIEFib3V0IGhhbGYgb2YgdGhlIGVzdGltYXRlZCB2YWx1ZSB3aWxsIGJlIGZyb20gdGhlIGxhc3QgfGhhbGZMaWZlfCBzYW1wbGVzIGJ5IHdlaWdodC5cbiAgICBmdW5jdGlvbiBFV01BKGhhbGZMaWZlKSB7XG4gICAgICAgIC8vIExhcmdlciB2YWx1ZXMgb2YgYWxwaGEgZXhwaXJlIGhpc3RvcmljYWwgZGF0YSBtb3JlIHNsb3dseS5cbiAgICAgICAgdGhpcy5hbHBoYV8gPSBoYWxmTGlmZSA/IE1hdGguZXhwKE1hdGgubG9nKDAuNSkgLyBoYWxmTGlmZSkgOiAwO1xuICAgICAgICB0aGlzLmVzdGltYXRlXyA9IDA7XG4gICAgICAgIHRoaXMudG90YWxXZWlnaHRfID0gMDtcbiAgICB9XG4gICAgRVdNQS5wcm90b3R5cGUuc2FtcGxlID0gZnVuY3Rpb24gKHdlaWdodCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGFkakFscGhhID0gTWF0aC5wb3codGhpcy5hbHBoYV8sIHdlaWdodCk7XG4gICAgICAgIHRoaXMuZXN0aW1hdGVfID0gdmFsdWUgKiAoMSAtIGFkakFscGhhKSArIGFkakFscGhhICogdGhpcy5lc3RpbWF0ZV87XG4gICAgICAgIHRoaXMudG90YWxXZWlnaHRfICs9IHdlaWdodDtcbiAgICB9O1xuICAgIEVXTUEucHJvdG90eXBlLmdldFRvdGFsV2VpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b3RhbFdlaWdodF87XG4gICAgfTtcbiAgICBFV01BLnByb3RvdHlwZS5nZXRFc3RpbWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWxwaGFfKSB7XG4gICAgICAgICAgICB2YXIgemVyb0ZhY3RvciA9IDEgLSBNYXRoLnBvdyh0aGlzLmFscGhhXywgdGhpcy50b3RhbFdlaWdodF8pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVfIC8gemVyb0ZhY3RvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVzdGltYXRlXztcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEVXTUE7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRVdNQTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9nZXQtc2VsZi1zY29wZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy9nZXQtc2VsZi1zY29wZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gZ2V0U2VsZlNjb3BlKCkge1xuICAgIC8vIHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTEyMzcyNTkvNTg5NDkzXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZiAqL1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRTZWxmU2NvcGUgPSBnZXRTZWxmU2NvcGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy9sb2dnZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ2V0X3NlbGZfc2NvcGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0LXNlbGYtc2NvcGUgKi8gXCIuL3NyYy91dGlscy9nZXQtc2VsZi1zY29wZS5qc1wiKTtcbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbnZhciBmYWtlTG9nZ2VyID0ge1xuICAgIHRyYWNlOiBub29wLFxuICAgIGRlYnVnOiBub29wLFxuICAgIGxvZzogbm9vcCxcbiAgICB3YXJuOiBub29wLFxuICAgIGluZm86IG5vb3AsXG4gICAgZXJyb3I6IG5vb3Bcbn07XG52YXIgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyO1xuLy8gbGV0IGxhc3RDYWxsVGltZTtcbi8vIGZ1bmN0aW9uIGZvcm1hdE1zZ1dpdGhUaW1lSW5mbyh0eXBlLCBtc2cpIHtcbi8vICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbi8vICAgY29uc3QgZGlmZiA9IGxhc3RDYWxsVGltZSA/ICcrJyArIChub3cgLSBsYXN0Q2FsbFRpbWUpIDogJzAnO1xuLy8gICBsYXN0Q2FsbFRpbWUgPSBub3c7XG4vLyAgIG1zZyA9IChuZXcgRGF0ZShub3cpKS50b0lTT1N0cmluZygpICsgJyB8IFsnICsgIHR5cGUgKyAnXSA+ICcgKyBtc2cgKyAnICggJyArIGRpZmYgKyAnIG1zICknO1xuLy8gICByZXR1cm4gbXNnO1xuLy8gfVxuZnVuY3Rpb24gZm9ybWF0TXNnKHR5cGUsIG1zZykge1xuICAgIG1zZyA9ICdbJyArIHR5cGUgKyAnXSA+ICcgKyBtc2c7XG4gICAgcmV0dXJuIG1zZztcbn1cbnZhciBnbG9iYWwgPSBnZXRfc2VsZl9zY29wZV8xLmdldFNlbGZTY29wZSgpO1xuZnVuY3Rpb24gY29uc29sZVByaW50Rm4odHlwZSkge1xuICAgIHZhciBmdW5jID0gZ2xvYmFsLmNvbnNvbGVbdHlwZV07XG4gICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcmdzWzBdKSB7XG4gICAgICAgICAgICAgICAgYXJnc1swXSA9IGZvcm1hdE1zZyh0eXBlLCBhcmdzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmMuYXBwbHkoZ2xvYmFsLmNvbnNvbGUsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbm9vcDtcbn1cbmZ1bmN0aW9uIGV4cG9ydExvZ2dlckZ1bmN0aW9ucyhkZWJ1Z0NvbmZpZykge1xuICAgIHZhciBmdW5jdGlvbnMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBmdW5jdGlvbnNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGZ1bmN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIGV4cG9ydGVkTG9nZ2VyW3R5cGVdID0gZGVidWdDb25maWdbdHlwZV0gPyBkZWJ1Z0NvbmZpZ1t0eXBlXS5iaW5kKGRlYnVnQ29uZmlnKSA6IGNvbnNvbGVQcmludEZuKHR5cGUpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5lbmFibGVMb2dzID0gZnVuY3Rpb24gKGRlYnVnQ29uZmlnKSB7XG4gICAgaWYgKGRlYnVnQ29uZmlnID09PSB0cnVlIHx8IHR5cGVvZiBkZWJ1Z0NvbmZpZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZXhwb3J0TG9nZ2VyRnVuY3Rpb25zKGRlYnVnQ29uZmlnLCBcbiAgICAgICAgLy8gUmVtb3ZlIG91dCBmcm9tIGxpc3QgaGVyZSB0byBoYXJkLWRpc2FibGUgYSBsb2ctbGV2ZWxcbiAgICAgICAgLy8gJ3RyYWNlJyxcbiAgICAgICAgJ2RlYnVnJywgJ2xvZycsICdpbmZvJywgJ3dhcm4nLCAnZXJyb3InKTtcbiAgICAgICAgLy8gU29tZSBicm93c2VycyBkb24ndCBhbGxvdyB0byB1c2UgYmluZCBvbiBjb25zb2xlIG9iamVjdCBhbnl3YXlcbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gZGVmYXVsdCBpZiBuZWVkZWRcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGV4cG9ydGVkTG9nZ2VyLmxvZygpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGV4cG9ydGVkTG9nZ2VyID0gZmFrZUxvZ2dlcjtcbiAgICB9XG59O1xuZXhwb3J0cy5sb2dnZXIgPSBleHBvcnRlZExvZ2dlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9tZWRpYWtleXMtaGVscGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvbWVkaWFrZXlzLWhlbHBlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzcykge1xuICAgICAgICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MuYmluZCh3aW5kb3cubmF2aWdhdG9yKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn0pKCk7XG5leHBvcnRzLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyA9IHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9tZWRpYXNvdXJjZS1oZWxwZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL21lZGlhc291cmNlLWhlbHBlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogTWVkaWFTb3VyY2UgaGVscGVyXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGdldE1lZGlhU291cmNlKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gd2luZG93Lk1lZGlhU291cmNlIHx8IHdpbmRvdy5XZWJLaXRNZWRpYVNvdXJjZTtcbiAgICB9XG59XG5leHBvcnRzLmdldE1lZGlhU291cmNlID0gZ2V0TWVkaWFTb3VyY2U7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvb3V0cHV0LWZpbHRlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL291dHB1dC1maWx0ZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE91dHB1dEZpbHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPdXRwdXRGaWx0ZXIodGltZWxpbmVDb250cm9sbGVyLCB0cmFja05hbWUpIHtcbiAgICAgICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIgPSB0aW1lbGluZUNvbnRyb2xsZXI7XG4gICAgICAgIHRoaXMudHJhY2tOYW1lID0gdHJhY2tOYW1lO1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZW5kVGltZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2NyZWVuID0gbnVsbDtcbiAgICB9XG4gICAgT3V0cHV0RmlsdGVyLnByb3RvdHlwZS5kaXNwYXRjaEN1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRUaW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIuYWRkQ3Vlcyh0aGlzLnRyYWNrTmFtZSwgdGhpcy5zdGFydFRpbWUsIHRoaXMuZW5kVGltZSwgdGhpcy5zY3JlZW4pO1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG4gICAgfTtcbiAgICBPdXRwdXRGaWx0ZXIucHJvdG90eXBlLm5ld0N1ZSA9IGZ1bmN0aW9uIChzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbikge1xuICAgICAgICBpZiAodGhpcy5zdGFydFRpbWUgPT09IG51bGwgfHwgdGhpcy5zdGFydFRpbWUgPiBzdGFydFRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW5kVGltZSA9IGVuZFRpbWU7XG4gICAgICAgIHRoaXMuc2NyZWVuID0gc2NyZWVuO1xuICAgICAgICB0aGlzLnRpbWVsaW5lQ29udHJvbGxlci5jcmVhdGVDYXB0aW9uc1RyYWNrKHRoaXMudHJhY2tOYW1lKTtcbiAgICB9O1xuICAgIHJldHVybiBPdXRwdXRGaWx0ZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gT3V0cHV0RmlsdGVyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL3RleHR0cmFjay11dGlscy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvdGV4dHRyYWNrLXV0aWxzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gc2VuZEFkZFRyYWNrRXZlbnQodHJhY2ssIHZpZGVvRWwpIHtcbiAgICB2YXIgZXZlbnQgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICAgIGV2ZW50ID0gbmV3IHdpbmRvdy5FdmVudCgnYWRkdHJhY2snKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBmb3IgSUUxMVxuICAgICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgICBldmVudC5pbml0RXZlbnQoJ2FkZHRyYWNrJywgZmFsc2UsIGZhbHNlKTtcbiAgICB9XG4gICAgZXZlbnQudHJhY2sgPSB0cmFjaztcbiAgICB2aWRlb0VsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuZXhwb3J0cy5zZW5kQWRkVHJhY2tFdmVudCA9IHNlbmRBZGRUcmFja0V2ZW50O1xuZnVuY3Rpb24gY2xlYXJDdXJyZW50Q3Vlcyh0cmFjaykge1xuICAgIGlmICh0cmFjayAmJiB0cmFjay5jdWVzKSB7XG4gICAgICAgIHdoaWxlICh0cmFjay5jdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRyYWNrLnJlbW92ZUN1ZSh0cmFjay5jdWVzWzBdKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuY2xlYXJDdXJyZW50Q3VlcyA9IGNsZWFyQ3VycmVudEN1ZXM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvdGltZS1yYW5nZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvdGltZS1yYW5nZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogIFRpbWVSYW5nZXMgdG8gc3RyaW5nIGhlbHBlclxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVGltZVJhbmdlcyA9IHtcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgdmFyIGxvZyA9ICcnLCBsZW4gPSByLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgbG9nICs9ICdbJyArIHIuc3RhcnQoaSkudG9GaXhlZCgzKSArICcsJyArIHIuZW5kKGkpLnRvRml4ZWQoMykgKyAnXSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZztcbiAgICB9XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gVGltZVJhbmdlcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy92dHRjdWUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL3Z0dGN1ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTMgdnR0LmpzIENvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5WVFRDdWUpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5WVFRDdWU7XG4gICAgfVxuICAgIHZhciBhdXRvS2V5d29yZCA9ICdhdXRvJztcbiAgICB2YXIgZGlyZWN0aW9uU2V0dGluZyA9IHtcbiAgICAgICAgJyc6IHRydWUsXG4gICAgICAgIGxyOiB0cnVlLFxuICAgICAgICBybDogdHJ1ZVxuICAgIH07XG4gICAgdmFyIGFsaWduU2V0dGluZyA9IHtcbiAgICAgICAgc3RhcnQ6IHRydWUsXG4gICAgICAgIG1pZGRsZTogdHJ1ZSxcbiAgICAgICAgZW5kOiB0cnVlLFxuICAgICAgICBsZWZ0OiB0cnVlLFxuICAgICAgICByaWdodDogdHJ1ZVxuICAgIH07XG4gICAgZnVuY3Rpb24gZmluZERpcmVjdGlvblNldHRpbmcodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlyID0gZGlyZWN0aW9uU2V0dGluZ1t2YWx1ZS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgcmV0dXJuIGRpciA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZEFsaWduU2V0dGluZyh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbGlnbiA9IGFsaWduU2V0dGluZ1t2YWx1ZS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgcmV0dXJuIGFsaWduID8gdmFsdWUudG9Mb3dlckNhc2UoKSA6IGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBleHRlbmQob2JqKSB7XG4gICAgICAgIHZhciBpID0gMTtcbiAgICAgICAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjb2JqID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBjb2JqKSB7XG4gICAgICAgICAgICAgICAgb2JqW3BdID0gY29ialtwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBmdW5jdGlvbiBWVFRDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCB0ZXh0KSB7XG4gICAgICAgIHZhciBjdWUgPSB0aGlzO1xuICAgICAgICB2YXIgaXNJRTggPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgvTVNJRVxcczhcXC4wLykudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgdmFyIGJhc2VPYmogPSB7fTtcbiAgICAgICAgaWYgKGlzSUU4KSB7XG4gICAgICAgICAgICBjdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJhc2VPYmouZW51bWVyYWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNoaW0gaW1wbGVtZW50YXRpb24gc3BlY2lmaWMgcHJvcGVydGllcy4gVGhlc2UgcHJvcGVydGllcyBhcmUgbm90IGluXG4gICAgICAgICAqIHRoZSBzcGVjLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gTGV0cyB1cyBrbm93IHdoZW4gdGhlIFZUVEN1ZSdzIGRhdGEgaGFzIGNoYW5nZWQgaW4gc3VjaCBhIHdheSB0aGF0IHdlIG5lZWRcbiAgICAgICAgLy8gdG8gcmVjb21wdXRlIGl0cyBkaXNwbGF5IHN0YXRlLiBUaGlzIGxldHMgdXMgY29tcHV0ZSBpdHMgZGlzcGxheSBzdGF0ZVxuICAgICAgICAvLyBsYXppbHkuXG4gICAgICAgIGN1ZS5oYXNCZWVuUmVzZXQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZUVEN1ZSBhbmQgVGV4dFRyYWNrQ3VlIHByb3BlcnRpZXNcbiAgICAgICAgICogaHR0cDovL2Rldi53My5vcmcvaHRtbDUvd2VidnR0LyN2dHRjdWUtaW50ZXJmYWNlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgX2lkID0gJyc7XG4gICAgICAgIHZhciBfcGF1c2VPbkV4aXQgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9zdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gICAgICAgIHZhciBfZW5kVGltZSA9IGVuZFRpbWU7XG4gICAgICAgIHZhciBfdGV4dCA9IHRleHQ7XG4gICAgICAgIHZhciBfcmVnaW9uID0gbnVsbDtcbiAgICAgICAgdmFyIF92ZXJ0aWNhbCA9ICcnO1xuICAgICAgICB2YXIgX3NuYXBUb0xpbmVzID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9saW5lID0gJ2F1dG8nO1xuICAgICAgICB2YXIgX2xpbmVBbGlnbiA9ICdzdGFydCc7XG4gICAgICAgIHZhciBfcG9zaXRpb24gPSA1MDtcbiAgICAgICAgdmFyIF9wb3NpdGlvbkFsaWduID0gJ21pZGRsZSc7XG4gICAgICAgIHZhciBfc2l6ZSA9IDUwO1xuICAgICAgICB2YXIgX2FsaWduID0gJ21pZGRsZSc7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdpZCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9pZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIF9pZCA9ICcnICsgdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3BhdXNlT25FeGl0JywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3BhdXNlT25FeGl0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgX3BhdXNlT25FeGl0ID0gISF2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnc3RhcnRUaW1lJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N0YXJ0VGltZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N0YXJ0IHRpbWUgbXVzdCBiZSBzZXQgdG8gYSBudW1iZXIuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9zdGFydFRpbWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2VuZFRpbWUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZW5kVGltZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuZCB0aW1lIG11c3QgYmUgc2V0IHRvIGEgbnVtYmVyLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfZW5kVGltZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAndGV4dCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90ZXh0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgX3RleHQgPSAnJyArIHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAncmVnaW9uJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2lvbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIF9yZWdpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3ZlcnRpY2FsJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3ZlcnRpY2FsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kRGlyZWN0aW9uU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gSGF2ZSB0byBjaGVjayBmb3IgZmFsc2UgYmVjYXVzZSB0aGUgc2V0dGluZyBhbiBiZSBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdmVydGljYWwgPSBzZXR0aW5nO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnc25hcFRvTGluZXMnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc25hcFRvTGluZXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfc25hcFRvTGluZXMgPSAhIXZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnbGluZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9saW5lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgJiYgdmFsdWUgIT09IGF1dG9LZXl3b3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBudW1iZXIgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2xpbmUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2xpbmVBbGlnbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9saW5lQWxpZ247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2xpbmVBbGlnbiA9IHNldHRpbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdwb3NpdGlvbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9wb3NpdGlvbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3NpdGlvbiBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfcG9zaXRpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3Bvc2l0aW9uQWxpZ24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcG9zaXRpb25BbGlnbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfcG9zaXRpb25BbGlnbiA9IHNldHRpbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzaXplJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NpemU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2l6ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfc2l6ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnYWxpZ24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfYWxpZ247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2FsaWduID0gc2V0dGluZztcbiAgICAgICAgICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE90aGVyIDx0cmFjaz4gc3BlYyBkZWZpbmVkIHByb3BlcnRpZXNcbiAgICAgICAgICovXG4gICAgICAgIC8vIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS12aWRlby1lbGVtZW50Lmh0bWwjdGV4dC10cmFjay1jdWUtZGlzcGxheS1zdGF0ZVxuICAgICAgICBjdWUuZGlzcGxheVN0YXRlID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaXNJRTgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVlRUQ3VlIG1ldGhvZHNcbiAgICAgKi9cbiAgICBWVFRDdWUucHJvdG90eXBlLmdldEN1ZUFzSFRNTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQXNzdW1lIFdlYlZUVC5jb252ZXJ0Q3VlVG9ET01UcmVlIGlzIG9uIHRoZSBnbG9iYWwuXG4gICAgICAgIHZhciBXZWJWVFQgPSB3aW5kb3cuV2ViVlRUO1xuICAgICAgICByZXR1cm4gV2ViVlRULmNvbnZlcnRDdWVUb0RPTVRyZWUod2luZG93LCB0aGlzLnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFZUVEN1ZTtcbn0pKCk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvdnR0cGFyc2VyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy92dHRwYXJzZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKlxuICogU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS92dHQuanMvYmxvYi9tYXN0ZXIvZGlzdC92dHQuanMjTDE3MTZcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZ0dGN1ZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi92dHRjdWUgKi8gXCIuL3NyYy91dGlscy92dHRjdWUuanNcIik7XG52YXIgU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVjb2RlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgLSBleHBlY3RlZCBzdHJpbmcgZGF0YS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZW5jb2RlVVJJQ29tcG9uZW50KGRhdGEpKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuZnVuY3Rpb24gVlRUUGFyc2VyKCkge1xuICAgIHRoaXMud2luZG93ID0gd2luZG93O1xuICAgIHRoaXMuc3RhdGUgPSAnSU5JVElBTCc7XG4gICAgdGhpcy5idWZmZXIgPSAnJztcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcigpO1xuICAgIHRoaXMucmVnaW9uTGlzdCA9IFtdO1xufVxuLy8gVHJ5IHRvIHBhcnNlIGlucHV0IGFzIGEgdGltZSBzdGFtcC5cbmZ1bmN0aW9uIHBhcnNlVGltZVN0YW1wKGlucHV0KSB7XG4gICAgZnVuY3Rpb24gY29tcHV0ZVNlY29uZHMoaCwgbSwgcywgZikge1xuICAgICAgICByZXR1cm4gKGggfCAwKSAqIDM2MDAgKyAobSB8IDApICogNjAgKyAocyB8IDApICsgKGYgfCAwKSAvIDEwMDA7XG4gICAgfVxuICAgIHZhciBtID0gaW5wdXQubWF0Y2goL14oXFxkKyk6KFxcZHsyfSkoOlxcZHsyfSk/XFwuKFxcZHszfSkvKTtcbiAgICBpZiAoIW0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChtWzNdKSB7XG4gICAgICAgIC8vIFRpbWVzdGFtcCB0YWtlcyB0aGUgZm9ybSBvZiBbaG91cnNdOlttaW51dGVzXTpbc2Vjb25kc10uW21pbGxpc2Vjb25kc11cbiAgICAgICAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKG1bMV0sIG1bMl0sIG1bM10ucmVwbGFjZSgnOicsICcnKSwgbVs0XSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1bMV0gPiA1OSkge1xuICAgICAgICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW2hvdXJzXTpbbWludXRlc10uW21pbGxpc2Vjb25kc11cbiAgICAgICAgLy8gRmlyc3QgcG9zaXRpb24gaXMgaG91cnMgYXMgaXQncyBvdmVyIDU5LlxuICAgICAgICByZXR1cm4gY29tcHV0ZVNlY29uZHMobVsxXSwgbVsyXSwgMCwgbVs0XSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW21pbnV0ZXNdOltzZWNvbmRzXS5bbWlsbGlzZWNvbmRzXVxuICAgICAgICByZXR1cm4gY29tcHV0ZVNlY29uZHMoMCwgbVsxXSwgbVsyXSwgbVs0XSk7XG4gICAgfVxufVxuLy8gQSBzZXR0aW5ncyBvYmplY3QgaG9sZHMga2V5L3ZhbHVlIHBhaXJzIGFuZCB3aWxsIGlnbm9yZSBhbnl0aGluZyBidXQgdGhlIGZpcnN0XG4vLyBhc3NpZ25tZW50IHRvIGEgc3BlY2lmaWMga2V5LlxuZnVuY3Rpb24gU2V0dGluZ3MoKSB7XG4gICAgdGhpcy52YWx1ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuU2V0dGluZ3MucHJvdG90eXBlID0ge1xuICAgIC8vIE9ubHkgYWNjZXB0IHRoZSBmaXJzdCBhc3NpZ25tZW50IHRvIGFueSBrZXkuXG4gICAgc2V0OiBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICBpZiAoIXRoaXMuZ2V0KGspICYmIHYgIT09ICcnKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlc1trXSA9IHY7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8vIFJldHVybiB0aGUgdmFsdWUgZm9yIGEga2V5LCBvciBhIGRlZmF1bHQgdmFsdWUuXG4gICAgLy8gSWYgJ2RlZmF1bHRLZXknIGlzIHBhc3NlZCB0aGVuICdkZmx0JyBpcyBhc3N1bWVkIHRvIGJlIGFuIG9iamVjdCB3aXRoXG4gICAgLy8gYSBudW1iZXIgb2YgcG9zc2libGUgZGVmYXVsdCB2YWx1ZXMgYXMgcHJvcGVydGllcyB3aGVyZSAnZGVmYXVsdEtleScgaXNcbiAgICAvLyB0aGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0aGF0IHdpbGwgYmUgY2hvc2VuOyBvdGhlcndpc2UgaXQncyBhc3N1bWVkIHRvIGJlXG4gICAgLy8gYSBzaW5nbGUgdmFsdWUuXG4gICAgZ2V0OiBmdW5jdGlvbiAoaywgZGZsdCwgZGVmYXVsdEtleSkge1xuICAgICAgICBpZiAoZGVmYXVsdEtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzKGspID8gdGhpcy52YWx1ZXNba10gOiBkZmx0W2RlZmF1bHRLZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhhcyhrKSA/IHRoaXMudmFsdWVzW2tdIDogZGZsdDtcbiAgICB9LFxuICAgIC8vIENoZWNrIHdoZXRoZXIgd2UgaGF2ZSBhIHZhbHVlIGZvciBhIGtleS5cbiAgICBoYXM6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrIGluIHRoaXMudmFsdWVzO1xuICAgIH0sXG4gICAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgb25lIG9mIHRoZSBnaXZlbiBhbHRlcm5hdGl2ZXMuXG4gICAgYWx0OiBmdW5jdGlvbiAoaywgdiwgYSkge1xuICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGEubGVuZ3RoOyArK24pIHtcbiAgICAgICAgICAgIGlmICh2ID09PSBhW25dKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoaywgdik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8vIEFjY2VwdCBhIHNldHRpbmcgaWYgaXRzIGEgdmFsaWQgKHNpZ25lZCkgaW50ZWdlci5cbiAgICBpbnRlZ2VyOiBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICBpZiAoL14tP1xcZCskLy50ZXN0KHYpKSB7IC8vIGludGVnZXJcbiAgICAgICAgICAgIHRoaXMuc2V0KGssIHBhcnNlSW50KHYsIDEwKSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8vIEFjY2VwdCBhIHNldHRpbmcgaWYgaXRzIGEgdmFsaWQgcGVyY2VudGFnZS5cbiAgICBwZXJjZW50OiBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICB2YXIgbTtcbiAgICAgICAgaWYgKChtID0gdi5tYXRjaCgvXihbXFxkXXsxLDN9KShcXC5bXFxkXSopPyUkLykpKSB7XG4gICAgICAgICAgICB2ID0gcGFyc2VGbG9hdCh2KTtcbiAgICAgICAgICAgIGlmICh2ID49IDAgJiYgdiA8PSAxMDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldChrLCB2KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbi8vIEhlbHBlciBmdW5jdGlvbiB0byBwYXJzZSBpbnB1dCBpbnRvIGdyb3VwcyBzZXBhcmF0ZWQgYnkgJ2dyb3VwRGVsaW0nLCBhbmRcbi8vIGludGVycHJldGUgZWFjaCBncm91cCBhcyBhIGtleS92YWx1ZSBwYWlyIHNlcGFyYXRlZCBieSAna2V5VmFsdWVEZWxpbScuXG5mdW5jdGlvbiBwYXJzZU9wdGlvbnMoaW5wdXQsIGNhbGxiYWNrLCBrZXlWYWx1ZURlbGltLCBncm91cERlbGltKSB7XG4gICAgdmFyIGdyb3VwcyA9IGdyb3VwRGVsaW0gPyBpbnB1dC5zcGxpdChncm91cERlbGltKSA6IFtpbnB1dF07XG4gICAgZm9yICh2YXIgaSBpbiBncm91cHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBncm91cHNbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga3YgPSBncm91cHNbaV0uc3BsaXQoa2V5VmFsdWVEZWxpbSk7XG4gICAgICAgIGlmIChrdi5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrID0ga3ZbMF07XG4gICAgICAgIHZhciB2ID0ga3ZbMV07XG4gICAgICAgIGNhbGxiYWNrKGssIHYpO1xuICAgIH1cbn1cbnZhciBkZWZhdWx0cyA9IG5ldyB2dHRjdWVfMS5kZWZhdWx0KDAsIDAsIDApO1xuLy8gJ21pZGRsZScgd2FzIGNoYW5nZWQgdG8gJ2NlbnRlcicgaW4gdGhlIHNwZWM6IGh0dHBzOi8vZ2l0aHViLmNvbS93M2Mvd2VidnR0L3B1bGwvMjQ0XG4vLyAgU2FmYXJpIGRvZXNuJ3QgeWV0IHN1cHBvcnQgdGhpcyBjaGFuZ2UsIGJ1dCBGRiBhbmQgQ2hyb21lIGRvLlxudmFyIGNlbnRlciA9IGRlZmF1bHRzLmFsaWduID09PSAnbWlkZGxlJyA/ICdtaWRkbGUnIDogJ2NlbnRlcic7XG5mdW5jdGlvbiBwYXJzZUN1ZShpbnB1dCwgY3VlLCByZWdpb25MaXN0KSB7XG4gICAgLy8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIGlucHV0IGlmIHdlIG5lZWQgdG8gdGhyb3cgYW4gZXJyb3IuXG4gICAgdmFyIG9JbnB1dCA9IGlucHV0O1xuICAgIC8vIDQuMSBXZWJWVFQgdGltZXN0YW1wXG4gICAgZnVuY3Rpb24gY29uc3VtZVRpbWVTdGFtcCgpIHtcbiAgICAgICAgdmFyIHRzID0gcGFyc2VUaW1lU3RhbXAoaW5wdXQpO1xuICAgICAgICBpZiAodHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIHRpbWVzdGFtcDogJyArIG9JbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRpbWUgc3RhbXAgZnJvbSBpbnB1dC5cbiAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eW15cXHNhLXpBLVotXSsvLCAnJyk7XG4gICAgICAgIHJldHVybiB0cztcbiAgICB9XG4gICAgLy8gNC40LjIgV2ViVlRUIGN1ZSBzZXR0aW5nc1xuICAgIGZ1bmN0aW9uIGNvbnN1bWVDdWVTZXR0aW5ncyhpbnB1dCwgY3VlKSB7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncygpO1xuICAgICAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGspIHtcbiAgICAgICAgICAgICAgICBjYXNlICdyZWdpb24nOlxuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBsYXN0IHJlZ2lvbiB3ZSBwYXJzZWQgd2l0aCB0aGUgc2FtZSByZWdpb24gaWQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSByZWdpb25MaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVnaW9uTGlzdFtpXS5pZCA9PT0gdikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnNldChrLCByZWdpb25MaXN0W2ldLnJlZ2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5hbHQoaywgdiwgWydybCcsICdsciddKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbGluZSc6XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWxzID0gdi5zcGxpdCgnLCcpLCB2YWxzMCA9IHZhbHNbMF07XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmludGVnZXIoaywgdmFsczApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MucGVyY2VudChrLCB2YWxzMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnNldCgnc25hcFRvTGluZXMnLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYWx0KGssIHZhbHMwLCBbJ2F1dG8nXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYWx0KCdsaW5lQWxpZ24nLCB2YWxzWzFdLCBbJ3N0YXJ0JywgY2VudGVyLCAnZW5kJ10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3Bvc2l0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgdmFscyA9IHYuc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2YWxzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5hbHQoJ3Bvc2l0aW9uQWxpZ24nLCB2YWxzWzFdLCBbJ3N0YXJ0JywgY2VudGVyLCAnZW5kJywgJ2xpbmUtbGVmdCcsICdsaW5lLXJpZ2h0JywgJ2F1dG8nXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2l6ZSc6XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnBlcmNlbnQoaywgdik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FsaWduJzpcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYWx0KGssIHYsIFsnc3RhcnQnLCBjZW50ZXIsICdlbmQnLCAnbGVmdCcsICdyaWdodCddKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIC86LywgL1xccy8pO1xuICAgICAgICAvLyBBcHBseSBkZWZhdWx0IHZhbHVlcyBmb3IgYW55IG1pc3NpbmcgZmllbGRzLlxuICAgICAgICBjdWUucmVnaW9uID0gc2V0dGluZ3MuZ2V0KCdyZWdpb24nLCBudWxsKTtcbiAgICAgICAgY3VlLnZlcnRpY2FsID0gc2V0dGluZ3MuZ2V0KCd2ZXJ0aWNhbCcsICcnKTtcbiAgICAgICAgdmFyIGxpbmUgPSBzZXR0aW5ncy5nZXQoJ2xpbmUnLCAnYXV0bycpO1xuICAgICAgICBpZiAobGluZSA9PT0gJ2F1dG8nICYmIGRlZmF1bHRzLmxpbmUgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBzZXQgbnVtZXJpYyBsaW5lIG51bWJlciBmb3IgU2FmYXJpXG4gICAgICAgICAgICBsaW5lID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgY3VlLmxpbmUgPSBsaW5lO1xuICAgICAgICBjdWUubGluZUFsaWduID0gc2V0dGluZ3MuZ2V0KCdsaW5lQWxpZ24nLCAnc3RhcnQnKTtcbiAgICAgICAgY3VlLnNuYXBUb0xpbmVzID0gc2V0dGluZ3MuZ2V0KCdzbmFwVG9MaW5lcycsIHRydWUpO1xuICAgICAgICBjdWUuc2l6ZSA9IHNldHRpbmdzLmdldCgnc2l6ZScsIDEwMCk7XG4gICAgICAgIGN1ZS5hbGlnbiA9IHNldHRpbmdzLmdldCgnYWxpZ24nLCBjZW50ZXIpO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBzZXR0aW5ncy5nZXQoJ3Bvc2l0aW9uJywgJ2F1dG8nKTtcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAnYXV0bycgJiYgZGVmYXVsdHMucG9zaXRpb24gPT09IDUwKSB7XG4gICAgICAgICAgICAvLyBzZXQgbnVtZXJpYyBwb3NpdGlvbiBmb3IgU2FmYXJpXG4gICAgICAgICAgICBwb3NpdGlvbiA9IGN1ZS5hbGlnbiA9PT0gJ3N0YXJ0JyB8fCBjdWUuYWxpZ24gPT09ICdsZWZ0JyA/IDAgOiBjdWUuYWxpZ24gPT09ICdlbmQnIHx8IGN1ZS5hbGlnbiA9PT0gJ3JpZ2h0JyA/IDEwMCA6IDUwO1xuICAgICAgICB9XG4gICAgICAgIGN1ZS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBza2lwV2hpdGVzcGFjZSgpIHtcbiAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eXFxzKy8sICcnKTtcbiAgICB9XG4gICAgLy8gNC4xIFdlYlZUVCBjdWUgdGltaW5ncy5cbiAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgIGN1ZS5zdGFydFRpbWUgPSBjb25zdW1lVGltZVN0YW1wKCk7IC8vICgxKSBjb2xsZWN0IGN1ZSBzdGFydCB0aW1lXG4gICAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgICBpZiAoaW5wdXQuc3Vic3RyKDAsIDMpICE9PSAnLS0+JykgeyAvLyAoMykgbmV4dCBjaGFyYWN0ZXJzIG11c3QgbWF0Y2ggJy0tPidcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgdGltZSBzdGFtcCAodGltZSBzdGFtcHMgbXVzdCBiZSBzZXBhcmF0ZWQgYnkgXFwnLS0+XFwnKTogJyArXG4gICAgICAgICAgICBvSW5wdXQpO1xuICAgIH1cbiAgICBpbnB1dCA9IGlucHV0LnN1YnN0cigzKTtcbiAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgIGN1ZS5lbmRUaW1lID0gY29uc3VtZVRpbWVTdGFtcCgpOyAvLyAoNSkgY29sbGVjdCBjdWUgZW5kIHRpbWVcbiAgICAvLyA0LjEgV2ViVlRUIGN1ZSBzZXR0aW5ncyBsaXN0LlxuICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgY29uc3VtZUN1ZVNldHRpbmdzKGlucHV0LCBjdWUpO1xufVxuZnVuY3Rpb24gZml4TGluZUJyZWFrcyhpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC88YnIoPzogXFwvKT8+L2dpLCAnXFxuJyk7XG59XG5leHBvcnRzLmZpeExpbmVCcmVha3MgPSBmaXhMaW5lQnJlYWtzO1xuVlRUUGFyc2VyLnByb3RvdHlwZSA9IHtcbiAgICBwYXJzZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBkYXRhIHRoZW4gd2Ugd29uJ3QgZGVjb2RlIGl0LCBidXQgd2lsbCBqdXN0IHRyeSB0byBwYXJzZVxuICAgICAgICAvLyB3aGF0ZXZlciBpcyBpbiBidWZmZXIgYWxyZWFkeS4gVGhpcyBtYXkgb2NjdXIgaW4gY2lyY3Vtc3RhbmNlcywgZm9yXG4gICAgICAgIC8vIGV4YW1wbGUgd2hlbiBmbHVzaCgpIGlzIGNhbGxlZC5cbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBkZWNvZGUgdGhlIGRhdGEgdGhhdCB3ZSByZWNlaXZlZC5cbiAgICAgICAgICAgIHNlbGYuYnVmZmVyICs9IHNlbGYuZGVjb2Rlci5kZWNvZGUoZGF0YSwgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29sbGVjdE5leHRMaW5lKCkge1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IHNlbGYuYnVmZmVyO1xuICAgICAgICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICAgICAgICBidWZmZXIgPSBmaXhMaW5lQnJlYWtzKGJ1ZmZlcik7XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgYnVmZmVyLmxlbmd0aCAmJiBidWZmZXJbcG9zXSAhPT0gJ1xccicgJiYgYnVmZmVyW3Bvc10gIT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgKytwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGluZSA9IGJ1ZmZlci5zdWJzdHIoMCwgcG9zKTtcbiAgICAgICAgICAgIC8vIEFkdmFuY2UgdGhlIGJ1ZmZlciBlYXJseSBpbiBjYXNlIHdlIGZhaWwgYmVsb3cuXG4gICAgICAgICAgICBpZiAoYnVmZmVyW3Bvc10gPT09ICdcXHInKSB7XG4gICAgICAgICAgICAgICAgKytwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnVmZmVyW3Bvc10gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgKytwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmJ1ZmZlciA9IGJ1ZmZlci5zdWJzdHIocG9zKTtcbiAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICB9XG4gICAgICAgIC8vIDMuMiBXZWJWVFQgbWV0YWRhdGEgaGVhZGVyIHN5bnRheFxuICAgICAgICBmdW5jdGlvbiBwYXJzZUhlYWRlcihpbnB1dCkge1xuICAgICAgICAgICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoaykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdSZWdpb24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMy4zIFdlYlZUVCByZWdpb24gbWV0YWRhdGEgaGVhZGVyIHN5bnRheFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3BhcnNlIHJlZ2lvbicsIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFyc2VSZWdpb24odik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAvOi8pO1xuICAgICAgICB9XG4gICAgICAgIC8vIDUuMSBXZWJWVFQgZmlsZSBwYXJzaW5nLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gJ0lOSVRJQUwnKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuJ3Qgc3RhcnQgcGFyc2luZyB1bnRpbCB3ZSBoYXZlIHRoZSBmaXJzdCBsaW5lLlxuICAgICAgICAgICAgICAgIGlmICghL1xcclxcbnxcXG4vLnRlc3Qoc2VsZi5idWZmZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lID0gY29sbGVjdE5leHRMaW5lKCk7XG4gICAgICAgICAgICAgICAgLy8gc3RyaXAgb2YgVVRGLTggQk9NIGlmIGFueVxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0J5dGVfb3JkZXJfbWFyayNVVEYtOFxuICAgICAgICAgICAgICAgIHZhciBtID0gbGluZS5tYXRjaCgvXijDr8K7wr8pP1dFQlZUVChbIFxcdF0uKik/JC8pO1xuICAgICAgICAgICAgICAgIGlmICghbSB8fCAhbVswXSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBXZWJWVFQgc2lnbmF0dXJlLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLnN0YXRlID0gJ0hFQURFUic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYWxyZWFkeUNvbGxlY3RlZExpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlIChzZWxmLmJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIC8vIFdlIGNhbid0IHBhcnNlIGEgbGluZSB1bnRpbCB3ZSBoYXZlIHRoZSBmdWxsIGxpbmUuXG4gICAgICAgICAgICAgICAgaWYgKCEvXFxyXFxufFxcbi8udGVzdChzZWxmLmJ1ZmZlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghYWxyZWFkeUNvbGxlY3RlZExpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IGNvbGxlY3ROZXh0TGluZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWxyZWFkeUNvbGxlY3RlZExpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzZWxmLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0hFQURFUic6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAxMy0xOCAtIEFsbG93IGEgaGVhZGVyIChtZXRhZGF0YSkgdW5kZXIgdGhlIFdFQlZUVCBsaW5lLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC86Ly50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VIZWFkZXIobGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghbGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFuIGVtcHR5IGxpbmUgdGVybWluYXRlcyB0aGUgaGVhZGVyIGFuZCBzdGFydHMgdGhlIGJvZHkgKGN1ZXMpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnSUQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ05PVEUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIE5PVEUgYmxvY2tzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSUQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBzdGFydCBvZiBOT1RFIGJsb2Nrcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXk5PVEUoJHxbIFxcdF0pLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdOT1RFJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDE5LTI5IC0gQWxsb3cgYW55IG51bWJlciBvZiBsaW5lIHRlcm1pbmF0b3JzLCB0aGVuIGluaXRpYWxpemUgbmV3IGN1ZSB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY3VlID0gbmV3IHZ0dGN1ZV8xLmRlZmF1bHQoMCwgMCwgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdDVUUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMzAtMzkgLSBDaGVjayBpZiBzZWxmIGxpbmUgY29udGFpbnMgYW4gb3B0aW9uYWwgaWRlbnRpZmllciBvciB0aW1pbmcgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoJy0tPicpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY3VlLmlkID0gbGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBsaW5lIGFzIHN0YXJ0IG9mIGEgY3VlLlxuICAgICAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0NVRSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyA0MCAtIENvbGxlY3QgY3VlIHRpbWluZ3MgYW5kIHNldHRpbmdzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUN1ZShsaW5lLCBzZWxmLmN1ZSwgc2VsZi5yZWdpb25MaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gY2FzZSBvZiBhbiBlcnJvciBpZ25vcmUgcmVzdCBvZiB0aGUgY3VlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY3VlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnN0YXRlID0gJ0JBRENVRSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnN0YXRlID0gJ0NVRVRFWFQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0NVRVRFWFQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhc1N1YnN0cmluZyA9IGxpbmUuaW5kZXhPZignLS0+JykgIT09IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMzQgLSBJZiB3ZSBoYXZlIGFuIGVtcHR5IGxpbmUgdGhlbiByZXBvcnQgdGhlIGN1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDM1IC0gSWYgd2UgaGF2ZSB0aGUgc3BlY2lhbCBzdWJzdHJpbmcgJy0tPicgdGhlbiByZXBvcnQgdGhlIGN1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBkbyBub3QgY29sbGVjdCB0aGUgbGluZSBhcyB3ZSBuZWVkIHRvIHByb2Nlc3MgdGhlIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uZSBhcyBhIG5ldyBjdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxpbmUgfHwgaGFzU3Vic3RyaW5nICYmIChhbHJlYWR5Q29sbGVjdGVkTGluZSA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlIGRvbmUgcGFyc2luZyBzZWxmIGN1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5vbmN1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm9uY3VlKHNlbGYuY3VlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnSUQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY3VlLnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmN1ZS50ZXh0ICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jdWUudGV4dCArPSBsaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0JBRENVRSc6IC8vIEJBRENVRVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gNTQtNjIgLSBDb2xsZWN0IGFuZCBkaXNjYXJkIHRoZSByZW1haW5pbmcgY3VlLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgcGFyc2luZyBhIGN1ZSwgcmVwb3J0IHdoYXQgd2UgaGF2ZS5cbiAgICAgICAgICAgIGlmIChzZWxmLnN0YXRlID09PSAnQ1VFVEVYVCcgJiYgc2VsZi5jdWUgJiYgc2VsZi5vbmN1ZSkge1xuICAgICAgICAgICAgICAgIHNlbGYub25jdWUoc2VsZi5jdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5jdWUgPSBudWxsO1xuICAgICAgICAgICAgLy8gRW50ZXIgQkFEV0VCVlRUIHN0YXRlIGlmIGhlYWRlciB3YXMgbm90IHBhcnNlZCBjb3JyZWN0bHkgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBhbm90aGVyIGV4Y2VwdGlvbiBvY2N1cnJlZCBzbyBlbnRlciBCQURDVUUgc3RhdGUuXG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gc2VsZi5zdGF0ZSA9PT0gJ0lOSVRJQUwnID8gJ0JBRFdFQlZUVCcgOiAnQkFEQ1VFJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGZsdXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEZpbmlzaCBkZWNvZGluZyB0aGUgc3RyZWFtLlxuICAgICAgICAgICAgc2VsZi5idWZmZXIgKz0gc2VsZi5kZWNvZGVyLmRlY29kZSgpO1xuICAgICAgICAgICAgLy8gU3ludGhlc2l6ZSB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGN1ZSBvciByZWdpb24uXG4gICAgICAgICAgICBpZiAoc2VsZi5jdWUgfHwgc2VsZi5zdGF0ZSA9PT0gJ0hFQURFUicpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmJ1ZmZlciArPSAnXFxuXFxuJztcbiAgICAgICAgICAgICAgICBzZWxmLnBhcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSd2ZSBmbHVzaGVkLCBwYXJzZWQsIGFuZCB3ZSdyZSBzdGlsbCBvbiB0aGUgSU5JVElBTCBzdGF0ZSB0aGVuXG4gICAgICAgICAgICAvLyB0aGF0IG1lYW5zIHdlIGRvbid0IGhhdmUgZW5vdWdoIG9mIHRoZSBzdHJlYW0gdG8gcGFyc2UgdGhlIGZpcnN0XG4gICAgICAgICAgICAvLyBsaW5lLlxuICAgICAgICAgICAgaWYgKHNlbGYuc3RhdGUgPT09ICdJTklUSUFMJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFdlYlZUVCBzaWduYXR1cmUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYub25mbHVzaCkge1xuICAgICAgICAgICAgc2VsZi5vbmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IFZUVFBhcnNlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy93ZWJ2dHQtcGFyc2VyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvd2VidnR0LXBhcnNlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKE51bWJlcikge1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZ0dHBhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi92dHRwYXJzZXIgKi8gXCIuL3NyYy91dGlscy92dHRwYXJzZXIuanNcIik7XG52YXIgaWQzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9pZDMgKi8gXCIuL3NyYy9kZW11eC9pZDMuanNcIik7XG4vLyBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGggaXMgbm90IHN1cHBvcnRlZCBpbiBJRTExXG52YXIgc3RhcnRzV2l0aCA9IGZ1bmN0aW9uIChpbnB1dFN0cmluZywgc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikge1xuICAgIHJldHVybiBpbnB1dFN0cmluZy5zdWJzdHIocG9zaXRpb24gfHwgMCwgc2VhcmNoU3RyaW5nLmxlbmd0aCkgPT09IHNlYXJjaFN0cmluZztcbn07XG52YXIgY3VlU3RyaW5nMm1pbGxpcyA9IGZ1bmN0aW9uICh0aW1lU3RyaW5nKSB7XG4gICAgdmFyIHRzID0gcGFyc2VJbnQodGltZVN0cmluZy5zdWJzdHIoLTMpKTtcbiAgICB2YXIgc2VjcyA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc3Vic3RyKC02LCAyKSk7XG4gICAgdmFyIG1pbnMgPSBwYXJzZUludCh0aW1lU3RyaW5nLnN1YnN0cigtOSwgMikpO1xuICAgIHZhciBob3VycyA9IHRpbWVTdHJpbmcubGVuZ3RoID4gOSA/IHBhcnNlSW50KHRpbWVTdHJpbmcuc3Vic3RyKDAsIHRpbWVTdHJpbmcuaW5kZXhPZignOicpKSkgOiAwO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHRzKSB8fCAhTnVtYmVyLmlzRmluaXRlKHNlY3MpIHx8ICFOdW1iZXIuaXNGaW5pdGUobWlucykgfHwgIU51bWJlci5pc0Zpbml0ZShob3VycykpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICB0cyArPSAxMDAwICogc2VjcztcbiAgICB0cyArPSA2MCAqIDEwMDAgKiBtaW5zO1xuICAgIHRzICs9IDYwICogNjAgKiAxMDAwICogaG91cnM7XG4gICAgcmV0dXJuIHRzO1xufTtcbi8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Rhcmtza3lhcHAvc3RyaW5nLWhhc2hcbnZhciBoYXNoID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICB2YXIgaGFzaCA9IDUzODE7XG4gICAgdmFyIGkgPSB0ZXh0Lmxlbmd0aDtcbiAgICB3aGlsZSAoaSkge1xuICAgICAgICBoYXNoID0gKGhhc2ggKiAzMykgXiB0ZXh0LmNoYXJDb2RlQXQoLS1pKTtcbiAgICB9XG4gICAgcmV0dXJuIChoYXNoID4+PiAwKS50b1N0cmluZygpO1xufTtcbnZhciBjYWxjdWxhdGVPZmZzZXQgPSBmdW5jdGlvbiAodnR0Q0NzLCBjYywgcHJlc2VudGF0aW9uVGltZSkge1xuICAgIHZhciBjdXJyQ0MgPSB2dHRDQ3NbY2NdO1xuICAgIHZhciBwcmV2Q0MgPSB2dHRDQ3NbY3VyckNDLnByZXZDQ107XG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgZGlzY29udGludWl0eSBvciBjdWVzIGhhdmUgYmVlbiBwcm9jZXNzZWQgc2luY2UgdGhlIGxhc3QgZGlzY29udGludWl0eVxuICAgIC8vIE9mZnNldCA9IGN1cnJlbnQgZGlzY29udGludWl0eSB0aW1lXG4gICAgaWYgKCFwcmV2Q0MgfHwgKCFwcmV2Q0MubmV3ICYmIGN1cnJDQy5uZXcpKSB7XG4gICAgICAgIHZ0dENDcy5jY09mZnNldCA9IHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQgPSBjdXJyQ0Muc3RhcnQ7XG4gICAgICAgIGN1cnJDQy5uZXcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBUaGVyZSBoYXZlIGJlZW4gZGlzY29udGludWl0aWVzIHNpbmNlIGN1ZXMgd2VyZSBsYXN0IHBhcnNlZC5cbiAgICAvLyBPZmZzZXQgPSB0aW1lIGVsYXBzZWRcbiAgICB3aGlsZSAocHJldkNDICYmIHByZXZDQy5uZXcpIHtcbiAgICAgICAgdnR0Q0NzLmNjT2Zmc2V0ICs9IGN1cnJDQy5zdGFydCAtIHByZXZDQy5zdGFydDtcbiAgICAgICAgY3VyckNDLm5ldyA9IGZhbHNlO1xuICAgICAgICBjdXJyQ0MgPSBwcmV2Q0M7XG4gICAgICAgIHByZXZDQyA9IHZ0dENDc1tjdXJyQ0MucHJldkNDXTtcbiAgICB9XG4gICAgdnR0Q0NzLnByZXNlbnRhdGlvbk9mZnNldCA9IHByZXNlbnRhdGlvblRpbWU7XG59O1xudmFyIFdlYlZUVFBhcnNlciA9IHtcbiAgICBwYXJzZTogZnVuY3Rpb24gKHZ0dEJ5dGVBcnJheSwgc3luY1BUUywgdnR0Q0NzLCBjYywgY2FsbEJhY2ssIGVycm9yQ2FsbEJhY2spIHtcbiAgICAgICAgLy8gQ29udmVydCBieXRlQXJyYXkgaW50byBzdHJpbmcsIHJlcGxhY2luZyBhbnkgc29tZXdoYXQgZXhvdGljIGxpbmVmZWVkcyB3aXRoIFwiXFxuXCIsIHRoZW4gc3BsaXQgb24gdGhhdCBjaGFyYWN0ZXIuXG4gICAgICAgIHZhciByZSA9IC9cXHJcXG58XFxuXFxyfFxcbnxcXHIvZztcbiAgICAgICAgLy8gVWludDhBcnJheS5wcm90b3R5cGUucmVkdWNlIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiBJRTExXG4gICAgICAgIHZhciB2dHRMaW5lcyA9IGlkM18xLnV0ZjhBcnJheVRvU3RyKG5ldyBVaW50OEFycmF5KHZ0dEJ5dGVBcnJheSkpLnRyaW0oKS5yZXBsYWNlKHJlLCAnXFxuJykuc3BsaXQoJ1xcbicpO1xuICAgICAgICB2YXIgY3VlVGltZSA9ICcwMDowMC4wMDAnO1xuICAgICAgICB2YXIgbXBlZ1RzID0gMDtcbiAgICAgICAgdmFyIGxvY2FsVGltZSA9IDA7XG4gICAgICAgIHZhciBwcmVzZW50YXRpb25UaW1lID0gMDtcbiAgICAgICAgdmFyIGN1ZXMgPSBbXTtcbiAgICAgICAgdmFyIHBhcnNpbmdFcnJvcjtcbiAgICAgICAgdmFyIGluSGVhZGVyID0gdHJ1ZTtcbiAgICAgICAgLy8gbGV0IFZUVEN1ZSA9IFZUVEN1ZSB8fCB3aW5kb3cuVGV4dFRyYWNrQ3VlO1xuICAgICAgICAvLyBDcmVhdGUgcGFyc2VyIG9iamVjdCB1c2luZyBWVFRDdWUgd2l0aCBUZXh0VHJhY2tDdWUgZmFsbGJhY2sgb24gY2VydGFpbiBicm93c2Vycy5cbiAgICAgICAgdmFyIHBhcnNlciA9IG5ldyB2dHRwYXJzZXJfMS5kZWZhdWx0KCk7XG4gICAgICAgIHBhcnNlci5vbmN1ZSA9IGZ1bmN0aW9uIChjdWUpIHtcbiAgICAgICAgICAgIC8vIEFkanVzdCBjdWUgdGltaW5nOyBjbGFtcCBjdWVzIHRvIHN0YXJ0IG5vIGVhcmxpZXIgdGhhbiAtIGFuZCBkcm9wIGN1ZXMgdGhhdCBkb24ndCBlbmQgYWZ0ZXIgLSAwIG9uIHRpbWVsaW5lLlxuICAgICAgICAgICAgdmFyIGN1cnJDQyA9IHZ0dENDc1tjY107XG4gICAgICAgICAgICB2YXIgY3VlT2Zmc2V0ID0gdnR0Q0NzLmNjT2Zmc2V0O1xuICAgICAgICAgICAgLy8gVXBkYXRlIG9mZnNldHMgZm9yIG5ldyBkaXNjb250aW51aXRpZXNcbiAgICAgICAgICAgIGlmIChjdXJyQ0MgJiYgY3VyckNDLm5ldykge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbFRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGxvY2FsIHRpbWUgaXMgcHJvdmlkZWQsIG9mZnNldCA9IGRpc2NvbnRpbnVpdHkgc3RhcnQgdGltZSAtIGxvY2FsIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgY3VlT2Zmc2V0ID0gdnR0Q0NzLmNjT2Zmc2V0ID0gY3VyckNDLnN0YXJ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlT2Zmc2V0KHZ0dENDcywgY2MsIHByZXNlbnRhdGlvblRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmVzZW50YXRpb25UaW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBNUEVHVFMsIG9mZnNldCA9IHByZXNlbnRhdGlvbiB0aW1lICsgZGlzY29udGludWl0eSBvZmZzZXRcbiAgICAgICAgICAgICAgICBjdWVPZmZzZXQgPSBwcmVzZW50YXRpb25UaW1lIC0gdnR0Q0NzLnByZXNlbnRhdGlvbk9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1ZS5zdGFydFRpbWUgKz0gY3VlT2Zmc2V0IC0gbG9jYWxUaW1lO1xuICAgICAgICAgICAgY3VlLmVuZFRpbWUgKz0gY3VlT2Zmc2V0IC0gbG9jYWxUaW1lO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgdW5pcXVlIGhhc2ggaWQgZm9yIGEgY3VlIGJhc2VkIG9uIHN0YXJ0L2VuZCB0aW1lcyBhbmQgdGV4dC5cbiAgICAgICAgICAgIC8vIFRoaXMgaGVscHMgdGltZWxpbmUtY29udHJvbGxlciB0byBhdm9pZCBzaG93aW5nIHJlcGVhdGVkIGNhcHRpb25zLlxuICAgICAgICAgICAgY3VlLmlkID0gaGFzaChjdWUuc3RhcnRUaW1lLnRvU3RyaW5nKCkpICsgaGFzaChjdWUuZW5kVGltZS50b1N0cmluZygpKSArIGhhc2goY3VlLnRleHQpO1xuICAgICAgICAgICAgLy8gRml4IGVuY29kaW5nIG9mIHNwZWNpYWwgY2hhcmFjdGVycy4gVE9ETzogVGVzdCB3aXRoIGFsbCBzb3J0cyBvZiB3ZWlyZCBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgY3VlLnRleHQgPSBkZWNvZGVVUklDb21wb25lbnQoZW5jb2RlVVJJQ29tcG9uZW50KGN1ZS50ZXh0KSk7XG4gICAgICAgICAgICBpZiAoY3VlLmVuZFRpbWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgY3Vlcy5wdXNoKGN1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHBhcnNlci5vbnBhcnNpbmdlcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBwYXJzaW5nRXJyb3IgPSBlO1xuICAgICAgICB9O1xuICAgICAgICBwYXJzZXIub25mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChwYXJzaW5nRXJyb3IgJiYgZXJyb3JDYWxsQmFjaykge1xuICAgICAgICAgICAgICAgIGVycm9yQ2FsbEJhY2socGFyc2luZ0Vycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsQmFjayhjdWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gR28gdGhyb3VnaCBjb250ZW50cyBsaW5lIGJ5IGxpbmUuXG4gICAgICAgIHZ0dExpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgIGlmIChpbkhlYWRlcikge1xuICAgICAgICAgICAgICAgIC8vIExvb2sgZm9yIFgtVElNRVNUQU1QLU1BUCBpbiBoZWFkZXIuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0c1dpdGgobGluZSwgJ1gtVElNRVNUQU1QLU1BUD0nKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmNlIGZvdW5kLCBubyBtb3JlIGFyZSBhbGxvd2VkIGFueXdheSwgc28gc3RvcCBzZWFyY2hpbmcuXG4gICAgICAgICAgICAgICAgICAgIGluSGVhZGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgTE9DQUwgYW5kIE1QRUdUUy5cbiAgICAgICAgICAgICAgICAgICAgbGluZS5zdWJzdHIoMTYpLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbiAodGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRzV2l0aCh0aW1lc3RhbXAsICdMT0NBTDonKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ZVRpbWUgPSB0aW1lc3RhbXAuc3Vic3RyKDYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnRzV2l0aCh0aW1lc3RhbXAsICdNUEVHVFM6JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtcGVnVHMgPSBwYXJzZUludCh0aW1lc3RhbXAuc3Vic3RyKDcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgc3VidGl0bGUgb2Zmc2V0IGluIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzeW5jUFRTICsgKCh2dHRDQ3NbY2NdLnN0YXJ0ICogOTAwMDApIHx8IDApIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bmNQVFMgKz0gODU4OTkzNDU5MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkanVzdCBNUEVHVFMgYnkgc3luYyBQVFMuXG4gICAgICAgICAgICAgICAgICAgICAgICBtcGVnVHMgLT0gc3luY1BUUztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgY3VlIHRpbWUgdG8gc2Vjb25kc1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxUaW1lID0gY3VlU3RyaW5nMm1pbGxpcyhjdWVUaW1lKSAvIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IE1QRUdUUyB0byBzZWNvbmRzIGZyb20gOTBrSHouXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW50YXRpb25UaW1lID0gbXBlZ1RzIC8gOTAwMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxUaW1lID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcihcIk1hbGZvcm1lZCBYLVRJTUVTVEFNUC1NQVA6IFwiICsgbGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcihcIk1hbGZvcm1lZCBYLVRJTUVTVEFNUC1NQVA6IFwiICsgbGluZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHdpdGhvdXQgcGFyc2luZyBYLVRJTUVTVEFNUC1NQVAgbGluZS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsaW5lID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBpbkhlYWRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhcnNlIGxpbmUgYnkgZGVmYXVsdC5cbiAgICAgICAgICAgIHBhcnNlci5wYXJzZShsaW5lICsgJ1xcbicpO1xuICAgICAgICB9KTtcbiAgICAgICAgcGFyc2VyLmZsdXNoKCk7XG4gICAgfVxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IFdlYlZUVFBhcnNlcjtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLmpzXCIpW1wiTnVtYmVyXCJdKSlcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMveGhyLWxvYWRlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL3hoci1sb2FkZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBYSFIgYmFzZWQgbG9nZ2VyXG4qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGxvZ2dlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLmpzXCIpO1xudmFyIHBlcmZvcm1hbmNlID0gd2luZG93LnBlcmZvcm1hbmNlLCBYTUxIdHRwUmVxdWVzdCA9IHdpbmRvdy5YTUxIdHRwUmVxdWVzdDtcbnZhciBYaHJMb2FkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWGhyTG9hZGVyKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICYmIGNvbmZpZy54aHJTZXR1cCkge1xuICAgICAgICAgICAgdGhpcy54aHJTZXR1cCA9IGNvbmZpZy54aHJTZXR1cDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBYaHJMb2FkZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWJvcnQoKTtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIH07XG4gICAgWGhyTG9hZGVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxvYWRlciA9IHRoaXMubG9hZGVyO1xuICAgICAgICBpZiAobG9hZGVyICYmIGxvYWRlci5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IG51bGw7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVvdXQpO1xuICAgICAgICB0aGlzLnJldHJ5VGltZW91dCA9IG51bGw7XG4gICAgfTtcbiAgICBYaHJMb2FkZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoY29udGV4dCwgY29uZmlnLCBjYWxsYmFja3MpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgICAgICB0aGlzLnN0YXRzID0geyB0cmVxdWVzdDogcGVyZm9ybWFuY2Uubm93KCksIHJldHJ5OiAwIH07XG4gICAgICAgIHRoaXMucmV0cnlEZWxheSA9IGNvbmZpZy5yZXRyeURlbGF5O1xuICAgICAgICB0aGlzLmxvYWRJbnRlcm5hbCgpO1xuICAgIH07XG4gICAgWGhyTG9hZGVyLnByb3RvdHlwZS5sb2FkSW50ZXJuYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB4aHIsIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIHhociA9IHRoaXMubG9hZGVyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHZhciBzdGF0cyA9IHRoaXMuc3RhdHM7XG4gICAgICAgIHN0YXRzLnRmaXJzdCA9IDA7XG4gICAgICAgIHN0YXRzLmxvYWRlZCA9IDA7XG4gICAgICAgIHZhciB4aHJTZXR1cCA9IHRoaXMueGhyU2V0dXA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoeGhyU2V0dXApIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB4aHJTZXR1cCh4aHIsIGNvbnRleHQudXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZml4IHhoclNldHVwOiAoeGhyLCB1cmwpID0+IHt4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtTGFuZ3VhZ2VcIiwgXCJ0ZXN0XCIpO31cbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IHdvcmtpbmcsIGFzIHhoci5zZXRSZXF1ZXN0SGVhZGVyIGV4cGVjdHMgeGhyLnJlYWR5U3RhdGUgPT09IE9QRU5cbiAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIGNvbnRleHQudXJsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgeGhyU2V0dXAoeGhyLCBjb250ZXh0LnVybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF4aHIucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCBjb250ZXh0LnVybCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIElFMTEgdGhyb3dzIGFuIGV4Y2VwdGlvbiBvbiB4aHIub3BlbiBpZiBhdHRlbXB0aW5nIHRvIGFjY2VzcyBhbiBIVFRQIHJlc291cmNlIG92ZXIgSFRUUFNcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uRXJyb3IoeyBjb2RlOiB4aHIuc3RhdHVzLCB0ZXh0OiBlLm1lc3NhZ2UgfSwgY29udGV4dCwgeGhyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dC5yYW5nZUVuZCkge1xuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1JhbmdlJywgJ2J5dGVzPScgKyBjb250ZXh0LnJhbmdlU3RhcnQgKyAnLScgKyAoY29udGV4dC5yYW5nZUVuZCAtIDEpKTtcbiAgICAgICAgfVxuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5yZWFkeXN0YXRlY2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHhoci5vbnByb2dyZXNzID0gdGhpcy5sb2FkcHJvZ3Jlc3MuYmluZCh0aGlzKTtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IGNvbnRleHQucmVzcG9uc2VUeXBlO1xuICAgICAgICAvLyBzZXR1cCB0aW1lb3V0IGJlZm9yZSB3ZSBwZXJmb3JtIHJlcXVlc3RcbiAgICAgICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKSwgdGhpcy5jb25maWcudGltZW91dCk7XG4gICAgICAgIHhoci5zZW5kKCk7XG4gICAgfTtcbiAgICBYaHJMb2FkZXIucHJvdG90eXBlLnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHhociA9IGV2ZW50LmN1cnJlbnRUYXJnZXQsIHJlYWR5U3RhdGUgPSB4aHIucmVhZHlTdGF0ZSwgc3RhdHMgPSB0aGlzLnN0YXRzLCBjb250ZXh0ID0gdGhpcy5jb250ZXh0LCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgLy8gZG9uJ3QgcHJvY2VlZCBpZiB4aHIgaGFzIGJlZW4gYWJvcnRlZFxuICAgICAgICBpZiAoc3RhdHMuYWJvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vID49IEhFQURFUlNfUkVDRUlWRURcbiAgICAgICAgaWYgKHJlYWR5U3RhdGUgPj0gMikge1xuICAgICAgICAgICAgLy8gY2xlYXIgeGhyIHRpbWVvdXQgYW5kIHJlYXJtIGl0IGlmIHJlYWR5U3RhdGUgbGVzcyB0aGFuIDRcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICAgICAgICBpZiAoc3RhdHMudGZpcnN0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RhdHMudGZpcnN0ID0gTWF0aC5tYXgocGVyZm9ybWFuY2Uubm93KCksIHN0YXRzLnRyZXF1ZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXR1c18xID0geGhyLnN0YXR1cztcbiAgICAgICAgICAgICAgICAvLyBodHRwIHN0YXR1cyBiZXR3ZWVuIDIwMCB0byAyOTkgYXJlIGFsbCBzdWNjZXNzZnVsXG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1c18xID49IDIwMCAmJiBzdGF0dXNfMSA8IDMwMCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0cy50bG9hZCA9IE1hdGgubWF4KHN0YXRzLnRmaXJzdCwgcGVyZm9ybWFuY2Uubm93KCkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHZvaWQgMCwgbGVuID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5yZXNwb25zZVR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSB4aHIucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXRzLmxvYWRlZCA9IHN0YXRzLnRvdGFsID0gbGVuO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSB7IHVybDogeGhyLnJlc3BvbnNlVVJMLCBkYXRhOiBkYXRhIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uU3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIHhocik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBtYXggbmIgb2YgcmV0cmllcyByZWFjaGVkIG9yIGlmIGh0dHAgc3RhdHVzIGJldHdlZW4gNDAwIGFuZCA0OTkgKHN1Y2ggZXJyb3IgY2Fubm90IGJlIHJlY292ZXJlZCwgcmV0cnlpbmcgaXMgdXNlbGVzcyksIHJldHVybiBlcnJvclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHMucmV0cnkgPj0gY29uZmlnLm1heFJldHJ5IHx8IChzdGF0dXNfMSA+PSA0MDAgJiYgc3RhdHVzXzEgPCA0OTkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5sb2dnZXIuZXJyb3Ioc3RhdHVzXzEgKyBcIiB3aGlsZSBsb2FkaW5nIFwiICsgY29udGV4dC51cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25FcnJvcih7IGNvZGU6IHN0YXR1c18xLCB0ZXh0OiB4aHIuc3RhdHVzVGV4dCB9LCBjb250ZXh0LCB4aHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0cnlcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmxvZ2dlci53YXJuKHN0YXR1c18xICsgXCIgd2hpbGUgbG9hZGluZyBcIiArIGNvbnRleHQudXJsICsgXCIsIHJldHJ5aW5nIGluIFwiICsgdGhpcy5yZXRyeURlbGF5ICsgXCIuLi5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhYm9ydHMgYW5kIHJlc2V0cyBpbnRlcm5hbCBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzY2hlZHVsZSByZXRyeVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXRyeVRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCh0aGlzLmxvYWRJbnRlcm5hbC5iaW5kKHRoaXMpLCB0aGlzLnJldHJ5RGVsYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IGV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmV0cnlEZWxheSA9IE1hdGgubWluKDIgKiB0aGlzLnJldHJ5RGVsYXksIGNvbmZpZy5tYXhSZXRyeURlbGF5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzLnJldHJ5Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyByZWFkeVN0YXRlID49IDIgQU5EIHJlYWR5U3RhdGUgIT09NCAocmVhZHlTdGF0ZSA9IEhFQURFUlNfUkVDRUlWRUQgfHwgTE9BRElORykgcmVhcm0gdGltZW91dCBhcyB4aHIgbm90IGZpbmlzaGVkIHlldFxuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCh0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcyksIGNvbmZpZy50aW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgWGhyTG9hZGVyLnByb3RvdHlwZS5sb2FkdGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEubG9nZ2VyLndhcm4oXCJ0aW1lb3V0IHdoaWxlIGxvYWRpbmcgXCIgKyB0aGlzLmNvbnRleHQudXJsKTtcbiAgICAgICAgdGhpcy5jYWxsYmFja3Mub25UaW1lb3V0KHRoaXMuc3RhdHMsIHRoaXMuY29udGV4dCwgbnVsbCk7XG4gICAgfTtcbiAgICBYaHJMb2FkZXIucHJvdG90eXBlLmxvYWRwcm9ncmVzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgeGhyID0gZXZlbnQuY3VycmVudFRhcmdldCwgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICAgICAgICBzdGF0cy5sb2FkZWQgPSBldmVudC5sb2FkZWQ7XG4gICAgICAgIGlmIChldmVudC5sZW5ndGhDb21wdXRhYmxlKSB7XG4gICAgICAgICAgICBzdGF0cy50b3RhbCA9IGV2ZW50LnRvdGFsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvblByb2dyZXNzID0gdGhpcy5jYWxsYmFja3Mub25Qcm9ncmVzcztcbiAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIC8vIHRoaXJkIGFyZyBpcyB0byBwcm92aWRlIG9uIHByb2dyZXNzIGRhdGFcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIHRoaXMuY29udGV4dCwgbnVsbCwgeGhyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFhockxvYWRlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBYaHJMb2FkZXI7XG5cblxuLyoqKi8gfSlcblxuLyoqKioqKi8gfSlbXCJkZWZhdWx0XCJdO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1obHMuanMubWFwIiwiLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYzLjMuMVxuICogaHR0cHM6Ly9qcXVlcnkuY29tL1xuICpcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTgtMDEtMjBUMTc6MjRaXG4gKi9cbiggZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciBgd2luZG93YFxuXHRcdC8vIGlzIHByZXNlbnQsIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnkuXG5cdFx0Ly8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBoYXZlIGEgYHdpbmRvd2Agd2l0aCBhIGBkb2N1bWVudGBcblx0XHQvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0cy5cblx0XHQvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIGB3aW5kb3dgLlxuXHRcdC8vIGUuZy4gdmFyIGpRdWVyeSA9IHJlcXVpcmUoXCJqcXVlcnlcIikod2luZG93KTtcblx0XHQvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cblx0XHRcdGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcblx0XHRcdGZ1bmN0aW9uKCB3ICkge1xuXHRcdFx0XHRpZiAoICF3LmRvY3VtZW50ICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFjdG9yeSggdyApO1xuXHRcdFx0fTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwgKTtcblx0fVxuXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxufSApKCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XG5cbi8vIEVkZ2UgPD0gMTIgLSAxMyssIEZpcmVmb3ggPD0xOCAtIDQ1KywgSUUgMTAgLSAxMSwgU2FmYXJpIDUuMSAtIDkrLCBpT1MgNiAtIDkuMVxuLy8gdGhyb3cgZXhjZXB0aW9ucyB3aGVuIG5vbi1zdHJpY3QgY29kZSAoZS5nLiwgQVNQLk5FVCA0LjUpIGFjY2Vzc2VzIHN0cmljdCBtb2RlXG4vLyBhcmd1bWVudHMuY2FsbGVlLmNhbGxlciAodHJhYy0xMzMzNSkuIEJ1dCBhcyBvZiBqUXVlcnkgMy4wICgyMDE2KSwgc3RyaWN0IG1vZGUgc2hvdWxkIGJlIGNvbW1vblxuLy8gZW5vdWdoIHRoYXQgYWxsIHN1Y2ggYXR0ZW1wdHMgYXJlIGd1YXJkZWQgaW4gYSB0cnkgYmxvY2suXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGFyciA9IFtdO1xuXG52YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG52YXIgY29uY2F0ID0gYXJyLmNvbmNhdDtcblxudmFyIHB1c2ggPSBhcnIucHVzaDtcblxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xuXG52YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoIE9iamVjdCApO1xuXG52YXIgc3VwcG9ydCA9IHt9O1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24oIG9iaiApIHtcblxuICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9NTcsIEZpcmVmb3ggPD01MlxuICAgICAgLy8gSW4gc29tZSBicm93c2VycywgdHlwZW9mIHJldHVybnMgXCJmdW5jdGlvblwiIGZvciBIVE1MIDxvYmplY3Q+IGVsZW1lbnRzXG4gICAgICAvLyAoaS5lLiwgYHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9iamVjdFwiICkgPT09IFwiZnVuY3Rpb25cImApLlxuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBjbGFzc2lmeSAqYW55KiBET00gbm9kZSBhcyBhIGZ1bmN0aW9uLlxuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9PSBcIm51bWJlclwiO1xuICB9O1xuXG5cbnZhciBpc1dpbmRvdyA9IGZ1bmN0aW9uIGlzV2luZG93KCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcblx0fTtcblxuXG5cblxuXHR2YXIgcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyA9IHtcblx0XHR0eXBlOiB0cnVlLFxuXHRcdHNyYzogdHJ1ZSxcblx0XHRub01vZHVsZTogdHJ1ZVxuXHR9O1xuXG5cdGZ1bmN0aW9uIERPTUV2YWwoIGNvZGUsIGRvYywgbm9kZSApIHtcblx0XHRkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG5cblx0XHR2YXIgaSxcblx0XHRcdHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCBcInNjcmlwdFwiICk7XG5cblx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0aWYgKCBub2RlICkge1xuXHRcdFx0Zm9yICggaSBpbiBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzICkge1xuXHRcdFx0XHRpZiAoIG5vZGVbIGkgXSApIHtcblx0XHRcdFx0XHRzY3JpcHRbIGkgXSA9IG5vZGVbIGkgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRkb2MuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0ICkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XG5cdH1cblxuXG5mdW5jdGlvbiB0b1R5cGUoIG9iaiApIHtcblx0aWYgKCBvYmogPT0gbnVsbCApIHtcblx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seSAoZnVuY3Rpb25pc2ggUmVnRXhwKVxuXHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwoIG9iaiApIF0gfHwgXCJvYmplY3RcIiA6XG5cdFx0dHlwZW9mIG9iajtcbn1cbi8qIGdsb2JhbCBTeW1ib2wgKi9cbi8vIERlZmluaW5nIHRoaXMgZ2xvYmFsIGluIC5lc2xpbnRyYy5qc29uIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXG4vLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8gZGVmaW5lIGdsb2JhbCBvbmx5IGZvciB0aGlzIG1vZHVsZVxuXG5cblxudmFyXG5cdHZlcnNpb24gPSBcIjMuMy4xXCIsXG5cblx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcblx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXG5cdFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG5cdFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuXHQvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1Bcblx0cnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2c7XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IHZlcnNpb24sXG5cblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cblx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0aWYgKCBudW0gPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdHJldHVybiBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFpc0Z1bmN0aW9uKCB0YXJnZXQgKSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGkgPT09IGxlbmd0aCApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdGktLTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmICggKCBvcHRpb25zID0gYXJndW1lbnRzWyBpIF0gKSAhPSBudWxsICkge1xuXG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29weSApIHx8XG5cdFx0XHRcdFx0KCBjb3B5SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICkge1xuXHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIEFycmF5LmlzQXJyYXkoIHNyYyApID8gc3JjIDogW107XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHNyYyApID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcHJvdG8sIEN0b3I7XG5cblx0XHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcblx0XHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcblx0XHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cblx0XHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG5cdFx0aWYgKCAhcHJvdG8gKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuXHRcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFwiY29uc3RydWN0b3JcIiApICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXG5cdFx0LyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzYxMjVcblx0XHR2YXIgbmFtZTtcblxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxuXHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSApIHtcblx0XHRET01FdmFsKCBjb2RlICk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0dHJpbTogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XHRcIlwiIDpcblx0XHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0gKTtcblxuaWYgKCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xufVxuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5mdW5jdGlvbiggaSwgbmFtZSApIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSB0b1R5cGUoIG9iaiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggb2JqICkgfHwgaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE2LTA4LTA4XG4gKi9cbihmdW5jdGlvbiggd2luZG93ICkge1xuXG52YXIgaSxcblx0c3VwcG9ydCxcblx0RXhwcixcblx0Z2V0VGV4dCxcblx0aXNYTUwsXG5cdHRva2VuaXplLFxuXHRjb21waWxlLFxuXHRzZWxlY3QsXG5cdG91dGVybW9zdENvbnRleHQsXG5cdHNvcnRJbnB1dCxcblx0aGFzRHVwbGljYXRlLFxuXG5cdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcblx0c2V0RG9jdW1lbnQsXG5cdGRvY3VtZW50LFxuXHRkb2NFbGVtLFxuXHRkb2N1bWVudElzSFRNTCxcblx0cmJ1Z2d5UVNBLFxuXHRyYnVnZ3lNYXRjaGVzLFxuXHRtYXRjaGVzLFxuXHRjb250YWlucyxcblxuXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG5cdGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXG5cdHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcblx0ZGlycnVucyA9IDAsXG5cdGRvbmUgPSAwLFxuXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cHM6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIGxpc3RbaV0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG5cdGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcMC1cXFxceGEwXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cblx0cmF0dHJpYnV0ZVF1b3RlcyA9IG5ldyBSZWdFeHAoIFwiPVwiICsgd2hpdGVzcGFjZSArIFwiKihbXlxcXFxdJ1xcXCJdKj8pXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIiwgXCJnXCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiICksXG5cdFx0XCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0XCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG5cdFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuXHRcdFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHRybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXG5cdC8vIENTUyBlc2NhcGVzXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXChbXFxcXGRhLWZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98KFwiICsgd2hpdGVzcGFjZSArIFwiKXwuKVwiLCBcImlnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7XG5cdFx0Ly8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI0XG5cdFx0Ly8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArXCIweFwiXG5cdFx0cmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2UgP1xuXHRcdFx0ZXNjYXBlZCA6XG5cdFx0XHRoaWdoIDwgMCA/XG5cdFx0XHRcdC8vIEJNUCBjb2RlcG9pbnRcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG5cdFx0XHRcdC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fSxcblxuXHQvLyBDU1Mgc3RyaW5nL2lkZW50aWZpZXIgc2VyaWFsaXphdGlvblxuXHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2NvbW1vbi1zZXJpYWxpemluZy1pZGlvbXNcblx0cmNzc2VzY2FwZSA9IC8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxcMC1cXHgxZlxceDdmLVxcdUZGRkZcXHctXS9nLFxuXHRmY3NzZXNjYXBlID0gZnVuY3Rpb24oIGNoLCBhc0NvZGVQb2ludCApIHtcblx0XHRpZiAoIGFzQ29kZVBvaW50ICkge1xuXG5cdFx0XHQvLyBVKzAwMDAgTlVMTCBiZWNvbWVzIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVJcblx0XHRcdGlmICggY2ggPT09IFwiXFwwXCIgKSB7XG5cdFx0XHRcdHJldHVybiBcIlxcdUZGRkRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udHJvbCBjaGFyYWN0ZXJzIGFuZCAoZGVwZW5kZW50IHVwb24gcG9zaXRpb24pIG51bWJlcnMgZ2V0IGVzY2FwZWQgYXMgY29kZSBwb2ludHNcblx0XHRcdHJldHVybiBjaC5zbGljZSggMCwgLTEgKSArIFwiXFxcXFwiICsgY2guY2hhckNvZGVBdCggY2gubGVuZ3RoIC0gMSApLnRvU3RyaW5nKCAxNiApICsgXCIgXCI7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXIgcG90ZW50aWFsbHktc3BlY2lhbCBBU0NJSSBjaGFyYWN0ZXJzIGdldCBiYWNrc2xhc2gtZXNjYXBlZFxuXHRcdHJldHVybiBcIlxcXFxcIiArIGNoO1xuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIGlmcmFtZXNcblx0Ly8gU2VlIHNldERvY3VtZW50KClcblx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG5cdC8vIGVycm9yIGluIElFXG5cdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRzZXREb2N1bWVudCgpO1xuXHR9LFxuXG5cdGRpc2FibGVkQW5jZXN0b3IgPSBhZGRDb21iaW5hdG9yKFxuXHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWUgJiYgKFwiZm9ybVwiIGluIGVsZW0gfHwgXCJsYWJlbFwiIGluIGVsZW0pO1xuXHRcdH0sXG5cdFx0eyBkaXI6IFwicGFyZW50Tm9kZVwiLCBuZXh0OiBcImxlZ2VuZFwiIH1cblx0KTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hfbmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3Rvcixcblx0XHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cblx0XHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cdGlmICggIXNlZWQgKSB7XG5cblx0XHRpZiAoICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jICkgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0XHR9XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHQvLyBJRCBzZWxlY3RvclxuXHRcdFx0XHRpZiAoIChtID0gbWF0Y2hbMV0pICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9jdW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBFbGVtZW50IGNvbnRleHRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAmJiAoZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcblx0XHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuXHRcdFx0XHRcdFx0XHRlbGVtLmlkID09PSBtICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHlwZSBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXG5cdFx0XHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG5cdFx0XHRpZiAoIHN1cHBvcnQucXNhICYmXG5cdFx0XHRcdCFjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF0gJiZcblx0XHRcdFx0KCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XG5cblx0XHRcdFx0Ly8gcVNBIGxvb2tzIG91dHNpZGUgRWxlbWVudCBjb250ZXh0LCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50XG5cdFx0XHRcdC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHdvcmthcm91bmQgdGVjaG5pcXVlXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OFxuXHRcdFx0XHQvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0XHQvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdGlmICggKG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSkgKSB7XG5cdFx0XHRcdFx0XHRuaWQgPSBuaWQucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAobmlkID0gZXhwYW5kbykgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3Rcblx0XHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGdyb3Vwc1tpXSA9IFwiI1wiICsgbmlkICsgXCIgXCIgKyB0b1NlbGVjdG9yKCBncm91cHNbaV0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbiggXCIsXCIgKTtcblxuXHRcdFx0XHRcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbmV3U2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXG5cdFx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcblx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0aWYgKCBuaWQgPT09IGV4cGFuZG8gKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBbGwgb3RoZXJzXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xufVxuXG4vKipcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcblx0dmFyIGtleXMgPSBbXTtcblxuXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblx0XHQvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxuXHRcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcIiBcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcblx0XHRcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcblx0XHR9XG5cdFx0cmV0dXJuIChjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlKTtcblx0fVxuXHRyZXR1cm4gY2FjaGU7XG59XG5cbi8qKlxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gKi9cbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG5cdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuXHRyZXR1cm4gZm47XG59XG5cbi8qKlxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpO1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuICEhZm4oIGVsICk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZmluYWxseSB7XG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0aWYgKCBlbC5wYXJlbnROb2RlICkge1xuXHRcdFx0ZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWwgKTtcblx0XHR9XG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRlbCA9IG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAqL1xuZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcblx0dmFyIGFyciA9IGF0dHJzLnNwbGl0KFwifFwiKSxcblx0XHRpID0gYXJyLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRFeHByLmF0dHJIYW5kbGVbIGFycltpXSBdID0gaGFuZGxlcjtcblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcbiAqL1xuZnVuY3Rpb24gc2libGluZ0NoZWNrKCBhLCBiICkge1xuXHR2YXIgY3VyID0gYiAmJiBhLFxuXHRcdGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRhLnNvdXJjZUluZGV4IC0gYi5zb3VyY2VJbmRleDtcblxuXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblx0aWYgKCBkaWZmICkge1xuXHRcdHJldHVybiBkaWZmO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblx0aWYgKCBjdXIgKSB7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLm5leHRTaWJsaW5nKSApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGEgPyAxIDogLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIDplbmFibGVkLzpkaXNhYmxlZFxuICogQHBhcmFtIHtCb29sZWFufSBkaXNhYmxlZCB0cnVlIGZvciA6ZGlzYWJsZWQ7IGZhbHNlIGZvciA6ZW5hYmxlZFxuICovXG5mdW5jdGlvbiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZGlzYWJsZWQgKSB7XG5cblx0Ly8gS25vd24gOmRpc2FibGVkIGZhbHNlIHBvc2l0aXZlczogZmllbGRzZXRbZGlzYWJsZWRdID4gbGVnZW5kOm50aC1vZi10eXBlKG4rMikgOmNhbi1kaXNhYmxlXG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE9ubHkgY2VydGFpbiBlbGVtZW50cyBjYW4gbWF0Y2ggOmVuYWJsZWQgb3IgOmRpc2FibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZW5hYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWRpc2FibGVkXG5cdFx0aWYgKCBcImZvcm1cIiBpbiBlbGVtICkge1xuXG5cdFx0XHQvLyBDaGVjayBmb3IgaW5oZXJpdGVkIGRpc2FibGVkbmVzcyBvbiByZWxldmFudCBub24tZGlzYWJsZWQgZWxlbWVudHM6XG5cdFx0XHQvLyAqIGxpc3RlZCBmb3JtLWFzc29jaWF0ZWQgZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBmaWVsZHNldFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NhdGVnb3J5LWxpc3RlZFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtZmUtZGlzYWJsZWRcblx0XHRcdC8vICogb3B0aW9uIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LW9wdGlvbi1kaXNhYmxlZFxuXHRcdFx0Ly8gQWxsIHN1Y2ggZWxlbWVudHMgaGF2ZSBhIFwiZm9ybVwiIHByb3BlcnR5LlxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgJiYgZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0Ly8gT3B0aW9uIGVsZW1lbnRzIGRlZmVyIHRvIGEgcGFyZW50IG9wdGdyb3VwIGlmIHByZXNlbnRcblx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5wYXJlbnROb2RlLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDYgLSAxMVxuXHRcdFx0XHQvLyBVc2UgdGhlIGlzRGlzYWJsZWQgc2hvcnRjdXQgcHJvcGVydHkgdG8gY2hlY2sgZm9yIGRpc2FibGVkIGZpZWxkc2V0IGFuY2VzdG9yc1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pc0Rpc2FibGVkID09PSBkaXNhYmxlZCB8fFxuXG5cdFx0XHRcdFx0Ly8gV2hlcmUgdGhlcmUgaXMgbm8gaXNEaXNhYmxlZCwgY2hlY2sgbWFudWFsbHlcblx0XHRcdFx0XHQvKiBqc2hpbnQgLVcwMTggKi9cblx0XHRcdFx0XHRlbGVtLmlzRGlzYWJsZWQgIT09ICFkaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0ZGlzYWJsZWRBbmNlc3RvciggZWxlbSApID09PSBkaXNhYmxlZDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXG5cdFx0Ly8gVHJ5IHRvIHdpbm5vdyBvdXQgZWxlbWVudHMgdGhhdCBjYW4ndCBiZSBkaXNhYmxlZCBiZWZvcmUgdHJ1c3RpbmcgdGhlIGRpc2FibGVkIHByb3BlcnR5LlxuXHRcdC8vIFNvbWUgdmljdGltcyBnZXQgY2F1Z2h0IGluIG91ciBuZXQgKGxhYmVsLCBsZWdlbmQsIG1lbnUsIHRyYWNrKSwgYnV0IGl0IHNob3VsZG4ndFxuXHRcdC8vIGV2ZW4gZXhpc3Qgb24gdGhlbSwgbGV0IGFsb25lIGhhdmUgYSBib29sZWFuIHZhbHVlLlxuXHRcdH0gZWxzZSBpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdH1cblxuXHRcdC8vIFJlbWFpbmluZyBlbGVtZW50cyBhcmUgbmVpdGhlciA6ZW5hYmxlZCBub3IgOmRpc2FibGVkXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZuICkge1xuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcblx0XHRhcmd1bWVudCA9ICthcmd1bWVudDtcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0dmFyIGosXG5cdFx0XHRcdG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXG5cdFx0XHRcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNlZWRbIChqID0gbWF0Y2hJbmRleGVzW2ldKSBdICkge1xuXHRcdFx0XHRcdHNlZWRbal0gPSAhKG1hdGNoZXNbal0gPSBzZWVkW2pdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuXHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xufVxuXG4vLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuc3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XG5cbi8qKlxuICogRGV0ZWN0cyBYTUwgbm9kZXNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXG4gKi9cbmlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdC8vIGRvY3VtZW50RWxlbWVudCBpcyB2ZXJpZmllZCBmb3IgY2FzZXMgd2hlcmUgaXQgZG9lc24ndCB5ZXQgZXhpc3Rcblx0Ly8gKHN1Y2ggYXMgbG9hZGluZyBpZnJhbWVzIGluIElFIC0gIzQ4MzMpXG5cdHZhciBkb2N1bWVudEVsZW1lbnQgPSBlbGVtICYmIChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xuXHRyZXR1cm4gZG9jdW1lbnRFbGVtZW50ID8gZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9PSBcIkhUTUxcIiA6IGZhbHNlO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBzdWJXaW5kb3csXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDktMTEsIEVkZ2Vcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXHRpZiAoIHByZWZlcnJlZERvYyAhPT0gZG9jdW1lbnQgJiZcblx0XHQoc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXG5cdFx0aWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHR9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZWwuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHR9KTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pZCA9IGV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIElEIGZpbHRlciBhbmQgZmluZFxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdHJldHVybiBlbGVtID8gWyBlbGVtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSAgZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG5vZGUsIGksIGVsZW1zLFxuXHRcdFx0XHRcdGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXG5cdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdC8vIFZlcmlmeSB0aGUgaWQgYXR0cmlidXRlXG5cdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBGYWxsIGJhY2sgb24gZ2V0RWxlbWVudHNCeU5hbWVcblx0XHRcdFx0XHRlbGVtcyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoIGlkICk7XG5cdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1zW2krK10pICkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbXCJDTEFTU1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcblx0XHRcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuXHRcdFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cIiArXG5cdFx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuXHRcdFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuXHRcdFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG5cdFx0XHQvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHRcdC8vIElFJ3MgOmRpc2FibGVkIHNlbGVjdG9yIGRvZXMgbm90IHBpY2sgdXAgdGhlIGNoaWxkcmVuIG9mIGRpc2FibGVkIGZpZWxkc2V0c1xuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZGlzYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRlbC5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBlbCwgXCIqXCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBlbCwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9KTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XG5cblx0LyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblx0XHRcdHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jdW1lbnQgPyAxIDpcblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHQvLyBNYWtlIHN1cmUgdGhhdCBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFyZSBxdW90ZWRcblx0ZXhwciA9IGV4cHIucmVwbGFjZSggcmF0dHJpYnV0ZVF1b3RlcywgXCI9JyQxJ11cIiApO1xuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhY29tcGlsZXJDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXHRcdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxuXHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge31cblx0fVxuXG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XG59O1xuXG5TaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0dmFsIDpcblx0XHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cblx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuXHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXNjYXBlID0gZnVuY3Rpb24oIHNlbCApIHtcblx0cmV0dXJuIChzZWwgKyBcIlwiKS5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG5cdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHR3aGlsZSAoIChub2RlID0gZWxlbVtpKytdKSApIHtcblx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXHRcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcblx0XHQvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxuXHRcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWzNdID0gKCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsyXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFszXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRtYXRjaFs0XSA9ICsoIG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKCBtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKSApO1xuXHRcdFx0XHRtYXRjaFs1XSA9ICsoICggbWF0Y2hbN10gKyBtYXRjaFs4XSApIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFs2XSAmJiBtYXRjaFsyXTtcblxuXHRcdFx0aWYgKCBtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KCBtYXRjaFswXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdG1hdGNoWzJdID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIjtcblxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkpICYmXG5cdFx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuXHRcdFx0XHQoZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdFx0bWF0Y2hbMl0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApKSAmJlxuXHRcdFx0XHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoIHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiICk7XG5cdFx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiXj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIqPVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifj1cIiA/ICggXCIgXCIgKyByZXN1bHQucmVwbGFjZSggcndoaXRlc3BhY2UsIFwiIFwiICkgKyBcIiBcIiApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCIgOlxuXHRcdFx0XHRcdGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGVbIGRpciBdKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuXHRcdFx0XHRcdFx0Ly8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcblx0XHRcdFx0XHRcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBwYXJlbnQ7XG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXg7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXG5cdFx0XHRcdFx0XHRcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdFx0aWYgKCBkaWZmID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2RpZmYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFswXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuXHRcdH0sXG5cblx0XHRcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCBmYWxzZSApLFxuXHRcdFwiZGlzYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIHRydWUgKSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0XCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiYnV0dG9uXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xuXHRcdH0sXG5cblx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoIChhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9KSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9KSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0c2tpcCA9IGNvbWJpbmF0b3IubmV4dCxcblx0XHRrZXkgPSBza2lwIHx8IGRpcixcblx0XHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBrZXkgPT09IFwicGFyZW50Tm9kZVwiLFxuXHRcdGRvbmVOYW1lID0gZG9uZSsrO1xuXG5cdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSA6XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIG9sZENhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xuXHRcdFx0aWYgKCB4bWwgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gfHwgKG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0aWYgKCBza2lwICYmIHNraXAgPT09IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0ZWxlbSA9IGVsZW1bIGRpciBdIHx8IGVsZW07XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCAob2xkQ2FjaGUgPSB1bmlxdWVDYWNoZVsga2V5IF0pICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuIChuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyBrZXkgXSA9IG5ld0NhY2hlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuXHRcdFx0XHRcdFx0XHRpZiAoIChuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkpICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzW2ldKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gOlxuXHRcdG1hdGNoZXJzWzBdO1xufVxuXG5mdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdHZhciBlbGVtLFxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRpZiAoICFmaWx0ZXIgfHwgZmlsdGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0bmV3VW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0aWYgKCBtYXBwZWQgKSB7XG5cdFx0XHRcdFx0bWFwLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXdVbm1hdGNoZWQ7XG59XG5cbmZ1bmN0aW9uIHNldE1hdGNoZXIoIHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApIHtcblx0aWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbHRlciA9IHNldE1hdGNoZXIoIHBvc3RGaWx0ZXIgKTtcblx0fVxuXHRpZiAoIHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmluZGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICk7XG5cdH1cblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xuXHRcdHZhciB0ZW1wLCBpLCBlbGVtLFxuXHRcdFx0cHJlTWFwID0gW10sXG5cdFx0XHRwb3N0TWFwID0gW10sXG5cdFx0XHRwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuXHRcdFx0ZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yIHx8IFwiKlwiLCBjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LCBbXSApLFxuXG5cdFx0XHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cblx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuXHRcdFx0XHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdGVsZW1zLFxuXG5cdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG5cdFx0XHRcdHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cblxuXHRcdFx0XHRcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFtdIDpcblxuXHRcdFx0XHRcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxuXHRcdFx0XHRcdHJlc3VsdHMgOlxuXHRcdFx0XHRtYXRjaGVySW47XG5cblx0XHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuXHRcdGlmICggbWF0Y2hlciApIHtcblx0XHRcdG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcG9zdEZpbHRlclxuXHRcdGlmICggcG9zdEZpbHRlciApIHtcblx0XHRcdHRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApO1xuXHRcdFx0cG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuXG5cdFx0XHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG5cdFx0XHRpID0gdGVtcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAoZWxlbSA9IHRlbXBbaV0pICkge1xuXHRcdFx0XHRcdG1hdGNoZXJPdXRbIHBvc3RNYXBbaV0gXSA9ICEobWF0Y2hlckluWyBwb3N0TWFwW2ldIF0gPSBlbGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggc2VlZCApIHtcblx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0XHQvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcblx0XHRcdFx0XHR0ZW1wID0gW107XG5cdFx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuXHRcdFx0XHRcdFx0XHR0ZW1wLnB1c2goIChtYXRjaGVySW5baV0gPSBlbGVtKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAobWF0Y2hlck91dCA9IFtdKSwgdGVtcCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxuXHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSAmJlxuXHRcdFx0XHRcdFx0KHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZiggc2VlZCwgZWxlbSApIDogcHJlTWFwW2ldKSA+IC0xICkge1xuXG5cdFx0XHRcdFx0XHRzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlck91dCA9IGNvbmRlbnNlKFxuXHRcdFx0XHRtYXRjaGVyT3V0ID09PSByZXN1bHRzID9cblx0XHRcdFx0XHRtYXRjaGVyT3V0LnNwbGljZSggcHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoICkgOlxuXHRcdFx0XHRcdG1hdGNoZXJPdXRcblx0XHRcdCk7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XG5cdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMF0udHlwZSBdLFxuXHRcdGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVtcIiBcIl0sXG5cdFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG5cdFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcblx0XHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdChjaGVja0NvbnRleHQgPSBjb250ZXh0KS5ub2RlVHlwZSA/XG5cdFx0XHRcdFx0bWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuXHRcdFx0Ly8gQXZvaWQgaGFuZ2luZyBvbnRvIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRjaGVja0NvbnRleHQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9IF07XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAobWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1tpXS50eXBlIF0pICkge1xuXHRcdFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIpIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zW2ldLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zW2ldLm1hdGNoZXMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHQvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcblx0XHRcdFx0aiA9ICsraTtcblx0XHRcdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbal0udHlwZSBdICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZXRNYXRjaGVyKFxuXHRcdFx0XHRcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuXHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuXHRcdFx0XHRcdFx0dG9rZW5zLnNsaWNlKCAwLCBpIC0gMSApLmNvbmNhdCh7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSlcblx0XHRcdFx0XHQpLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSxcblx0XHRcdFx0XHRtYXRjaGVyLFxuXHRcdFx0XHRcdGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMuc2xpY2UoIGksIGogKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoICh0b2tlbnMgPSB0b2tlbnMuc2xpY2UoIGogKSkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXG5cdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcblx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblx0XHRcdFx0Ly8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxuXHRcdFx0XHRlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFtcIlRBR1wiXSggXCIqXCIsIG91dGVybW9zdCApLFxuXHRcdFx0XHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuXHRcdFx0XHRkaXJydW5zVW5pcXVlID0gKGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xKSxcblx0XHRcdFx0bGVuID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgPT09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHRpZiAoICFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHRcdFx0XHRcdFx0eG1sID0gIWRvY3VtZW50SXNIVE1MO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwpICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVkQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG5cdFx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdFx0dW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gYGlgIGlzIG5vdyB0aGUgY291bnQgb2YgZWxlbWVudHMgdmlzaXRlZCBhYm92ZSwgYW5kIGFkZGluZyBpdCB0byBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cblx0XHRcdG1hdGNoZWRDb3VudCArPSBpO1xuXG5cdFx0XHQvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcblx0XHRcdC8vIE5PVEU6IFRoaXMgY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgYXJlIG5vIHVubWF0Y2hlZCBlbGVtZW50cyAoaS5lLiwgYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIGVxdWFscyBgaWApLCB1bmxlc3Mgd2UgZGlkbid0IHZpc2l0IF9hbnlfIGVsZW1lbnRzIGluIHRoZSBhYm92ZSBsb29wIGJlY2F1c2Ugd2UgaGF2ZVxuXHRcdFx0Ly8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cblx0XHRcdC8vIEluY3JlbWVudGluZyBhbiBpbml0aWFsbHktc3RyaW5nIFwiMFwiIGBpYCBhbGxvd3MgYGlgIHRvIHJlbWFpbiBhIHN0cmluZyBvbmx5IGluIHRoYXRcblx0XHRcdC8vIGNhc2UsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgXCIwMFwiIGBtYXRjaGVkQ291bnRgIHRoYXQgZGlmZmVycyBmcm9tIGBpYCBidXQgaXMgYWxzb1xuXHRcdFx0Ly8gbnVtZXJpY2FsbHkgemVyby5cblx0XHRcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IHNldE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuXHRcdFx0XHRcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRcdHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdGkgPSBtYXRjaC5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbaV0gKTtcblx0XHRcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoIHNlbGVjdG9yLCBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSApO1xuXG5cdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cdFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdH1cblx0cmV0dXJuIGNhY2hlZDtcbn07XG5cbi8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3Rvcixcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvcikgKTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxuXHQvLyAodGhlIGxhdHRlciBvZiB3aGljaCBndWFyYW50ZWVzIHVzIGNvbnRleHQpXG5cdGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG5cdFx0Ly8gUmVkdWNlIGNvbnRleHQgaWYgdGhlIGxlYWRpbmcgY29tcG91bmQgc2VsZWN0b3IgaXMgYW4gSURcblx0XHR0b2tlbnMgPSBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwICk7XG5cdFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAodG9rZW4gPSB0b2tlbnNbMF0pLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0XHRjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmIEV4cHIucmVsYXRpdmVbIHRva2Vuc1sxXS50eXBlIF0gKSB7XG5cblx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZFtcIklEXCJdKCB0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLCBjb250ZXh0ICkgfHwgW10gKVswXTtcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdGkgPSBtYXRjaEV4cHJbXCJuZWVkc0NvbnRleHRcIl0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG9rZW4gPSB0b2tlbnNbaV07XG5cblx0XHRcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3Jcblx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgKHR5cGUgPSB0b2tlbi50eXBlKSBdICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggKGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSkgKSB7XG5cdFx0XHRcdC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuXHRcdFx0XHRpZiAoIChzZWVkID0gZmluZChcblx0XHRcdFx0XHR0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG5cdFx0XHRcdFx0cnNpYmxpbmcudGVzdCggdG9rZW5zWzBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHRcdFx0XHQpKSApIHtcblxuXHRcdFx0XHRcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuXHRcdFx0XHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcblx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXG5cdFx0c2VlZCxcblx0XHRjb250ZXh0LFxuXHRcdCFkb2N1bWVudElzSFRNTCxcblx0XHRyZXN1bHRzLFxuXHRcdCFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0KTtcblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG4vLyBTb3J0IHN0YWJpbGl0eVxuc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdChcIlwiKS5zb3J0KCBzb3J0T3JkZXIgKS5qb2luKFwiXCIpID09PSBleHBhbmRvO1xuXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG5zdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuXHRyZXR1cm4gZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKSApICYgMTtcbn0pO1xuXG4vLyBTdXBwb3J0OiBJRTw4XG4vLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xuXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIiA7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG5pZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdGVsLmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcblx0ZWwuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBcIlwiO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ2YWx1ZVwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0cmV0dXJuIGVsLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09IG51bGw7XG59KSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0fVxuXHR9KTtcbn1cblxucmV0dXJuIFNpenpsZTtcblxufSkoIHdpbmRvdyApO1xuXG5cblxualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG5cbi8vIERlcHJlY2F0ZWRcbmpRdWVyeS5leHByWyBcIjpcIiBdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbmpRdWVyeS51bmlxdWVTb3J0ID0galF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xualF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbmpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbmpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcbmpRdWVyeS5lc2NhcGVTZWxlY3RvciA9IFNpenpsZS5lc2NhcGU7XG5cblxuXG5cbnZhciBkaXIgPSBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcblx0dmFyIG1hdGNoZWQgPSBbXSxcblx0XHR0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cblx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0aWYgKCB0cnVuY2F0ZSAmJiBqUXVlcnkoIGVsZW0gKS5pcyggdW50aWwgKSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBzaWJsaW5ncyA9IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdGZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7XG5cdFx0aWYgKCBuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0gKSB7XG5cdFx0XHRtYXRjaGVkLnB1c2goIG4gKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHJuZWVkc0NvbnRleHQgPSBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7XG5cblxuXG5mdW5jdGlvbiBub2RlTmFtZSggZWxlbSwgbmFtZSApIHtcblxuICByZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblxufTtcbnZhciByc2luZ2xlVGFnID0gKCAvXjwoW2Etel1bXlxcL1xcMD46XFx4MjBcXHRcXHJcXG5cXGZdKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcLz8+KD86PFxcL1xcMT58KSQvaSApO1xuXG5cblxuLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbmZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwgbm90ICkge1xuXHRpZiAoIGlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIFNpbmdsZSBlbGVtZW50XG5cdGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggZWxlbSA9PT0gcXVhbGlmaWVyICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBBcnJheWxpa2Ugb2YgZWxlbWVudHMgKGpRdWVyeSwgYXJndW1lbnRzLCBBcnJheSlcblx0aWYgKCB0eXBlb2YgcXVhbGlmaWVyICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBGaWx0ZXJlZCBkaXJlY3RseSBmb3IgYm90aCBzaW1wbGUgYW5kIGNvbXBsZXggc2VsZWN0b3JzXG5cdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcbn1cblxualF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cblx0aWYgKCBub3QgKSB7XG5cdFx0ZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcblx0fVxuXG5cdGlmICggZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHR9ICkgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLCByZXQsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXG5cdFx0cmV0ID0gdGhpcy5wdXNoU3RhY2soIFtdICk7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIHJldCApIDogcmV0O1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlICkgKTtcblx0fSxcblx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlICkgKTtcblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISF3aW5ub3coXG5cdFx0XHR0aGlzLFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXG5cdFx0XHRmYWxzZVxuXHRcdCkubGVuZ3RoO1xuXHR9XG59ICk7XG5cblxuLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcblxuXG4vLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbnZhciByb290alF1ZXJ5LFxuXG5cdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG5cdC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcblx0Ly8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG5cdC8vIFNob3J0Y3V0IHNpbXBsZSAjaWQgY2FzZSBmb3Igc3BlZWRcblx0cnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvLFxuXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcm9vdCApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxuXHRcdC8vIHNvIG1pZ3JhdGUgY2FuIHN1cHBvcnQgalF1ZXJ5LnN1YiAoZ2gtMjEwMSlcblx0XHRyb290ID0gcm9vdCB8fCByb290alF1ZXJ5O1xuXG5cdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aWYgKCBzZWxlY3RvclsgMCBdID09PSBcIjxcIiAmJlxuXHRcdFx0XHRzZWxlY3Rvclsgc2VsZWN0b3IubGVuZ3RoIC0gMSBdID09PSBcIj5cIiAmJlxuXHRcdFx0XHRzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblxuXHRcdFx0XHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuXHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdGlmICggbWF0Y2ggJiYgKCBtYXRjaFsgMSBdIHx8ICFjb250ZXh0ICkgKSB7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG5cdFx0XHRcdGlmICggbWF0Y2hbIDEgXSApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbIDAgXSA6IGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0XHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcblx0XHRcdFx0XHRcdG1hdGNoWyAxIF0sXG5cdFx0XHRcdFx0XHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuXHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCkgKTtcblxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcblx0XHRcdFx0XHRpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbIDEgXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpc1sgMCBdID0gZWxlbTtcblx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcblx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gKCBjb250ZXh0IHx8IHJvb3QgKS5maW5kKCBzZWxlY3RvciApO1xuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcblx0XHRcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXG5cdFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG5cdFx0XHR0aGlzWyAwIF0gPSBzZWxlY3Rvcjtcblx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0Ly8gSEFORExFOiAkKGZ1bmN0aW9uKVxuXHRcdC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuXHRcdH0gZWxzZSBpZiAoIGlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0cm9vdC5yZWFkeSggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yLCB0aGlzICk7XG5cdH07XG5cbi8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cbmluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xuXG4vLyBJbml0aWFsaXplIGNlbnRyYWwgcmVmZXJlbmNlXG5yb290alF1ZXJ5ID0galF1ZXJ5KCBkb2N1bWVudCApO1xuXG5cbnZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcblxuXHQvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuXHRndWFyYW50ZWVkVW5pcXVlID0ge1xuXHRcdGNoaWxkcmVuOiB0cnVlLFxuXHRcdGNvbnRlbnRzOiB0cnVlLFxuXHRcdG5leHQ6IHRydWUsXG5cdFx0cHJldjogdHJ1ZVxuXHR9O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgdGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXG5cdFx0XHRsID0gdGFyZ2V0cy5sZW5ndGg7XG5cblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1sgaSBdICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHR0YXJnZXRzID0gdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiAmJiBqUXVlcnkoIHNlbGVjdG9ycyApO1xuXG5cdFx0Ly8gUG9zaXRpb25hbCBzZWxlY3RvcnMgbmV2ZXIgbWF0Y2gsIHNpbmNlIHRoZXJlJ3Mgbm8gX3NlbGVjdGlvbl8gY29udGV4dFxuXHRcdGlmICggIXJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZvciAoIGN1ciA9IHRoaXNbIGkgXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0XHQvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcblx0XHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA8IDExICYmICggdGFyZ2V0cyA/XG5cdFx0XHRcdFx0XHR0YXJnZXRzLmluZGV4KCBjdXIgKSA+IC0xIDpcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcGFzcyBub24tZWxlbWVudHMgdG8gU2l6emxlXG5cdFx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBjdXIsIHNlbGVjdG9ycyApICkgKSB7XG5cblx0XHRcdFx0XHRcdG1hdGNoZWQucHVzaCggY3VyICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XG5cdH0sXG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbiB0aGUgc2V0XG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybiAoIHRoaXNbIDAgXSAmJiB0aGlzWyAwIF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcblx0XHR9XG5cblx0XHQvLyBJbmRleCBpbiBzZWxlY3RvclxuXHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdGhpc1sgMCBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggdGhpcyxcblxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW1cblx0XHQpO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcblx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXHRhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoIHNlbGVjdG9yIClcblx0XHQpO1xuXHR9XG59ICk7XG5cbmZ1bmN0aW9uIHNpYmxpbmcoIGN1ciwgZGlyICkge1xuXHR3aGlsZSAoICggY3VyID0gY3VyWyBkaXIgXSApICYmIGN1ci5ub2RlVHlwZSAhPT0gMSApIHt9XG5cdHJldHVybiBjdXI7XG59XG5cbmpRdWVyeS5lYWNoKCB7XG5cdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRyZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuXHR9LFxuXHRwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuXHR9LFxuXHRwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuXHR9LFxuXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0fSxcblx0Y29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICBpZiAoIG5vZGVOYW1lKCBlbGVtLCBcImlmcmFtZVwiICkgKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcbiAgICAgICAgLy8gVHJlYXQgdGhlIHRlbXBsYXRlIGVsZW1lbnQgYXMgYSByZWd1bGFyIG9uZSBpbiBicm93c2VycyB0aGF0XG4gICAgICAgIC8vIGRvbid0IHN1cHBvcnQgaXQuXG4gICAgICAgIGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGVtcGxhdGVcIiApICkge1xuICAgICAgICAgICAgZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSApO1xudmFyIHJub3RodG1sd2hpdGUgPSAoIC9bXlxceDIwXFx0XFxyXFxuXFxmXSsvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG5cdFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuXHR9ICk7XG5cdHJldHVybiBvYmplY3Q7XG59XG5cbi8qXG4gKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAqXG4gKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XG4gKlxuICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBQb3NzaWJsZSBvcHRpb25zOlxuICpcbiAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcbiAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcbiAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXG4gKlxuICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gKlxuICovXG5qUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0Ly8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG5cdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0Y3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIDpcblx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXG5cdFx0Ly8gTGFzdCBmaXJlIHZhbHVlIGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHNcblx0XHRtZW1vcnksXG5cblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuXHRcdGZpcmVkLFxuXG5cdFx0Ly8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xuXHRcdGxvY2tlZCxcblxuXHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXG5cdFx0Ly8gUXVldWUgb2YgZXhlY3V0aW9uIGRhdGEgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRxdWV1ZSA9IFtdLFxuXG5cdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXG5cdFx0ZmlyaW5nSW5kZXggPSAtMSxcblxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbmZvcmNlIHNpbmdsZS1maXJpbmdcblx0XHRcdGxvY2tlZCA9IGxvY2tlZCB8fCBvcHRpb25zLm9uY2U7XG5cblx0XHRcdC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxuXHRcdFx0Ly8gcmVzcGVjdGluZyBmaXJpbmdJbmRleCBvdmVycmlkZXMgYW5kIHJ1bnRpbWUgY2hhbmdlc1xuXHRcdFx0ZmlyZWQgPSBmaXJpbmcgPSB0cnVlO1xuXHRcdFx0Zm9yICggOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRcdHdoaWxlICggKytmaXJpbmdJbmRleCA8IGxpc3QubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gUnVuIGNhbGxiYWNrIGFuZCBjaGVjayBmb3IgZWFybHkgdGVybWluYXRpb25cblx0XHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIG1lbW9yeVsgMCBdLCBtZW1vcnlbIDEgXSApID09PSBmYWxzZSAmJlxuXHRcdFx0XHRcdFx0b3B0aW9ucy5zdG9wT25GYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XG5cdFx0XHRpZiAoICFvcHRpb25zLm1lbW9yeSApIHtcblx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGZpcmluZyA9IGZhbHNlO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCBpZiB3ZSdyZSBkb25lIGZpcmluZyBmb3IgZ29vZFxuXHRcdFx0aWYgKCBsb2NrZWQgKSB7XG5cblx0XHRcdFx0Ly8gS2VlcCBhbiBlbXB0eSBsaXN0IGlmIHdlIGhhdmUgZGF0YSBmb3IgZnV0dXJlIGFkZCBjYWxsc1xuXHRcdFx0XHRpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB0aGlzIG9iamVjdCBpcyBzcGVudFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpc3QgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG5cdFx0c2VsZiA9IHtcblxuXHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBtZW1vcnkgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQoIGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgdG9UeXBlKCBhcmcgKSAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fSApKCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRyZXR1cm4gZm4gP1xuXHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOlxuXHRcdFx0XHRcdGxpc3QubGVuZ3RoID4gMDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3Rcblx0XHRcdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcblx0XHRcdC8vIEFib3J0IGFueSBjdXJyZW50L3BlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0Ly8gQ2xlYXIgYWxsIGNhbGxiYWNrcyBhbmQgdmFsdWVzXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZVxuXHRcdFx0Ly8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcblx0XHRcdC8vIEFib3J0IGFueSBwZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRpZiAoICFtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFsb2NrZWQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggIWxvY2tlZCApIHtcblx0XHRcdFx0XHRhcmdzID0gYXJncyB8fCBbXTtcblx0XHRcdFx0XHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGFyZ3MgKTtcblx0XHRcdFx0XHRpZiAoICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2Vcblx0XHRcdGZpcmVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhZmlyZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gc2VsZjtcbn07XG5cblxuZnVuY3Rpb24gSWRlbnRpdHkoIHYgKSB7XG5cdHJldHVybiB2O1xufVxuZnVuY3Rpb24gVGhyb3dlciggZXggKSB7XG5cdHRocm93IGV4O1xufVxuXG5mdW5jdGlvbiBhZG9wdFZhbHVlKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0LCBub1ZhbHVlICkge1xuXHR2YXIgbWV0aG9kO1xuXG5cdHRyeSB7XG5cblx0XHQvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXG5cdFx0aWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnByb21pc2UgKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlICkuZG9uZSggcmVzb2x2ZSApLmZhaWwoIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgdGhlbmFibGVzXG5cdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS50aGVuICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciBub24tdGhlbmFibGVzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29udHJvbCBgcmVzb2x2ZWAgYXJndW1lbnRzIGJ5IGxldHRpbmcgQXJyYXkjc2xpY2UgY2FzdCBib29sZWFuIGBub1ZhbHVlYCB0byBpbnRlZ2VyOlxuXHRcdFx0Ly8gKiBmYWxzZTogWyB2YWx1ZSBdLnNsaWNlKCAwICkgPT4gcmVzb2x2ZSggdmFsdWUgKVxuXHRcdFx0Ly8gKiB0cnVlOiBbIHZhbHVlIF0uc2xpY2UoIDEgKSA9PiByZXNvbHZlKClcblx0XHRcdHJlc29sdmUuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdLnNsaWNlKCBub1ZhbHVlICkgKTtcblx0XHR9XG5cblx0Ly8gRm9yIFByb21pc2VzL0ErLCBjb252ZXJ0IGV4Y2VwdGlvbnMgaW50byByZWplY3Rpb25zXG5cdC8vIFNpbmNlIGpRdWVyeS53aGVuIGRvZXNuJ3QgdW53cmFwIHRoZW5hYmxlcywgd2UgY2FuIHNraXAgdGhlIGV4dHJhIGNoZWNrcyBhcHBlYXJpbmcgaW5cblx0Ly8gRGVmZXJyZWQjdGhlbiB0byBjb25kaXRpb25hbGx5IHN1cHByZXNzIHJlamVjdGlvbi5cblx0fSBjYXRjaCAoIHZhbHVlICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgb25seVxuXHRcdC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcblx0XHRyZWplY3QuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdICk7XG5cdH1cbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHR2YXIgdHVwbGVzID0gW1xuXG5cdFx0XHRcdC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBjYWxsYmFja3MsXG5cdFx0XHRcdC8vIC4uLiAudGhlbiBoYW5kbGVycywgYXJndW1lbnQgaW5kZXgsIFtmaW5hbCBzdGF0ZV1cblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksIDIgXSxcblx0XHRcdFx0WyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAwLCBcInJlc29sdmVkXCIgXSxcblx0XHRcdFx0WyBcInJlamVjdFwiLCBcImZhaWxcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDEsIFwicmVqZWN0ZWRcIiBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwiY2F0Y2hcIjogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRcdHJldHVybiBwcm9taXNlLnRoZW4oIG51bGwsIGZuICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRwaXBlOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG5cdFx0XHRcdFx0dmFyIGZucyA9IGFyZ3VtZW50cztcblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBNYXAgdHVwbGVzIChwcm9ncmVzcywgZG9uZSwgZmFpbCkgdG8gYXJndW1lbnRzIChkb25lLCBmYWlsLCBwcm9ncmVzcylcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0gaXNGdW5jdGlvbiggZm5zWyB0dXBsZVsgNCBdIF0gKSAmJiBmbnNbIHR1cGxlWyA0IF0gXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5wcm9ncmVzcyhmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5ub3RpZnkgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZG9uZShmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZXNvbHZlIH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmZhaWwoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVqZWN0IH0pXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMSBdIF0oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5kb25lKCBuZXdEZWZlci5yZXNvbHZlIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmZhaWwoIG5ld0RlZmVyLnJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0Zm5zID0gbnVsbDtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MgKSB7XG5cdFx0XHRcdFx0dmFyIG1heERlcHRoID0gMDtcblx0XHRcdFx0XHRmdW5jdGlvbiByZXNvbHZlKCBkZXB0aCwgZGVmZXJyZWQsIGhhbmRsZXIsIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdFx0XHRcdFx0XHRhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCwgdGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjNcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgZG91YmxlLXJlc29sdXRpb24gYXR0ZW1wdHNcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggPCBtYXhEZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCA9IGhhbmRsZXIuYXBwbHkoIHRoYXQsIGFyZ3MgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNDhcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgPT09IGRlZmVycmVkLnByb21pc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cIiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9ucyAyLjMuMy4xLCAzLjVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU0XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC03NVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gUmV0cmlldmUgYHRoZW5gIG9ubHkgb25jZVxuXHRcdFx0XHRcdFx0XHRcdFx0dGhlbiA9IHJldHVybmVkICYmXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuNFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02NFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGNoZWNrIG9iamVjdHMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlbmFiaWxpdHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCB0eXBlb2YgcmV0dXJuZWQgPT09IFwib2JqZWN0XCIgfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgcmV0dXJuZWQgPT09IFwiZnVuY3Rpb25cIiApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhIHJldHVybmVkIHRoZW5hYmxlXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHRoZW4gKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTcGVjaWFsIHByb2Nlc3NvcnMgKG5vdGlmeSkganVzdCB3YWl0IGZvciByZXNvbHV0aW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBOb3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgYWxzbyBob29rIGludG8gcHJvZ3Jlc3Ncblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBkaXNyZWdhcmQgb2xkZXIgcmVzb2x1dGlvbiB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXhEZXB0aCsrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGggKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGFsbCBvdGhlciByZXR1cm5lZCB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBJZGVudGl0eSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIHJldHVybmVkIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBQcm9jZXNzIHRoZSB2YWx1ZShzKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZhdWx0IHByb2Nlc3MgaXMgcmVzb2x2ZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHNwZWNpYWwgfHwgZGVmZXJyZWQucmVzb2x2ZVdpdGggKSggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IG5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBjYXRjaCBhbmQgcmVqZWN0IGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzID0gc3BlY2lhbCA/XG5cdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93IDpcblx0XHRcdFx0XHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3coKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soIGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy40LjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02MVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBwb3N0LXJlc29sdXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKyAxID49IG1heERlcHRoICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gVGhyb3dlciApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgZSBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4xXG5cdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU3XG5cdFx0XHRcdFx0XHRcdC8vIFJlLXJlc29sdmUgcHJvbWlzZXMgaW1tZWRpYXRlbHkgdG8gZG9kZ2UgZmFsc2UgcmVqZWN0aW9uIGZyb21cblx0XHRcdFx0XHRcdFx0Ly8gc3Vic2VxdWVudCBlcnJvcnNcblx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzKCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDYWxsIGFuIG9wdGlvbmFsIGhvb2sgdG8gcmVjb3JkIHRoZSBzdGFjaywgaW4gY2FzZSBvZiBleGNlcHRpb25cblx0XHRcdFx0XHRcdFx0XHQvLyBzaW5jZSBpdCdzIG90aGVyd2lzZSBsb3N0IHdoZW4gZXhlY3V0aW9uIGdvZXMgYXN5bmNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgPSBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBwcm9jZXNzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXG5cdFx0XHRcdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uUHJvZ3Jlc3MgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblByb2dyZXNzIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLm5vdGlmeVdpdGhcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMSBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25GdWxmaWxsZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvbkZ1bGZpbGxlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDIgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uUmVqZWN0ZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblJlamVjdGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdFRocm93ZXJcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcblx0XHRcdFx0Ly8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuXHRcdFx0XHRwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0XHRcdHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlZmVycmVkID0ge307XG5cblx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuXHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyA1IF07XG5cblx0XHRcdC8vIHByb21pc2UucHJvZ3Jlc3MgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5kb25lID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZmFpbCA9IGxpc3QuYWRkXG5cdFx0XHRwcm9taXNlWyB0dXBsZVsgMSBdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZChcblx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlc29sdmVkXCIgKGkuZS4sIGZ1bGZpbGxlZClcblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZWplY3RlZFwiXG5cdFx0XHRcdFx0XHRzdGF0ZSA9IHN0YXRlU3RyaW5nO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHQvLyByZWplY3RlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMiBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDMgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfY2FsbGJhY2tzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMiBdLmxvY2ssXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5sb2NrXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5maXJlXG5cdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5maXJlXG5cdFx0XHRsaXN0LmFkZCggdHVwbGVbIDMgXS5maXJlICk7XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5ub3RpZnlXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZXNvbHZlV2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZWplY3RXaXRoKC4uLikgfVxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gdW5kZWZpbmVkIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmVXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSApO1xuXG5cdFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdGlmICggZnVuYyApIHtcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGRvbmUhXG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9LFxuXG5cdC8vIERlZmVycmVkIGhlbHBlclxuXHR3aGVuOiBmdW5jdGlvbiggc2luZ2xlVmFsdWUgKSB7XG5cdFx0dmFyXG5cblx0XHRcdC8vIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gYXJndW1lbnRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5wcm9jZXNzZWQgYXJndW1lbnRzXG5cdFx0XHRpID0gcmVtYWluaW5nLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBmdWxmaWxsbWVudCBkYXRhXG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBBcnJheSggaSApLFxuXHRcdFx0cmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXG5cdFx0XHQvLyB0aGUgbWFzdGVyIERlZmVycmVkXG5cdFx0XHRtYXN0ZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgY2FsbGJhY2sgZmFjdG9yeVxuXHRcdFx0dXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJlc29sdmVDb250ZXh0c1sgaSBdID0gdGhpcztcblx0XHRcdFx0XHRyZXNvbHZlVmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xuXHRcdFx0XHRcdFx0bWFzdGVyLnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXG5cdFx0Ly8gU2luZ2xlLSBhbmQgZW1wdHkgYXJndW1lbnRzIGFyZSBhZG9wdGVkIGxpa2UgUHJvbWlzZS5yZXNvbHZlXG5cdFx0aWYgKCByZW1haW5pbmcgPD0gMSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHNpbmdsZVZhbHVlLCBtYXN0ZXIuZG9uZSggdXBkYXRlRnVuYyggaSApICkucmVzb2x2ZSwgbWFzdGVyLnJlamVjdCxcblx0XHRcdFx0IXJlbWFpbmluZyApO1xuXG5cdFx0XHQvLyBVc2UgLnRoZW4oKSB0byB1bndyYXAgc2Vjb25kYXJ5IHRoZW5hYmxlcyAoY2YuIGdoLTMwMDApXG5cdFx0XHRpZiAoIG1hc3Rlci5zdGF0ZSgpID09PSBcInBlbmRpbmdcIiB8fFxuXHRcdFx0XHRpc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0gJiYgcmVzb2x2ZVZhbHVlc1sgaSBdLnRoZW4gKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gbWFzdGVyLnRoZW4oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBNdWx0aXBsZSBhcmd1bWVudHMgYXJlIGFnZ3JlZ2F0ZWQgbGlrZSBQcm9taXNlLmFsbCBhcnJheSBlbGVtZW50c1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggcmVzb2x2ZVZhbHVlc1sgaSBdLCB1cGRhdGVGdW5jKCBpICksIG1hc3Rlci5yZWplY3QgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWFzdGVyLnByb21pc2UoKTtcblx0fVxufSApO1xuXG5cbi8vIFRoZXNlIHVzdWFsbHkgaW5kaWNhdGUgYSBwcm9ncmFtbWVyIG1pc3Rha2UgZHVyaW5nIGRldmVsb3BtZW50LFxuLy8gd2FybiBhYm91dCB0aGVtIEFTQVAgcmF0aGVyIHRoYW4gc3dhbGxvd2luZyB0aGVtIGJ5IGRlZmF1bHQuXG52YXIgcmVycm9yTmFtZXMgPSAvXihFdmFsfEludGVybmFsfFJhbmdlfFJlZmVyZW5jZXxTeW50YXh8VHlwZXxVUkkpRXJyb3IkLztcblxualF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgPSBmdW5jdGlvbiggZXJyb3IsIHN0YWNrICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDggLSA5IG9ubHlcblx0Ly8gQ29uc29sZSBleGlzdHMgd2hlbiBkZXYgdG9vbHMgYXJlIG9wZW4sIHdoaWNoIGNhbiBoYXBwZW4gYXQgYW55IHRpbWVcblx0aWYgKCB3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS53YXJuICYmIGVycm9yICYmIHJlcnJvck5hbWVzLnRlc3QoIGVycm9yLm5hbWUgKSApIHtcblx0XHR3aW5kb3cuY29uc29sZS53YXJuKCBcImpRdWVyeS5EZWZlcnJlZCBleGNlcHRpb246IFwiICsgZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2ssIHN0YWNrICk7XG5cdH1cbn07XG5cblxuXG5cbmpRdWVyeS5yZWFkeUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKCBlcnJvciApIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdHRocm93IGVycm9yO1xuXHR9ICk7XG59O1xuXG5cblxuXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbnZhciByZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcblxualF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xuXG5cdHJlYWR5TGlzdFxuXHRcdC50aGVuKCBmbiApXG5cblx0XHQvLyBXcmFwIGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiBpbiBhIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIGxvb2t1cFxuXHRcdC8vIGhhcHBlbnMgYXQgdGhlIHRpbWUgb2YgZXJyb3IgaGFuZGxpbmcgaW5zdGVhZCBvZiBjYWxsYmFja1xuXHRcdC8vIHJlZ2lzdHJhdGlvbi5cblx0XHQuY2F0Y2goIGZ1bmN0aW9uKCBlcnJvciApIHtcblx0XHRcdGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiggZXJyb3IgKTtcblx0XHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5yZWFkeS50aGVuID0gcmVhZHlMaXN0LnRoZW47XG5cbi8vIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXG5mdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG5cdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcblx0alF1ZXJ5LnJlYWR5KCk7XG59XG5cbi8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkXG4vLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDEwIG9ubHlcbi8vIE9sZGVyIElFIHNvbWV0aW1lcyBzaWduYWxzIFwiaW50ZXJhY3RpdmVcIiB0b28gc29vblxuaWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHxcblx0KCBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIiAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICkgKSB7XG5cblx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxufSBlbHNlIHtcblxuXHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblxuXHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xufVxuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGVsZW1zLmxlbmd0aCxcblx0XHRidWxrID0ga2V5ID09IG51bGw7XG5cblx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRpZiAoIHRvVHlwZSgga2V5ICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblx0XHRmb3IgKCBpIGluIGtleSApIHtcblx0XHRcdGFjY2VzcyggZWxlbXMsIGZuLCBpLCBrZXlbIGkgXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xuXHRcdH1cblxuXHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cblx0XHRpZiAoICFpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cblx0XHRcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuXHRcdFx0aWYgKCByYXcgKSB7XG5cdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xuXHRcdFx0XHRmbiA9IG51bGw7XG5cblx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ1bGsgPSBmbjtcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKFxuXHRcdFx0XHRcdGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cblx0XHRcdFx0XHR2YWx1ZSA6XG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIGNoYWluYWJsZSApIHtcblx0XHRyZXR1cm4gZWxlbXM7XG5cdH1cblxuXHQvLyBHZXRzXG5cdGlmICggYnVsayApIHtcblx0XHRyZXR1cm4gZm4uY2FsbCggZWxlbXMgKTtcblx0fVxuXG5cdHJldHVybiBsZW4gPyBmbiggZWxlbXNbIDAgXSwga2V5ICkgOiBlbXB0eUdldDtcbn07XG5cblxuLy8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG52YXIgcm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFthLXpdKS9nO1xuXG4vLyBVc2VkIGJ5IGNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcbmZ1bmN0aW9uIGZjYW1lbENhc2UoIGFsbCwgbGV0dGVyICkge1xuXHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG59XG5cbi8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcbi8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3MilcbmZ1bmN0aW9uIGNhbWVsQ2FzZSggc3RyaW5nICkge1xuXHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgXCJtcy1cIiApLnJlcGxhY2UoIHJkYXNoQWxwaGEsIGZjYW1lbENhc2UgKTtcbn1cbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBEYXRhKCkge1xuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG59XG5cbkRhdGEudWlkID0gMTtcblxuRGF0YS5wcm90b3R5cGUgPSB7XG5cblx0Y2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHRcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuXHRcdHZhciB2YWx1ZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuXHRcdGlmICggIXZhbHVlICkge1xuXHRcdFx0dmFsdWUgPSB7fTtcblxuXHRcdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuXHRcdFx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuXHRcdFx0XHQvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuXHRcdFx0XHQvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcblx0XHR2YXIgcHJvcCxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZSggb3duZXIgKTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3Ncblx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIGRhdGEgKSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIHByb3AgKSBdID0gZGF0YVsgcHJvcCBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7XG5cdH0sXG5cdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMuY2FjaGUoIG93bmVyICkgOlxuXG5cdFx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gJiYgb3duZXJbIHRoaXMuZXhwYW5kbyBdWyBjYW1lbENhc2UoIGtleSApIF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblx0XHR9XG5cblx0XHQvLyBXaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly9cblx0XHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG5cdH0sXG5cdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBrZXkgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc2V0IGNhbWVsQ2FzZSBrZXlzLCBzbyByZW1vdmUgdGhhdC5cblx0XHRcdFx0a2V5ID0ga2V5Lm1hcCggY2FtZWxDYXNlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXkgPSBjYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2Vcblx0XHRcdFx0a2V5ID0ga2V5IGluIGNhY2hlID9cblx0XHRcdFx0XHRbIGtleSBdIDpcblx0XHRcdFx0XHQoIGtleS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdICk7XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBrZXkubGVuZ3RoO1xuXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDVcblx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDcgKGJ1ZyByZXN0cmljdGVkKVxuXHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHR2YXIgY2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0cmV0dXJuIGNhY2hlICE9PSB1bmRlZmluZWQgJiYgIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApO1xuXHR9XG59O1xudmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcblxudmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuXG5cbi8vXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XG4vL1xuLy9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcbi8vXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2Vcbi8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbi8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuLy9cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcbi8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbi8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcblxudmFyIHJicmFjZSA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxcblx0cm11bHRpRGFzaCA9IC9bQS1aXS9nO1xuXG5mdW5jdGlvbiBnZXREYXRhKCBkYXRhICkge1xuXHRpZiAoIGRhdGEgPT09IFwidHJ1ZVwiICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcImZhbHNlXCIgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcIm51bGxcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdGlmICggZGF0YSA9PT0gK2RhdGEgKyBcIlwiICkge1xuXHRcdHJldHVybiArZGF0YTtcblx0fVxuXG5cdGlmICggcmJyYWNlLnRlc3QoIGRhdGEgKSApIHtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSApO1xuXHR9XG5cblx0cmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZ2V0RGF0YSggZGF0YSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGRhdGFVc2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhVXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fSxcblxuXHQvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuXHQvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGNhbWVsQ2FzZSggbmFtZS5zbGljZSggNSApICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGRhdGE7XG5cblx0XHRcdC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XG5cdFx0XHQvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxuXHRcdFx0Ly8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3Rcblx0XHRcdC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcblx0XHRcdC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXG5cdFx0XHRpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIFRoZSBrZXkgd2lsbCBhbHdheXMgYmUgY2FtZWxDYXNlZCBpbiBEYXRhXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG5cdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzdG9yZSB0aGUgY2FtZWxDYXNlZCBrZXlcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XG5cdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRhdGFVc2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YVByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgQXJyYXkuaXNBcnJheSggZGF0YSApICkge1xuXHRcdFx0XHRcdHF1ZXVlID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KCBkYXRhICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBxdWV1ZSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG5cdFx0XHRuZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0c3RhcnRMZW5ndGgtLTtcblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuXHRcdH1cblxuXHRcdGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxuXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcblx0XHRyZXR1cm4gZGF0YVByaXYuZ2V0KCBlbGVtLCBrZXkgKSB8fCBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuXHRcdFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLmFkZCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgWyB0eXBlICsgXCJxdWV1ZVwiLCBrZXkgXSApO1xuXHRcdFx0fSApXG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbIDAgXSwgdHlwZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcyA6XG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHQvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVsgMCBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHR9ICk7XG5cdH0sXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0fSxcblxuXHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG5cdC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxuXHRwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqICkge1xuXHRcdHZhciB0bXAsXG5cdFx0XHRjb3VudCA9IDEsXG5cdFx0XHRkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0ZWxlbWVudHMgPSB0aGlzLFxuXHRcdFx0aSA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICEoIC0tY291bnQgKSApIHtcblx0XHRcdFx0XHRkZWZlci5yZXNvbHZlV2l0aCggZWxlbWVudHMsIFsgZWxlbWVudHMgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9iaiA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRtcCA9IGRhdGFQcml2LmdldCggZWxlbWVudHNbIGkgXSwgdHlwZSArIFwicXVldWVIb29rc1wiICk7XG5cdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzb2x2ZSgpO1xuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcblx0fVxufSApO1xudmFyIHBudW0gPSAoIC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvICkuc291cmNlO1xuXG52YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoIFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICk7XG5cblxudmFyIGNzc0V4cGFuZCA9IFsgXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIiBdO1xuXG52YXIgaXNIaWRkZW5XaXRoaW5UcmVlID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXG5cdFx0Ly8gaXNIaWRkZW5XaXRoaW5UcmVlIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cblx0XHQvLyBJbmxpbmUgc3R5bGUgdHJ1bXBzIGFsbFxuXHRcdHJldHVybiBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8XG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiZcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBjaGVjayBjb21wdXRlZCBzdHlsZVxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQzIC0gNDVcblx0XHRcdC8vIERpc2Nvbm5lY3RlZCBlbGVtZW50cyBjYW4gaGF2ZSBjb21wdXRlZCBkaXNwbGF5OiBub25lLCBzbyBmaXJzdCBjb25maXJtIHRoYXQgZWxlbSBpc1xuXHRcdFx0Ly8gaW4gdGhlIGRvY3VtZW50LlxuXHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSAmJlxuXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIjtcblx0fTtcblxudmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG5cblxuZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcblx0dmFyIGFkanVzdGVkLCBzY2FsZSxcblx0XHRtYXhJdGVyYXRpb25zID0gMjAsXG5cdFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5jdXIoKTtcblx0XHRcdH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7XG5cdFx0XHR9LFxuXHRcdGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcblx0XHR1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdGluaXRpYWxJblVuaXQgPSAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwgKSAmJlxuXHRcdFx0cmNzc051bS5leGVjKCBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wICkgKTtcblxuXHRpZiAoIGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFsgMyBdICE9PSB1bml0ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdFx0Ly8gSGFsdmUgdGhlIGl0ZXJhdGlvbiB0YXJnZXQgdmFsdWUgdG8gcHJldmVudCBpbnRlcmZlcmVuY2UgZnJvbSBDU1MgdXBwZXIgYm91bmRzIChnaC0yMTQ0KVxuXHRcdGluaXRpYWwgPSBpbml0aWFsIC8gMjtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0d2hpbGUgKCBtYXhJdGVyYXRpb25zLS0gKSB7XG5cblx0XHRcdC8vIEV2YWx1YXRlIGFuZCB1cGRhdGUgb3VyIGJlc3QgZ3Vlc3MgKGRvdWJsaW5nIGd1ZXNzZXMgdGhhdCB6ZXJvIG91dCkuXG5cdFx0XHQvLyBGaW5pc2ggaWYgdGhlIHNjYWxlIGVxdWFscyBvciBjcm9zc2VzIDEgKG1ha2luZyB0aGUgb2xkKm5ldyBwcm9kdWN0IG5vbi1wb3NpdGl2ZSkuXG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cdFx0XHRpZiAoICggMSAtIHNjYWxlICkgKiAoIDEgLSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsIHx8IDAuNSApICkgPD0gMCApIHtcblx0XHRcdFx0bWF4SXRlcmF0aW9ucyA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xuXG5cdFx0fVxuXG5cdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgKiAyO1xuXHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHR2YWx1ZVBhcnRzID0gdmFsdWVQYXJ0cyB8fCBbXTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG5cblxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuXHR2YXIgdGVtcCxcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuXHRcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuXHRpZiAoIGRpc3BsYXkgKSB7XG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH1cblxuXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICk7XG5cdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcImRpc3BsYXlcIiApO1xuXG5cdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG5cdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0ZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0fVxuXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2Vcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG5cdFx0XHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcblx0XHRcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcblx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IFwibm9uZVwiO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuXHRcdFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKykvaSApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxebW9kdWxlJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldDtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2Uge1xuXHRcdHJldCA9IFtdO1xuXHR9XG5cblx0aWYgKCB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgbm9kZU5hbWUoIGNvbnRleHQsIHRhZyApICkge1xuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBjb250YWlucywgaixcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdG5vZGVzID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIHRvVHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Y29udGFpbnMgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XG5cdFx0dG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0aWYgKCBjb250YWlucyApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xuXHRcdH1cblxuXHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRpZiAoIHNjcmlwdHMgKSB7XG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdG1wWyBqKysgXSApICkge1xuXHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZnJhZ21lbnQ7XG59XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKSxcblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcblx0Ly8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKCMxMTIxNylcblx0Ly8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuXHQvLyBgbmFtZWAgYW5kIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKCMxNDkwMSlcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwidFwiICk7XG5cblx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgb25seVxuXHQvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcblx0c3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxuXHRkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XG5cdHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSAhIWRpdi5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xufSApKCk7XG52YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxudmFyXG5cdHJrZXlFdmVudCA9IC9ea2V5Lyxcblx0cm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay8sXG5cdHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpLztcblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBTZWUgIzEzMzkzIGZvciBtb3JlIGluZm9cbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyICkgeyB9XG59XG5cbmZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG5cdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblxuXHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggb25lID09PSAxICkge1xuXHRcdG9yaWdGbiA9IGZuO1xuXHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cblx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuXHR9XG5cdHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcblx0fSApO1xufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0Ly8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChidXQgYWxsb3cgcGxhaW4gb2JqZWN0cylcblx0XHRpZiAoICFlbGVtRGF0YSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBFbnN1cmUgdGhhdCBpbnZhbGlkIHNlbGVjdG9ycyB0aHJvdyBleGNlcHRpb25zIGF0IGF0dGFjaCB0aW1lXG5cdFx0Ly8gRXZhbHVhdGUgYWdhaW5zdCBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBlbGVtIGlzIGEgbm9uLWVsZW1lbnQgbm9kZSAoZS5nLiwgZG9jdW1lbnQpXG5cdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZG9jdW1lbnRFbGVtZW50LCBzZWxlY3RvciApO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuXHRcdGlmICggISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcblx0XHR9XG5cdFx0aWYgKCAhKCBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSApICkge1xuXHRcdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblxuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHxcblx0XHRcdFx0XHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG5cdFx0XHR0bXAgPSB0bXBbIDIgXSAmJlxuXHRcdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXHRcdFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdO1xuXG5cdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHQoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuXHRcdFx0XHRcdCggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcblx0XHRcdFx0XHQoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBkYXRhIGFuZCB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGRpc3BhdGNoOiBmdW5jdGlvbiggbmF0aXZlRXZlbnQgKSB7XG5cblx0XHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3Rcblx0XHR2YXIgZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBuYXRpdmVFdmVudCApO1xuXG5cdFx0dmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLCBoYW5kbGVyUXVldWUsXG5cdFx0XHRhcmdzID0gbmV3IEFycmF5KCBhcmd1bWVudHMubGVuZ3RoICksXG5cdFx0XHRoYW5kbGVycyA9ICggZGF0YVByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdIHx8IFtdLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyBldmVudC50eXBlIF0gfHwge307XG5cblx0XHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuXHRcdGFyZ3NbIDAgXSA9IGV2ZW50O1xuXG5cdFx0Zm9yICggaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRhcmdzWyBpIF0gPSBhcmd1bWVudHNbIGkgXTtcblx0XHR9XG5cblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cdFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggbWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdICkgJiZcblx0XHRcdFx0IWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvciAyKSBoYXZlIG5hbWVzcGFjZShzKVxuXHRcdFx0XHQvLyBhIHN1YnNldCBvciBlcXVhbCB0byB0aG9zZSBpbiB0aGUgYm91bmQgZXZlbnQgKGJvdGggY2FuIGhhdmUgbm8gbmFtZXNwYWNlKS5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgaGFuZGxlT2JqLCBzZWwsIG1hdGNoZWRIYW5kbGVycywgbWF0Y2hlZFNlbGVjdG9ycyxcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OVxuXHRcdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKHRyYWMtMTMxODApXG5cdFx0XHRjdXIubm9kZVR5cGUgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQyXG5cdFx0XHQvLyBTdXBwcmVzcyBzcGVjLXZpb2xhdGluZyBjbGlja3MgaW5kaWNhdGluZyBhIG5vbi1wcmltYXJ5IHBvaW50ZXIgYnV0dG9uICh0cmFjLTM4NjEpXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudC10eXBlLWNsaWNrXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHQvLyAuLi5idXQgbm90IGFycm93IGtleSBcImNsaWNrc1wiIG9mIHJhZGlvIGlucHV0cywgd2hpY2ggY2FuIGhhdmUgYGJ1dHRvbmAgLTEgKGdoLTIzNDMpXG5cdFx0XHQhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgZXZlbnQuYnV0dG9uID49IDEgKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgY3VyLmRpc2FibGVkID09PSB0cnVlICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzID0gW107XG5cdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9ycyA9IHt9O1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPiAtMSA6XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkSGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzIH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0Y3VyID0gdGhpcztcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdGFkZFByb3A6IGZ1bmN0aW9uKCBuYW1lLCBob29rICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuXHRcdFx0Z2V0OiBpc0Z1bmN0aW9uKCBob29rICkgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGhvb2soIHRoaXMub3JpZ2luYWxFdmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50WyBuYW1lIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBuYW1lLCB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggb3JpZ2luYWxFdmVudCApIHtcblx0XHRyZXR1cm4gb3JpZ2luYWxFdmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRvcmlnaW5hbEV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblx0fSxcblxuXHRzcGVjaWFsOiB7XG5cdFx0bG9hZDoge1xuXG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0Zm9jdXM6IHtcblxuXHRcdFx0Ly8gRmlyZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzICE9PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuZm9jdXMgKSB7XG5cdFx0XHRcdFx0dGhpcy5mb2N1cygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c2luXCJcblx0XHR9LFxuXHRcdGJsdXI6IHtcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5ibHVyICkge1xuXHRcdFx0XHRcdHRoaXMuYmx1cigpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c291dFwiXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBGb3IgY2hlY2tib3gsIGZpcmUgbmF0aXZlIGV2ZW50IHNvIGNoZWNrZWQgc3RhdGUgd2lsbCBiZSByaWdodFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy50eXBlID09PSBcImNoZWNrYm94XCIgJiYgdGhpcy5jbGljayAmJiBub2RlTmFtZSggdGhpcywgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5jbGljaygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIGRvbid0IGZpcmUgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRyZXR1cm4gbm9kZU5hbWUoIGV2ZW50LnRhcmdldCwgXCJhXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXG5cdC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuXHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcblx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSApO1xuXHR9XG59O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblxuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seVxuXHRcdFx0XHRzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cblx0XHRcdHJldHVyblRydWUgOlxuXHRcdFx0cmV0dXJuRmFsc2U7XG5cblx0XHQvLyBDcmVhdGUgdGFyZ2V0IHByb3BlcnRpZXNcblx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgPD02IC0gNyBvbmx5XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0Mylcblx0XHR0aGlzLnRhcmdldCA9ICggc3JjLnRhcmdldCAmJiBzcmMudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkgP1xuXHRcdFx0c3JjLnRhcmdldC5wYXJlbnROb2RlIDpcblx0XHRcdHNyYy50YXJnZXQ7XG5cblx0XHR0aGlzLmN1cnJlbnRUYXJnZXQgPSBzcmMuY3VycmVudFRhcmdldDtcblx0XHR0aGlzLnJlbGF0ZWRUYXJnZXQgPSBzcmMucmVsYXRlZFRhcmdldDtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuXG5cdC8vIE1hcmsgaXQgYXMgZml4ZWRcblx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG59O1xuXG4vLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBqUXVlcnkuRXZlbnQsXG5cdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc1NpbXVsYXRlZDogZmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0fVxufTtcblxuLy8gSW5jbHVkZXMgYWxsIGNvbW1vbiBldmVudCBwcm9wcyBpbmNsdWRpbmcgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnQgc3BlY2lmaWMgcHJvcHNcbmpRdWVyeS5lYWNoKCB7XG5cdGFsdEtleTogdHJ1ZSxcblx0YnViYmxlczogdHJ1ZSxcblx0Y2FuY2VsYWJsZTogdHJ1ZSxcblx0Y2hhbmdlZFRvdWNoZXM6IHRydWUsXG5cdGN0cmxLZXk6IHRydWUsXG5cdGRldGFpbDogdHJ1ZSxcblx0ZXZlbnRQaGFzZTogdHJ1ZSxcblx0bWV0YUtleTogdHJ1ZSxcblx0cGFnZVg6IHRydWUsXG5cdHBhZ2VZOiB0cnVlLFxuXHRzaGlmdEtleTogdHJ1ZSxcblx0dmlldzogdHJ1ZSxcblx0XCJjaGFyXCI6IHRydWUsXG5cdGNoYXJDb2RlOiB0cnVlLFxuXHRrZXk6IHRydWUsXG5cdGtleUNvZGU6IHRydWUsXG5cdGJ1dHRvbjogdHJ1ZSxcblx0YnV0dG9uczogdHJ1ZSxcblx0Y2xpZW50WDogdHJ1ZSxcblx0Y2xpZW50WTogdHJ1ZSxcblx0b2Zmc2V0WDogdHJ1ZSxcblx0b2Zmc2V0WTogdHJ1ZSxcblx0cG9pbnRlcklkOiB0cnVlLFxuXHRwb2ludGVyVHlwZTogdHJ1ZSxcblx0c2NyZWVuWDogdHJ1ZSxcblx0c2NyZWVuWTogdHJ1ZSxcblx0dGFyZ2V0VG91Y2hlczogdHJ1ZSxcblx0dG9FbGVtZW50OiB0cnVlLFxuXHR0b3VjaGVzOiB0cnVlLFxuXG5cdHdoaWNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcblxuXHRcdC8vIEFkZCB3aGljaCBmb3Iga2V5IGV2ZW50c1xuXHRcdGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCAmJiBya2V5RXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0cmV0dXJuIGV2ZW50LmNoYXJDb2RlICE9IG51bGwgPyBldmVudC5jaGFyQ29kZSA6IGV2ZW50LmtleUNvZGU7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuXHRcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIHJtb3VzZUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdGlmICggYnV0dG9uICYgMSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnV0dG9uICYgMiApIHtcblx0XHRcdFx0cmV0dXJuIDM7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnV0dG9uICYgNCApIHtcblx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC53aGljaDtcblx0fVxufSwgalF1ZXJ5LmV2ZW50LmFkZFByb3AgKTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbi8vXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG52YXJcblxuXHQvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy8zMjI5XG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKilbXj5dKilcXC8+L2dpLFxuXG5cdC8qIGVzbGludC1lbmFibGUgKi9cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxMyBvbmx5XG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuLy8gUHJlZmVyIGEgdGJvZHkgb3ZlciBpdHMgcGFyZW50IHRhYmxlIGZvciBjb250YWluaW5nIG5ldyByb3dzXG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0bm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRyZXR1cm4galF1ZXJ5KCBlbGVtICkuY2hpbGRyZW4oIFwidGJvZHlcIiApWyAwIF0gfHwgZWxlbTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHRpZiAoICggZWxlbS50eXBlIHx8IFwiXCIgKS5zbGljZSggMCwgNSApID09PSBcInRydWUvXCIgKSB7XG5cdFx0ZWxlbS50eXBlID0gZWxlbS50eXBlLnNsaWNlKCA1ICk7XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5hY2Nlc3MoIHNyYyApO1xuXHRcdHBkYXRhQ3VyID0gZGF0YVByaXYuc2V0KCBkZXN0LCBwZGF0YU9sZCApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcblx0XHRcdHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gY29uY2F0LmFwcGx5KCBbXSwgYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRpZiAoIHZhbHVlSXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyAmJiAoIG5vZGUudHlwZSB8fCBcIlwiICkudG9Mb3dlckNhc2UoKSAgIT09IFwibW9kdWxlXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRET01FdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApLCBkb2MsIG5vZGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG5cdHZhciBub2RlLFxuXHRcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcblx0XHRpID0gMDtcblxuXHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRpZiAoIGtlZXBEYXRhICYmIGpRdWVyeS5jb250YWlucyggbm9kZS5vd25lckRvY3VtZW50LCBub2RlICkgKSB7XG5cdFx0XHRcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHR9XG5cdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRyZXR1cm4gaHRtbC5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuXHRcdFx0aW5QYWdlID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xuXHR9LFxuXG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIHZhbHVlICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZ25vcmVkID0gW107XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cblx0XHR9LCBpZ25vcmVkICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5LCBGaXJlZm94IDw9MzAgKCMxNTA5OCwgIzE0MTUwKVxuXHRcdC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuXHRcdC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuXHRcdHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG5cdFx0aWYgKCAhdmlldyB8fCAhdmlldy5vcGVuZXIgKSB7XG5cdFx0XHR2aWV3ID0gd2luZG93O1xuXHRcdH1cblxuXHRcdHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcblx0fTtcblxudmFyIHJib3hTdHlsZSA9IG5ldyBSZWdFeHAoIGNzc0V4cGFuZC5qb2luKCBcInxcIiApLCBcImlcIiApO1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblxuXHQvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcblx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cblx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cblx0XHQvLyBUaGlzIGlzIGEgc2luZ2xldG9uLCB3ZSBuZWVkIHRvIGV4ZWN1dGUgaXQgb25seSBvbmNlXG5cdFx0aWYgKCAhZGl2ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O3dpZHRoOjYwcHg7XCIgK1xuXHRcdFx0XCJtYXJnaW4tdG9wOjFweDtwYWRkaW5nOjA7Ym9yZGVyOjBcIjtcblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9XG5cdFx0XHRcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OnNjcm9sbDtcIiArXG5cdFx0XHRcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xuXHRcdFx0XCJ3aWR0aDo2MCU7dG9wOjElXCI7XG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKS5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0XHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2ICk7XG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgRmlyZWZveCA8PTMgLSA0NFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUubWFyZ2luTGVmdCApID09PSAxMjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIFNhZmFyaSA8PTkuMSAtIDEwLjEsIGlPUyA8PTcuMCAtIDkuM1xuXHRcdC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxuXHRcdGRpdi5zdHlsZS5yaWdodCA9IFwiNjAlXCI7XG5cdFx0cGl4ZWxCb3hTdHlsZXNWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLnJpZ2h0ICkgPT09IDM2O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0XHQvLyBEZXRlY3QgbWlzcmVwb3J0aW5nIG9mIGNvbnRlbnQgZGltZW5zaW9ucyBmb3IgYm94LXNpemluZzpib3JkZXItYm94IGVsZW1lbnRzXG5cdFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLndpZHRoICkgPT09IDM2O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG92ZXJmbG93OnNjcm9sbCBzY3Jld2luZXNzIChnaC0zNjk5KVxuXHRcdGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0XHRzY3JvbGxib3hTaXplVmFsID0gZGl2Lm9mZnNldFdpZHRoID09PSAzNiB8fCBcImFic29sdXRlXCI7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0Ly8gTnVsbGlmeSB0aGUgZGl2IHNvIGl0IHdvdWxkbid0IGJlIHN0b3JlZCBpbiB0aGUgbWVtb3J5IGFuZFxuXHRcdC8vIGl0IHdpbGwgYWxzbyBiZSBhIHNpZ24gdGhhdCBjaGVja3MgYWxyZWFkeSBwZXJmb3JtZWRcblx0XHRkaXYgPSBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gcm91bmRQaXhlbE1lYXN1cmVzKCBtZWFzdXJlICkge1xuXHRcdHJldHVybiBNYXRoLnJvdW5kKCBwYXJzZUZsb2F0KCBtZWFzdXJlICkgKTtcblx0fVxuXG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgc2Nyb2xsYm94U2l6ZVZhbCwgcGl4ZWxCb3hTdHlsZXNWYWwsXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKCM4OTA4KVxuXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG5cdFx0fSxcblx0XHRwaXhlbEJveFN0eWxlczogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsQm94U3R5bGVzVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG5cdFx0fSxcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG5cdFx0fSxcblx0XHRzY3JvbGxib3hTaXplOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gc2Nyb2xsYm94U2l6ZVZhbDtcblx0XHR9XG5cdH0gKTtcbn0gKSgpO1xuXG5cbmZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDUxK1xuXHRcdC8vIFJldHJpZXZpbmcgc3R5bGUgYmVmb3JlIGNvbXB1dGVkIHNvbWVob3dcblx0XHQvLyBmaXhlcyBhbiBpc3N1ZSB3aXRoIGdldHRpbmcgd3JvbmcgdmFsdWVzXG5cdFx0Ly8gb24gZGV0YWNoZWQgZWxlbWVudHNcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG5lZWRlZCBmb3I6XG5cdC8vICAgLmNzcygnZmlsdGVyJykgKElFIDkgb25seSwgIzEyNTM3KVxuXHQvLyAgIC5jc3MoJy0tY3VzdG9tUHJvcGVydHkpICgjMzE0NClcblx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRyZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXTtcblxuXHRcdGlmICggcmV0ID09PSBcIlwiICYmICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuXHRcdC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXG5cdFx0Ly8gVGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOlxuXHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5waXhlbEJveFN0eWxlcygpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiByYm94U3R5bGUudGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG52YXJcblxuXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG5cdC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcblx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXHRyY3VzdG9tUHJvcCA9IC9eLS0vLFxuXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHRcdGZvbnRXZWlnaHQ6IFwiNDAwXCJcblx0fSxcblxuXHRjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG5cdGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkuc3R5bGU7XG5cbi8vIFJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBuYW1lICkge1xuXG5cdC8vIFNob3J0Y3V0IGZvciBuYW1lcyB0aGF0IGFyZSBub3QgdmVuZG9yIHByZWZpeGVkXG5cdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdHJldHVybiBuYW1lO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuXHR2YXIgY2FwTmFtZSA9IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG59XG5cbi8vIFJldHVybiBhIHByb3BlcnR5IG1hcHBlZCBhbG9uZyB3aGF0IGpRdWVyeS5jc3NQcm9wcyBzdWdnZXN0cyBvciB0b1xuLy8gYSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHkuXG5mdW5jdGlvbiBmaW5hbFByb3BOYW1lKCBuYW1lICkge1xuXHR2YXIgcmV0ID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF07XG5cdGlmICggIXJldCApIHtcblx0XHRyZXQgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBuYW1lICkgfHwgbmFtZTtcblx0fVxuXHRyZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXG5cdC8vIEFueSByZWxhdGl2ZSAoKy8tKSB2YWx1ZXMgaGF2ZSBhbHJlYWR5IGJlZW5cblx0Ly8gbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50XG5cdHZhciBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAyIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgYm94LCBpc0JvcmRlckJveCwgc3R5bGVzLCBjb21wdXRlZFZhbCApIHtcblx0dmFyIGkgPSBkaW1lbnNpb24gPT09IFwid2lkdGhcIiA/IDEgOiAwLFxuXHRcdGV4dHJhID0gMCxcblx0XHRkZWx0YSA9IDA7XG5cblx0Ly8gQWRqdXN0bWVudCBtYXkgbm90IGJlIG5lY2Vzc2FyeVxuXHRpZiAoIGJveCA9PT0gKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApICkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXG5cdFx0Ly8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luXG5cdFx0aWYgKCBib3ggPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBib3ggKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZ2V0IGhlcmUgd2l0aCBhIGNvbnRlbnQtYm94LCB3ZSdyZSBzZWVraW5nIFwicGFkZGluZ1wiIG9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIlxuXHRcdGlmICggIWlzQm9yZGVyQm94ICkge1xuXG5cdFx0XHQvLyBBZGQgcGFkZGluZ1xuXHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEZvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCIsIGFkZCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gQnV0IHN0aWxsIGtlZXAgdHJhY2sgb2YgaXQgb3RoZXJ3aXNlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRleHRyYSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZ2V0IGhlcmUgd2l0aCBhIGJvcmRlci1ib3ggKGNvbnRlbnQgKyBwYWRkaW5nICsgYm9yZGVyKSwgd2UncmUgc2Vla2luZyBcImNvbnRlbnRcIiBvclxuXHRcdC8vIFwicGFkZGluZ1wiIG9yIFwibWFyZ2luXCJcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBGb3IgXCJjb250ZW50XCIsIHN1YnRyYWN0IHBhZGRpbmdcblx0XHRcdGlmICggYm94ID09PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdFx0ZGVsdGEgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiBvciBcInBhZGRpbmdcIiwgc3VidHJhY3QgYm9yZGVyXG5cdFx0XHRpZiAoIGJveCAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0ZGVsdGEgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBY2NvdW50IGZvciBwb3NpdGl2ZSBjb250ZW50LWJveCBzY3JvbGwgZ3V0dGVyIHdoZW4gcmVxdWVzdGVkIGJ5IHByb3ZpZGluZyBjb21wdXRlZFZhbFxuXHRpZiAoICFpc0JvcmRlckJveCAmJiBjb21wdXRlZFZhbCA+PSAwICkge1xuXG5cdFx0Ly8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGlzIGEgcm91bmRlZCBzdW0gb2YgY29udGVudCwgcGFkZGluZywgc2Nyb2xsIGd1dHRlciwgYW5kIGJvcmRlclxuXHRcdC8vIEFzc3VtaW5nIGludGVnZXIgc2Nyb2xsIGd1dHRlciwgc3VidHJhY3QgdGhlIHJlc3QgYW5kIHJvdW5kIGRvd25cblx0XHRkZWx0YSArPSBNYXRoLm1heCggMCwgTWF0aC5jZWlsKFxuXHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdGNvbXB1dGVkVmFsIC1cblx0XHRcdGRlbHRhIC1cblx0XHRcdGV4dHJhIC1cblx0XHRcdDAuNVxuXHRcdCkgKTtcblx0fVxuXG5cdHJldHVybiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIGNvbXB1dGVkIHN0eWxlXG5cdHZhciBzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIGRpbWVuc2lvbiwgc3R5bGVzICksXG5cdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveDtcblxuXHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcblx0Ly8gUmV0dXJuIGEgY29uZm91bmRpbmcgbm9uLXBpeGVsIHZhbHVlIG9yIGZlaWduIGlnbm9yYW5jZSwgYXMgYXBwcm9wcmlhdGUuXG5cdGlmICggcm51bW5vbnB4LnRlc3QoIHZhbCApICkge1xuXHRcdGlmICggIWV4dHJhICkge1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9XG5cdFx0dmFsID0gXCJhdXRvXCI7XG5cdH1cblxuXHQvLyBDaGVjayBmb3Igc3R5bGUgaW4gY2FzZSBhIGJyb3dzZXIgd2hpY2ggcmV0dXJucyB1bnJlbGlhYmxlIHZhbHVlc1xuXHQvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXG5cdHZhbHVlSXNCb3JkZXJCb3ggPSB2YWx1ZUlzQm9yZGVyQm94ICYmXG5cdFx0KCBzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgdmFsID09PSBlbGVtLnN0eWxlWyBkaW1lbnNpb24gXSApO1xuXG5cdC8vIEZhbGwgYmFjayB0byBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgd2hlbiB2YWx1ZSBpcyBcImF1dG9cIlxuXHQvLyBUaGlzIGhhcHBlbnMgZm9yIGlubGluZSBlbGVtZW50cyB3aXRoIG5vIGV4cGxpY2l0IHNldHRpbmcgKGdoLTM1NzEpXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgLSA0LjMgb25seVxuXHQvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIG1pc3JlcG9ydGVkIGlubGluZSBkaW1lbnNpb25zIChnaC0zNjAyKVxuXHRpZiAoIHZhbCA9PT0gXCJhdXRvXCIgfHxcblx0XHQhcGFyc2VGbG9hdCggdmFsICkgJiYgalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJpbmxpbmVcIiApIHtcblxuXHRcdHZhbCA9IGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXTtcblxuXHRcdC8vIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBwcm92aWRlIGJvcmRlci1ib3ggdmFsdWVzXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IHRydWU7XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgXCJcIiBhbmQgYXV0b1xuXHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXG5cdC8vIEFkanVzdCBmb3IgdGhlIGVsZW1lbnQncyBib3ggbW9kZWxcblx0cmV0dXJuICggdmFsICtcblx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlcyxcblxuXHRcdFx0Ly8gUHJvdmlkZSB0aGUgY3VycmVudCBjb21wdXRlZCBzaXplIHRvIHJlcXVlc3Qgc2Nyb2xsIGd1dHRlciBjYWxjdWxhdGlvbiAoZ2gtMzU4OSlcblx0XHRcdHZhbFxuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwibGluZUhlaWdodFwiOiB0cnVlLFxuXHRcdFwib3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwib3JkZXJcIjogdHJ1ZSxcblx0XHRcIm9ycGhhbnNcIjogdHJ1ZSxcblx0XHRcIndpZG93c1wiOiB0cnVlLFxuXHRcdFwiekluZGV4XCI6IHRydWUsXG5cdFx0XCJ6b29tXCI6IHRydWVcblx0fSxcblxuXHQvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXG5cdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcblx0Y3NzUHJvcHM6IHt9LFxuXG5cdC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG5cdHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuXG5cdFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0dmFyIHJldCwgdHlwZSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApLFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdC8vIHdhbnQgdG8gcXVlcnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmICggcmV0ID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiYgcmV0WyAxIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gYWRqdXN0Q1NTKCBlbGVtLCBuYW1lLCByZXQgKTtcblxuXHRcdFx0XHQvLyBGaXhlcyBidWcgIzkyMzdcblx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHRcdHN0eWxlLnNldFByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBtb2RpZnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBkaW1lbnNpb24gKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgZGltZW5zaW9uIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuXHRcdFx0XHRcdC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG5cdFx0XHRcdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHRcdFx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdFx0XHRcdFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRcdFx0XHRcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XG5cdFx0XHRcdFx0XHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRcdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhICYmIGJveE1vZGVsQWRqdXN0bWVudChcblx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdGRpbWVuc2lvbixcblx0XHRcdFx0XHRleHRyYSxcblx0XHRcdFx0XHRpc0JvcmRlckJveCxcblx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0KTtcblxuXHRcdFx0Ly8gQWNjb3VudCBmb3IgdW5yZWxpYWJsZSBib3JkZXItYm94IGRpbWVuc2lvbnMgYnkgY29tcGFyaW5nIG9mZnNldCogdG8gY29tcHV0ZWQgYW5kXG5cdFx0XHQvLyBmYWtpbmcgYSBjb250ZW50LWJveCB0byBnZXQgYm9yZGVyIGFuZCBwYWRkaW5nIChnaC0zNjk5KVxuXHRcdFx0aWYgKCBpc0JvcmRlckJveCAmJiBzdXBwb3J0LnNjcm9sbGJveFNpemUoKSA9PT0gc3R5bGVzLnBvc2l0aW9uICkge1xuXHRcdFx0XHRzdWJ0cmFjdCAtPSBNYXRoLmNlaWwoXG5cdFx0XHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdFx0XHRwYXJzZUZsb2F0KCBzdHlsZXNbIGRpbWVuc2lvbiBdICkgLVxuXHRcdFx0XHRcdGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBcImJvcmRlclwiLCBmYWxzZSwgc3R5bGVzICkgLVxuXHRcdFx0XHRcdDAuNVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdGVsZW0uc3R5bGVbIGRpbWVuc2lvbiBdID0gdmFsdWU7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgZGltZW5zaW9uICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCBwcmVmaXggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCB0d2Vlbi5lbGVtLnN0eWxlWyBqUXVlcnkuY3NzUHJvcHNbIHR3ZWVuLnByb3AgXSBdICE9IG51bGwgfHxcblx0XHRcdFx0XHRqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgaW5Qcm9ncmVzcyxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG5mdW5jdGlvbiBzY2hlZHVsZSgpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdGlmICggZG9jdW1lbnQuaGlkZGVuID09PSBmYWxzZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggc2NoZWR1bGUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHNjaGVkdWxlLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0XHR9XG5cblx0XHRqUXVlcnkuZngudGljaygpO1xuXHR9XG59XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBEYXRlLm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG5cdFx0aXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3Ncblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcblx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xuXHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcblx0aWYgKCBpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuXHRcdC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZIGFuZCBFZGdlIGp1c3QgbWlycm9yc1xuXHRcdC8vIHRoZSBvdmVyZmxvd1ggdmFsdWUgdGhlcmUuXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcblx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG5cdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0fVxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xuXHRcdFx0XHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHRcdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0XHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0cHJvcFR3ZWVuID0gZmFsc2U7XG5cdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuXHRcdC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXG5cdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcblx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0XHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcblx0XHRcdFx0aWYgKCAhaGlkZGVuICkge1xuXHRcdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxuXHRcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRwcm9wVHdlZW4uc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9ICksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgd2FzIGFuIGVtcHR5IGFuaW1hdGlvbiwgc3ludGhlc2l6ZSBhIGZpbmFsIHByb2dyZXNzIG5vdGlmaWNhdGlvblxuXHRcdFx0aWYgKCAhbGVuZ3RoICkge1xuXHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9ICksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0cmVzdWx0LnN0b3AuYmluZCggcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0Ly8gQXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0YW5pbWF0aW9uXG5cdFx0LnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9IClcblx0KTtcblxuXHRyZXR1cm4gYW5pbWF0aW9uO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0dHdlZW5lcnM6IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuXHRcdFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH0sXG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0aWYgKCBwcmVwZW5kICkge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdGlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmXG5cdGlmICggalF1ZXJ5LmZ4Lm9mZiApIHtcblx0XHRvcHQuZHVyYXRpb24gPSAwO1xuXG5cdH0gZWxzZSB7XG5cdFx0aWYgKCB0eXBlb2Ygb3B0LmR1cmF0aW9uICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0aWYgKCBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyApIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbldpdGhpblRyZWUgKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG5cdFx0XHRcdFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XG5cblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goIHtcblx0c2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIgKSxcblx0c2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiICksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeCggXCJ0b2dnbGVcIiApLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBEYXRlLm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gUnVuIHRoZSB0aW1lciBhbmQgc2FmZWx5IHJlbW92ZSBpdCB3aGVuIGRvbmUgKGFsbG93aW5nIGZvciBleHRlcm5hbCByZW1vdmFsKVxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHR9XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufTtcblxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdGpRdWVyeS5meC5zdGFydCgpO1xufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGluUHJvZ3Jlc3MgPSB0cnVlO1xuXHRzY2hlZHVsZSgpO1xufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0aW5Qcm9ncmVzcyA9IG51bGw7XG59O1xuXG5qUXVlcnkuZnguc3BlZWRzID0ge1xuXHRzbG93OiA2MDAsXG5cdGZhc3Q6IDIwMCxcblxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0gKTtcbn07XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4zIG9ubHlcblx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG5cdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXR0cmlidXRlIGhvb2tzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0bm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsXG5cdFx0XHRpID0gMCxcblxuXHRcdFx0Ly8gQXR0cmlidXRlIG5hbWVzIGNhbiBjb250YWluIG5vbi1IVE1MIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuXHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXG5cdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHdoaWxlICggKCBuYW1lID0gYXR0ck5hbWVzWyBpKysgXSApICkge1xuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2Vcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lICk7XG5cdFx0fVxuXHRcdHJldHVybiBuYW1lO1xuXHR9XG59O1xuXG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlLFxuXHRcdFx0bG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdGlmICggIWlzWE1MICkge1xuXG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdGxvd2VyY2FzZU5hbWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSApO1xuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG5cdFx0XHRcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdGlmICggdGFiaW5kZXggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmXG5cdFx0XHRcdFx0ZWxlbS5ocmVmXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG4vLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcbi8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cblx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIEhUTUwgc3BlY1xuXHQvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLWFzY2lpLXdoaXRlc3BhY2Vcblx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XG5cdFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdFx0cmV0dXJuIHRva2Vucy5qb2luKCBcIiBcIiApO1xuXHR9XG5cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxuZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICkge1xuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHR9XG5cdHJldHVybiBbXTtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuXHRcdH1cblxuXHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUsXG5cdFx0XHRpc1ZhbGlkVmFsdWUgPSB0eXBlID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgaXNWYWxpZFZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0c3RhdGVWYWxcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XG5cblx0XHRcdGlmICggaXNWYWxpZFZhbHVlICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGdldENsYXNzKCBlbGVtICkgKSArIFwiIFwiICkuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIHZhbHVlSXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdGlmICggdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG5cdFx0XHRcdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2Vcblx0XHRcdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRcdFx0XHRcdHN0cmlwQW5kQ29sbGFwc2UoIGpRdWVyeS50ZXh0KCBlbGVtICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sIGksXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0XHRpID0gbWF4O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aSA9IG9uZSA/IGluZGV4IDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCFvcHRpb24uZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhbm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbnN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcblx0c3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbiggZSApIHtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9O1xuXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsIGxhc3RFbGVtZW50LFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSBsYXN0RWxlbWVudCA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGxhc3RFbGVtZW50ID0gY3VyO1xuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBpc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4vL1xuLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXG4vLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbi8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbmlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcblx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XG5cdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICkgLSAxO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0gKTtcbn1cbnZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcblxudmFyIG5vbmNlID0gRGF0ZS5ub3coKTtcblxudmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0eG1sID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggb2JqICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyhcblx0XHRcdFx0XHRwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuXHRcdFx0XHRcdHYsXG5cdFx0XHRcdFx0dHJhZGl0aW9uYWwsXG5cdFx0XHRcdFx0YWRkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiB0b1R5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlT3JGdW5jdGlvbiApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuXHRcdFx0dmFyIHZhbHVlID0gaXNGdW5jdGlvbiggdmFsdWVPckZ1bmN0aW9uICkgP1xuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb24oKSA6XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbjtcblxuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArXG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdH07XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHR9ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG5cdFx0Zm9yICggcHJlZml4IGluIGEgKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0cmV0dXJuIHMuam9pbiggXCImXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0gKVxuXHRcdC5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFwiOmRpc2FibGVkXCIgKSAmJlxuXHRcdFx0XHRyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmXG5cdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcblx0XHR9IClcblx0XHQubWFwKCBmdW5jdGlvbiggaSwgZWxlbSApIHtcblx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0gKS5nZXQoKTtcblx0fVxufSApO1xuXG5cbnZhclxuXHRyMjAgPSAvJTIwL2csXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRyYW50aUNhY2hlID0gLyhbPyZdKV89W14mXSovLFxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXG5cblx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cblx0LyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHRwcmVmaWx0ZXJzID0ge30sXG5cblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHR0cmFuc3BvcnRzID0ge30sXG5cblx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG5cdGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdCggXCIqXCIgKSxcblxuXHQvLyBBbmNob3IgdGFnIGZvciBwYXJzaW5nIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblx0b3JpZ2luQW5jaG9yLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVHlwZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggZnVuYyApICkge1xuXG5cdFx0XHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG5cdFx0XHR3aGlsZSAoICggZGF0YVR5cGUgPSBkYXRhVHlwZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcblx0XHRcdFx0aWYgKCBkYXRhVHlwZVsgMCBdID09PSBcIitcIiApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS51bnNoaWZ0KCBmdW5jICk7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkucHVzaCggZnVuYyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcbmZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XG5cblx0dmFyIGluc3BlY3RlZCA9IHt9LFxuXHRcdHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xuXG5cdGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuXHRcdHZhciBzZWxlY3RlZDtcblx0XHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xuXHRcdGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG5cdFx0XHR2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XG5cblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9XG5cblx0cmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyBcIipcIiBdICYmIGluc3BlY3QoIFwiKlwiICk7XG59XG5cbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbi8vIEZpeGVzICM5ODg3XG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcblx0dmFyIGtleSwgZGVlcCxcblx0XHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cblx0Zm9yICgga2V5IGluIHNyYyApIHtcblx0XHRpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8ICggZGVlcCA9IHt9ICkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0fVxuXHR9XG5cdGlmICggZGVlcCApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuXHR2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LVR5cGVcIiApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbIDAgXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblxuXHRcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuXHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcblx0d2hpbGUgKCBjdXJyZW50ICkge1xuXG5cdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG5cdFx0XHRqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcblx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHRcdH1cblxuXHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdGlmICggY3VycmVudCApIHtcblxuXHRcdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgcy50aHJvd3MgKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogbG9jYXRpb24uaHJlZixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC9cXGJ4bWxcXGIvLFxuXHRcdFx0aHRtbDogL1xcYmh0bWwvLFxuXHRcdFx0anNvbjogL1xcYmpzb25cXGIvXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0fSxcblxuXHRcdC8vIERhdGEgY29udmVydGVyc1xuXHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IEpTT04ucGFyc2UsXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRjb250ZXh0OiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHRyYW5zcG9ydCxcblxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcblx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblxuXHRcdFx0Ly8gVXJsIGNsZWFudXAgdmFyXG5cdFx0XHR1cmxBbmNob3IsXG5cblx0XHRcdC8vIFJlcXVlc3Qgc3RhdGUgKGJlY29tZXMgZmFsc2UgdXBvbiBzZW5kIGFuZCB0cnVlIHVwb24gY29tcGxldGlvbilcblx0XHRcdGNvbXBsZXRlZCxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG5cdFx0XHRmaXJlR2xvYmFscyxcblxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblxuXHRcdFx0Ly8gdW5jYWNoZWQgcGFydCBvZiB0aGUgdXJsXG5cdFx0XHR1bmNhY2hlZCxcblxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cblx0XHRcdC8vIENhbGxiYWNrcyBjb250ZXh0XG5cdFx0XHRjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblxuXHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmXG5cdFx0XHRcdCggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LFxuXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSBdID0gbWF0Y2hbIDIgXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJhdyBzdHJpbmdcblx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tcGxldGVkID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSA9XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRzLm1pbWVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdFx0c3RhdHVzQ29kZTogZnVuY3Rpb24oIG1hcCApIHtcblx0XHRcdFx0XHR2YXIgY29kZTtcblx0XHRcdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFja3MgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICk7XG5cblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcIlwiIClcblx0XHRcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICk7XG5cblx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcblx0XHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0gKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBvcmlnaW4uXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSwgRWRnZSAxMiAtIDE1XG5cdFx0XHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIG9uIGFjY2Vzc2luZyB0aGUgaHJlZiBwcm9wZXJ0eSBpZiB1cmwgaXMgbWFsZm9ybWVkLFxuXHRcdFx0Ly8gZS5nLiBodHRwOi8vZXhhbXBsZS5jb206ODB4L1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSBvbmx5XG5cdFx0XHRcdC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWY7XG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cblx0XHRcdFx0XHR1cmxBbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyB1cmxBbmNob3IuaG9zdDtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxuXHRcdFx0XHQvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuXHRcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xuXHRcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcblx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdC8vIFJlbW92ZSBoYXNoIHRvIHNpbXBsaWZ5IHVybCBtYW5pcHVsYXRpb25cblx0XHRjYWNoZVVSTCA9IHMudXJsLnJlcGxhY2UoIHJoYXNoLCBcIlwiICk7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIGhhc2ggc28gd2UgY2FuIHB1dCBpdCBiYWNrXG5cdFx0XHR1bmNhY2hlZCA9IHMudXJsLnNsaWNlKCBjYWNoZVVSTC5sZW5ndGggKTtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUgYW5kIHNob3VsZCBiZSBwcm9jZXNzZWQsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgJiYgKCBzLnByb2Nlc3NEYXRhIHx8IHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgKSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YTtcblxuXHRcdFx0XHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvciB1cGRhdGUgYW50aS1jYWNoZSBwYXJhbSBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZSggcmFudGlDYWNoZSwgXCIkMVwiICk7XG5cdFx0XHRcdHVuY2FjaGVkID0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArICggbm9uY2UrKyApICsgdW5jYWNoZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcblx0XHRcdHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcblxuXHRcdC8vIENoYW5nZSAnJTIwJyB0byAnKycgaWYgdGhpcyBpcyBlbmNvZGVkIGZvcm0gYm9keSBjb250ZW50IChnaC0yNjU4KVxuXHRcdH0gZWxzZSBpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmXG5cdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApLmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCApIHtcblx0XHRcdHMuZGF0YSA9IHMuZGF0YS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcblx0XHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcblx0XHRcdFwiQWNjZXB0XCIsXG5cdFx0XHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gK1xuXHRcdFx0XHRcdCggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG5cdFx0XHRcdHMuYWNjZXB0c1sgXCIqXCIgXVxuXHRcdCk7XG5cblx0XHQvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cblx0XHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXHRcdGlmICggcy5iZWZvcmVTZW5kICYmXG5cdFx0XHQoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IGNvbXBsZXRlZCApICkge1xuXG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Y29tcGxldGVEZWZlcnJlZC5hZGQoIHMuY29tcGxldGUgKTtcblx0XHRqcVhIUi5kb25lKCBzLnN1Y2Nlc3MgKTtcblx0XHRqcVhIUi5mYWlsKCBzLmVycm9yICk7XG5cblx0XHQvLyBHZXQgdHJhbnNwb3J0XG5cdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcblx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XG5cdFx0XHRkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybiBqcVhIUjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydCggXCJ0aW1lb3V0XCIgKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbXBsZXRlZCA9IGZhbHNlO1xuXHRcdFx0XHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIFJldGhyb3cgcG9zdC1jb21wbGV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBvdGhlcnMgYXMgcmVzdWx0c1xuXHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbXBsZXRlZCA9IHRydWU7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcblx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cblx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkxhc3QtTW9kaWZpZWRcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiZXRhZ1wiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgbm8gY29udGVudFxuXHRcdFx0XHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cblx0XHRcdFx0Ly8gaWYgbm90IG1vZGlmaWVkXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuXHRcdFx0XHRcdHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuXHRcdFx0XHRcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG5cdFx0XHRcdFx0aXNTdWNjZXNzID0gIWVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xuXHRcdFx0XHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cblx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuXHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG5cdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcGxldGVcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RvcFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ganFYSFI7XG5cdH0sXG5cblx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG5cdH0sXG5cblx0Z2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIGksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXG5cdFx0Ly8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBUaGUgdXJsIGNhbiBiZSBhbiBvcHRpb25zIG9iamVjdCAod2hpY2ggdGhlbiBtdXN0IGhhdmUgLnVybClcblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoIGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0dHlwZTogbWV0aG9kLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2tcblx0XHR9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCggdXJsICkgJiYgdXJsICkgKTtcblx0fTtcbn0gKTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsICkge1xuXHRyZXR1cm4galF1ZXJ5LmFqYXgoIHtcblx0XHR1cmw6IHVybCxcblxuXHRcdC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAoIzExMjY0KVxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCIsXG5cdFx0Y2FjaGU6IHRydWUsXG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdsb2JhbDogZmFsc2UsXG5cdFx0XCJ0aHJvd3NcIjogdHJ1ZVxuXHR9ICk7XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIHdyYXA7XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblx0XHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0XHRodG1sID0gaHRtbC5jYWxsKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSApLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBodG1sSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbElzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dGhpcy5wYXJlbnQoIHNlbGVjdG9yICkubm90KCBcImJvZHlcIiApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlKCBlbGVtICk7XG59O1xualF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhISggZWxlbS5vZmZzZXRXaWR0aCB8fCBlbGVtLm9mZnNldEhlaWdodCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICk7XG59O1xuXG5cblxuXG5qUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2ggKCBlICkge31cbn07XG5cbnZhciB4aHJTdWNjZXNzU3RhdHVzID0ge1xuXG5cdFx0Ly8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcblx0XHQwOiAyMDAsXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKTtcblxuXHRcdFx0XHR4aHIub3Blbihcblx0XHRcdFx0XHRvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0b3B0aW9ucy51cmwsXG5cdFx0XHRcdFx0b3B0aW9ucy5hc3luYyxcblx0XHRcdFx0XHRvcHRpb25zLnVzZXJuYW1lLFxuXHRcdFx0XHRcdG9wdGlvbnMucGFzc3dvcmRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPVxuXHRcdFx0XHRcdFx0XHRcdHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub250aW1lb3V0ID1cblx0XHRcdFx0XHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xuXHRcdFx0XHRcdFx0XHRcdC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB4aHIuc3RhdHVzICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIDAsIFwiZXJyb3JcIiApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0LFxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcblx0XHRcdFx0XHRcdFx0XHRcdCggeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIiApICE9PSBcInRleHRcIiAgfHxcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyBiaW5hcnk6IHhoci5yZXNwb25zZSB9IDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBMaXN0ZW4gdG8gZXZlbnRzXG5cdFx0XHRcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSB4aHIub250aW1lb3V0ID0gY2FsbGJhY2soIFwiZXJyb3JcIiApO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdFx0XHQvLyBVc2Ugb25yZWFkeXN0YXRlY2hhbmdlIHRvIHJlcGxhY2Ugb25hYm9ydFxuXHRcdFx0XHQvLyB0byBoYW5kbGUgdW5jYXVnaHQgYWJvcnRzXG5cdFx0XHRcdGlmICggeGhyLm9uYWJvcnQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR4aHIub25hYm9ydCA9IGVycm9yQ2FsbGJhY2s7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBDaGVjayByZWFkeVN0YXRlIGJlZm9yZSB0aW1lb3V0IGFzIGl0IGNoYW5nZXNcblx0XHRcdFx0XHRcdGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQWxsb3cgb25lcnJvciB0byBiZSBjYWxsZWQgZmlyc3QsXG5cdFx0XHRcdFx0XHRcdC8vIGJ1dCB0aGF0IHdpbGwgbm90IGhhbmRsZSBhIG5hdGl2ZSBhYm9ydFxuXHRcdFx0XHRcdFx0XHQvLyBBbHNvLCBzYXZlIGVycm9yQ2FsbGJhY2sgdG8gYSB2YXJpYWJsZVxuXHRcdFx0XHRcdFx0XHQvLyBhcyB4aHIub25lcnJvciBjYW5ub3QgYmUgYWNjZXNzZWRcblx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlcnJvckNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayggXCJhYm9ydFwiICk7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcblx0XHRcdFx0XHR4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gIzE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBQcmV2ZW50IGF1dG8tZXhlY3V0aW9uIG9mIHNjcmlwdHMgd2hlbiBubyBleHBsaWNpdCBkYXRhVHlwZSB3YXMgcHJvdmlkZWQgKFNlZSBnaC0yNDMyKVxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy5jb250ZW50cy5zY3JpcHQgPSBmYWxzZTtcblx0fVxufSApO1xuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRhY2NlcHRzOiB7XG5cdFx0c2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgXCIgK1xuXHRcdFx0XCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogL1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHMuY2FjaGUgPSBmYWxzZTtcblx0fVxuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy50eXBlID0gXCJHRVRcIjtcblx0fVxufSApO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblxuXHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIHJlcXVlc3RzXG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHR2YXIgc2NyaXB0LCBjYWxsYmFjaztcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNvbXBsZXRlICkge1xuXHRcdFx0XHRzY3JpcHQgPSBqUXVlcnkoIFwiPHNjcmlwdD5cIiApLnByb3AoIHtcblx0XHRcdFx0XHRjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsXG5cdFx0XHRcdFx0c3JjOiBzLnVybFxuXHRcdFx0XHR9ICkub24oXG5cdFx0XHRcdFx0XCJsb2FkIGVycm9yXCIsXG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XG4vLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XG4vLyBjb2xsYXBzZSBzaWJsaW5nIGZvcm1zOiB0aGUgc2Vjb25kIG9uZSBiZWNvbWVzIGEgY2hpbGQgb2YgdGhlIGZpcnN0IG9uZS5cbi8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcbnN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID0gKCBmdW5jdGlvbigpIHtcblx0dmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKS5ib2R5O1xuXHRib2R5LmlubmVySFRNTCA9IFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIjtcblx0cmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XG59ICkoKTtcblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoIHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cblx0dmFyIGJhc2UsIHBhcnNlZCwgc2NyaXB0cztcblxuXHRpZiAoICFjb250ZXh0ICkge1xuXG5cdFx0Ly8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gYnkgdXNpbmcgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cblx0XHRpZiAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ICkge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcblx0XHRcdC8vIHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXG5cdFx0XHQvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxuXHRcdFx0YmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJiYXNlXCIgKTtcblx0XHRcdGJhc2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG5cdFx0XHRjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoIGJhc2UgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50O1xuXHRcdH1cblx0fVxuXG5cdHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApO1xuXHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHQvLyBvZmZzZXQoKSByZWxhdGVzIGFuIGVsZW1lbnQncyBib3JkZXIgYm94IHRvIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciByZWN0LCB3aW4sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG5cdFx0Ly8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cdFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdC8vIEdldCBkb2N1bWVudC1yZWxhdGl2ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmlld3BvcnQgc2Nyb2xsIHRvIHZpZXdwb3J0LXJlbGF0aXZlIGdCQ1Jcblx0XHRyZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR3aW4gPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQsXG5cdFx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXRcblx0XHR9O1xuXHR9LFxuXG5cdC8vIHBvc2l0aW9uKCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgbWFyZ2luIGJveCB0byBpdHMgb2Zmc2V0IHBhcmVudCdzIHBhZGRpbmcgYm94XG5cdC8vIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIGJlaGF2aW9yIG9mIENTUyBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCwgZG9jLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBwb3NpdGlvbjpmaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gdGhlIHZpZXdwb3J0LCB3aGljaCBpdHNlbGYgYWx3YXlzIGhhcyB6ZXJvIG9mZnNldFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gQXNzdW1lIHBvc2l0aW9uOmZpeGVkIGltcGxpZXMgYXZhaWxhYmlsaXR5IG9mIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB0aGUgKnJlYWwqIG9mZnNldCBwYXJlbnQsIHdoaWNoIGNhbiBiZSB0aGUgZG9jdW1lbnQgb3IgaXRzIHJvb3QgZWxlbWVudFxuXHRcdFx0Ly8gd2hlbiBhIHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50IGlzIGlkZW50aWZpZWRcblx0XHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHRcdG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJlxuXHRcdFx0XHQoIG9mZnNldFBhcmVudCA9PT0gZG9jLmJvZHkgfHwgb2Zmc2V0UGFyZW50ID09PSBkb2MuZG9jdW1lbnRFbGVtZW50ICkgJiZcblx0XHRcdFx0alF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblxuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGlmICggb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZWxlbSAmJiBvZmZzZXRQYXJlbnQubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgYm9yZGVycyBpbnRvIGl0cyBvZmZzZXQsIHNpbmNlIHRoZXkgYXJlIG91dHNpZGUgaXRzIGNvbnRlbnQgb3JpZ2luXG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IGpRdWVyeSggb2Zmc2V0UGFyZW50ICkub2Zmc2V0KCk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cblx0XHRcdC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xuXHRcdFx0dmFyIHdpbjtcblx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblx0XHRcdFx0d2luID0gZWxlbTtcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW0uZGVmYXVsdFZpZXc7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSxcblx0XHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcblx0XHRcdFx0XHRyZXR1cm4gZnVuY05hbWUuaW5kZXhPZiggXCJvdXRlclwiICkgPT09IDAgP1xuXHRcdFx0XHRcdFx0ZWxlbVsgXCJpbm5lclwiICsgbmFtZSBdIDpcblx0XHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cblxuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG4vLyBhcmd1bWVudHMuXG4vLyBqUXVlcnkucHJveHkgaXMgZGVwcmVjYXRlZCB0byBwcm9tb3RlIHN0YW5kYXJkcyAoc3BlY2lmaWNhbGx5IEZ1bmN0aW9uI2JpbmQpXG4vLyBIb3dldmVyLCBpdCBpcyBub3Qgc2xhdGVkIGZvciByZW1vdmFsIGFueSB0aW1lIHNvb25cbmpRdWVyeS5wcm94eSA9IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdGNvbnRleHQgPSBmbjtcblx0XHRmbiA9IHRtcDtcblx0fVxuXG5cdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdGlmICggIWlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vIFNpbXVsYXRlZCBiaW5kXG5cdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0fTtcblxuXHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0cmV0dXJuIHByb3h5O1xufTtcblxualF1ZXJ5LmhvbGRSZWFkeSA9IGZ1bmN0aW9uKCBob2xkICkge1xuXHRpZiAoIGhvbGQgKSB7XG5cdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHR9XG59O1xualF1ZXJ5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xualF1ZXJ5LnBhcnNlSlNPTiA9IEpTT04ucGFyc2U7XG5qUXVlcnkubm9kZU5hbWUgPSBub2RlTmFtZTtcbmpRdWVyeS5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmpRdWVyeS5pc1dpbmRvdyA9IGlzV2luZG93O1xualF1ZXJ5LmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbmpRdWVyeS50eXBlID0gdG9UeXBlO1xuXG5qUXVlcnkubm93ID0gRGF0ZS5ub3c7XG5cbmpRdWVyeS5pc051bWVyaWMgPSBmdW5jdGlvbiggb2JqICkge1xuXG5cdC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXG5cdC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcblx0Ly8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2Milcblx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cdHJldHVybiAoIHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiApICYmXG5cblx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0IWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xufTtcblxuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9ICk7XG59XG5cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggIW5vR2xvYmFsICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cblxuXG5cbnJldHVybiBqUXVlcnk7XG59ICk7XG4iLCIvKiFcbiAqIEphdmFTY3JpcHQgQ29va2llIHYyLjIuMFxuICogaHR0cHM6Ly9naXRodWIuY29tL2pzLWNvb2tpZS9qcy1jb29raWVcbiAqXG4gKiBDb3B5cmlnaHQgMjAwNiwgMjAxNSBLbGF1cyBIYXJ0bCAmIEZhZ25lciBCcmFja1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbjsoZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0dmFyIHJlZ2lzdGVyZWRJbk1vZHVsZUxvYWRlciA9IGZhbHNlO1xuXHRpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0ZGVmaW5lKGZhY3RvcnkpO1xuXHRcdHJlZ2lzdGVyZWRJbk1vZHVsZUxvYWRlciA9IHRydWU7XG5cdH1cblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRcdHJlZ2lzdGVyZWRJbk1vZHVsZUxvYWRlciA9IHRydWU7XG5cdH1cblx0aWYgKCFyZWdpc3RlcmVkSW5Nb2R1bGVMb2FkZXIpIHtcblx0XHR2YXIgT2xkQ29va2llcyA9IHdpbmRvdy5Db29raWVzO1xuXHRcdHZhciBhcGkgPSB3aW5kb3cuQ29va2llcyA9IGZhY3RvcnkoKTtcblx0XHRhcGkubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHdpbmRvdy5Db29raWVzID0gT2xkQ29va2llcztcblx0XHRcdHJldHVybiBhcGk7XG5cdFx0fTtcblx0fVxufShmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIGV4dGVuZCAoKSB7XG5cdFx0dmFyIGkgPSAwO1xuXHRcdHZhciByZXN1bHQgPSB7fTtcblx0XHRmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSBhcmd1bWVudHNbIGkgXTtcblx0XHRcdGZvciAodmFyIGtleSBpbiBhdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdHJlc3VsdFtrZXldID0gYXR0cmlidXRlc1trZXldO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5pdCAoY29udmVydGVyKSB7XG5cdFx0ZnVuY3Rpb24gYXBpIChrZXksIHZhbHVlLCBhdHRyaWJ1dGVzKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXHRcdFx0aWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXcml0ZVxuXG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0YXR0cmlidXRlcyA9IGV4dGVuZCh7XG5cdFx0XHRcdFx0cGF0aDogJy8nXG5cdFx0XHRcdH0sIGFwaS5kZWZhdWx0cywgYXR0cmlidXRlcyk7XG5cblx0XHRcdFx0aWYgKHR5cGVvZiBhdHRyaWJ1dGVzLmV4cGlyZXMgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0dmFyIGV4cGlyZXMgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0XHRcdGV4cGlyZXMuc2V0TWlsbGlzZWNvbmRzKGV4cGlyZXMuZ2V0TWlsbGlzZWNvbmRzKCkgKyBhdHRyaWJ1dGVzLmV4cGlyZXMgKiA4NjRlKzUpO1xuXHRcdFx0XHRcdGF0dHJpYnV0ZXMuZXhwaXJlcyA9IGV4cGlyZXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSdyZSB1c2luZyBcImV4cGlyZXNcIiBiZWNhdXNlIFwibWF4LWFnZVwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUVcblx0XHRcdFx0YXR0cmlidXRlcy5leHBpcmVzID0gYXR0cmlidXRlcy5leHBpcmVzID8gYXR0cmlidXRlcy5leHBpcmVzLnRvVVRDU3RyaW5nKCkgOiAnJztcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcblx0XHRcdFx0XHRpZiAoL15bXFx7XFxbXS8udGVzdChyZXN1bHQpKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IHJlc3VsdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cblx0XHRcdFx0aWYgKCFjb252ZXJ0ZXIud3JpdGUpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcodmFsdWUpKVxuXHRcdFx0XHRcdFx0LnJlcGxhY2UoLyUoMjN8MjR8MjZ8MkJ8M0F8M0N8M0V8M0R8MkZ8M0Z8NDB8NUJ8NUR8NUV8NjB8N0J8N0R8N0MpL2csIGRlY29kZVVSSUNvbXBvbmVudCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjb252ZXJ0ZXIud3JpdGUodmFsdWUsIGtleSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRrZXkgPSBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGtleSkpO1xuXHRcdFx0XHRrZXkgPSBrZXkucmVwbGFjZSgvJSgyM3wyNHwyNnwyQnw1RXw2MHw3QykvZywgZGVjb2RlVVJJQ29tcG9uZW50KTtcblx0XHRcdFx0a2V5ID0ga2V5LnJlcGxhY2UoL1tcXChcXCldL2csIGVzY2FwZSk7XG5cblx0XHRcdFx0dmFyIHN0cmluZ2lmaWVkQXR0cmlidXRlcyA9ICcnO1xuXG5cdFx0XHRcdGZvciAodmFyIGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuXHRcdFx0XHRcdGlmICghYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHN0cmluZ2lmaWVkQXR0cmlidXRlcyArPSAnOyAnICsgYXR0cmlidXRlTmFtZTtcblx0XHRcdFx0XHRpZiAoYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHN0cmluZ2lmaWVkQXR0cmlidXRlcyArPSAnPScgKyBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAoZG9jdW1lbnQuY29va2llID0ga2V5ICsgJz0nICsgdmFsdWUgKyBzdHJpbmdpZmllZEF0dHJpYnV0ZXMpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZWFkXG5cblx0XHRcdGlmICgha2V5KSB7XG5cdFx0XHRcdHJlc3VsdCA9IHt9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUbyBwcmV2ZW50IHRoZSBmb3IgbG9vcCBpbiB0aGUgZmlyc3QgcGxhY2UgYXNzaWduIGFuIGVtcHR5IGFycmF5XG5cdFx0XHQvLyBpbiBjYXNlIHRoZXJlIGFyZSBubyBjb29raWVzIGF0IGFsbC4gQWxzbyBwcmV2ZW50cyBvZGQgcmVzdWx0IHdoZW5cblx0XHRcdC8vIGNhbGxpbmcgXCJnZXQoKVwiXG5cdFx0XHR2YXIgY29va2llcyA9IGRvY3VtZW50LmNvb2tpZSA/IGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOyAnKSA6IFtdO1xuXHRcdFx0dmFyIHJkZWNvZGUgPSAvKCVbMC05QS1aXXsyfSkrL2c7XG5cdFx0XHR2YXIgaSA9IDA7XG5cblx0XHRcdGZvciAoOyBpIDwgY29va2llcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgcGFydHMgPSBjb29raWVzW2ldLnNwbGl0KCc9Jyk7XG5cdFx0XHRcdHZhciBjb29raWUgPSBwYXJ0cy5zbGljZSgxKS5qb2luKCc9Jyk7XG5cblx0XHRcdFx0aWYgKCF0aGlzLmpzb24gJiYgY29va2llLmNoYXJBdCgwKSA9PT0gJ1wiJykge1xuXHRcdFx0XHRcdGNvb2tpZSA9IGNvb2tpZS5zbGljZSgxLCAtMSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHZhciBuYW1lID0gcGFydHNbMF0ucmVwbGFjZShyZGVjb2RlLCBkZWNvZGVVUklDb21wb25lbnQpO1xuXHRcdFx0XHRcdGNvb2tpZSA9IGNvbnZlcnRlci5yZWFkID9cblx0XHRcdFx0XHRcdGNvbnZlcnRlci5yZWFkKGNvb2tpZSwgbmFtZSkgOiBjb252ZXJ0ZXIoY29va2llLCBuYW1lKSB8fFxuXHRcdFx0XHRcdFx0Y29va2llLnJlcGxhY2UocmRlY29kZSwgZGVjb2RlVVJJQ29tcG9uZW50KTtcblxuXHRcdFx0XHRcdGlmICh0aGlzLmpzb24pIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdGNvb2tpZSA9IEpTT04ucGFyc2UoY29va2llKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGtleSA9PT0gbmFtZSkge1xuXHRcdFx0XHRcdFx0cmVzdWx0ID0gY29va2llO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCFrZXkpIHtcblx0XHRcdFx0XHRcdHJlc3VsdFtuYW1lXSA9IGNvb2tpZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXG5cdFx0YXBpLnNldCA9IGFwaTtcblx0XHRhcGkuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0cmV0dXJuIGFwaS5jYWxsKGFwaSwga2V5KTtcblx0XHR9O1xuXHRcdGFwaS5nZXRKU09OID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGFwaS5hcHBseSh7XG5cdFx0XHRcdGpzb246IHRydWVcblx0XHRcdH0sIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG5cdFx0fTtcblx0XHRhcGkuZGVmYXVsdHMgPSB7fTtcblxuXHRcdGFwaS5yZW1vdmUgPSBmdW5jdGlvbiAoa2V5LCBhdHRyaWJ1dGVzKSB7XG5cdFx0XHRhcGkoa2V5LCAnJywgZXh0ZW5kKGF0dHJpYnV0ZXMsIHtcblx0XHRcdFx0ZXhwaXJlczogLTFcblx0XHRcdH0pKTtcblx0XHR9O1xuXG5cdFx0YXBpLndpdGhDb252ZXJ0ZXIgPSBpbml0O1xuXG5cdFx0cmV0dXJuIGFwaTtcblx0fVxuXG5cdHJldHVybiBpbml0KGZ1bmN0aW9uICgpIHt9KTtcbn0pKTtcbiIsImltcG9ydCB7IFJlc291cmNlcyB9IGZyb20gJy4vbGliL3Jlc291cmNlcydcblxuLyoqIFxuICog5rWP6KeI5Zmo5LiN5pSv5oyB5omA5byV5Y+R55qE6ZSZ6K+vXG4gKiBAZGVwcmVjYXRlZCDmtY/op4jlmajkuI3mlK/mjIHmiYDlvJXlj5HnmoTplJnor6/jgILmnInlhbPln7rnsbvnmoTor6bnu4bkv6Hmga/vvIzor7flj4LpmIUgTUROIFtFcnJvcl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3J9IOOAglxuICogQGFsaWFzIG9wZW5CU0UuQnJvd3Nlck5vdFN1cHBvcnRFcnJvclxuICogQGV4dGVuZHMgRXJyb3JcbiAqL1xuY2xhc3MgQnJvd3Nlck5vdFN1cHBvcnRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICAvKipcbiAgICAgKiDliJvlu7rkuIDkuKrlvILluLjlr7nosaFcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIOa2iOaBr1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoUmVzb3VyY2VzLkJST1dTRVJfTk9UX1NVUFBPUlRfRVJST1IuZmlsbERhdGEoeyBtZXNzYWdlOiBtZXNzYWdlIH0pKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJCcm93c2VyTm90U3VwcG9ydEVycm9yXCI7XG4gICAgfVxufVxuXG5leHBvcnQgeyBCcm93c2VyTm90U3VwcG9ydEVycm9yIH0iLCJtb2R1bGUuZXhwb3J0cz17XCJ2ZXJzaW9uXCI6XCIyLjFcIixcImhvbWVcIjpcImh0dHBzOi8vaWFtc2NvdHR4dS5naXRodWIuaW8vb3BlbkJTRS9cIixcIm5hbWVcIjpcIm9wZW5CU0VcIixcImRlc2NyaXB0aW9uXCI6XCJvcGVuQlNFIGlzIGEgaGlnaC1wZXJmb3JtYW5jZSBKYXZhU2NyaXB0IGJ1bGxldC1zY3JlZW4gKGRhbm1ha3UpIGVuZ2luZS5cIixcImJ1aWxkRGF0ZVwiOlwiVHVlLCAwNSBNYXIgMjAxOSAwMToxOToxNiBHTVRcIn1cbiIsImltcG9ydCB7IExpbmtlZExpc3QgfSBmcm9tICcuL2xpYi9saW5rZWRMaXN0J1xuaW1wb3J0IHsgRXZlbnQgfSBmcm9tICcuL2xpYi9ldmVudCdcbmltcG9ydCB7IFJlbmRlcmVyc0ZhY3RvcnkgfSBmcm9tICcuL2xpYi9yZW5kZXJlcnMvcmVuZGVyZXJzRmFjdG9yeSdcbmltcG9ydCB7IEJ1bGxldFNjcmVlblR5cGUgfSBmcm9tICcuL2J1bGxldFNjcmVlblR5cGUnXG5pbXBvcnQgeyBIZWxwZXIgfSBmcm9tICcuL2xpYi9oZWxwZXInXG5pbXBvcnQgeyBSZXNvdXJjZXMgfSBmcm9tICcuL2xpYi9yZXNvdXJjZXMnXG5pbXBvcnQgKiBhcyBidWlsZCBmcm9tICcuL2J1aWxkLmpzb24nXG5cbi8qKiBcbiAqIOW8ueW5leW8leaTjuWvueixoeexuyBcbiAqIEBhbGlhcyBvcGVuQlNFLkJ1bGxldFNjcmVlbkVuZ2luZVxuICogQHRocm93cyB7b3BlbkJTRS5Ccm93c2VyTm90U3VwcG9ydEVycm9yfSDmtY/op4jlmajkuI3mlK/mjIHnibnlrprmuLLmn5PmqKHlvI/ml7blvJXlj5HplJnor6/jgIJcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0g5Lyg5YWl55qE5Y+C5pWw6ZSZ6K+v5pe25byV5Y+R6ZSZ6K+v44CC6K+35Y+C6ZiFIE1ETiBbVHlwZUVycm9yXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9UeXBlRXJyb3J9IOOAglxuICovXG5jbGFzcyBCdWxsZXRTY3JlZW5FbmdpbmUge1xuICAgIC8qKlxuICAgICAqIOWIm+W7uuS4gOS4quW8ueW5leW8leaTjuWvueixoeOAglxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIOimgeWKoOi9veW8ueW5leeahOWFg+e0oO+8muacieWFsyBFbGVtZW50IOaOpeWPo+eahOS/oeaBr+ivt+WPgumYhU1ETiBbRWxlbWVudF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0VsZW1lbnR9IOOAglxuICAgICAqIEBwYXJhbSB7b3BlbkJTRX5PcHRpb25zfSBbX29wdGlvbnNdIC0g5YWo5bGA6YCJ6aG577ya5LiA5LiqIHtAbGluayBvcGVuQlNFfk9wdGlvbnN9IOe7k+aehOOAglxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVuZGVyTW9kZT1cImNhbnZhc1wiXSAtIOa4suafk+aooeW8j++8mum7mOiupOS4uuKAnGNhbnZhc+KAnSwg4oCc5Y+v6YCJY3NzM+KAne+8jCDigJx3ZWJnbOKAneWSjOKAnHN2Z+KAneOAguS4gOiIrOW7uuiuruS9v+eUqOKAnGNhbnZhc+KAne+8iOeJueWIq+aYryBGaXJlRm94IOa1j+iniOWZqCBDU1MzIOa4suafk+aViOeOh+i+g+S9ju+8ieOAguWcqOS4gOS6m+eJiOacrOi+g+iAgeeahOa1j+iniOWZqOS4reKAnHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlv4oCd5Y+Y6YeP5LiN6KKr5pSv5oyB5oiW5pSv5oyB5LiN5a6M5pW077yM6L+Z5Lya5a+86Ie05Zyo6auYRFBJ5ZKM6aG16Z2i6KKr57yp5pS+55qE5oOF5Ya15LiL4oCcY2FudmFz4oCd5ZKM4oCcd2ViZ2zigJ3muLLmn5PmqKHlvI/lvLnluZXmmL7npLrkuI3mraPluLjnmoTmg4XlhrXvvIjlvLnluZXmqKHns4rvvInvvIzmraTml7blu7rorq7kvb/nlKjigJxjc3Mz4oCd5riy5p+T5qih5byP44CCXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucywgcmVuZGVyTW9kZSA9ICdjYW52YXMnKSB7XG4gICAgICAgIC8v5Y+Y6YeP5Yid5aeL5YyWXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvIDlp4vml7bpl7RcbiAgICAgICAgICogQHByaXZhdGUgQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGxldCBfc3RhcnRUaW1lO1xuICAgICAgICAvKipcbiAgICAgICAgICog5pqC5YGc5pe26Ze0XG4gICAgICAgICAqIEBwcml2YXRlIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgX3BhdXNlVGltZSA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliankvZnlvLnluZVcbiAgICAgICAgICogQHByaXZhdGUgQHR5cGUge0xpbmtlZExpc3R9XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgX2J1bGxldFNjcmVlbnMgPSBuZXcgTGlua2VkTGlzdCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICog5bGP5bmV5LiK55qE5by55bmVXG4gICAgICAgICAqIEBwcml2YXRlIEB0eXBlIHtMaW5rZWRMaXN0fVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IF9idWxsZXRTY3JlZW5zT25TY3JlZW4gPSBuZXcgTGlua2VkTGlzdCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICog5bu26L+f5by55bmV5oC75pWwXG4gICAgICAgICAqIEBwcml2YXRlIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgX2RlbGF5QnVsbGV0U2NyZWVuc0NvdW50ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW7tui/n++8iOWNleS9je+8muavq+enku+8iVxuICAgICAgICAgKiBAcHJpdmF0ZSBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IF9kZWxheSA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmkq3mlL7moIflv5dcbiAgICAgICAgICogQHByaXZhdGUgQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgX3BsYXlpbmc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliLfmlrDpopHnjodcbiAgICAgICAgICogQHByaXZhdGUgQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGxldCBfcmVmcmVzaFJhdGUgPSAwLjA2OyAvL+WIneWni+WIt+aWsOmikeeOh1xuICAgICAgICAvKipcbiAgICAgICAgICog5LiK5LiA5qyh5Yi35paw5pe26Ze0XG4gICAgICAgICAqIEBwcml2YXRlIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgX2xhc3RSZWZyZXNoVGltZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWFqOWxgOmAiemhuVxuICAgICAgICAgKiBAcHJpdmF0ZSBAdHlwZSB7b3BlbkJTRX5PcHRpb25zfVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IF9vcHRpb25zO1xuICAgICAgICAvKipcbiAgICAgICAgICog6buY6K6k5YWo5bGA5Y+Y6YePXG4gICAgICAgICAqIEBwcml2YXRlIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgX2RlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICAgICAgLyoqIOWeguebtOmXtOi3nSAqL1xuICAgICAgICAgICAgdmVydGljYWxJbnRlcnZhbDogOCxcbiAgICAgICAgICAgIC8qKiDmkq3mlL7pgJ/luqYo5YCN5pWwKSAqL1xuICAgICAgICAgICAgcGxheVNwZWVkOiAxLFxuICAgICAgICAgICAgLyoqIOaXtumXtOWfuuWHhiAqL1xuICAgICAgICAgICAgY2xvY2s6IHRpbWUgPT4gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBfc3RhcnRUaW1lLFxuICAgICAgICAgICAgLyoqIOe8qeaUvuavlOS+iyAqL1xuICAgICAgICAgICAgc2NhbGluZzogMSxcbiAgICAgICAgICAgIC8qKiDotoXml7bkuKLlvIMgKi9cbiAgICAgICAgICAgIHRpbWVPdXREaXNjYXJkOiB0cnVlLFxuICAgICAgICAgICAgLyoqIOimgemakOiXj+eahOW8ueW5leexu+WeiyAqL1xuICAgICAgICAgICAgaGlkZGVuVHlwZXM6IDAsXG4gICAgICAgICAgICAvKiog5by55bmV5LiN6YCP5piO5bqmICovXG4gICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgLyoqIOm8oOagh+e7j+i/h+agt+W8jyAqL1xuICAgICAgICAgICAgY3Vyc29yT25Nb3VzZU92ZXI6ICdwb2ludGVyJyxcbiAgICAgICAgICAgIC8qKiDpu5jorqTlvLnluZXmoLflvI8gKi9cbiAgICAgICAgICAgIGRlZmF1bHRTdHlsZToge1xuICAgICAgICAgICAgICAgIC8qKiDpmLTlvbHnmoTmqKHns4rnuqfliKvvvIww5Li65LiN5pi+56S66Zi05b2xICovXG4gICAgICAgICAgICAgICAgc2hhZG93Qmx1cjogMixcbiAgICAgICAgICAgICAgICAvKiog5a2X5L2T57KX57uGICovXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogJzYwMCcsXG4gICAgICAgICAgICAgICAgLyoqIOWtl+S9k+ezu+WIlyAqL1xuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6ICdzYW5zLXNlcmlmJyxcbiAgICAgICAgICAgICAgICAvKiog5a2X5L2T5aSn5bCP77yI5Y2V5L2N77ya5YOP57Sg77yJICovXG4gICAgICAgICAgICAgICAgc2l6ZTogMjUsXG4gICAgICAgICAgICAgICAgLyoqIOWkluahhuminOiJsiAqL1xuICAgICAgICAgICAgICAgIGJveENvbG9yOiBudWxsLFxuICAgICAgICAgICAgICAgIC8qKiDlrZfkvZPpopzoibIgKi9cbiAgICAgICAgICAgICAgICBjb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICAgICAgICAvKiog5o+P6L656aKc6ImyICovXG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgLyoqIOW8ueW5lemAn+W6pu+8iOWNleS9je+8muWDj+e0oC/mr6vnp5LvvIkg5LuF5rWB5by55bmV57G75Z6L5pyJ5pWIICovXG4gICAgICAgICAgICAgICAgc3BlZWQ6IDAuMTUsXG4gICAgICAgICAgICAgICAgLyoqIOW8ueW5leWBnOeVmeaXtumXtCDku4Xlm7rlrprlvLnluZXnsbvlnovmnInmlYggKi9cbiAgICAgICAgICAgICAgICByZXNpZGVuY2VUaW1lOiA1MDAwXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICog5YWo5bGA6YCJ6aG557G75Z6LXG4gICAgICAgICAqIEBwcml2YXRlIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgX29wdGlvbnNUeXBlID0ge1xuICAgICAgICAgICAgdmVydGljYWxJbnRlcnZhbDogJ251bWJlcicsXG4gICAgICAgICAgICBwbGF5U3BlZWQ6ICdudW1iZXInLFxuICAgICAgICAgICAgY2xvY2s6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICBzY2FsaW5nOiAnbnVtYmVyJyxcbiAgICAgICAgICAgIHRpbWVPdXREaXNjYXJkOiAnYm9vbGVhbicsXG4gICAgICAgICAgICBoaWRkZW5UeXBlczogJ251bWJlcicsXG4gICAgICAgICAgICBvcGFjaXR5OiAnbnVtYmVyJyxcbiAgICAgICAgICAgIGN1cnNvck9uTW91c2VPdmVyOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGRlZmF1bHRTdHlsZToge1xuICAgICAgICAgICAgICAgIHNoYWRvd0JsdXI6ICdudW1iZXInLFxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IFsnc3RyaW5nJywgJ251bWJlciddLFxuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgIHNpemU6ICdudW1iZXInLFxuICAgICAgICAgICAgICAgIGJveENvbG9yOiBbJ3N0cmluZycsICdudWxsJ10sXG4gICAgICAgICAgICAgICAgY29sb3I6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBbJ3N0cmluZycsICdudWxsJ10sXG4gICAgICAgICAgICAgICAgc3BlZWQ6ICdudW1iZXInLFxuICAgICAgICAgICAgICAgIHJlc2lkZW5jZVRpbWU6ICdudW1iZXInXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICog6buY6K6k5by55bmV5pWw5o2uXG4gICAgICAgICAqIEBwcml2YXRlIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgX2RlZmF1bHRCdWxsZXRTY3JlZW4gPSB7XG4gICAgICAgICAgICAvKiog5by55bmV5paH5pysICovXG4gICAgICAgICAgICB0ZXh0OiBudWxsLFxuICAgICAgICAgICAgLyoqIOaYr+WQpuWFgeiuuOS4ouW8gyAqL1xuICAgICAgICAgICAgY2FuRGlzY2FyZDogdHJ1ZSxcbiAgICAgICAgICAgIC8qKiDlvLnluZXov5vlhaXml7bpl7QgKi9cbiAgICAgICAgICAgIHN0YXJ0VGltZTogbnVsbCxcbiAgICAgICAgICAgIC8qKiDlvLnluZXnsbvlnosgKi9cbiAgICAgICAgICAgIHR5cGU6IEJ1bGxldFNjcmVlblR5cGUucmlnaHRUb0xlZnQsXG4gICAgICAgICAgICAvKiog5by55bmV5bGC57qn77yI6LaK5aSn6LaK5YmN77yJICovXG4gICAgICAgICAgICBsYXllcjogMFxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueW5leaVsOaNruexu+Wei1xuICAgICAgICAgKiBAcHJpdmF0ZSBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IF9idWxsZXRTY3JlZW5UeXBlID0ge1xuICAgICAgICAgICAgdGV4dDogJ3N0cmluZycsXG4gICAgICAgICAgICBjYW5EaXNjYXJkOiAnYm9vbGVhbicsXG4gICAgICAgICAgICBzdGFydFRpbWU6ICdudW1iZXInLFxuICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICBsYXllcjogJ251bWJlcidcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUg5a6a5LmJ77yI5LiA5Lqb6ICB5byP5rWP6KeI5Zmo5LiN5pSv5oyBIHJlcXVlc3RBbmltYXRpb25GcmFtZSDvvIlcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuIC0g5Zue6LCD5pa55rOVIFxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIGxldCByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJykgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oUmVzb3VyY2VzLlJFUVVFU1RBTklNQVRJT05GUkFNRV9OT1RfU1VQUE9SVF9XQVJOKTtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IChmdW4pID0+IHdpbmRvdy5zZXRUaW1lb3V0KGZ1biwgMTcpOyAvLzYwZnBzXG4gICAgICAgIH1cblxuICAgICAgICBfb3B0aW9ucyA9IEhlbHBlci5zZXRWYWx1ZXMob3B0aW9ucywgX2RlZmF1bHRPcHRpb25zLCBfb3B0aW9uc1R5cGUpOyAvL+iuvue9rum7mOiupOWAvFxuXG4gICAgICAgIC8v5LqL5Lu25Yid5aeL5YyWXG4gICAgICAgIGxldCBfZXZlbnQgPSBuZXcgRXZlbnQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueW5leWNleWHu+S6i+S7tuOAguW9k+WNleWHu+W8ueW5leaXtuinpuWPkeOAglxuICAgICAgICAgKiBAZXZlbnQgb3BlbkJTRS5CdWxsZXRTY3JlZW5FbmdpbmUjY2xpY2tcbiAgICAgICAgICogQHByb3BlcnR5IHtvcGVuQlNFfkJ1bGxldFNjcmVlbkV2ZW50fSBlIC0g5by55bmV5LqL5Lu257uT5p6EXG4gICAgICAgICAqL1xuICAgICAgICBfZXZlbnQuYWRkKCdjbGljaycpO1xuICAgICAgICAvKipcbiAgICAgICAgICog5by55bmV5LiK5LiL5paH6I+c5Y2V5LqL5Lu244CC5b2T6Kem5Y+R5by55bmV5LiK5LiL5paH6I+c5Y2V5pe26Kem5Y+R44CCXG4gICAgICAgICAqIEBldmVudCBvcGVuQlNFLkJ1bGxldFNjcmVlbkVuZ2luZSNjb250ZXh0bWVudVxuICAgICAgICAgKiBAcHJvcGVydHkge29wZW5CU0V+QnVsbGV0U2NyZWVuRXZlbnR9IGUgLSDlvLnluZXkuovku7bnu5PmnoRcbiAgICAgICAgICovXG4gICAgICAgIF9ldmVudC5hZGQoJ2NvbnRleHRtZW51Jyk7XG4gICAgICAgIC8qKlxuICAgICAgICAqIOW8ueW5lem8oOagh+emu+W8gOS6i+S7tuOAguW9k+m8oOagh+emu+W8gOW8ueW5leaXtuinpuWPkeOAglxuICAgICAgICAqIEBldmVudCBvcGVuQlNFLkJ1bGxldFNjcmVlbkVuZ2luZSNtb3VzZWxlYXZlXG4gICAgICAgICogQHByb3BlcnR5IHtvcGVuQlNFfkJ1bGxldFNjcmVlbkV2ZW50fSBlIC0g5by55bmV5LqL5Lu257uT5p6EXG4gICAgICAgICovXG4gICAgICAgIF9ldmVudC5hZGQoJ21vdXNlbGVhdmUnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8ueW5lem8oOagh+i/m+WFpeS6i+S7tuOAguW9k+m8oOagh+i/m+WFpeW8ueW5leaXtuinpuWPkeOAglxuICAgICAgICAgKiBAZXZlbnQgb3BlbkJTRS5CdWxsZXRTY3JlZW5FbmdpbmUjbW91c2VlbnRlclxuICAgICAgICAgKiBAcHJvcGVydHkge29wZW5CU0V+QnVsbGV0U2NyZWVuRXZlbnR9IGUgLSDlvLnluZXkuovku7bnu5PmnoRcbiAgICAgICAgICovXG4gICAgICAgIF9ldmVudC5hZGQoJ21vdXNlZW50ZXInKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOe7keWumuS6i+S7tuWkhOeQhueoi+W6j1xuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOe7keWumuS6i+S7tuWkhOeQhueoi+W6j+OAguW9k+S6i+S7tuWkhOeQhueoi+W6j+i/lOWbnuWAvOS4uiBmYWxzZSDml7blgZzmraLlhpLms6HjgIJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSDkuovku7blkI3np7BcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuIC0g5LqL5Lu25aSE55CG56iL5bqPXG4gICAgICAgICAqIEBsaXN0ZW5zIG9wZW5CU0UuQnVsbGV0U2NyZWVuRW5naW5lI2NsaWNrXG4gICAgICAgICAqIEBsaXN0ZW5zIG9wZW5CU0UuQnVsbGV0U2NyZWVuRW5naW5lI2NvbnRleHRtZW51XG4gICAgICAgICAqIEBsaXN0ZW5zIG9wZW5CU0UuQnVsbGV0U2NyZWVuRW5naW5lI21vdXNlbGVhdmVcbiAgICAgICAgICogQGxpc3RlbnMgb3BlbkJTRS5CdWxsZXRTY3JlZW5FbmdpbmUjbW91c2VlbnRlclxuICAgICAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IOS8oOWFpeeahOWPguaVsOmUmeivr+aIluS6i+S7tuS4jeWtmOWcqOaXtuW8leWPkemUmeivr+OAguivt+WPgumYhSBNRE4gW1R5cGVFcnJvcl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvVHlwZUVycm9yfSDjgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmluZCA9IF9ldmVudC5iaW5kO1xuICAgICAgICAvKipcbiAgICAgICAgICog6Kej57uR5LqL5Lu25aSE55CG56iL5bqP77yIZnVu5Li656m66Kej57uR5omA5pyJ5LqL5Lu25aSE55CG56iL5bqP77yJXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIOS6i+S7tuWQjeensFxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW4gLSDkuovku7blpITnkIbnqIvluo9cbiAgICAgICAgICogQHRocm93cyB7VHlwZUVycm9yfSDkvKDlhaXnmoTlj4LmlbDplJnor6/miJbkuovku7bkuI3lrZjlnKjml7blvJXlj5HplJnor6/jgILor7flj4LpmIUgTUROIFtUeXBlRXJyb3Jde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1R5cGVFcnJvcn0g44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVuYmluZCA9IF9ldmVudC51bmJpbmQ7XG4gICAgICAgIC8v5Yid5aeL5YyWXG4gICAgICAgIGxldCBfZWxlbWVudFNpemUgPSB7XG4gICAgICAgICAgICB3aWR0aDogZWxlbWVudC5jbGllbnRXaWR0aCAvIF9vcHRpb25zLnNjYWxpbmcsXG4gICAgICAgICAgICBoZWlnaHQ6IGVsZW1lbnQuY2xpZW50SGVpZ2h0IC8gX29wdGlvbnMuc2NhbGluZ1xuICAgICAgICB9XG4gICAgICAgIGxldCBfb2xkRGV2aWNlUGl4ZWxSYXRpbyA9IEhlbHBlci5nZXREZXZpY2VQaXhlbFJhdGlvKCk7XG4gICAgICAgIGxldCBfb2xkU2NhbGluZyA9IF9vcHRpb25zLnNjYWxpbmc7XG4gICAgICAgIGxldCBfb2xkQ2xpZW50V2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoO1xuICAgICAgICBsZXQgX29sZENsaWVudEhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICBsZXQgX29sZEhpZGRlblR5cGVzID0gX29wdGlvbnMuaGlkZGVuVHlwZXM7XG4gICAgICAgIGxldCBfb2xkT3BhY2l0eSA9IF9vcHRpb25zLm9wYWNpdHk7XG4gICAgICAgIC8v5riy5p+T5Zmo5bel5Y6CXG4gICAgICAgIGxldCByZW5kZXJlcnNGYWN0b3J5ID0gbmV3IFJlbmRlcmVyc0ZhY3RvcnkoZWxlbWVudCwgX29wdGlvbnMsIF9lbGVtZW50U2l6ZSwgYnVsbGV0U2NyZWVuRXZlbnRUcmlnZ2VyKTtcbiAgICAgICAgbGV0IF9yZW5kZXJlciA9IHJlbmRlcmVyc0ZhY3RvcnkuZ2V0UmVuZGVyZXIocmVuZGVyTW9kZSk7IC8v5a6e5L6L5YyW5riy5p+T5ZmoXG4gICAgICAgIHNldEludGVydmFsKHNldFNpemUsIDEwMCk7XG5cbiAgICAgICAgLy/lhazlhbHlh73mlbBcblxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u5YWo5bGA6YCJ6aG5XG4gICAgICAgICAqIEBwYXJhbSB7b3BlbkJTRX5PcHRpb25zfSBvcHRpb25zIC0g5YWo5bGA6YCJ6aG577ya5LiA5LiqIHtAbGluayBvcGVuQlNFfk9wdGlvbnN9IOe7k+aehOOAglxuICAgICAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IOS8oOWFpeeahOWPguaVsOmUmeivr+aXtuW8leWPkemUmeivr+OAguivt+WPgumYhSBNRE4gW1R5cGVFcnJvcl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvVHlwZUVycm9yfSDjgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICBfb3B0aW9ucyA9IEhlbHBlci5zZXRWYWx1ZXMob3B0aW9ucywgX29wdGlvbnMsIF9vcHRpb25zVHlwZSwgZmFsc2UpOyAvL+iuvue9rum7mOiupOWAvFxuICAgICAgICAgICAgaWYgKF9vbGRIaWRkZW5UeXBlcyAhPSBfb3B0aW9ucy5oaWRkZW5UeXBlcykge1xuICAgICAgICAgICAgICAgIF9vbGRIaWRkZW5UeXBlcyA9IF9vcHRpb25zLmhpZGRlblR5cGVzO1xuICAgICAgICAgICAgICAgIGlmICghX3BsYXlpbmcpIF9yZW5kZXJlci5kcmF3KCk7IC8v6Z2e5pKt5pS+54q25oCB5YiZ6YeN57uYXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX29sZE9wYWNpdHkgIT0gX29wdGlvbnMub3BhY2l0eSkge1xuICAgICAgICAgICAgICAgIF9vbGRPcGFjaXR5ID0gX29wdGlvbnMub3BhY2l0eTtcbiAgICAgICAgICAgICAgICBfcmVuZGVyZXIuc2V0T3BhY2l0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5blhajlsYDpgInpoblcbiAgICAgICAgICogQHJldHVybnMge29wZW5CU0V+T3B0aW9uc30g5YWo5bGA6YCJ6aG577ya5LiA5LiqIHtAbGluayBvcGVuQlNFfk9wdGlvbnN9IOe7k+aehOOAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRPcHRpb25zID0gKCkgPT4gX29wdGlvbnM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3u+WKoOW8ueW5leWIsOW8ueW5leWIl+ihqOOAglxuICAgICAgICAgKiBAZGVzY3JpcHRpb24g5re75Yqg5by55bmV5Yiw5by55bmV5YiX6KGo44CC55Sx5LqO5by55bmV5Zyo5bGP5bmV5LiK5Ye6546w6L+H5ZCO77yM5by55bmV5byV5pOO5bCG5LuO5YiX6KGo5Lit5b275bqV5Yig6Zmk5q2k5by55bmV44CC5omA5Lul77yM5Zyo5pS55Y+Y5pKt5pS+6L+b5bqm5pe277yM5Y+v6IO96ZyA6KaB5YWIW+a4heepuuW8ueW5leWIl+ihqF17QGxpbmsgb3BlbkJTRS5CdWxsZXRTY3JlZW5FbmdpbmUjY2xlYW5CdWxsZXRTY3JlZW5MaXN0fe+8jOeEtuWQjumHjeaWsOWKoOi9veatpOaSreaUvui/m+W6puS7peWQjueahOW8ueW5leOAglxuICAgICAgICAgKiBAcGFyYW0ge29wZW5CU0V+QnVsbGV0U2NyZWVufSBidWxsZXRTY3JlZW4gLSDljZXmnaHlvLnluZXmlbDmja7vvJrkuIDkuKoge0BsaW5rIG9wZW5CU0V+QnVsbGV0U2NyZWVufSDnu5PmnoTjgIJcbiAgICAgICAgICogQHRocm93cyB7VHlwZUVycm9yfSDkvKDlhaXnmoTlj4LmlbDplJnor6/ml7blvJXlj5HplJnor6/jgILor7flj4LpmIUgTUROIFtUeXBlRXJyb3Jde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1R5cGVFcnJvcn0g44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFkZEJ1bGxldFNjcmVlbiA9IGZ1bmN0aW9uIChidWxsZXRTY3JlZW4pIHtcbiAgICAgICAgICAgIF9kZWZhdWx0QnVsbGV0U2NyZWVuLnN0YXJ0VGltZSA9IF9vcHRpb25zLmNsb2NrKCk7XG4gICAgICAgICAgICBidWxsZXRTY3JlZW4gPSBIZWxwZXIuc2V0VmFsdWVzKGJ1bGxldFNjcmVlbiwgX2RlZmF1bHRCdWxsZXRTY3JlZW4sIF9idWxsZXRTY3JlZW5UeXBlKTsgLy/orr7nva7pu5jorqTlgLxcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGJ1bGxldFNjcmVlbi50eXBlICE9IEJ1bGxldFNjcmVlblR5cGUubGVmdFRvUmlnaHQgJiZcbiAgICAgICAgICAgICAgICBidWxsZXRTY3JlZW4udHlwZSAhPSBCdWxsZXRTY3JlZW5UeXBlLnJpZ2h0VG9MZWZ0ICYmXG4gICAgICAgICAgICAgICAgYnVsbGV0U2NyZWVuLnR5cGUgIT0gQnVsbGV0U2NyZWVuVHlwZS50b3AgJiZcbiAgICAgICAgICAgICAgICBidWxsZXRTY3JlZW4udHlwZSAhPSBCdWxsZXRTY3JlZW5UeXBlLmJvdHRvbVxuICAgICAgICAgICAgKSB0aHJvdyBuZXcgVHlwZUVycm9yKFJlc291cmNlcy5QQVJBTUVURVJTX1RZUEVfRVJST1IpO1xuXG4gICAgICAgICAgICBIZWxwZXIuY2hlY2tUeXBlcyhidWxsZXRTY3JlZW4uc3R5bGUsIF9vcHRpb25zVHlwZS5kZWZhdWx0U3R5bGUpOyAvL+ajgOafpeW8ueW5leagt+W8j+exu+Wei1xuXG4gICAgICAgICAgICBsZXQgb2xkTGVuZ3RoID0gX2J1bGxldFNjcmVlbnMuZ2V0TGVuZ3RoKCk7XG4gICAgICAgICAgICBfYnVsbGV0U2NyZWVucy5mb3JFYWNoKGZ1bmN0aW9uIChsYXN0QnVsbGV0U2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJ1bGxldFNjcmVlbi5zdGFydFRpbWUgPiBsYXN0QnVsbGV0U2NyZWVuLnN0YXJ0VGltZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZDogeyBhZGRUb1VwOiB0cnVlLCBlbGVtZW50OiBidWxsZXRTY3JlZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3A6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgaWYgKG9sZExlbmd0aCA9PT0gX2J1bGxldFNjcmVlbnMuZ2V0TGVuZ3RoKCkpXG4gICAgICAgICAgICAgICAgX2J1bGxldFNjcmVlbnMucHVzaChidWxsZXRTY3JlZW4sIGZhbHNlKTtcblxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvIDlp4vmkq3mlL7lvLnluZXjgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghX3BsYXlpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV9zdGFydFRpbWUpXG4gICAgICAgICAgICAgICAgICAgIF9zdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICBpZiAoX3BhdXNlVGltZSlcbiAgICAgICAgICAgICAgICAgICAgX3N0YXJ0VGltZSArPSBfb3B0aW9ucy5jbG9jaygpIC0gX3BhdXNlVGltZTtcbiAgICAgICAgICAgICAgICBfbGFzdFJlZnJlc2hUaW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfcGxheWluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlZnJlc2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnu6fnu63miYDmnInlnKjkuovku7blk43lupTkuK3orr7nva7kuoYgZS5wYXVzZSA9IHRydWU7IOW8ueW5leeahOaSreaUvuOAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wbGF5QWxsQnVsbGV0U2NyZWVucyA9ICgpID0+XG4gICAgICAgICAgICBfYnVsbGV0U2NyZWVuc09uU2NyZWVuLmZvckVhY2goKGJ1bGxldFNjcmVlbk9uU2NyZWVuKSA9PiBidWxsZXRTY3JlZW5PblNjcmVlbi5wYXVzZSA9IGZhbHNlKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICog5pqC5YGc5pKt5pS+5by55bmV44CCXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiDmmoLlgZzmkq3mlL7lvLnluZXjgILmmoLlgZzmkq3mlL7lvLnluZXmmK/mjIflvLnluZXmkq3mlL7mmoLlgZzvvIzmiYDmnInmnKrlh7rnjrDnmoTlvLnluZXlsIblgZzmraLlh7rnjrDvvIzlt7Llh7rnjrDnmoTlvLnluZXlgZzmraLov5DliqjvvIzlgZzmraLmtojlpLHjgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3BsYXlpbmcpIHtcbiAgICAgICAgICAgICAgICBfcGF1c2VUaW1lID0gX29wdGlvbnMuY2xvY2soKTtcbiAgICAgICAgICAgICAgICBfcGxheWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmuIXnqbrlvLnluZXliJfooajjgIJcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOa4heepuuW8ueW5leWIl+ihqO+8jOS9huWxj+W5leS4iuW3sue7j+WHuueOsOeahOW8ueW5leS4jeS8muiiq+a4hemZpOOAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGVhbkJ1bGxldFNjcmVlbkxpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfYnVsbGV0U2NyZWVucy5jbGVhbigpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmuIXnqbrlsY/luZXlhoXlrrnjgIJcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOa4heepuuWxj+W5leWGheWuueOAgua4heepuuWxj+W5leS4iuW3sue7j+WHuueOsOeahOW8ueW5le+8jOS4jeWMheaLrOW8ueW5leWIl+ihqOS4reeahOW8ueW5leOAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGVhblNjcmVlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF9idWxsZXRTY3JlZW5zT25TY3JlZW4uY2xlYW4oKTtcbiAgICAgICAgICAgIF9yZW5kZXJlci5jbGVhblNjcmVlbigpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlgZzmraLmkq3mlL7lvLnluZXjgIJcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOWBnOatouaSreaUvuW8ueW5leOAguWBnOatouaSreaUvuW8ueW5leaYr+aMh+WBnOatouaSreaUvuW8ueW5le+8jOm7mOiupFvml7bpl7Tln7rlh4bvvIhvcHRpb25zLmNsb2Nr77yJXXtAbGluayBvcGVuQlNFfkJ1bGxldFNjcmVlblN0eWxlfeW9kumbtu+8jOW5tlvmuIXnqbrlvLnluZXliJfooahde0BsaW5rIG9wZW5CU0UuQnVsbGV0U2NyZWVuRW5naW5lI2NsZWFuQnVsbGV0U2NyZWVuTGlzdH3jgIFb5riF56m65bGP5bmV5YaF5a65XXtAbGluayBvcGVuQlNFLkJ1bGxldFNjcmVlbkVuZ2luZSNjbGVhblNjcmVlbn3jgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfcGxheWluZykge1xuICAgICAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2xlYW5CdWxsZXRTY3JlZW5MaXN0KCk7XG4gICAgICAgICAgICB0aGlzLmNsZWFuU2NyZWVuKCk7XG4gICAgICAgICAgICBfcGF1c2VUaW1lID0gMDtcbiAgICAgICAgICAgIF9zdGFydFRpbWUgPSBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpmpDol4/lvLnluZXjgIJcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhpZGUgPSBfcmVuZGVyZXIuaGlkZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICog5pi+56S65by55bmV44CCXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaG93ID0gX3JlbmRlcmVyLnNob3c7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPluW8ueW5leWPr+ingeaAp+OAglxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IC0g5oyH56S65by55bmV5piv5ZCm5Y+v6KeB44CCXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiDojrflj5blvLnluZXlj6/op4HmgKfjgILlpoLopoHmmL7npLrlvLnluZXor7fosIPnlKggW2J1bGxldFNjcmVlbkVuZ2luZS5zaG93KCk7XXtAbGluayBvcGVuQlNFLkJ1bGxldFNjcmVlbkVuZ2luZSNzaG93fSDvvIzopoHpmpDol4/lvLnluZXor7fosIPnlKggW2J1bGxldFNjcmVlbkVuZ2luZS5oaWRlKCk7XXtAbGluayBvcGVuQlNFLkJ1bGxldFNjcmVlbkVuZ2luZSNoaWRlfSDjgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0VmlzaWJpbGl0eSA9IF9yZW5kZXJlci5nZXRWaXNpYmlsaXR5O1xuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W5riy5p+T5qih5byP44CCXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0g5by55bmV5riy5p+T5qih5byP77yaIOWPluWAvOS4uuKAnGNhbnZhc+KAneOAgeKAnGNzczPigJ3jgIHigJx3ZWJnbOKAneaIluKAnHN2Z+KAneOAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRSZW5kZXJNb2RlID0gKCkgPT4gcmVuZGVyTW9kZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W5pKt5pS+54q25oCB44CCXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIOato+WcqOaSreaUvuagh+W/l++8mnRydWXvvJrmraPlnKjmkq3mlL7vvJtmYWxzZe+8muW3suaaguWBnC/lgZzmraLmkq3mlL7jgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0UGxheVN0YXRlID0gKCkgPT4gX3BsYXlpbmc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICog6I635Y+W6LCD6K+V5L+h5oGv44CCXG4gICAgICAgICogQHJldHVybnMge29wZW5CU0V+RGVidWdJbmZvfSAtIOiwg+ivleS/oeaBr++8muS4gOS4qiB7QGxpbmsgb3BlbkJTRX5EZWJ1Z0luZm99IOe7k+aehOOAglxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldERlYnVnSW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGltZTogX3BsYXlpbmcgPyBfb3B0aW9ucy5jbG9jaygpIDogX3BhdXNlVGltZSxcbiAgICAgICAgICAgICAgICBidWxsZXRTY3JlZW5zT25TY3JlZW5Db3VudDogX2J1bGxldFNjcmVlbnNPblNjcmVlbi5nZXRMZW5ndGgoKSxcbiAgICAgICAgICAgICAgICBidWxsZXRTY3JlZW5zQ291bnQ6IF9idWxsZXRTY3JlZW5zLmdldExlbmd0aCgpLFxuICAgICAgICAgICAgICAgIGRlbGF5OiBfZGVsYXksXG4gICAgICAgICAgICAgICAgZGVsYXlCdWxsZXRTY3JlZW5zQ291bnQ6IF9kZWxheUJ1bGxldFNjcmVlbnNDb3VudCxcbiAgICAgICAgICAgICAgICBmcHM6IF9wbGF5aW5nID8gTWF0aC5mbG9vcihfcmVmcmVzaFJhdGUgKiAxMDAwKSA6IDAgLy/luKfpopFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgLy/lhoXpg6jlh73mlbBcblxuICAgICAgICAvKipcbiAgICAgICAgICog5by55bmV5LqL5Lu25ZON5bqUXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0g5LqL5Lu25ZCN56ewXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBidWxsZXRTY3JlZW5PblNjcmVlbiAtIOWxj+W5leW8ueW5leWvueixoVxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZSAtIOS6i+S7tuS/oeaBr1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gYnVsbGV0U2NyZWVuRXZlbnRUcmlnZ2VyKG5hbWUsIGJ1bGxldFNjcmVlbk9uU2NyZWVuLCBlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGUucGFnZVggPT09ICd1bmRlZmluZWQnIHx8IGUucGFnZVggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgZG9jID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgICAgICBlLnBhZ2VYID0gZS5jbGllbnRYICsgKGRvYyAmJiBkb2Muc2Nyb2xsTGVmdCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsTGVmdCB8fCAwKSAtIChkb2MgJiYgZG9jLmNsaWVudExlZnQgfHwgYm9keSAmJiBib2R5LmNsaWVudExlZnQgfHwgMCk7XG4gICAgICAgICAgICAgICAgZS5wYWdlWSA9IGUuY2xpZW50WSArIChkb2MgJiYgZG9jLnNjcm9sbFRvcCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsVG9wIHx8IDApIC0gKGRvYyAmJiBkb2MuY2xpZW50VG9wIHx8IGJvZHkgJiYgYm9keS5jbGllbnRUb3AgfHwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfZXZlbnQudHJpZ2dlcihuYW1lLCB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICog6I635Y+W5byV5Y+R5LqL5Lu255qE5by55bmV5by55bmV55qE5pWw5o2uXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7b3BlbkJTRX5CdWxsZXRTY3JlZW59IOW8leWPkeS6i+S7tueahOW8ueW5leeahOaVsOaNru+8muS4gOS4qiB7QGxpbmsgb3BlbkJTRX5CdWxsZXRTY3JlZW59IOe7k+aehOOAgu+8iOazqOaEj++8muS4jeimgeivleWbvuS4jlvmt7vliqDlvLnluZVde0BsaW5rIG9wZW5CU0UuQnVsbGV0U2NyZWVuRW5naW5lI2FkZEJ1bGxldFNjcmVlbn3ml7bliJvlu7rnmoTlr7nosaHov5vooYzmr5TovoPvvIzov5nkuKrlr7nosaHmmK/lhYvpmoblvpfliLDnmoTvvIzlubbkuI3nm7jnrYnjgILmraPnoa7nmoTmlrnms5XmmK/lnKjmt7vliqDlvLnluZXml7bkuIDlubbmj5LlhaUgaWQg562J6Ieq5a6a5LmJ5a2X5q615p2l5ZSv5LiA5qCH6K+G5LiA5p2h5by55bmV44CC77yJXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZ2V0QnVsbGV0U2NyZWVuOiAoKSA9PiBIZWxwZXIuY2xvbmUoYnVsbGV0U2NyZWVuT25TY3JlZW4uYnVsbGV0U2NyZWVuKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiDorr7nva7lvJXlj5Hkuovku7bnmoTlvLnluZXlvLnluZXnmoTmlbDmja5cbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7b3BlbkJTRX5CdWxsZXRTY3JlZW59IGJ1bGxldFNjcmVlbiAtIOW8leWPkeS6i+S7tueahOW8ueW5leeahOaVsOaNru+8muS4gOS4qiB7QGxpbmsgb3BlbkJTRX5CdWxsZXRTY3JlZW59IOe7k+aehOOAguiuvue9ruatpOWPguaVsOS7peS+v+WKqOaAgeiwg+aVtOW8ueW5leagt+W8j++8jOS9huaYr+S4gOS6m+WPguaVsOWcqOS6i+S7tuS4reS/ruaUueaXoOaViO+8jOafpeeci+atpOe7k+aehOeahOivtOaYjuS7peS6huino+ivpuaDheOAglxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlZHJhdz1mYWxzZV0gLSDmmK/lkKbph43nu5jlvLnluZXvvJrmraTlj4LmlbDlnKjmr4/mrKHlvJXlj5Hkuovku7bml7bnmoTliJ3lp4vlgLzkuLogZmFsc2Ug77yM5aaC5p6c5L+u5pS55LqGIGJ1bGxldFNjcmVlbiDkuK3nmoTlgLzvvIzmraTlj4LmlbDlv4Xpobvorr7kuLogdHJ1ZSDjgIJcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzZXRCdWxsZXRTY3JlZW46IChidWxsZXRTY3JlZW4sIHJlZHJhdyA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVkcmF3ICE9ICdib29sZWFuJykgdGhyb3cgbmV3IFR5cGVFcnJvcihSZXNvdXJjZXMuUEFSQU1FVEVSU19UWVBFX0VSUk9SKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJ1bGxldFNjcmVlblR5cGUgPSBIZWxwZXIuY2xvbmUoX2J1bGxldFNjcmVlblR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBidWxsZXRTY3JlZW5UeXBlLnN0eWxlID0gX29wdGlvbnNUeXBlLmRlZmF1bHRTdHlsZTtcbiAgICAgICAgICAgICAgICAgICAgYnVsbGV0U2NyZWVuT25TY3JlZW4uYnVsbGV0U2NyZWVuID0gSGVscGVyLnNldFZhbHVlcyhidWxsZXRTY3JlZW4sIGJ1bGxldFNjcmVlbk9uU2NyZWVuLmJ1bGxldFNjcmVlbiwgYnVsbGV0U2NyZWVuVHlwZSk7IC8v6K6+572u5YC8XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWRyYXcgPT09IHRydWUpIF9yZW5kZXJlci5yZUNyZWF0QW5kZ2V0V2lkdGgoYnVsbGV0U2NyZWVuT25TY3JlZW4pOyAvL+mHjeaWsOWIm+W7uuW5tue7mOWItuW8ueW5lVxuICAgICAgICAgICAgICAgICAgICBpZiAoIV9wbGF5aW5nICYmIHJlZHJhdykgX3JlbmRlcmVyLmRyYXcoKTsgLy/pnZ7mkq3mlL7nirbmgIHliJnph43nu5hcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIOiOt+WPluW8leWPkeS6i+S7tueahOW8ueW5leeahOaSreaUvueKtuaAgVxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IOWPluW8leWPkeS6i+S7tueahOW8ueW5leaYr+WQpuWcqOaSreaUvi/np7vliqjvvJrlpoLmnpzorr7nva7kuLogdHJ1ZSDliJnor6XlvLnluZXmmoLlgZzvvIznm7TliLDlsIbmraTlj4LmlbDorr7kuLogZmFsc2Ug5oiW6LCD55SoIHtAbGluayBvcGVuQlNFLkJ1bGxldFNjcmVlbkVuZ2luZSNwbGF5QWxsQnVsbGV0U2NyZWVuc30g5pa55rOV44CCXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZ2V0UGxheVN0YXRlOiAoKSA9PiAhYnVsbGV0U2NyZWVuT25TY3JlZW4ucGF1c2UsXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICog6K6+572u5byV5Y+R5LqL5Lu255qE5by55bmV55qE5pKt5pS+54q25oCBXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhbHkgLSDmmK/lkKbnu6fnu63mkq3mlL4v56e75Yqo5byV5Y+R5LqL5Lu255qE5by55bmV77ya6K+75Y+W5q2k5Y+C5pWw5Y+v5Yik5pat6L+Z5p2h5by55bmV5piv5ZCm5aSE5LqO5pqC5YGc54q25oCB44CCXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgc2V0UGxheVN0YXRlOiAocGxheSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBsYXkgIT0gJ2Jvb2xlYW4nKSB0aHJvdyBuZXcgVHlwZUVycm9yKFJlc291cmNlcy5QQVJBTUVURVJTX1RZUEVfRVJST1IpO1xuICAgICAgICAgICAgICAgICAgICBidWxsZXRTY3JlZW5PblNjcmVlbi5wYXVzZSA9ICFwbGF5O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2NyZWVuWDogZS5zY3JlZW5YLCBzY3JlZW5ZOiBlLnNjcmVlblksXG4gICAgICAgICAgICAgICAgcGFnZVg6IGUucGFnZVgsIHBhZ2VZOiBlLnBhZ2VZLFxuICAgICAgICAgICAgICAgIGNsaWVudFg6IGUuY2xpZW50WCwgY2xpZW50WTogZS5jbGllbnRZXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliLfmlrDlvLnluZXlh73mlbBcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgICAgICAgICBsZXQgbm93VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgaWYgKF9sYXN0UmVmcmVzaFRpbWUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBfcmVmcmVzaFJhdGUgPSAxIC8gKG5vd1RpbWUgLSBfbGFzdFJlZnJlc2hUaW1lKTtcbiAgICAgICAgICAgIF9sYXN0UmVmcmVzaFRpbWUgPSBub3dUaW1lO1xuICAgICAgICAgICAgYWRkQnVsbGV0U2NyZWVuc1RvU2NyZWVuKCk7XG4gICAgICAgICAgICBtb3ZlQnVsbGV0U2NyZWVuT25TY3JlZW4oKTtcbiAgICAgICAgICAgIF9yZW5kZXJlci5kcmF3KCk7IC8v57uY5Yi25by55bmVXG4gICAgICAgICAgICBpZiAoX3BsYXlpbmcpXG4gICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlZnJlc2gpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOenu+WKqOW8ueW5leWHveaVsFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gbW92ZUJ1bGxldFNjcmVlbk9uU2NyZWVuKCkge1xuICAgICAgICAgICAgX2J1bGxldFNjcmVlbnNPblNjcmVlbi5mb3JFYWNoKChidWxsZXRTY3JlZW5PblNjcmVlbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChidWxsZXRTY3JlZW5PblNjcmVlbi5wYXVzZSkgcmV0dXJuOyAvL+aaguWBnOenu+WKqFxuICAgICAgICAgICAgICAgIGxldCBub3dUaW1lID0gX29wdGlvbnMuY2xvY2soKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGJ1bGxldFNjcmVlbk9uU2NyZWVuLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBCdWxsZXRTY3JlZW5UeXBlLnJpZ2h0VG9MZWZ0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1bGxldFNjcmVlbk9uU2NyZWVuLnggPiAtYnVsbGV0U2NyZWVuT25TY3JlZW4ud2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWxsZXRTY3JlZW5PblNjcmVlbi54IC09IGJ1bGxldFNjcmVlbk9uU2NyZWVuLmJ1bGxldFNjcmVlbi5zdHlsZS5zcGVlZCAqIF9vcHRpb25zLnBsYXlTcGVlZCAvIF9yZWZyZXNoUmF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZW5kZXJlci5kZWxldGUoYnVsbGV0U2NyZWVuT25TY3JlZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHJlbW92ZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQnVsbGV0U2NyZWVuVHlwZS5sZWZ0VG9SaWdodDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidWxsZXRTY3JlZW5PblNjcmVlbi54IDwgX2VsZW1lbnRTaXplLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVsbGV0U2NyZWVuT25TY3JlZW4ueCArPSBidWxsZXRTY3JlZW5PblNjcmVlbi5idWxsZXRTY3JlZW4uc3R5bGUuc3BlZWQgKiBfb3B0aW9ucy5wbGF5U3BlZWQgLyBfcmVmcmVzaFJhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVuZGVyZXIuZGVsZXRlKGJ1bGxldFNjcmVlbk9uU2NyZWVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyByZW1vdmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEJ1bGxldFNjcmVlblR5cGUudG9wOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIEJ1bGxldFNjcmVlblR5cGUuYm90dG9tOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1bGxldFNjcmVlbk9uU2NyZWVuLmVuZFRpbWUgPCBub3dUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlbmRlcmVyLmRlbGV0ZShidWxsZXRTY3JlZW5PblNjcmVlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcmVtb3ZlOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqDlvLnluZXliLDlsY/luZXlh73mlbBcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGFkZEJ1bGxldFNjcmVlbnNUb1NjcmVlbigpIHtcbiAgICAgICAgICAgIGlmIChfYnVsbGV0U2NyZWVuc09uU2NyZWVuLmdldExlbmd0aCgpID09PSAwKVxuICAgICAgICAgICAgICAgIF9kZWxheSA9IDA7XG4gICAgICAgICAgICBsZXQgdGltZXMgPSBNYXRoLmZsb29yKF9yZWZyZXNoUmF0ZSAqIDIwMDApO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGxldCBidWxsZXRTY3JlZW4gPSBfYnVsbGV0U2NyZWVucy5wb3AoZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAoYnVsbGV0U2NyZWVuID09PSBudWxsKSByZXR1cm47XG4gICAgICAgICAgICAgICAgbGV0IG5vd1RpbWUgPSBfb3B0aW9ucy5jbG9jaygpO1xuICAgICAgICAgICAgICAgIGlmIChidWxsZXRTY3JlZW4uc3RhcnRUaW1lID4gbm93VGltZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICghX29wdGlvbnMudGltZU91dERpc2NhcmQgfHwgIWJ1bGxldFNjcmVlbi5jYW5EaXNjYXJkIHx8IGJ1bGxldFNjcmVlbi5zdGFydFRpbWUgPiBub3dUaW1lIC0gTWF0aC5mbG9vcigxIC8gX3JlZnJlc2hSYXRlKSAqIDYwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1bGxldFNjcmVlbi5zdHlsZSA9IEhlbHBlci5zZXRWYWx1ZXMoYnVsbGV0U2NyZWVuLnN0eWxlLCBfb3B0aW9ucy5kZWZhdWx0U3R5bGUsIF9vcHRpb25zVHlwZS5kZWZhdWx0U3R5bGUpOyAvL+Whq+WFhem7mOiupOagt+W8j1xuICAgICAgICAgICAgICAgICAgICBnZXRCdWxsZXRTY3JlZW5PblNjcmVlbihub3dUaW1lLCBidWxsZXRTY3JlZW4pOyAvL+eUn+aIkOWxj+W5leW8ueW5leWvueixoeW5tua3u+WKoOWIsOWxj+W5leW8ueW5lembhuWQiCAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIF9kZWxheUJ1bGxldFNjcmVlbnNDb3VudCsrO1xuICAgICAgICAgICAgICAgIF9idWxsZXRTY3JlZW5zLnBvcCh0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGltZXMtLTtcbiAgICAgICAgICAgIH0gd2hpbGUgKF9idWxsZXRTY3JlZW5zT25TY3JlZW4uZ2V0TGVuZ3RoKCkgPT09IDAgfHwgdGltZXMgPiAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnlJ/miJDlsY/luZXlvLnluZXlr7nosaHlh73mlbBcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG5vd1RpbWUgLSDlvZPliY3ml7bpl7RcbiAgICAgICAgICogQHBhcmFtIHtvcGVuQlNFfkJ1bGxldFNjcmVlbn0gYnVsbGV0U2NyZWVuIC0g5by55bmVXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBnZXRCdWxsZXRTY3JlZW5PblNjcmVlbihub3dUaW1lLCBidWxsZXRTY3JlZW4pIHtcbiAgICAgICAgICAgIF9kZWxheSA9IG5vd1RpbWUgLSBidWxsZXRTY3JlZW4uc3RhcnRUaW1lO1xuICAgICAgICAgICAgbGV0IGJ1bGxldFNjcmVlbk9uU2NyZWVuID0ge307XG4gICAgICAgICAgICBidWxsZXRTY3JlZW5PblNjcmVlbi5wYXVzZSA9IGZhbHNlOyAvL+aYr+WQpuaaguWBnOenu+WKqFxuICAgICAgICAgICAgYnVsbGV0U2NyZWVuT25TY3JlZW4uYnVsbGV0U2NyZWVuID0gYnVsbGV0U2NyZWVuO1xuICAgICAgICAgICAgYnVsbGV0U2NyZWVuT25TY3JlZW4uc3RhcnRUaW1lID0gbm93VGltZTsgLy/lvLnluZXlpLTpg6jov5vlsY/luZXml7bpl7RcbiAgICAgICAgICAgIGJ1bGxldFNjcmVlbk9uU2NyZWVuLnNpemUgPSBidWxsZXRTY3JlZW4uc3R5bGUuc2l6ZTsgLy/lrZfkvZPlpKflsI/vvJrlg4/ntKBcbiAgICAgICAgICAgIGJ1bGxldFNjcmVlbk9uU2NyZWVuLnR5cGUgPSBidWxsZXRTY3JlZW4udHlwZTsgLy/lvLnluZXnsbvlnotcbiAgICAgICAgICAgIGJ1bGxldFNjcmVlbk9uU2NyZWVuLmhlaWdodCA9IGJ1bGxldFNjcmVlbk9uU2NyZWVuLnNpemU7IC8v5by55bmV55qE6auY5bqm77ya5YOP57SgXG4gICAgICAgICAgICBfcmVuZGVyZXIuY3JlYXRBbmRnZXRXaWR0aChidWxsZXRTY3JlZW5PblNjcmVlbik7IC8v5Yib5bu65by55bmV5YWD57Sg5bm26K6h566X5a695bqmXG4gICAgICAgICAgICBzd2l0Y2ggKGJ1bGxldFNjcmVlbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBCdWxsZXRTY3JlZW5UeXBlLnJpZ2h0VG9MZWZ0OlxuICAgICAgICAgICAgICAgICAgICBidWxsZXRTY3JlZW5PblNjcmVlbi5lbmRUaW1lID0gTWF0aC5yb3VuZChub3dUaW1lICsgKF9lbGVtZW50U2l6ZS53aWR0aCArIGJ1bGxldFNjcmVlbk9uU2NyZWVuLndpZHRoKSAvIChidWxsZXRTY3JlZW4uc3R5bGUuc3BlZWQgKiBfb3B0aW9ucy5wbGF5U3BlZWQpKTsgLy/lvLnluZXlsL7pg6jlh7rlsY/luZXnmoTml7bpl7RcbiAgICAgICAgICAgICAgICAgICAgYnVsbGV0U2NyZWVuT25TY3JlZW4ueCA9IF9lbGVtZW50U2l6ZS53aWR0aDsgLy/lvLnluZXliJ3lp4tY5Z2Q5qCHXG4gICAgICAgICAgICAgICAgICAgIGJ1bGxldFNjcmVlbk9uU2NyZWVuLnkgPSBfb3B0aW9ucy52ZXJ0aWNhbEludGVydmFsOyAvL+W8ueW5leWIneWni1nlnZDmoIdcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBCdWxsZXRTY3JlZW5UeXBlLmxlZnRUb1JpZ2h0OlxuICAgICAgICAgICAgICAgICAgICBidWxsZXRTY3JlZW5PblNjcmVlbi5lbmRUaW1lID0gTWF0aC5yb3VuZChub3dUaW1lICsgKF9lbGVtZW50U2l6ZS53aWR0aCArIGJ1bGxldFNjcmVlbk9uU2NyZWVuLndpZHRoKSAvIChidWxsZXRTY3JlZW4uc3R5bGUuc3BlZWQgKiBfb3B0aW9ucy5wbGF5U3BlZWQpKTsgLy/lvLnluZXlsL7pg6jlh7rlsY/luZXnmoTml7bpl7RcbiAgICAgICAgICAgICAgICAgICAgYnVsbGV0U2NyZWVuT25TY3JlZW4ueCA9IC1idWxsZXRTY3JlZW5PblNjcmVlbi53aWR0aDsgLy/lvLnluZXliJ3lp4tY5Z2Q5qCHXG4gICAgICAgICAgICAgICAgICAgIGJ1bGxldFNjcmVlbk9uU2NyZWVuLnkgPSBfb3B0aW9ucy52ZXJ0aWNhbEludGVydmFsOyAvL+W8ueW5leWIneWni1nlnZDmoIdcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBCdWxsZXRTY3JlZW5UeXBlLnRvcDpcbiAgICAgICAgICAgICAgICAgICAgYnVsbGV0U2NyZWVuT25TY3JlZW4uZW5kVGltZSA9IGJ1bGxldFNjcmVlbk9uU2NyZWVuLnN0YXJ0VGltZSArIGJ1bGxldFNjcmVlbi5zdHlsZS5yZXNpZGVuY2VUaW1lICogX29wdGlvbnMucGxheVNwZWVkO1xuICAgICAgICAgICAgICAgICAgICBidWxsZXRTY3JlZW5PblNjcmVlbi54ID0gTWF0aC5yb3VuZCgoX2VsZW1lbnRTaXplLndpZHRoIC0gYnVsbGV0U2NyZWVuT25TY3JlZW4ud2lkdGgpIC8gMik7IC8v5by55bmV5Yid5aeLWOWdkOagh1xuICAgICAgICAgICAgICAgICAgICBidWxsZXRTY3JlZW5PblNjcmVlbi55ID0gX29wdGlvbnMudmVydGljYWxJbnRlcnZhbDsgLy/lvLnluZXliJ3lp4tZ5Z2Q5qCHXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQnVsbGV0U2NyZWVuVHlwZS5ib3R0b206XG4gICAgICAgICAgICAgICAgICAgIGJ1bGxldFNjcmVlbk9uU2NyZWVuLmVuZFRpbWUgPSBidWxsZXRTY3JlZW5PblNjcmVlbi5zdGFydFRpbWUgKyBidWxsZXRTY3JlZW4uc3R5bGUucmVzaWRlbmNlVGltZSAqIF9vcHRpb25zLnBsYXlTcGVlZDtcbiAgICAgICAgICAgICAgICAgICAgYnVsbGV0U2NyZWVuT25TY3JlZW4ueCA9IE1hdGgucm91bmQoKF9lbGVtZW50U2l6ZS53aWR0aCAtIGJ1bGxldFNjcmVlbk9uU2NyZWVuLndpZHRoKSAvIDIpOyAvL+W8ueW5leWIneWni1jlnZDmoIdcbiAgICAgICAgICAgICAgICAgICAgYnVsbGV0U2NyZWVuT25TY3JlZW4ueSA9IC1fb3B0aW9ucy52ZXJ0aWNhbEludGVydmFsIC0gYnVsbGV0U2NyZWVuT25TY3JlZW4uaGVpZ2h0OyAvL+W8ueW5leWIneWni1nlnZDmoIdcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgb2xkTGVuZ3RoID0gX2J1bGxldFNjcmVlbnNPblNjcmVlbi5nZXRMZW5ndGgoKTtcbiAgICAgICAgICAgIGlmIChidWxsZXRTY3JlZW4udHlwZSA9PT0gQnVsbGV0U2NyZWVuVHlwZS50b3AgfHwgYnVsbGV0U2NyZWVuLnR5cGUgPT09IEJ1bGxldFNjcmVlblR5cGUuYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgX2J1bGxldFNjcmVlbnNPblNjcmVlbi5mb3JFYWNoKChuZXh0QnVsbGV0U2NyZWVuT25TY3JlZW4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy/lvLnluZXkuI3lnKjmtYHkuK3vvIzmmK/lm7rlrprlvLnluZVcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRCdWxsZXRTY3JlZW5PblNjcmVlbi5idWxsZXRTY3JlZW4udHlwZSAhPSBidWxsZXRTY3JlZW4udHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy/kuI3mmK/lkIzkuIDnp43nsbvlnovnmoTlvLnluZVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1bGxldFNjcmVlbi50eXBlID09PSBCdWxsZXRTY3JlZW5UeXBlLnRvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy/lpoLmnpzmlrDlvLnluZXlnKjlvZPliY3lvLnluZXkuIrmlrnkuJTmnKrkuI7lvZPliY3lvLnluZXph43lj6BcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidWxsZXRTY3JlZW5PblNjcmVlbi55ICsgYnVsbGV0U2NyZWVuT25TY3JlZW4uaGVpZ2h0IDwgbmV4dEJ1bGxldFNjcmVlbk9uU2NyZWVuLnkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgYWRkOiB7IGFkZFRvVXA6IHRydWUsIGVsZW1lbnQ6IHNldEFjdHVhbFkoYnVsbGV0U2NyZWVuT25TY3JlZW4pIH0sIHN0b3A6IHRydWUgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8v5aaC5p6c5LiK5LiA5p2h5by55bmV55qE5raI5aSx5pe26Ze05bCP5LqO5b2T5YmN5by55bmV55qE5Ye6546w5pe26Ze0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dEJ1bGxldFNjcmVlbk9uU2NyZWVuLmVuZFRpbWUgPCBub3dUaW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1bGxldFNjcmVlbk9uU2NyZWVuLnkgPSBuZXh0QnVsbGV0U2NyZWVuT25TY3JlZW4ueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWxsZXRTY3JlZW5PblNjcmVlbi55ID0gbmV4dEJ1bGxldFNjcmVlbk9uU2NyZWVuLnkgKyBuZXh0QnVsbGV0U2NyZWVuT25TY3JlZW4uaGVpZ2h0ICsgX29wdGlvbnMudmVydGljYWxJbnRlcnZhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8v5aaC5p6c5paw5by55bmV5Zyo5b2T5YmN5by55bmV5LiL5pa55LiU5pyq5LiO5b2T5YmN5by55bmV6YeN5Y+gXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnVsbGV0U2NyZWVuT25TY3JlZW4ueSA+IG5leHRCdWxsZXRTY3JlZW5PblNjcmVlbi55ICsgbmV4dEJ1bGxldFNjcmVlbk9uU2NyZWVuLmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGFkZDogeyBhZGRUb1VwOiB0cnVlLCBlbGVtZW50OiBzZXRBY3R1YWxZKGJ1bGxldFNjcmVlbk9uU2NyZWVuKSB9LCBzdG9wOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvL+WmguaenOS4iuS4gOadoeW8ueW5leeahOa2iOWkseaXtumXtOWwj+S6juW9k+WJjeW8ueW5leeahOWHuueOsOaXtumXtFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRCdWxsZXRTY3JlZW5PblNjcmVlbi5lbmRUaW1lIDwgbm93VGltZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWxsZXRTY3JlZW5PblNjcmVlbi55ID0gbmV4dEJ1bGxldFNjcmVlbk9uU2NyZWVuLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVsbGV0U2NyZWVuT25TY3JlZW4ueSA9IG5leHRCdWxsZXRTY3JlZW5PblNjcmVlbi55IC0gYnVsbGV0U2NyZWVuT25TY3JlZW4uaGVpZ2h0IC0gX29wdGlvbnMudmVydGljYWxJbnRlcnZhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy/lvZPliY3lvLnluZXnu4/ov4fkuIDkuKrngrnpnIDopoHnmoTmgLvml7bplb9cbiAgICAgICAgICAgICAgICBsZXQgYnVsbGV0U2NyZWVuT25TY3JlZW5XaWR0aFRpbWUgPSBidWxsZXRTY3JlZW5PblNjcmVlbi53aWR0aCAvIChidWxsZXRTY3JlZW4uc3R5bGUuc3BlZWQgKiBfb3B0aW9ucy5wbGF5U3BlZWQpO1xuICAgICAgICAgICAgICAgIF9idWxsZXRTY3JlZW5zT25TY3JlZW4uZm9yRWFjaCgobmV4dEJ1bGxldFNjcmVlbk9uU2NyZWVuKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8v5by55bmV5Zyo5rWB5Lit77yM5piv56e75Yqo5by55bmVXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0QnVsbGV0U2NyZWVuT25TY3JlZW4uYnVsbGV0U2NyZWVuLnR5cGUgPT09IEJ1bGxldFNjcmVlblR5cGUudG9wIHx8IG5leHRCdWxsZXRTY3JlZW5PblNjcmVlbi5idWxsZXRTY3JlZW4udHlwZSA9PT0gQnVsbGV0U2NyZWVuVHlwZS5ib3R0b20pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8v5by55bmV5LiN5Zyo5rWB5Lit77yM5Li65Zu65a6a5by55bmVXG4gICAgICAgICAgICAgICAgICAgIC8v5aaC5p6c5paw5by55bmV5Zyo5b2T5YmN5by55bmV5LiK5pa55LiU5pyq5LiO5b2T5YmN5by55bmV6YeN5Y+gXG4gICAgICAgICAgICAgICAgICAgIGlmIChidWxsZXRTY3JlZW5PblNjcmVlbi55ICsgYnVsbGV0U2NyZWVuT25TY3JlZW4uaGVpZ2h0IDwgbmV4dEJ1bGxldFNjcmVlbk9uU2NyZWVuLnkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBhZGQ6IHsgYWRkVG9VcDogdHJ1ZSwgZWxlbWVudDogc2V0QWN0dWFsWShidWxsZXRTY3JlZW5PblNjcmVlbikgfSwgc3RvcDogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgICAgICAvL+S4iuS4gOadoeW8ueW5lee7j+i/h+S4gOS4queCuemcgOimgeeahOaAu+aXtumVv1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dEJ1bGxldFNjcmVlbk9uU2NyZWVuV2lkdGhUaW1lID0gbmV4dEJ1bGxldFNjcmVlbk9uU2NyZWVuLndpZHRoIC8gKG5leHRCdWxsZXRTY3JlZW5PblNjcmVlbi5idWxsZXRTY3JlZW4uc3R5bGUuc3BlZWQgKiBfb3B0aW9ucy5wbGF5U3BlZWQpO1xuICAgICAgICAgICAgICAgICAgICAvL+WmguaenOS4iuS4gOadoeW8ueW5leeahOa2iOWkseaXtumXtOWwj+S6juW9k+WJjeW8ueW5leeahOWHuueOsOaXtumXtFxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dEJ1bGxldFNjcmVlbk9uU2NyZWVuLnN0YXJ0VGltZSArIG5leHRCdWxsZXRTY3JlZW5PblNjcmVlbldpZHRoVGltZSA+PSBub3dUaW1lIHx8IC8v5aaC5p6c5LiK5LiA5p2h5by55bmV55qE5aS06L+b5YWl5LqG77yM5L2G5piv5bC+6L+Y5rKh6L+b5YWlXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0QnVsbGV0U2NyZWVuT25TY3JlZW4uZW5kVGltZSA+PSBidWxsZXRTY3JlZW5PblNjcmVlbi5lbmRUaW1lIC0gYnVsbGV0U2NyZWVuT25TY3JlZW5XaWR0aFRpbWUpIC8v5aaC5p6c5b2T5YmN5by55bmV5aS05Ye65Y675LqG77yM5LiK5LiA5p2h5by55bmV5bC+6L+Y5rKh5Ye65Y67XG4gICAgICAgICAgICAgICAgICAgICAgICBidWxsZXRTY3JlZW5PblNjcmVlbi55ID0gbmV4dEJ1bGxldFNjcmVlbk9uU2NyZWVuLnkgKyBuZXh0QnVsbGV0U2NyZWVuT25TY3JlZW4uaGVpZ2h0ICsgX29wdGlvbnMudmVydGljYWxJbnRlcnZhbDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnVsbGV0U2NyZWVuT25TY3JlZW4ueSA9IG5leHRCdWxsZXRTY3JlZW5PblNjcmVlbi55O1xuICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9idWxsZXRTY3JlZW5zT25TY3JlZW4uZ2V0TGVuZ3RoKCkgPT09IG9sZExlbmd0aClcbiAgICAgICAgICAgICAgICBfYnVsbGV0U2NyZWVuc09uU2NyZWVuLnB1c2goc2V0QWN0dWFsWShidWxsZXRTY3JlZW5PblNjcmVlbiksIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7nnJ/lrp7nmoRZ5Z2Q5qCHXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBidWxsZXRTY3JlZW5PblNjcmVlbiAtIOWxj+W5leW8ueW5leS6i+S7tlxuICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSDlsY/luZXlvLnluZXkuovku7ZcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHNldEFjdHVhbFkoYnVsbGV0U2NyZWVuT25TY3JlZW4pIHtcbiAgICAgICAgICAgIGxldCBidWxsZXRTY3JlZW4gPSBidWxsZXRTY3JlZW5PblNjcmVlbi5idWxsZXRTY3JlZW47XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgYnVsbGV0U2NyZWVuLnR5cGUgPT09IEJ1bGxldFNjcmVlblR5cGUubGVmdFRvUmlnaHQgfHxcbiAgICAgICAgICAgICAgICBidWxsZXRTY3JlZW4udHlwZSA9PT0gQnVsbGV0U2NyZWVuVHlwZS5yaWdodFRvTGVmdCB8fFxuICAgICAgICAgICAgICAgIGJ1bGxldFNjcmVlbi50eXBlID09PSBCdWxsZXRTY3JlZW5UeXBlLnRvcFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgYnVsbGV0U2NyZWVuT25TY3JlZW4uYWN0dWFsWSA9IGJ1bGxldFNjcmVlbk9uU2NyZWVuLnkgJSAoX2VsZW1lbnRTaXplLmhlaWdodCAtIGJ1bGxldFNjcmVlbk9uU2NyZWVuLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChidWxsZXRTY3JlZW4udHlwZSA9PT0gQnVsbGV0U2NyZWVuVHlwZS5ib3R0b20pIHtcbiAgICAgICAgICAgICAgICBidWxsZXRTY3JlZW5PblNjcmVlbi5hY3R1YWxZID0gX2VsZW1lbnRTaXplLmhlaWdodCArIGJ1bGxldFNjcmVlbk9uU2NyZWVuLnkgJSBfZWxlbWVudFNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ1bGxldFNjcmVlbk9uU2NyZWVuO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9ruWwuuWvuFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gc2V0U2l6ZSgpIHtcbiAgICAgICAgICAgIGxldCBkZXZpY2VQaXhlbFJhdGlvID0gSGVscGVyLmdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICAgICAgICAgIGlmIChfb2xkRGV2aWNlUGl4ZWxSYXRpbyAhPSBkZXZpY2VQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgX29sZENsaWVudFdpZHRoICE9IGVsZW1lbnQuY2xpZW50V2lkdGggfHxcbiAgICAgICAgICAgICAgICBfb2xkQ2xpZW50SGVpZ2h0ICE9IGVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8XG4gICAgICAgICAgICAgICAgX29sZFNjYWxpbmcgIT0gX29wdGlvbnMuc2NhbGluZykge1xuICAgICAgICAgICAgICAgIF9vbGRTY2FsaW5nID0gX29wdGlvbnMuc2NhbGluZztcbiAgICAgICAgICAgICAgICBfZWxlbWVudFNpemUud2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoIC8gX29wdGlvbnMuc2NhbGluZztcbiAgICAgICAgICAgICAgICBfZWxlbWVudFNpemUuaGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQgLyBfb3B0aW9ucy5zY2FsaW5nO1xuICAgICAgICAgICAgICAgIF9vbGRDbGllbnRXaWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgX29sZENsaWVudEhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgIF9vbGREZXZpY2VQaXhlbFJhdGlvID0gZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgICAgICAgICBfcmVuZGVyZXIuc2V0U2l6ZSgpO1xuICAgICAgICAgICAgICAgIGlmICghX3BsYXlpbmcpIF9yZW5kZXJlci5kcmF3KCk7IC8v6Z2e5pKt5pS+54q25oCB5YiZ6YeN57uYXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL0lFIEVkZ2Ug5rWP6KeI5Zmo5LiN5pSv5oyBICVjXG4gICAgICAgIGlmICghIXdpbmRvdy5BY3RpdmVYT2JqZWN0IHx8IFwiQWN0aXZlWE9iamVjdFwiIGluIHdpbmRvdyB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJUcmlkZW50XCIpID4gLTEgfHxcbiAgICAgICAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIk1TSUVcIikgPiAtMSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJFZGdlXCIpID4gLTEpIGNvbnNvbGUuaW5mbyhcbiAgICAgICAgICAgICAgICBSZXNvdXJjZXMuTE9BREVEX0lORk9fSUUuZmlsbERhdGEoYnVpbGQpXG4gICAgICAgICAgICApO1xuICAgICAgICAvL090aGVyXG4gICAgICAgIGVsc2UgY29uc29sZS5pbmZvKFxuICAgICAgICAgICAgUmVzb3VyY2VzLkxPQURFRF9JTkZPLmZpbGxEYXRhKGJ1aWxkKSxcbiAgICAgICAgICAgICdmb250LXdlaWdodDpib2xkOyBjb2xvcjojMDA5OUZGOycsICcnLCAnZm9udC1zdHlsZTppdGFsaWM7JywgJydcbiAgICAgICAgKTtcbiAgICB9XG59XG5leHBvcnQgeyBCdWxsZXRTY3JlZW5FbmdpbmUgfSIsIi8qKlxuICog5by55bmV57G75Z6L5p6a5Li+XG4gKiBAYWxpYXMgb3BlbkJTRS5CdWxsZXRTY3JlZW5UeXBlXG4gKiBAcmVhZG9ubHlcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmNvbnN0IEJ1bGxldFNjcmVlblR5cGUgPSB7XG4gICAgLyoqIFxuICAgICAqIOS7juWPs+WIsOW3puW8ueW5lVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHJpZ2h0VG9MZWZ0OiAxLFxuICAgIC8qKiBcbiAgICAgKiDku47lt6bliLDlj7PlvLnluZXvvIjpgIblkJHlvLnluZXvvIlcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBsZWZ0VG9SaWdodDogMixcbiAgICAvKiogXG4gICAgICog6aG26YOo5by55bmVXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdG9wOiA0LFxuICAgIC8qKiBcbiAgICAgKiDlupXpg6jlvLnluZVcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBib3R0b206IDhcbn1cblxuZXhwb3J0IHsgQnVsbGV0U2NyZWVuVHlwZSB9IiwiaW1wb3J0IHsgUmVzb3VyY2VzIH0gZnJvbSAnLi9saWIvcmVzb3VyY2VzJ1xuLyoqXG4gKiDkuIrkuIvmlofoj5zljZXnsbtcbiAqIEBhbGlhcyBvcGVuQlNFLkNvbnRleHRtZW51XG4gKiBAZGVzY3JpcHRpb24g5LiK5LiL5paH6I+c5Y2V5a+56LGh44CC55So5LqO5a6e546w5LiA5Liq5by55bmV5LiK5LiL5paH6I+c5Y2V44CCXG4gKi9cbmNsYXNzIENvbnRleHRtZW51IHtcbiAgICAvKipcbiAgICAgKiDliJvlu7rlvLnluZXlvJXmk47lr7nosaHnmoTkuIrkuIvmlofoj5zljZXjgIJcbiAgICAgKiBAcGFyYW0ge29wZW5CU0UuQnVsbGV0U2NyZWVuRW5naW5lfSBidWxsZXRTY3JlZW5FbmdpbmUgLSDlvLnluZXlvJXmk47lr7nosaHvvJrkuIDkuKrlvLnluZUge0BsaW5rIG9wZW5CU0UuQnVsbGV0U2NyZWVuRW5naW5lfSDlr7nosaHjgILopoHmt7vliqDkuIrkuIvmlofoj5zljZXnmoRcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSDkuIrkuIvmlofoj5zljZXlhYPntKDvvJrlvZPmmL7npLrkuIrkuIvmlofoj5zljZXml7bopoHmmL7npLrnmoQgZGl2IOOAguacieWFsyBFbGVtZW50IOaOpeWPo+eahOS/oeaBr+ivt+WPgumYhU1ETiBbRWxlbWVudF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0VsZW1lbnR9IOOAglxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGF5ZXI9MTBdIC0g5by55bmV5bGC57qn77ya5b2T5pi+56S65LiK5LiL5paH6I+c5Y2V5oiW6byg5qCH5oyH5ZCR5by55bmV5pe25by55bmV6KaB56e75Yqo5Yiw55qE5bGC57qn44CC5pyJ5YWz5by55bmV5bGC57qn55qE6K+m57uG6K+05piO6K+35Y+C6ZiFIHtAbGluayBvcGVuQlNFfm9wdGlvbnN9IOe7k+aehOOAglxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhdXNlPXRydWVdIC0g5piv5ZCm5pqC5YGc77ya5b2T6byg5qCH5oyH5ZCR5by55bmV5oiW5Y2V5byA5LiK5LiL5paH6I+c5Y2V5pe25by55bmV5piv5ZCm5pqC5YGc56e75YqoL+aSreaUvuOAglxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGJ1bGxldFNjcmVlbkVuZ2luZSwgZWxlbWVudCwgbGF5ZXIgPSAxMCwgcGF1c2UgPSB0cnVlKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBidWxsZXRTY3JlZW5FbmdpbmUgIT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbGVtZW50ICE9ICdvYmplY3QnIHx8XG4gICAgICAgICAgICB0eXBlb2YgcGF1c2UgIT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICAgICAodHlwZW9mIGxheWVyICE9ICdudW1iZXInICYmIGxheWVyICE9IG51bGwpXG4gICAgICAgICkgdGhyb3cgbmV3IFR5cGVFcnJvcihSZXNvdXJjZXMuUEFSQU1FVEVSU19UWVBFX0VSUk9SKTtcblxuICAgICAgICBlbGVtZW50LmJ1bGxldFNjcmVlbkV2ZW50ID0gbnVsbDtcblxuICAgICAgICBsZXQgX2dldENvbnRleHRtZW51U3RhdGUgPSAoKSA9PiBjb250ZXh0bWVudS5zdHlsZS5kaXNwbGF5ICE9ICdub25lJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPluS4iuS4i+aWh+iPnOWNleeahOeKtuaAgVxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IOaMh+ekuuS4iuS4i+aWh+iPnOWNleaYr+WQpuato+WkhOS6jua/gOa0uy/mmL7npLrnirbmgIHjgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0Q29udGV4dG1lbnVTdGF0ZSA9IF9nZXRDb250ZXh0bWVudVN0YXRlO1xuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W5r+A5rS75LiK5LiL5paH6I+c5Y2V55qE5by55bmV55qE5by55bmV5LqL5Lu257uT5p6EXG4gICAgICAgICAqIEByZXR1cm5zIHtvcGVuQlNFfkJ1bGxldFNjcmVlbkV2ZW50fSDlvLnluZXkuovku7bnu5PmnoTvvJrkuIDkuKoge0BsaW5rIG9wZW5CU0V+QnVsbGV0U2NyZWVuRXZlbnR9IOe7k+aehOOAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRCdWxsZXRTY3JlZW5FdmVudCA9ICgpID0+IGVsZW1lbnQuYnVsbGV0U2NyZWVuRXZlbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlhbPpl63kuIrkuIvmlofoj5zljZXvvJrlpoLmnpzlvZPliY3kuIrkuIvmlofoj5zljZXmraPlpITkuo7mv4DmtLsv5pi+56S654q25oCB5YiZ56uL5Y2z5YWz6Zet44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsb3NlQ29udGV4dG1lbnUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoX2dldENvbnRleHRtZW51U3RhdGUoKSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICBpZiAocGF1c2UpIGVsZW1lbnQuYnVsbGV0U2NyZWVuRXZlbnQuc2V0UGxheVN0YXRlKHRydWUpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYnVsbGV0U2NyZWVuRXZlbnQuc2V0QnVsbGV0U2NyZWVuKHsgX2NvbnRleHRtZW51OiBmYWxzZSB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5idWxsZXRTY3JlZW5FdmVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBlbGVtZW50Lm9uY29udGV4dG1lbnUgPSAoKSA9PiBmYWxzZTtcblxuICAgICAgICBsZXQgX2Nsb3NlQ29udGV4dG1lbnUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKF9nZXRDb250ZXh0bWVudVN0YXRlKCkgJiYgZS50YXJnZXQgIT0gZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICBpZiAocGF1c2UpIGVsZW1lbnQuYnVsbGV0U2NyZWVuRXZlbnQuc2V0UGxheVN0YXRlKHRydWUpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYnVsbGV0U2NyZWVuRXZlbnQuc2V0QnVsbGV0U2NyZWVuKHsgX2NvbnRleHRtZW51OiBmYWxzZSB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5idWxsZXRTY3JlZW5FdmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2NsaWNrJykgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfY2xvc2VDb250ZXh0bWVudSwgdHJ1ZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIF9jbG9zZUNvbnRleHRtZW51LCB0cnVlKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIF9jbG9zZUNvbnRleHRtZW51LCB0cnVlKTtcblxuICAgICAgICBidWxsZXRTY3JlZW5FbmdpbmUuYmluZCgnY29udGV4dG1lbnUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5zZXRCdWxsZXRTY3JlZW4oeyBsYXllcjogbGF5ZXIsIF9jb250ZXh0bWVudTogdHJ1ZSB9LCBsYXllciAhPSBudWxsKTtcbiAgICAgICAgICAgIGlmIChwYXVzZSkgZS5zZXRQbGF5U3RhdGUoZmFsc2UpO1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgICAgICBsZXQgdG9wID0gZS5jbGllbnRZLCBsZWZ0ID0gZS5jbGllbnRYO1xuICAgICAgICAgICAgaWYgKHRvcCArIGVsZW1lbnQuY2xpZW50SGVpZ2h0ID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkgdG9wIC09IGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgaWYgKGxlZnQgKyBlbGVtZW50LmNsaWVudFdpZHRoID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoKSBsZWZ0IC09IGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLnRvcCA9IGAke3RvcH1weGA7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLmxlZnQgPSBgJHtsZWZ0fXB4YDtcbiAgICAgICAgICAgIGVsZW1lbnQuYnVsbGV0U2NyZWVuRXZlbnQgPSBlO1xuICAgICAgICB9KTtcblxuICAgICAgICBidWxsZXRTY3JlZW5FbmdpbmUuYmluZCgnbW91c2VlbnRlcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAobGF5ZXIgIT0gbnVsbCkgZS5zZXRCdWxsZXRTY3JlZW4oeyBsYXllcjogbGF5ZXIgfSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocGF1c2UpIGUuc2V0UGxheVN0YXRlKGZhbHNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYnVsbGV0U2NyZWVuRW5naW5lLmJpbmQoJ21vdXNlbGVhdmUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKCFlLmdldEJ1bGxldFNjcmVlbigpLl9jb250ZXh0bWVudSAmJiBwYXVzZSkgZS5zZXRQbGF5U3RhdGUodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgQ29udGV4dG1lbnUgfSIsImltcG9ydCB7IFJlc291cmNlcyB9IGZyb20gJy4vcmVzb3VyY2VzJ1xuaW1wb3J0IHsgSGVscGVyIH0gZnJvbSAnLi9oZWxwZXInO1xuXG4vKipcbiAqIOS6i+S7tuaooeWei+exu1xuICovXG5jbGFzcyBFdmVudCB7XG4gICAgLyoqXG4gICAgICog5Yib5bu65LiA5Liq5paw55qE5LqL5Lu25qih5Z6L44CCXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDkuovku7bliJfooahcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIGxldCBldmVudExpc3QgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3u+WKoOS6i+S7tlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0g5LqL5Lu25ZCN56ewXG4gICAgICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0g5Lyg5YWl55qE5Y+C5pWw6ZSZ6K+v5oiW5LqL5Lu25bey5a2Y5Zyo5pe25byV5Y+R6ZSZ6K+v44CC6K+35Y+C6ZiFIE1ETiBbVHlwZUVycm9yXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9UeXBlRXJyb3J9IOOAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hZGQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKFJlc291cmNlcy5QQVJBTUVURVJTX1RZUEVfRVJST1IpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudExpc3RbbmFtZV0gIT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBUeXBlRXJyb3IoUmVzb3VyY2VzLkVWRU5UX0FMUkVBRFlfRVhJU1RTX0VSUk9SKTtcbiAgICAgICAgICAgIGV2ZW50TGlzdFtuYW1lXSA9IFtdO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5LqL5Lu2XG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSDkuovku7blkI3np7BcbiAgICAgICAgICogQHRocm93cyB7VHlwZUVycm9yfSDkvKDlhaXnmoTlj4LmlbDplJnor6/miJbkuovku7bkuI3lrZjlnKjml7blvJXlj5HplJnor6/jgILor7flj4LpmIUgTUROIFtUeXBlRXJyb3Jde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1R5cGVFcnJvcn0g44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlbW92ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoUmVzb3VyY2VzLlBBUkFNRVRFUlNfVFlQRV9FUlJPUik7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV2ZW50TGlzdFtuYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBUeXBlRXJyb3IoUmVzb3VyY2VzLkVWRU5UX05BTUVfTk9UX0ZPVU5EKTtcbiAgICAgICAgICAgIGRlbGV0ZSAoZXZlbnRMaXN0W25hbWVdKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOe7keWumuS6i+S7tuWkhOeQhueoi+W6j1xuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0g5LqL5Lu25ZCN56ewXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1biAtIOS6i+S7tuWkhOeQhueoi+W6j1xuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSDmt7vliqDlkI7nmoTkuovku7bmlbBcbiAgICAgICAgICogQHRocm93cyB7VHlwZUVycm9yfSDkvKDlhaXnmoTlj4LmlbDplJnor6/miJbkuovku7bkuI3lrZjlnKjml7blvJXlj5HplJnor6/jgILor7flj4LpmIUgTUROIFtUeXBlRXJyb3Jde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1R5cGVFcnJvcn0g44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJpbmQgPSBmdW5jdGlvbiAobmFtZSwgZnVuKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT0gJ3N0cmluZycgfHwgdHlwZW9mIGZ1biAhPSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKFJlc291cmNlcy5QQVJBTUVURVJTX1RZUEVfRVJST1IpO1xuICAgICAgICAgICAgbGV0IGV2ZW50ID0gZXZlbnRMaXN0W25hbWVdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudCA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBUeXBlRXJyb3IoUmVzb3VyY2VzLkVWRU5UX05BTUVfTk9UX0ZPVU5EKTtcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4IGluIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50W2luZGV4XSA9PT0gZnVuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnQudW5zaGlmdChmdW4pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICog6Kej57uR5LqL5Lu25aSE55CG56iL5bqP77yIZnVu5Li656m66Kej57uR5omA5pyJ5LqL5Lu25aSE55CG56iL5bqP77yJXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSDkuovku7blkI3np7BcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuIC0g5LqL5Lu25aSE55CG56iL5bqPXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IOWIoOmZpOWQjueahOS6i+S7tuaVsFxuICAgICAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IOS8oOWFpeeahOWPguaVsOmUmeivr+aIluS6i+S7tuS4jeWtmOWcqOaXtuW8leWPkemUmeivr+OAguivt+WPgumYhSBNRE4gW1R5cGVFcnJvcl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvVHlwZUVycm9yfSDjgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudW5iaW5kID0gZnVuY3Rpb24gKG5hbWUsIGZ1bikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKFJlc291cmNlcy5QQVJBTUVURVJTX1RZUEVfRVJST1IpO1xuICAgICAgICAgICAgbGV0IGV2ZW50ID0gZXZlbnRMaXN0W25hbWVdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudCA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBUeXBlRXJyb3IoUmVzb3VyY2VzLkVWRU5UX05BTUVfTk9UX0ZPVU5EKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnVuID09ICdmdW5jdGlvbicpIGZvciAobGV0IGluZGV4IGluIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50W2luZGV4XSA9PT0gZnVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnNwbGljZShmdW4sIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBldmVudExpc3RbbmFtZV0gPSBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOinpuWPkeS6i+S7tlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0g5LqL5Lu25ZCN56ewXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBlIC0g5LqL5Lu25pWw5o2uXG4gICAgICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0g5Lyg5YWl55qE5Y+C5pWw6ZSZ6K+v5oiW5LqL5Lu25LiN5a2Y5Zyo5pe25byV5Y+R6ZSZ6K+v44CC6K+35Y+C6ZiFIE1ETiBbVHlwZUVycm9yXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9UeXBlRXJyb3J9IOOAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmlnZ2VyID0gZnVuY3Rpb24gKG5hbWUsIGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPSAnc3RyaW5nJyB8fCBIZWxwZXIuX3R5cGVvZihlKSAhPSAnb2JqZWN0JykgdGhyb3cgbmV3IFR5cGVFcnJvcihSZXNvdXJjZXMuUEFSQU1FVEVSU19UWVBFX0VSUk9SKTtcbiAgICAgICAgICAgIGxldCBldmVudCA9IGV2ZW50TGlzdFtuYW1lXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXZlbnQgPT09ICd1bmRlZmluZWQnKSB0aHJvdyBuZXcgVHlwZUVycm9yKFJlc291cmNlcy5FVkVOVF9OQU1FX05PVF9GT1VORCk7XG4gICAgICAgICAgICBlLnR5cGUgPSBuYW1lO1xuICAgICAgICAgICAgZm9yIChsZXQgZnVuIG9mIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmdW4oZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgeyBFdmVudCB9IiwiaW1wb3J0IHsgUmVzb3VyY2VzIH0gZnJvbSAnLi9yZXNvdXJjZXMnXG5cbi8qKlxuICog6K6+572u5YC8XG4gKiBAYWxpYXMgSGVscGVyLnNldFZhbHVlXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0g5YC8XG4gKiBAcGFyYW0geyp9IGRlZmF1bHRWYWx1ZSAtIOm7mOiupOWAvFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSDnsbvlnotcbiAqIEByZXR1cm5zIHsqfSAtIOWAvFxuICovXG5mdW5jdGlvbiBzZXRWYWx1ZSh2YWx1ZSwgZGVmYXVsdFZhbHVlLCB0eXBlKSB7XG4gICAgbGV0IHJldHVyblZhbHVlO1xuICAgIGlmIChpc0VtcHR5KHZhbHVlKSkgcmV0dXJuVmFsdWUgPSBjbG9uZShkZWZhdWx0VmFsdWUpO1xuICAgIGVsc2UgcmV0dXJuVmFsdWUgPSBjbG9uZSh2YWx1ZSk7XG4gICAgaWYgKCFpc0VtcHR5KHR5cGUpKSBjaGVja1R5cGUocmV0dXJuVmFsdWUsIHR5cGUpO1xuICAgIGVsc2UgaWYgKCFpc0VtcHR5KGRlZmF1bHRWYWx1ZSkpIGNoZWNrVHlwZShyZXR1cm5WYWx1ZSwgX3R5cGVvZihkZWZhdWx0VmFsdWUpKTtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbi8qKlxuICog6K6+572u5aSa5Liq5YC8XG4gKiBAYWxpYXMgSGVscGVyLnNldFZhbHVlc1xuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyAtIOWAvFxuICogQHBhcmFtIHtvYmplY3R9IGRlZmF1bHRWYWx1ZXMgLSDpu5jorqTlgLxcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlcyAtIOexu+Wei1xuICogQHJldHVybnMge29iamVjdH0gLSDlgLxcbiAqL1xuZnVuY3Rpb24gc2V0VmFsdWVzKHZhbHVlcywgZGVmYXVsdFZhbHVlcywgdHlwZXMsIGNsb25lID0gdHJ1ZSkge1xuICAgIGxldCByZXR1cm5WYWx1ZXMgPSBjbG9uZSA/IHNldFZhbHVlKHZhbHVlcywge30pIDogZGVmYXVsdFZhbHVlcztcbiAgICBsZXQgX3ZhbHVlcyA9IGNsb25lID8gcmV0dXJuVmFsdWVzIDogc2V0VmFsdWUodmFsdWVzLCB7fSk7XG4gICAgZm9yIChsZXQga2V5IGluIGRlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgaWYgKF90eXBlb2YoZGVmYXVsdFZhbHVlc1trZXldKSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICByZXR1cm5WYWx1ZXNba2V5XSA9IHNldFZhbHVlcyhfdmFsdWVzW2tleV0sIGRlZmF1bHRWYWx1ZXNba2V5XSwgdHlwZXNba2V5XSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVyblZhbHVlc1trZXldID0gc2V0VmFsdWUoX3ZhbHVlc1trZXldLCBkZWZhdWx0VmFsdWVzW2tleV0sIHR5cGVzW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xufVxuXG4vKipcbiAqIOajgOafpeexu+Wei1xuICogQGFsaWFzIEhlbHBlci5jaGVja1R5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIOWAvFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSDnsbvlnotcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY2FuQmVOdWxsIC0g5Y+v5Lul5Li656m6XG4gKi9cbmZ1bmN0aW9uIGNoZWNrVHlwZSh2YWx1ZSwgdHlwZSwgY2FuQmVOdWxsID0gdHJ1ZSkge1xuICAgIGlmICh0eXBlb2YgdHlwZSAhPSAnc3RyaW5nJyAmJiBfdHlwZW9mKHR5cGUpICE9ICdhcnJheScpIHRocm93IG5ldyBUeXBlRXJyb3IoUmVzb3VyY2VzLlBBUkFNRVRFUlNfVFlQRV9FUlJPUik7XG4gICAgaWYgKGNhbkJlTnVsbCAmJiBpc0VtcHR5KHZhbHVlKSkgcmV0dXJuO1xuICAgIGlmIChfdHlwZW9mKHR5cGUpID09PSAnYXJyYXknKSB7XG4gICAgICAgIGxldCBmbGF0ID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgdHlwZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtICE9ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKFJlc291cmNlcy5QQVJBTUVURVJTX1RZUEVfRVJST1IpO1xuICAgICAgICAgICAgaWYgKF90eXBlb2YodmFsdWUpID09PSBpdGVtKSB7XG4gICAgICAgICAgICAgICAgZmxhdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmbGF0KSB0aHJvdyBuZXcgVHlwZUVycm9yKFJlc291cmNlcy5QQVJBTUVURVJTX1RZUEVfRVJST1IpO1xuICAgIH0gZWxzZSBpZiAoX3R5cGVvZih2YWx1ZSkgIT0gdHlwZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihSZXNvdXJjZXMuUEFSQU1FVEVSU19UWVBFX0VSUk9SKTtcbn1cblxuLyoqXG4gKiDmo4Dmn6XlpJrkuKrlgLxcbiAqIEBhbGlhcyBIZWxwZXIuY2hlY2tUeXBlc1xuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyAtIOWAvFxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVzIC0g57G75Z6LXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIOWAvFxuICovXG5mdW5jdGlvbiBjaGVja1R5cGVzKHZhbHVlcywgdHlwZXMsIGNhbkJlTnVsbCA9IHRydWUpIHtcbiAgICBpZiAoY2FuQmVOdWxsICYmIGlzRW1wdHkodmFsdWVzKSkgcmV0dXJuO1xuICAgIGZvciAobGV0IGtleSBpbiB0eXBlcykge1xuICAgICAgICBpZiAoX3R5cGVvZih0eXBlc1trZXldKSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBjaGVja1R5cGVzKHZhbHVlc1trZXldLCB0eXBlc1trZXldKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY2hlY2tUeXBlKHZhbHVlc1trZXldLCB0eXBlc1trZXldLCBjYW5CZU51bGwpO1xuICAgIH1cbn1cblxuLyoqXG4gKiDmo4Dmn6XmmK/lkKbkuLrnqbpcbiAqIEBhbGlhcyBIZWxwZXIuaXNFbXB0eVxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIOWAvFxuICovXG5mdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB8fFxuICAgICAgICB2YWx1ZSA9PT0gbnVsbFxufVxuXG4vKipcbiAqIOiOt+WPluWvueixoeeahOexu+Wei++8iOWPr+WMuuWIhuaVsOe7hOetie+8iVxuICogQGFsaWFzIEhlbHBlci5fdHlwZW9mXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIOWvueixoVxuICovXG5mdW5jdGlvbiBfdHlwZW9mKG9iamVjdCkge1xuICAgIC8vZWc6IFtPYmplY3QgRnVuY3Rpb25dIC0+IEZ1bmN0aW9uIC0+IGZ1bmN0aW9uXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiAqIOWFi+mahuWvueixoVxuICogQHBhcmFtIHsqfSBvYmplY3QgXG4gKi9cbmZ1bmN0aW9uIGNsb25lKG9iamVjdCkge1xuICAgIGxldCByZXN1bHQsIHR5cGUgPSBfdHlwZW9mKG9iamVjdCk7XG4gICAgLy/noa7lrppyZXN1bHTnmoTnsbvlnotcbiAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHJlc3VsdCA9IHt9O1xuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdhcnJheScpIHJlc3VsdCA9IFtdO1xuICAgIGVsc2UgcmV0dXJuIG9iamVjdDtcbiAgICBmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gY2xvbmUob2JqZWN0W2tleV0pOyAvL+mAkuW9kuiwg+eUqFxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIOa4heepuuWFg+e0oFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFxuICovXG5mdW5jdGlvbiBjbGVhbkVsZW1lbnQoZWxlbWVudCkge1xuICAgIGxldCBsYXN0Q2hpbGQ7XG4gICAgd2hpbGUgKChsYXN0Q2hpbGQgPSBlbGVtZW50Lmxhc3RDaGlsZCkgIT0gbnVsbCkgZWxlbWVudC5yZW1vdmVDaGlsZChsYXN0Q2hpbGQpO1xufVxuXG4vKipcbiAqIOiOt+WPluWxj+W5leeahOiuvuWkh+WDj+e0oOavlFxuICogQHBhcmFtIHtib29sZWFufSBzaG93V2FybiAtIOaYvuekuuitpuWRilxuICovXG5mdW5jdGlvbiBnZXREZXZpY2VQaXhlbFJhdGlvKHNob3dXYXJuID0gZmFsc2UpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID09PSAnbnVtYmVyJykgcmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIGlmICh0eXBlb2Ygd2luZG93LnNjcmVlbi5kZXZpY2VYRFBJID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygd2luZG93LnNjcmVlbi5sb2dpY2FsWERQSSA9PT0gJ251bWJlcicpIHJldHVybiBzY3JlZW4uZGV2aWNlWERQSSAvIHNjcmVlbi5sb2dpY2FsWERQSTtcbiAgICAvL+S4jeaUr+aMgSBkZXZpY2VQaXhlbFJhdGlvIOeahOitpuWRilxuICAgIGlmKHNob3dXYXJuKSBjb25zb2xlLndhcm4oUmVzb3VyY2VzLkRFVklDRVBJWEVMUkFUSU9fTk9UX1NVUFBPUlRfV0FSTik7XG4gICAgcmV0dXJuIDE7XG59XG5cbi8qKlxuICog5biu5Yqp5a+56LGhXG4gKiBAbmFtZXNwYWNlXG4gKi9cbmNvbnN0IEhlbHBlciA9IHtcbiAgICBzZXRWYWx1ZTogc2V0VmFsdWUsXG4gICAgc2V0VmFsdWVzOiBzZXRWYWx1ZXMsXG4gICAgY2hlY2tUeXBlOiBjaGVja1R5cGUsXG4gICAgY2hlY2tUeXBlczogY2hlY2tUeXBlcyxcbiAgICBpc0VtcHR5OiBpc0VtcHR5LFxuICAgIF90eXBlb2Y6IF90eXBlb2YsXG4gICAgY2xvbmU6IGNsb25lLFxuICAgIGNsZWFuRWxlbWVudDogY2xlYW5FbGVtZW50LFxuICAgIGdldERldmljZVBpeGVsUmF0aW86IGdldERldmljZVBpeGVsUmF0aW9cbn1cblxuZXhwb3J0IHsgSGVscGVyIH0iLCIvKipcbiAqIOWPjOWQkemTvuihqOexu1xuICovXG5jbGFzcyBMaW5rZWRMaXN0IHtcbiAgICAvKipcbiAgICAgKiDliJvlu7rkuIDkuKrlj4zlkJHpk77ooajjgIJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWPjOWQkemTvuihqOiKgueCuVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAqL1xuICAgICAgICBjbGFzcyBub2RlIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91cyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy/liJ3lp4vljJZcbiAgICAgICAgbGV0IHRvcE5vZGUgPSBuZXcgbm9kZShudWxsKTtcbiAgICAgICAgbGV0IGJvdHRvbU5vZGUgPSBuZXcgbm9kZShudWxsKTtcbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgICAgIHRvcE5vZGUubmV4dCA9IGJvdHRvbU5vZGU7XG4gICAgICAgIGJvdHRvbU5vZGUucHJldmlvdXMgPSB0b3BOb2RlO1xuICAgICAgICAvL+WFrOWFseWHveaVsFxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W5YWD57Sg5Liq5pWwXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IOWFg+e0oOS4quaVsFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRMZW5ndGggPSBsID0+IGxlbmd0aDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaPkuWFpeWFg+e0oFxuICAgICAgICAgKiBAcGFyYW0geyp9IGVsZW1lbnQgLSDlhYPntKBcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSB0b3AgLSB0cnVlOiDmj5LlhaXliLDpobbpg6ggZmFsc2U6IOaPkuWFpeWIsOW6lemDqFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wdXNoID0gZnVuY3Rpb24gKGVsZW1lbnQsIHRvcCkge1xuICAgICAgICAgICAgbGV0IHRoaXNOb2RlID0gbmV3IG5vZGUoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgICAgICAgdGhpc05vZGUubmV4dCA9IHRvcE5vZGUubmV4dDtcbiAgICAgICAgICAgICAgICB0aGlzTm9kZS5wcmV2aW91cyA9IHRvcE5vZGU7XG4gICAgICAgICAgICAgICAgdG9wTm9kZS5uZXh0ID0gdG9wTm9kZS5uZXh0LnByZXZpb3VzID0gdGhpc05vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzTm9kZS5wcmV2aW91cyA9IGJvdHRvbU5vZGUucHJldmlvdXM7XG4gICAgICAgICAgICAgICAgdGhpc05vZGUubmV4dCA9IGJvdHRvbU5vZGU7XG4gICAgICAgICAgICAgICAgYm90dG9tTm9kZS5wcmV2aW91cyA9IGJvdHRvbU5vZGUucHJldmlvdXMubmV4dCA9IHRoaXNOb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVuZ3RoKys7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDor7vlj5blhYPntKBcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSByZW1vdmUgLSDor7vlj5blkI7mmK/lkKbliKDpmaRcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSB0b3AgLSB0cnVlOiDor7vlj5bpobbpg6ggZmFsc2U6IOivu+WPluW6lemDqFxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0g5YWD57SgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvcCA9IGZ1bmN0aW9uIChyZW1vdmUsIHRvcCkge1xuICAgICAgICAgICAgbGV0IHRoaXNOb2RlO1xuICAgICAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgICAgICAgIHRoaXNOb2RlID0gdG9wTm9kZS5uZXh0O1xuICAgICAgICAgICAgICAgIGlmICh0b3BOb2RlLm5leHQgIT0gYm90dG9tTm9kZSAmJiByZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc05vZGUubmV4dC5wcmV2aW91cyA9IHRvcE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHRvcE5vZGUubmV4dCA9IHRoaXNOb2RlLm5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc05vZGUgPSBib3R0b21Ob2RlLnByZXZpb3VzO1xuICAgICAgICAgICAgICAgIGlmIChib3R0b21Ob2RlLnByZXZpb3VzICE9IHRvcE5vZGUgJiYgcmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNOb2RlLnByZXZpb3VzLm5leHQgPSBib3R0b21Ob2RlO1xuICAgICAgICAgICAgICAgICAgICBib3R0b21Ob2RlLnByZXZpb3VzID0gdGhpc05vZGUucHJldmlvdXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlbW92ZSlcbiAgICAgICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzTm9kZS5lbGVtZW50O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICog5riF56m66ZO+6KGoXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsZWFuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdG9wTm9kZSA9IG5ldyBub2RlKG51bGwpO1xuICAgICAgICAgICAgYm90dG9tTm9kZSA9IG5ldyBub2RlKG51bGwpO1xuICAgICAgICAgICAgdG9wTm9kZS5uZXh0ID0gYm90dG9tTm9kZTtcbiAgICAgICAgICAgIGJvdHRvbU5vZGUucHJldmlvdXMgPSB0b3BOb2RlO1xuICAgICAgICAgICAgbGVuZ3RoID0gMDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmBjeWOhumTvuihqFxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW4gLSDpgY3ljoblm57osIPlh73mlbBcbiAgICAgICAgICog5Zue6LCD5Ye95pWw77yI5Y+C5pWw77ya5YWD57Sg77yM6L+U5Zue77yae3JlbW92Ze+8muWIoOmZpOatpOWFg+e0oO+8jGFkZDrmj5LlhaXlhYPntKAoYWRkLmFkZFRvVXA65o+S5YWl5Yiw5LiK5pa5LCBhZGQuZWxlbWVudDrlhYPntKApLCBzdG9w77ya5YGc5q2i6YGN5Y6Gfe+8iVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHRvcFRvQm90dG9tIC0gdHJ1ZTog5LuO6aG25Yiw5bqVIGZhbHNlOiDku47lupXliLDpobZcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZm9yRWFjaCA9IGZ1bmN0aW9uIChmdW4sIHRvcFRvQm90dG9tKSB7XG4gICAgICAgICAgICBsZXQgdGhpc05vZGUgPSB0b3BUb0JvdHRvbSA/IHRvcE5vZGUgOiBib3R0b21Ob2RlO1xuICAgICAgICAgICAgd2hpbGUgKHRvcFRvQm90dG9tID9cbiAgICAgICAgICAgICAgICAodGhpc05vZGUgPSB0aGlzTm9kZS5uZXh0KSAhPSBib3R0b21Ob2RlIDogKHRoaXNOb2RlID0gdGhpc05vZGUucHJldmlvdXMpICE9IHRvcE5vZGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgX3JldHVybiA9IGZ1bih0aGlzTm9kZS5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoX3JldHVybikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3JldHVybi5hZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdOb2RlID0gbmV3IG5vZGUoX3JldHVybi5hZGQuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3JldHVybi5hZGQuYWRkVG9VcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUucHJldmlvdXMgPSB0aGlzTm9kZS5wcmV2aW91cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLm5leHQgPSB0aGlzTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzTm9kZS5wcmV2aW91cy5uZXh0ID0gbmV3Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzTm9kZS5wcmV2aW91cyA9IG5ld05vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLnByZXZpb3VzID0gdGhpc05vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5uZXh0ID0gdGhpc05vZGUubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzTm9kZS5uZXh0LnByZXZpb3VzID0gbmV3Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzTm9kZS5uZXh0ID0gbmV3Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChfcmV0dXJuLnJlbW92ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc05vZGUucHJldmlvdXMubmV4dCA9IHRoaXNOb2RlLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzTm9kZS5uZXh0LnByZXZpb3VzID0gdGhpc05vZGUucHJldmlvdXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoX3JldHVybi5zdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IHtMaW5rZWRMaXN0fSIsIi8qKlxuICog5riy5p+T5Zmo5oq96LGh57G7XG4gKi9cbmNsYXNzIEJhc2VSZW5kZXJlciB7XG4gICAgLyoqXG4gICAgICog5a6e5L6L5YyW5LiA5Liq5riy5p+T5Zmo5oq96LGh57G7XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGVsZW1lbnQgLSBFbGVtZW50IOWFg+e0oFxuICAgICAqIEBwYXJhbSB7b3BlbkJTRX5PcHRpb25zfSBvcHRpb25zIC0g5YWo5bGA6YCJ6aG5XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGVsZW1lbnRTaXplIC0g5YWD57Sg5aSn5bCPXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucywgZWxlbWVudFNpemUpIHtcbiAgICAgICAgaWYgKG5ldy50YXJnZXQgPT09IEJhc2VSZW5kZXJlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbml0KCk7IC8v5Yid5aeL5YyWXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmakOiXj+W8ueW5lVxuICAgICAgICAgKiBAcHJpdmF0ZSBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGxldCBfaGlkZSA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpgI/mmI7luqZcbiAgICAgICAgICogQHByaXZhdGUgQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGxldCBfb3BhY2l0eSA9IDAuMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICog5riF6Zmk5bGP5bmV5YaF5a65XG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGVhblNjcmVlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmakOiXj+W8ueW5leOAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX2hpZGUgPSB0cnVlO1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICog5pi+56S65by55bmV44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfaGlkZSA9IGZhbHNlO1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u5by55bmV5LiN6YCP5piO5bqm44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldE9wYWNpdHkgPSBfc2V0T3BhY2l0eTtcblxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u5by55bmV5LiN6YCP5piO5bqm44CCXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfc2V0T3BhY2l0eSgpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9wYWNpdHkgPT09IDEpIGVsZW1lbnQuc3R5bGUub3BhY2l0eSA9ICcnO1xuICAgICAgICAgICAgZWxzZSBlbGVtZW50LnN0eWxlLm9wYWNpdHkgPSBvcHRpb25zLm9wYWNpdHk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W5by55bmV5LiN6YCP5piO5bqm44CCXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IOW8ueW5leS4jemAj+aYjuW6pu+8muWPluWAvOiMg+WbtCAwLjAg5YiwIDEuMO+8jDAuMCDlhajpgI/mmI7vvJsxLjAg5LiN6YCP5piO44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldE9wYWNpdHkgPSAoKSA9PiBfb3BhY2l0eTtcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W5by55bmV5Y+v6KeB5oCn44CCXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSDmjIfnpLrlvLnluZXmmK/lkKblj6/op4HjgIJcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIOiOt+WPluW8ueW5leWPr+ingeaAp+OAglxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRWaXNpYmlsaXR5ID0gKCkgPT4gIV9oaWRlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnu5jliLblh73mlbBcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliJvlu7rlvLnluZXlhYPntKBcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBidWxsZXRTY3JlZW5PblNjcmVlbiAtIOWxj+W5leW8ueW5leWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdEFuZGdldFdpZHRoID0gZnVuY3Rpb24gKGJ1bGxldFNjcmVlbk9uU2NyZWVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliKDpmaTlvLnluZXlhYPntKBcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBidWxsZXRTY3JlZW5PblNjcmVlbiAtIOWxj+W5leW8ueW5leWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWxldGUgPSBmdW5jdGlvbiAoYnVsbGV0U2NyZWVuT25TY3JlZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmHjeaWsOa3u+WKoOW8ueW5lVxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGJ1bGxldFNjcmVlbk9uU2NyZWVuIC0g5bGP5bmV5by55bmV5a+56LGhXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlQ3JlYXRBbmRnZXRXaWR0aCA9IGZ1bmN0aW9uIChidWxsZXRTY3JlZW5PblNjcmVlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICog5qOA5p+l5by55bmV5piv5ZCm6KKr6ZqQ6JePXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBidWxsZXRTY3JlZW5PblNjcmVlbiAtIOWxj+W5leW8ueW5leWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGVja1doZXRoZXJIaWRlID0gKGJ1bGxldFNjcmVlbk9uU2NyZWVuKSA9PiAoYnVsbGV0U2NyZWVuT25TY3JlZW4uYnVsbGV0U2NyZWVuLnR5cGUgJiBvcHRpb25zLmhpZGRlblR5cGVzKSA9PT0gYnVsbGV0U2NyZWVuT25TY3JlZW4uYnVsbGV0U2NyZWVuLnR5cGU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICog6K6+572u5bC65a+4XG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0U2l6ZSA9IHNldFNpemU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9ruWwuuWvuFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gc2V0U2l6ZSgpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHtlbGVtZW50U2l6ZS53aWR0aH1weGA7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IGAke2VsZW1lbnRTaXplLmhlaWdodH1weGA7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zY2FsaW5nICE9IDEpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID1cbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5tc1RyYW5zZm9ybSA9IGBzY2FsZSgke29wdGlvbnMuc2NhbGluZ30sJHtvcHRpb25zLnNjYWxpbmd9KWA7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPVxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybU9yaWdpbiA9XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUubXNUcmFuc2Zvcm1PcmlnaW4gPSBgbGVmdCB0b3BgO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID1cbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5tc1RyYW5zZm9ybSA9XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtT3JpZ2luID1cbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm1PcmlnaW4gPVxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLm1zVHJhbnNmb3JtT3JpZ2luID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yid5aeL5YyWXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICAgICAgc2V0U2l6ZSgpO1xuICAgICAgICAgICAgX3NldE9wYWNpdHkoKTtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBCYXNlUmVuZGVyZXIgfTsiLCJpbXBvcnQgeyBCYXNlUmVuZGVyZXIgfSBmcm9tICcuL2Jhc2VSZW5kZXJlcidcbmltcG9ydCB7IExpbmtlZExpc3QgfSBmcm9tICcuLi9saW5rZWRMaXN0J1xuaW1wb3J0IHsgSGVscGVyIH0gZnJvbSAnLi4vaGVscGVyJ1xuXG4vKipcbiAqIENhbnZhcyDmuLLmn5Plmajmir3osaHnsbtcbiAqL1xuY2xhc3MgQ2FudmFzQmFzZVJlbmRlcmVyIGV4dGVuZHMgQmFzZVJlbmRlcmVyIHtcbiAgICAvKipcbiAgICAgKiDlrp7kvovljJbkuIDkuKogQ2FudmFzIOa4suafk+WZqOaKveixoeexu1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IC0gRWxlbWVudCDlhYPntKBcbiAgICAgKiBAcGFyYW0ge29wZW5CU0V+T3B0aW9uc30gb3B0aW9ucyAtIOWFqOWxgOmAiemhuVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50U2l6ZSAtIOWFg+e0oOWkp+Wwj1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGV2ZW50VHJpZ2dlciAtIOS6i+S7tuW8leWPkeaWueazlVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMsIGVsZW1lbnRTaXplLCBldmVudFRyaWdnZXIpIHtcbiAgICAgICAgaWYgKG5ldy50YXJnZXQgPT09IENhbnZhc0Jhc2VSZW5kZXJlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWxj+W5leS4iueahOW8ueW5lVxuICAgICAgICAgKiBAcHJpdmF0ZSBAdHlwZSB7TGlua2VkTGlzdH1cbiAgICAgICAgICovXG4gICAgICAgIGxldCBfYnVsbGV0U2NyZWVuc09uU2NyZWVuID0gbmV3IExpbmtlZExpc3QoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERQSSDnvKnmlL7mr5TkvovvvIjlgI3mlbDvvIlcbiAgICAgICAgICogQHByaXZhdGUgQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGxldCBfZGV2aWNlUGl4ZWxSYXRpbyA9IEhlbHBlci5nZXREZXZpY2VQaXhlbFJhdGlvKHRydWUpO1xuICAgICAgICBfZGV2aWNlUGl4ZWxSYXRpbyAqPSBvcHRpb25zLnNjYWxpbmc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnlLvluIPlhYPntKBcbiAgICAgICAgICogQHByaXZhdGUgQHR5cGUge0VsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgX2NhbnZhcyA9IGluaXQoKTtcbiAgICAgICAgc3VwZXIoX2NhbnZhcywgb3B0aW9ucywgZWxlbWVudFNpemUpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmuIXpmaTlsY/luZXlhoXlrrlcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGVhblNjcmVlbiA9IF9idWxsZXRTY3JlZW5zT25TY3JlZW4uY2xlYW47XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIm+W7uuW8ueW5leWFg+e0oFxuICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGJ1bGxldFNjcmVlbk9uU2NyZWVuIC0g5bGP5bmV5by55bmV5a+56LGhXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWF0QW5kZ2V0V2lkdGggPSBmdW5jdGlvbiAoYnVsbGV0U2NyZWVuT25TY3JlZW4pIHtcbiAgICAgICAgICAgIGxldCBidWxsZXRTY3JlZW4gPSBidWxsZXRTY3JlZW5PblNjcmVlbi5idWxsZXRTY3JlZW47XG4gICAgICAgICAgICBsZXQgaGlkZUNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgbGV0IGhpZGVDYW52YXNDb250ZXh0ID0gaGlkZUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICBoaWRlQ2FudmFzQ29udGV4dC5mb250ID0gYCR7YnVsbGV0U2NyZWVuLnN0eWxlLmZvbnRXZWlnaHR9ICR7YnVsbGV0U2NyZWVuT25TY3JlZW4uc2l6ZX1weCAke2J1bGxldFNjcmVlbi5zdHlsZS5mb250RmFtaWx5fWA7XG4gICAgICAgICAgICBidWxsZXRTY3JlZW5PblNjcmVlbi53aWR0aCA9IGhpZGVDYW52YXNDb250ZXh0Lm1lYXN1cmVUZXh0KGJ1bGxldFNjcmVlbi50ZXh0KS53aWR0aDsgLy/lvLnluZXnmoTlrr3luqbvvJrlg4/ntKBcblxuICAgICAgICAgICAgaGlkZUNhbnZhcy53aWR0aCA9IChidWxsZXRTY3JlZW5PblNjcmVlbi53aWR0aCArIDgpICogX2RldmljZVBpeGVsUmF0aW87XG4gICAgICAgICAgICBoaWRlQ2FudmFzLmhlaWdodCA9IChidWxsZXRTY3JlZW5PblNjcmVlbi5oZWlnaHQgKyA4KSAqIF9kZXZpY2VQaXhlbFJhdGlvO1xuXG4gICAgICAgICAgICBoaWRlQ2FudmFzQ29udGV4dC5zaGFkb3dDb2xvciA9ICdibGFjayc7XG4gICAgICAgICAgICBoaWRlQ2FudmFzQ29udGV4dC5mb250ID0gYCR7YnVsbGV0U2NyZWVuLnN0eWxlLmZvbnRXZWlnaHR9ICR7YnVsbGV0U2NyZWVuT25TY3JlZW4uc2l6ZSAqIF9kZXZpY2VQaXhlbFJhdGlvfXB4ICR7YnVsbGV0U2NyZWVuLnN0eWxlLmZvbnRGYW1pbHl9YDtcbiAgICAgICAgICAgIGxldCB0ZXh0WCA9IDQgKiBfZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgICAgIGxldCB0ZXh0WSA9ICg0ICsgYnVsbGV0U2NyZWVuT25TY3JlZW4uc2l6ZSAqIDAuOCkgKiBfZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgICAgIGlmIChidWxsZXRTY3JlZW4uc3R5bGUuY29sb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGhpZGVDYW52YXNDb250ZXh0LnNoYWRvd0JsdXIgPSAoYnVsbGV0U2NyZWVuLnN0eWxlLnNoYWRvd0JsdXIgKyAwLjUpICogX2RldmljZVBpeGVsUmF0aW87XG4gICAgICAgICAgICAgICAgaGlkZUNhbnZhc0NvbnRleHQuZmlsbFN0eWxlID0gYnVsbGV0U2NyZWVuLnN0eWxlLmNvbG9yO1xuICAgICAgICAgICAgICAgIGhpZGVDYW52YXNDb250ZXh0LmZpbGxUZXh0KGJ1bGxldFNjcmVlbi50ZXh0LCB0ZXh0WCwgdGV4dFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJ1bGxldFNjcmVlbi5zdHlsZS5ib3JkZXJDb2xvciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaGlkZUNhbnZhc0NvbnRleHQuc2hhZG93Qmx1ciA9IDA7XG4gICAgICAgICAgICAgICAgaGlkZUNhbnZhc0NvbnRleHQubGluZVdpZHRoID0gMC41ICogX2RldmljZVBpeGVsUmF0aW87XG4gICAgICAgICAgICAgICAgaGlkZUNhbnZhc0NvbnRleHQuc3Ryb2tlU3R5bGUgPSBidWxsZXRTY3JlZW4uc3R5bGUuYm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgICAgaGlkZUNhbnZhc0NvbnRleHQuc3Ryb2tlVGV4dChidWxsZXRTY3JlZW4udGV4dCwgdGV4dFgsIHRleHRZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChidWxsZXRTY3JlZW4uc3R5bGUuYm94Q29sb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGhpZGVDYW52YXNDb250ZXh0LnNoYWRvd0JsdXIgPSAwO1xuICAgICAgICAgICAgICAgIGhpZGVDYW52YXNDb250ZXh0LmxpbmVXaWR0aCA9IF9kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICAgICAgICAgIGhpZGVDYW52YXNDb250ZXh0LnN0cm9rZVN0eWxlID0gYnVsbGV0U2NyZWVuLnN0eWxlLmJveENvbG9yO1xuICAgICAgICAgICAgICAgIGhpZGVDYW52YXNDb250ZXh0LnN0cm9rZVJlY3QoX2RldmljZVBpeGVsUmF0aW8sIF9kZXZpY2VQaXhlbFJhdGlvLCBoaWRlQ2FudmFzLndpZHRoIC0gX2RldmljZVBpeGVsUmF0aW8sIGhpZGVDYW52YXMuaGVpZ2h0IC0gX2RldmljZVBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVsbGV0U2NyZWVuT25TY3JlZW4uaGlkZUNhbnZhcyA9IGhpZGVDYW52YXM7XG5cbiAgICAgICAgICAgIGlmIChfYnVsbGV0U2NyZWVuc09uU2NyZWVuLmdldExlbmd0aCgpID09PSAwKSBfYnVsbGV0U2NyZWVuc09uU2NyZWVuLnB1c2goYnVsbGV0U2NyZWVuT25TY3JlZW4sIHRydWUpO1xuICAgICAgICAgICAgbGV0IGZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIF9idWxsZXRTY3JlZW5zT25TY3JlZW4uZm9yRWFjaCgoX2J1bGxldFNjcmVlbk9uU2NyZWVuKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKF9idWxsZXRTY3JlZW5PblNjcmVlbi5idWxsZXRTY3JlZW4ubGF5ZXIgPD0gYnVsbGV0U2NyZWVuLmxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkOiB7IGVsZW1lbnQ6IGJ1bGxldFNjcmVlbk9uU2NyZWVuLCBhZGRUb1VwOiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKCFmbGFnKSBfYnVsbGV0U2NyZWVuc09uU2NyZWVuLnB1c2goYnVsbGV0U2NyZWVuT25TY3JlZW4sIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliKDpmaTlvLnluZXlhYPntKBcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBidWxsZXRTY3JlZW5PblNjcmVlbiAtIOWxj+W5leW8ueW5leWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWxldGUgPSAoYnVsbGV0U2NyZWVuT25TY3JlZW4pID0+IF9idWxsZXRTY3JlZW5zT25TY3JlZW4uZm9yRWFjaCgoX2J1bGxldFNjcmVlbk9uU2NyZWVuKSA9PlxuICAgICAgICAgICAgX2J1bGxldFNjcmVlbk9uU2NyZWVuID09PSBidWxsZXRTY3JlZW5PblNjcmVlbiA/IHsgcmVtb3ZlOiB0cnVlLCBzdG9wOiB0cnVlIH0gOiBudWxsLCB0cnVlKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICog6YeN5paw5re75Yqg5by55bmVXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gYnVsbGV0U2NyZWVuT25TY3JlZW4gLSDlsY/luZXlvLnluZXlr7nosaFcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVDcmVhdEFuZGdldFdpZHRoID0gZnVuY3Rpb24gKGJ1bGxldFNjcmVlbk9uU2NyZWVuKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZShidWxsZXRTY3JlZW5PblNjcmVlbik7XG4gICAgICAgICAgICB0aGlzLmNyZWF0QW5kZ2V0V2lkdGgoYnVsbGV0U2NyZWVuT25TY3JlZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IF9zZXRTaXplID0gdGhpcy5zZXRTaXplO1xuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u5bC65a+4XG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3NldFNpemUoKTtcbiAgICAgICAgICAgIF9kZXZpY2VQaXhlbFJhdGlvID0gSGVscGVyLmdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICAgICAgICAgIF9kZXZpY2VQaXhlbFJhdGlvICo9IG9wdGlvbnMuc2NhbGluZztcbiAgICAgICAgICAgIF9jYW52YXMud2lkdGggPSBlbGVtZW50U2l6ZS53aWR0aCAqIF9kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICAgICAgX2NhbnZhcy5oZWlnaHQgPSBlbGVtZW50U2l6ZS5oZWlnaHQgKiBfZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5bnvKnmlL7mr5TkvotcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn0g57yp5pS+5q+U5L6LXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldERldmljZVBpeGVsUmF0aW8gPSAoKSA9PiBfZGV2aWNlUGl4ZWxSYXRpbztcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W55S75biD5a+56LGhXG4gICAgICAgICAqIEByZXR1cm5zIHtFbGVtZW50fSDnlLvluIPlr7nosaFcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0Q2FudmFzID0gKCkgPT4gX2NhbnZhcztcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W5bGP5bmV5by55bmV5a+56LGhXG4gICAgICAgICAqIEByZXR1cm5zIHtMaW5rZWRMaXN0fSDnlLvluIPlr7nosaFcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0QnVsbGV0U2NyZWVuc09uU2NyZWVuID0gKCkgPT4gX2J1bGxldFNjcmVlbnNPblNjcmVlbjtcblxuICAgICAgICAvKipcbiAgICAgICAgICog5re75YqgQ2FudmFzXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEByZXR1cm5zIHtFbGVtZW50fSDnlLvluIPlr7nosaFcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgICAgICBsZXQgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7IC8vY2FudmFz5a+56LGhXG4gICAgICAgICAgICBIZWxwZXIuY2xlYW5FbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gZWxlbWVudFNpemUud2lkdGggKiBfZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBlbGVtZW50U2l6ZS5oZWlnaHQgKiBfZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgICAgIHJlZ2lzdGVyRXZlbnQoY2FudmFzKTsgLy/ms6jlhozkuovku7blk43lupTnqIvluo9cbiAgICAgICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgX2NoZWNrV2hldGhlckhpZGUgPSB0aGlzLmNoZWNrV2hldGhlckhpZGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDms6jlhozkuovku7blk43lupTnqIvluo9cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0g5YWD57SgXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiByZWdpc3RlckV2ZW50KGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldEJ1bGxldFNjcmVlbk9uU2NyZWVuQnlMb2NhdGlvbihsb2NhdGlvbikge1xuICAgICAgICAgICAgICAgIGxldCBfYnVsbGV0U2NyZWVuT25TY3JlZW4gPSBudWxsO1xuICAgICAgICAgICAgICAgIF9idWxsZXRTY3JlZW5zT25TY3JlZW4uZm9yRWFjaChmdW5jdGlvbiAoYnVsbGV0U2NyZWVuT25TY3JlZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jaGVja1doZXRoZXJIaWRlKGJ1bGxldFNjcmVlbk9uU2NyZWVuKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBsZXQgeDEgPSBidWxsZXRTY3JlZW5PblNjcmVlbi54IC0gNDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHgyID0geDEgKyBidWxsZXRTY3JlZW5PblNjcmVlbi53aWR0aCArIDg7XG4gICAgICAgICAgICAgICAgICAgIGxldCB5MSA9IGJ1bGxldFNjcmVlbk9uU2NyZWVuLmFjdHVhbFkgLSA0O1xuICAgICAgICAgICAgICAgICAgICBsZXQgeTIgPSB5MSArIGJ1bGxldFNjcmVlbk9uU2NyZWVuLmhlaWdodCArIDg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbi54ID49IHgxICYmIGxvY2F0aW9uLnggPD0geDIgJiYgbG9jYXRpb24ueSA+PSB5MSAmJiBsb2NhdGlvbi55IDw9IHkyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYnVsbGV0U2NyZWVuT25TY3JlZW4gPSBidWxsZXRTY3JlZW5PblNjcmVlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0b3A6IHRydWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2J1bGxldFNjcmVlbk9uU2NyZWVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0TG9jYXRpb24oZSkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldE9mZnNldFRvcChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXRUb3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRUb3AgKz0gZWxlbWVudC5vZmZzZXRUb3A7XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKChlbGVtZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQpICE9IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0VG9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRPZmZzZXRMZWZ0KGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldExlZnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0ICs9IGVsZW1lbnQub2Zmc2V0TGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoKGVsZW1lbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudCkgIT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXRMZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGUub2Zmc2V0WCA9PT0gJ3VuZGVmaW5lZCcgfHwgZS5vZmZzZXRYID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZS5sYXllclggPT09ICd1bmRlZmluZWQnIHx8IGUubGF5ZXJYID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGUucGFnZVggPT09ICd1bmRlZmluZWQnIHx8IGUucGFnZVggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZG9jID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnBhZ2VYID0gZS5jbGllbnRYICsgKGRvYyAmJiBkb2Muc2Nyb2xsTGVmdCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsTGVmdCB8fCAwKSAtIChkb2MgJiYgZG9jLmNsaWVudExlZnQgfHwgYm9keSAmJiBib2R5LmNsaWVudExlZnQgfHwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wYWdlWSA9IGUuY2xpZW50WSArIChkb2MgJiYgZG9jLnNjcm9sbFRvcCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsVG9wIHx8IDApIC0gKGRvYyAmJiBkb2MuY2xpZW50VG9wIHx8IGJvZHkgJiYgYm9keS5jbGllbnRUb3AgfHwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlLmxheWVyWCA9IGUucGFnZVggLSBnZXRPZmZzZXRMZWZ0KGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUubGF5ZXJZID0gZS5wYWdlWSAtIGdldE9mZnNldFRvcChlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZS5vZmZzZXRYID0gZS5sYXllclggLSBlLnRhcmdldC5jbGllbnRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICBlLm9mZnNldFkgPSBlLmxheWVyWSAtIGUudGFyZ2V0LmNsaWVudFRvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgeDogZS5vZmZzZXRYLFxuICAgICAgICAgICAgICAgICAgICB5OiBlLm9mZnNldFlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL+S4iuS4i+aWh+iPnOWNlVxuICAgICAgICAgICAgZWxlbWVudC5vbmNvbnRleHRtZW51ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgYnVsbGV0U2NyZWVuT25TY3JlZW4gPSBnZXRCdWxsZXRTY3JlZW5PblNjcmVlbkJ5TG9jYXRpb24oZ2V0TG9jYXRpb24oZSkpO1xuICAgICAgICAgICAgICAgIGlmIChidWxsZXRTY3JlZW5PblNjcmVlbilcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRUcmlnZ2VyKCdjb250ZXh0bWVudScsIGJ1bGxldFNjcmVlbk9uU2NyZWVuLCBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy/ljZXlh7tcbiAgICAgICAgICAgIGVsZW1lbnQub25jbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJ1bGxldFNjcmVlbk9uU2NyZWVuID0gZ2V0QnVsbGV0U2NyZWVuT25TY3JlZW5CeUxvY2F0aW9uKGdldExvY2F0aW9uKGUpKTtcbiAgICAgICAgICAgICAgICBpZiAoYnVsbGV0U2NyZWVuT25TY3JlZW4pXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50VHJpZ2dlcignY2xpY2snLCBidWxsZXRTY3JlZW5PblNjcmVlbiwgZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8v6byg5qCH56e75YqoXG4gICAgICAgICAgICBlbGVtZW50Lm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgYnVsbGV0U2NyZWVuT25TY3JlZW4gPSBnZXRCdWxsZXRTY3JlZW5PblNjcmVlbkJ5TG9jYXRpb24oZ2V0TG9jYXRpb24oZSkpO1xuICAgICAgICAgICAgICAgIF9idWxsZXRTY3JlZW5zT25TY3JlZW4uZm9yRWFjaCgoX2J1bGxldFNjcmVlbk9uU2NyZWVuKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChidWxsZXRTY3JlZW5PblNjcmVlbiAhPSBfYnVsbGV0U2NyZWVuT25TY3JlZW4gJiYgX2J1bGxldFNjcmVlbk9uU2NyZWVuLm1vdXNlaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9idWxsZXRTY3JlZW5PblNjcmVlbi5tb3VzZWluID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmN1cnNvciA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRUcmlnZ2VyKCdtb3VzZWxlYXZlJywgX2J1bGxldFNjcmVlbk9uU2NyZWVuLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmIChidWxsZXRTY3JlZW5PblNjcmVlbiA9PT0gbnVsbCB8fCBidWxsZXRTY3JlZW5PblNjcmVlbi5tb3VzZWluKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnVsbGV0U2NyZWVuT25TY3JlZW4ubW91c2VpbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5jdXJzb3IgPSBvcHRpb25zLmN1cnNvck9uTW91c2VPdmVyO1xuICAgICAgICAgICAgICAgIGV2ZW50VHJpZ2dlcignbW91c2VlbnRlcicsIGJ1bGxldFNjcmVlbk9uU2NyZWVuLCBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL+m8oOagh+emu+W8gFxuICAgICAgICAgICAgZWxlbWVudC5vbm1vdXNlb3V0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBfYnVsbGV0U2NyZWVuc09uU2NyZWVuLmZvckVhY2goKF9idWxsZXRTY3JlZW5PblNjcmVlbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2J1bGxldFNjcmVlbk9uU2NyZWVuLm1vdXNlaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9idWxsZXRTY3JlZW5PblNjcmVlbi5tb3VzZWluID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmN1cnNvciA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRUcmlnZ2VyKCdtb3VzZWxlYXZlJywgX2J1bGxldFNjcmVlbk9uU2NyZWVuLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBDYW52YXNCYXNlUmVuZGVyZXIgfTsiLCJpbXBvcnQgeyBDYW52YXNCYXNlUmVuZGVyZXIgfSBmcm9tICcuL2NhbnZhc0Jhc2VSZW5kZXJlcidcbmltcG9ydCB7IEJyb3dzZXJOb3RTdXBwb3J0RXJyb3IgfSBmcm9tICcuLi8uLi9icm93c2VyTm90U3VwcG9ydEVycm9yJ1xuXG4vKipcbiAqIENhbnZhcyDmuLLmn5PlmajnsbtcbiAqL1xuY2xhc3MgQ2FudmFzUmVuZGVyZXIgZXh0ZW5kcyBDYW52YXNCYXNlUmVuZGVyZXIge1xuICAgIC8qKlxuICAgICAqIOWunuS+i+WMluS4gOS4qiBDYW52YXMg5riy5p+T5Zmo57G7XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGVsZW1lbnQgLSBFbGVtZW50IOWFg+e0oFxuICAgICAqIEBwYXJhbSB7b3BlbkJTRX5PcHRpb25zfSBvcHRpb25zIC0g5YWo5bGA6YCJ6aG5XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGVsZW1lbnRTaXplIC0g5YWD57Sg5aSn5bCPXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRUcmlnZ2VyIC0g5LqL5Lu25byV5Y+R5pa55rOVXG4gICAgICogQHRocm93cyB7b3BlbkJTRS5Ccm93c2VyTm90U3VwcG9ydEVycm9yfSDmtY/op4jlmajkuI3mlK/mjIHnibnlrprmuLLmn5PmqKHlvI/ml7blvJXlj5HplJnor69cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBvcHRpb25zLCBlbGVtZW50U2l6ZSwgZXZlbnRUcmlnZ2VyKSB7XG4gICAgICAgIHN1cHBvcnRDaGVjaygpOyAvL+a1j+iniOWZqOaUr+aMgeajgOa1i1xuICAgICAgICBzdXBlcihlbGVtZW50LCBvcHRpb25zLCBlbGVtZW50U2l6ZSwgZXZlbnRUcmlnZ2VyKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICog5bGP5bmV5LiK55qE5by55bmVXG4gICAgICAgICAqIEBwcml2YXRlIEB0eXBlIHtMaW5rZWRMaXN0fVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IF9idWxsZXRTY3JlZW5zT25TY3JlZW4gPSB0aGlzLmdldEJ1bGxldFNjcmVlbnNPblNjcmVlbigpO1xuXG4gICAgICAgIGxldCBfY2xlYW5TY3JlZW4gPSB0aGlzLmNsZWFuU2NyZWVuO1xuICAgICAgICAvKipcbiAgICAgICAgICog5riF6Zmk5bGP5bmV5YaF5a65XG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGVhblNjcmVlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF9jbGVhblNjcmVlbigpO1xuICAgICAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKCk7XG4gICAgICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnu5jliLblh73mlbBcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsZXQgY2FudmFzID0gdGhpcy5nZXRDYW52YXMoKTtcbiAgICAgICAgICAgIGxldCBkZXZpY2VQaXhlbFJhdGlvID0gdGhpcy5nZXREZXZpY2VQaXhlbFJhdGlvKCk7XG4gICAgICAgICAgICBsZXQgY2FudmFzQ29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIF9idWxsZXRTY3JlZW5zT25TY3JlZW4uZm9yRWFjaCgoYnVsbGV0U2NyZWVuT25TY3JlZW4pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja1doZXRoZXJIaWRlKGJ1bGxldFNjcmVlbk9uU2NyZWVuKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuZHJhd0ltYWdlKGJ1bGxldFNjcmVlbk9uU2NyZWVuLmhpZGVDYW52YXMsIFxuICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKChidWxsZXRTY3JlZW5PblNjcmVlbi54IC0gNCkgKiBkZXZpY2VQaXhlbFJhdGlvKSwgXG4gICAgICAgICAgICAgICAgICAgIE1hdGgucm91bmQoKGJ1bGxldFNjcmVlbk9uU2NyZWVuLmFjdHVhbFkgLSA0KSAqIGRldmljZVBpeGVsUmF0aW8pLCBcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5yb3VuZCgoYnVsbGV0U2NyZWVuT25TY3JlZW4ud2lkdGggKyA4KSAqIGRldmljZVBpeGVsUmF0aW8pLCBcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5yb3VuZCgoYnVsbGV0U2NyZWVuT25TY3JlZW4uaGVpZ2h0ICsgOCkgKiBkZXZpY2VQaXhlbFJhdGlvKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmtY/op4jlmajmlK/mjIHmo4DmtYtcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHRocm93cyB7b3BlbkJTRS5Ccm93c2VyTm90U3VwcG9ydEVycm9yfSDmtY/op4jlmajkuI3mlK/mjIHnibnlrprmuLLmn5PmqKHlvI/ml7blvJXlj5HplJnor69cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHN1cHBvcnRDaGVjaygpIHtcbiAgICAgICAgICAgIGxldCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgLy9jYW52YXPlr7nosaFcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FudmFzLmdldENvbnRleHQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEJyb3dzZXJOb3RTdXBwb3J0RXJyb3IoJ0NhbnZhcycpO1xuICAgICAgICAgICAgbGV0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0ID09PSBudWxsKSB0aHJvdyBuZXcgQnJvd3Nlck5vdFN1cHBvcnRFcnJvcignQ2FudmFzIDJEJyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuZmlsbFRleHQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEJyb3dzZXJOb3RTdXBwb3J0RXJyb3IoJ0NhbnZhcyAyRCBmaWxsVGV4dCBGdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBDYW52YXNSZW5kZXJlciB9OyIsImltcG9ydCB7IEJhc2VSZW5kZXJlciB9IGZyb20gJy4vYmFzZVJlbmRlcmVyJ1xuaW1wb3J0IHsgQnJvd3Nlck5vdFN1cHBvcnRFcnJvciB9IGZyb20gJy4uLy4uL2Jyb3dzZXJOb3RTdXBwb3J0RXJyb3InXG5pbXBvcnQgeyBIZWxwZXIgfSBmcm9tICcuLi9oZWxwZXInO1xuXG4vKipcbiAqIENTUzMg5riy5p+T5Zmo57G7XG4gKi9cbmNsYXNzIENTUzNSZW5kZXJlciBleHRlbmRzIEJhc2VSZW5kZXJlciB7XG4gICAgLyoqXG4gICAgICog5a6e5L6L5YyW5LiA5LiqIENTUzMg5riy5p+T5Zmo57G7XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGVsZW1lbnQgLSBFbGVtZW50IOWFg+e0oFxuICAgICAqIEBwYXJhbSB7b3BlbkJTRX5PcHRpb25zfSBvcHRpb25zIC0g5YWo5bGA6YCJ6aG5XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGVsZW1lbnRTaXplIC0g5YWD57Sg5aSn5bCPXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRUcmlnZ2VyIC0g5LqL5Lu25byV5Y+R5pa55rOVXG4gICAgICogQHRocm93cyB7b3BlbkJTRS5Ccm93c2VyTm90U3VwcG9ydEVycm9yfSDmtY/op4jlmajkuI3mlK/mjIHnibnlrprmuLLmn5PmqKHlvI/ml7blvJXlj5HplJnor69cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBvcHRpb25zLCBlbGVtZW50U2l6ZSwgZXZlbnRUcmlnZ2VyKSB7XG4gICAgICAgIHN1cHBvcnRDaGVjaygpOyAvL+a1j+iniOWZqOaUr+aMgeajgOa1i1xuICAgICAgICBsZXQgX2RpdiA9IGluaXQoKTtcbiAgICAgICAgc3VwZXIoX2Rpdiwgb3B0aW9ucywgZWxlbWVudFNpemUpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmuIXpmaTlsY/luZXlhoXlrrlcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsZWFuU2NyZWVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgSGVscGVyLmNsZWFuRWxlbWVudChfZGl2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnu5jliLblh73mlbBcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBidWxsZXRTY3JlZW5EaXYgb2YgX2Rpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZGl2JykpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGJ1bGxldFNjcmVlbkRpdi5idWxsZXRTY3JlZW5PblNjcmVlbiAhPSAnb2JqZWN0JykgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tXaGV0aGVySGlkZShidWxsZXRTY3JlZW5EaXYuYnVsbGV0U2NyZWVuT25TY3JlZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1bGxldFNjcmVlbkRpdi5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWxsZXRTY3JlZW5EaXYuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICAgICAgICAgICAgICBidWxsZXRTY3JlZW5EaXYuc3R5bGUudHJhbnNmb3JtID1cbiAgICAgICAgICAgICAgICAgICAgYnVsbGV0U2NyZWVuRGl2LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9XG4gICAgICAgICAgICAgICAgICAgIGJ1bGxldFNjcmVlbkRpdi5zdHlsZS5tc1RyYW5zZm9ybSA9XG4gICAgICAgICAgICAgICAgICAgIGB0cmFuc2xhdGUoJHtNYXRoLnJvdW5kKGJ1bGxldFNjcmVlbkRpdi5idWxsZXRTY3JlZW5PblNjcmVlbi54IC0gNCl9cHgsJHtNYXRoLnJvdW5kKGJ1bGxldFNjcmVlbkRpdi5idWxsZXRTY3JlZW5PblNjcmVlbi5hY3R1YWxZIC0gNCl9cHgpYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliJvlu7rlvLnluZXlhYPntKBcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBidWxsZXRTY3JlZW5PblNjcmVlbiAtIOWxj+W5leW8ueW5leWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdEFuZGdldFdpZHRoID0gZnVuY3Rpb24gKGJ1bGxldFNjcmVlbk9uU2NyZWVuKSB7XG4gICAgICAgICAgICBsZXQgYnVsbGV0U2NyZWVuID0gYnVsbGV0U2NyZWVuT25TY3JlZW4uYnVsbGV0U2NyZWVuO1xuICAgICAgICAgICAgbGV0IGJ1bGxldFNjcmVlbkRpdiA9IGJ1bGxldFNjcmVlbk9uU2NyZWVuLmRpdiA/IGJ1bGxldFNjcmVlbk9uU2NyZWVuLmRpdiA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgYnVsbGV0U2NyZWVuRGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgIGJ1bGxldFNjcmVlbkRpdi5zdHlsZS53aGl0ZVNwYWNlID0gJ25vd3JhcCc7XG4gICAgICAgICAgICBidWxsZXRTY3JlZW5EaXYuc3R5bGUuZm9udFdlaWdodCA9IGJ1bGxldFNjcmVlbi5zdHlsZS5mb250V2VpZ2h0O1xuICAgICAgICAgICAgYnVsbGV0U2NyZWVuRGl2LnN0eWxlLmZvbnRTaXplID0gYCR7YnVsbGV0U2NyZWVuT25TY3JlZW4uc2l6ZX1weGA7XG4gICAgICAgICAgICBidWxsZXRTY3JlZW5EaXYuc3R5bGUuZm9udEZhbWlseSA9IGJ1bGxldFNjcmVlbi5zdHlsZS5mb250RmFtaWx5O1xuICAgICAgICAgICAgYnVsbGV0U2NyZWVuRGl2LnN0eWxlLmxpbmVIZWlnaHQgPSBgJHtidWxsZXRTY3JlZW5PblNjcmVlbi5zaXplfXB4YDtcbiAgICAgICAgICAgIGJ1bGxldFNjcmVlbkRpdi5zdHlsZS5jb2xvciA9IGJ1bGxldFNjcmVlbi5zdHlsZS5jb2xvcjtcbiAgICAgICAgICAgIGlmIChidWxsZXRTY3JlZW4uc3R5bGUuc2hhZG93Qmx1ciAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGJ1bGxldFNjcmVlbkRpdi5zdHlsZS50ZXh0U2hhZG93ID0gYDAgMCAke2J1bGxldFNjcmVlbi5zdHlsZS5zaGFkb3dCbHVyfXB4IGJsYWNrYDtcbiAgICAgICAgICAgIGlmIChidWxsZXRTY3JlZW4uc3R5bGUuYm9yZGVyQ29sb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJ1bGxldFNjcmVlbkRpdi5zdHlsZS50ZXh0U3Ryb2tlID0gYnVsbGV0U2NyZWVuRGl2LnN0eWxlLndlYmtpdFRleHRTdHJva2UgPSBgMC41cHhgO1xuICAgICAgICAgICAgICAgIGJ1bGxldFNjcmVlbkRpdi5zdHlsZS50ZXh0U3Ryb2tlQ29sb3IgPSBidWxsZXRTY3JlZW5EaXYuc3R5bGUud2Via2l0VGV4dFN0cm9rZUNvbG9yID0gYnVsbGV0U2NyZWVuLnN0eWxlLmJvcmRlckNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJ1bGxldFNjcmVlbi5zdHlsZS5ib3hDb2xvciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYnVsbGV0U2NyZWVuRGl2LnN0eWxlLnBhZGRpbmcgPSAnM3B4JztcbiAgICAgICAgICAgICAgICBidWxsZXRTY3JlZW5EaXYuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCc7XG4gICAgICAgICAgICAgICAgYnVsbGV0U2NyZWVuRGl2LnN0eWxlLmJvcmRlckNvbG9yID0gYnVsbGV0U2NyZWVuLnN0eWxlLmJveENvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVsbGV0U2NyZWVuRGl2LnN0eWxlLnBhZGRpbmcgPSAnNHB4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEhlbHBlci5jbGVhbkVsZW1lbnQoYnVsbGV0U2NyZWVuRGl2KTtcbiAgICAgICAgICAgIGJ1bGxldFNjcmVlbkRpdi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShidWxsZXRTY3JlZW4udGV4dCkpO1xuICAgICAgICAgICAgYnVsbGV0U2NyZWVuRGl2LmJ1bGxldFNjcmVlbk9uU2NyZWVuID0gYnVsbGV0U2NyZWVuT25TY3JlZW47XG4gICAgICAgICAgICBpbnNlcnRFbGVtZW50KGJ1bGxldFNjcmVlbkRpdik7IC8vaW5zZXJ0XG4gICAgICAgICAgICBidWxsZXRTY3JlZW5PblNjcmVlbi53aWR0aCA9IGJ1bGxldFNjcmVlbkRpdi5jbGllbnRXaWR0aCAtIDg7IC8v5by55bmV55qE5a695bqm77ya5YOP57SgXG4gICAgICAgICAgICBidWxsZXRTY3JlZW5PblNjcmVlbi5kaXYgPSBidWxsZXRTY3JlZW5EaXY7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgKiDliKDpmaTlvLnluZXlhYPntKBcbiAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gYnVsbGV0U2NyZWVuT25TY3JlZW4gLSDlsY/luZXlvLnluZXlr7nosaFcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWxldGUgPSBmdW5jdGlvbiAoYnVsbGV0U2NyZWVuT25TY3JlZW4pIHtcbiAgICAgICAgICAgIF9kaXYucmVtb3ZlQ2hpbGQoYnVsbGV0U2NyZWVuT25TY3JlZW4uZGl2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDph43mlrDmt7vliqDlvLnluZVcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBidWxsZXRTY3JlZW5PblNjcmVlbiAtIOWxj+W5leW8ueW5leWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZUNyZWF0QW5kZ2V0V2lkdGggPSBmdW5jdGlvbiAoYnVsbGV0U2NyZWVuT25TY3JlZW4pIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlKGJ1bGxldFNjcmVlbk9uU2NyZWVuKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRBbmRnZXRXaWR0aChidWxsZXRTY3JlZW5PblNjcmVlbik7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICog5re75YqgRGl2XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEByZXR1cm5zIHtFbGVtZW50fSBEaXZcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgICAgICBsZXQgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7IC8vRElWXG4gICAgICAgICAgICBIZWxwZXIuY2xlYW5FbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICAgICAgZGl2LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICBkaXYuc3R5bGUucGFkZGluZyA9ICcwJztcbiAgICAgICAgICAgIGRpdi5zdHlsZS5tYXJnaW4gPSAnMCc7XG4gICAgICAgICAgICBkaXYuc3R5bGUudXNlclNlbGVjdCA9XG4gICAgICAgICAgICAgICAgZGl2LnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPVxuICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5tc1VzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgICAgICAgICBkaXYuc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnO1xuICAgICAgICAgICAgcmVnaXN0ZXJFdmVudChkaXYpOyAvL+azqOWGjOS6i+S7tuWTjeW6lOeoi+W6j1xuICAgICAgICAgICAgcmV0dXJuIGRpdjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmtY/op4jlmajmlK/mjIHmo4DmtYtcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHRocm93cyB7b3BlbkJTRS5Ccm93c2VyTm90U3VwcG9ydEVycm9yfSDmtY/op4jlmajkuI3mlK/mjIHnibnlrprmuLLmn5PmqKHlvI/ml7blvJXlj5HplJnor69cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHN1cHBvcnRDaGVjaygpIHtcbiAgICAgICAgICAgIGxldCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHR5cGVvZiBzdHlsZS50cmFuc2Zvcm0gPT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHN0eWxlLm1zVHJhbnNmb3JtID09PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBzdHlsZS53ZWJraXRUcmFuc2Zvcm0gPT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICApIHRocm93IG5ldyBCcm93c2VyTm90U3VwcG9ydEVycm9yKCdDU1MzIHRyYW5zZm9ybScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOazqOWGjOS6i+S7tuWTjeW6lOeoi+W6j1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSDlhYPntKBcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHJlZ2lzdGVyRXZlbnQoZWxlbWVudCkge1xuICAgICAgICAgICAgLy/kuIrkuIvmlofoj5zljZVcbiAgICAgICAgICAgIGVsZW1lbnQub25jb250ZXh0bWVudSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0ICE9IHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50VHJpZ2dlcignY29udGV4dG1lbnUnLCBlLnRhcmdldC5idWxsZXRTY3JlZW5PblNjcmVlbiwgZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8v5Y2V5Ye7XG4gICAgICAgICAgICBlbGVtZW50Lm9uY2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLnRhcmdldCAhPSB0aGlzKVxuICAgICAgICAgICAgICAgICAgICBldmVudFRyaWdnZXIoJ2NsaWNrJywgZS50YXJnZXQuYnVsbGV0U2NyZWVuT25TY3JlZW4sIGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvL+m8oOagh+enu+WKqFxuICAgICAgICAgICAgZWxlbWVudC5vbm1vdXNlbW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJ1bGxldFNjcmVlbk9uU2NyZWVuID0gZS50YXJnZXQuYnVsbGV0U2NyZWVuT25TY3JlZW47XG4gICAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0ID09PSB0aGlzIHx8IGJ1bGxldFNjcmVlbk9uU2NyZWVuLm1vdXNlaW4pIHJldHVybjtcbiAgICAgICAgICAgICAgICBidWxsZXRTY3JlZW5PblNjcmVlbi5tb3VzZWluID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlLnRhcmdldC5zdHlsZS5jdXJzb3IgPSBvcHRpb25zLmN1cnNvck9uTW91c2VPdmVyO1xuICAgICAgICAgICAgICAgIGV2ZW50VHJpZ2dlcignbW91c2VlbnRlcicsIGJ1bGxldFNjcmVlbk9uU2NyZWVuLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8v6byg5qCH56a75byAXG4gICAgICAgICAgICBlbGVtZW50Lm9ubW91c2VvdXQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGxldCBidWxsZXRTY3JlZW5PblNjcmVlbiA9IGUudGFyZ2V0LmJ1bGxldFNjcmVlbk9uU2NyZWVuO1xuICAgICAgICAgICAgICAgIGlmIChlLnRhcmdldCA9PT0gdGhpcyB8fCAhYnVsbGV0U2NyZWVuT25TY3JlZW4ubW91c2VpbikgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGJ1bGxldFNjcmVlbk9uU2NyZWVuLm1vdXNlaW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlLnRhcmdldC5zdHlsZS5jdXJzb3IgPSAnJztcbiAgICAgICAgICAgICAgICBldmVudFRyaWdnZXIoJ21vdXNlbGVhdmUnLCBidWxsZXRTY3JlZW5PblNjcmVlbiwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICog5oyJIGxheWVyIOaPkuWFpeWFg+e0oFxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSDlhYPntKBcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGluc2VydEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICAgICAgbGV0IGVsZW1lbnRzID0gX2Rpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShlbGVtZW50LnRhZ05hbWUpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkgX2Rpdi5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgICAgIGxldCBpbmRleDtcbiAgICAgICAgICAgIGZvciAoaW5kZXggPSBlbGVtZW50cy5sZW5ndGggLSAxOyBpbmRleCA+IDA7IGluZGV4LS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgX2xheWVyID0gZWxlbWVudHNbaW5kZXhdLmJ1bGxldFNjcmVlbk9uU2NyZWVuLmJ1bGxldFNjcmVlbi5sYXllcjtcbiAgICAgICAgICAgICAgICBpZiAoX2xheWVyIDw9IGVsZW1lbnQuYnVsbGV0U2NyZWVuT25TY3JlZW4uYnVsbGV0U2NyZWVuLmxheWVyKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgrK2luZGV4ID09PSBlbGVtZW50cy5sZW5ndGgpIF9kaXYuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICBlbHNlIF9kaXYuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIGVsZW1lbnRzW2luZGV4XSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IENTUzNSZW5kZXJlciB9OyIsImltcG9ydCB7IFJlc291cmNlcyB9IGZyb20gJy4uL3Jlc291cmNlcydcblxuLyoqXG4gKiDmuLLmn5PlmahcbiAqIEBwcml2YXRlIEBjb25zdGFudFxuICovXG5jb25zdCBSRU5ERVJFUlMgPSB7XG4gICAgLyoqXG4gICAgICogQ1NTMyDmuLLmn5PmqKHlvI9cbiAgICAgKiBAcHJpdmF0ZSBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBjc3MzOiByZXF1aXJlKCcuL2NzczNSZW5kZXJlcicpLkNTUzNSZW5kZXJlcixcbiAgICAvKipcbiAgICAgKiBTVkcg5riy5p+T5qih5byPXG4gICAgICogQHByaXZhdGUgQHJlYWRvbmx5XG4gICAgICovXG4gICAgc3ZnOiByZXF1aXJlKCcuL3N2Z1JlbmRlcmVyJykuU1ZHUmVuZGVyZXIsXG4gICAgLyoqXG4gICAgICogV2ViR0wg5riy5p+T5qih5byPXG4gICAgICogQHByaXZhdGUgQHJlYWRvbmx5XG4gICAgICovXG4gICAgd2ViZ2w6IHJlcXVpcmUoJy4vd2ViZ2xSZW5kZXJlcicpLldlYkdMUmVuZGVyZXIsXG4gICAgLyoqXG4gICAgICogQ2FudmFzIDJEIOa4suafk+aooeW8j1xuICAgICAqIEBwcml2YXRlIEByZWFkb25seVxuICAgICAqL1xuICAgIGNhbnZhczogcmVxdWlyZSgnLi9jYW52YXNSZW5kZXJlcicpLkNhbnZhc1JlbmRlcmVyXG59XG5cbi8qKlxuICog5riy5p+T5Zmo5bel5Y6CXG4gKi9cbmNsYXNzIFJlbmRlcmVyc0ZhY3Rvcnkge1xuICAgIC8qKlxuICAgICAqIOWunuS+i+WMluS4gOS4qua4suafk+WZqOW3peWOglxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IC0gRWxlbWVudCDlhYPntKBcbiAgICAgKiBAcGFyYW0ge29wZW5CU0V+T3B0aW9uc30gb3B0aW9ucyAtIOWFqOWxgOmAiemhuVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50U2l6ZSAtIOWFg+e0oOWkp+Wwj1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50VHJpZ2dlciAtIOS6i+S7tuW8leWPkeaWueazlVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMsIGVsZW1lbnRTaXplLCBldmVudFRyaWdnZXIpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPlua4suafk+WZqFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVuZGVyTW9kZSAtIOa4suafk+aooeW8j1xuICAgICAgICAgKiBAcmV0dXJucyB7QmFzZVJlbmRlcmVyfSDmuLLmn5PlmajnmoTlrp7kvotcbiAgICAgICAgICogQHRocm93cyB7b3BlbkJTRS5Ccm93c2VyTm90U3VwcG9ydEVycm9yfSDmtY/op4jlmajkuI3mlK/mjIHnibnlrprmuLLmn5PmqKHlvI/ml7blvJXlj5HplJnor69cbiAgICAgICAgICogQHRocm93cyB7VHlwZUVycm9yfSDkvKDlhaXnmoTlj4LmlbDplJnor6/ml7blvJXlj5HplJnor6/jgILor7flj4LpmIUgTUROIFtUeXBlRXJyb3Jde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1R5cGVFcnJvcn0g44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFJlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlck1vZGUpIHtcbiAgICAgICAgICAgIGxldCByZW5kZXJlciA9IFJFTkRFUkVSU1tyZW5kZXJNb2RlXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHJlbmRlcmVyKSA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBUeXBlRXJyb3IoUmVzb3VyY2VzLlJFTkRFUl9NT0RFX0VSUk9SLmZpbGxEYXRhKHsgcmVuZGVyTW9kZTogcmVuZGVyTW9kZSB9KSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHJlbmRlcmVyKGVsZW1lbnQsIG9wdGlvbnMsIGVsZW1lbnRTaXplLCBldmVudFRyaWdnZXIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBSZW5kZXJlcnNGYWN0b3J5IH07IiwiaW1wb3J0IHsgQmFzZVJlbmRlcmVyIH0gZnJvbSAnLi9iYXNlUmVuZGVyZXInXG5pbXBvcnQgeyBCcm93c2VyTm90U3VwcG9ydEVycm9yIH0gZnJvbSAnLi4vLi4vYnJvd3Nlck5vdFN1cHBvcnRFcnJvcidcbmltcG9ydCB7IEhlbHBlciB9IGZyb20gJy4uL2hlbHBlcidcblxuLyoqXG4gKiBTVkcg5riy5p+T5Zmo57G7XG4gKi9cbmNsYXNzIFNWR1JlbmRlcmVyIGV4dGVuZHMgQmFzZVJlbmRlcmVyIHtcbiAgICAvKipcbiAgICAgKiDlrp7kvovljJbkuIDkuKogU1ZHIOa4suafk+WZqOexu1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IC0gRWxlbWVudCDlhYPntKBcbiAgICAgKiBAcGFyYW0ge29wZW5CU0V+T3B0aW9uc30gb3B0aW9ucyAtIOWFqOWxgOmAiemhuVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50U2l6ZSAtIOWFg+e0oOWkp+Wwj1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50VHJpZ2dlciAtIOS6i+S7tuW8leWPkeaWueazlVxuICAgICAqIEB0aHJvd3Mge29wZW5CU0UuQnJvd3Nlck5vdFN1cHBvcnRFcnJvcn0g5rWP6KeI5Zmo5LiN5pSv5oyB54m55a6a5riy5p+T5qih5byP5pe25byV5Y+R6ZSZ6K+vXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucywgZWxlbWVudFNpemUsIGV2ZW50VHJpZ2dlcikge1xuICAgICAgICBzdXBwb3J0Q2hlY2soKTsgLy/mtY/op4jlmajmlK/mjIHmo4DmtYtcbiAgICAgICAgbGV0IF9zdmc7XG4gICAgICAgIGxldCBfZGVmc1N2ZztcbiAgICAgICAgc3VwZXIoaW5pdCgpLCBvcHRpb25zLCBlbGVtZW50U2l6ZSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa4hemZpOWxj+W5leWGheWuuVxuICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xlYW5TY3JlZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBIZWxwZXIuY2xlYW5FbGVtZW50KF9zdmcpO1xuICAgICAgICAgICAgX2RlZnNTdmcgPSBjcmVhdGVFbGVtZW50U1ZHKCdkZWZzJyk7IC8vZGVmc1xuICAgICAgICAgICAgX3N2Zy5hcHBlbmRDaGlsZChfZGVmc1N2Zyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICog57uY5Yi25Ye95pWwXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yIChsZXQgdGV4dFN2ZyBvZiBfc3ZnLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0ZXh0JykpIHtcbiAgICAgICAgICAgICAgICBsZXQgYnVsbGV0U2NyZWVuT25TY3JlZW4gPSB0ZXh0U3ZnLmJ1bGxldFNjcmVlbk9uU2NyZWVuO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBidWxsZXRTY3JlZW5PblNjcmVlbi5zdmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBidWxsZXRTY3JlZW5PblNjcmVlbi5zdmdba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tXaGV0aGVySGlkZShidWxsZXRTY3JlZW5PblNjcmVlbikpIGl0ZW0uc2V0QXR0cmlidXRlKCdvcGFjaXR5JywgJzAnKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpdGVtLnNldEF0dHJpYnV0ZSgnb3BhY2l0eScsICcxJyk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7TWF0aC5yb3VuZChidWxsZXRTY3JlZW5PblNjcmVlbi54IC0gNCl9LCR7TWF0aC5yb3VuZChidWxsZXRTY3JlZW5PblNjcmVlbi5hY3R1YWxZIC0gNCl9KWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliJvlu7rlvLnluZXlhYPntKBcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBidWxsZXRTY3JlZW5PblNjcmVlbiAtIOWxj+W5leW8ueW5leWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdEFuZGdldFdpZHRoID0gZnVuY3Rpb24gKGJ1bGxldFNjcmVlbk9uU2NyZWVuKSB7XG4gICAgICAgICAgICBsZXQgYnVsbGV0U2NyZWVuID0gYnVsbGV0U2NyZWVuT25TY3JlZW4uYnVsbGV0U2NyZWVuO1xuICAgICAgICAgICAgYnVsbGV0U2NyZWVuT25TY3JlZW4uc3ZnID0gdHlwZW9mIGJ1bGxldFNjcmVlbk9uU2NyZWVuLnN2ZyA9PT0gJ29iamVjdCcgPyBidWxsZXRTY3JlZW5PblNjcmVlbi5zdmcgOiB7fTtcblxuICAgICAgICAgICAgbGV0IHRleHRTdmcgPSB0eXBlb2YgYnVsbGV0U2NyZWVuT25TY3JlZW4uc3ZnLnRleHQgPT09ICdvYmplY3QnID8gYnVsbGV0U2NyZWVuT25TY3JlZW4uc3ZnLnRleHQgOiBjcmVhdGVFbGVtZW50U1ZHKCd0ZXh0Jyk7XG4gICAgICAgICAgICB0ZXh0U3ZnLnNldEF0dHJpYnV0ZSgneCcsIDApO1xuICAgICAgICAgICAgdGV4dFN2Zy5zZXRBdHRyaWJ1dGUoJ3knLCBidWxsZXRTY3JlZW5PblNjcmVlbi5zaXplICogMC44KTtcbiAgICAgICAgICAgIHRleHRTdmcuc2V0QXR0cmlidXRlKCdmb250LWZhbWlseScsIGJ1bGxldFNjcmVlbi5zdHlsZS5mb250RmFtaWx5KTtcbiAgICAgICAgICAgIHRleHRTdmcuc2V0QXR0cmlidXRlKCdmb250LXNpemUnLCBidWxsZXRTY3JlZW5PblNjcmVlbi5zaXplKTtcbiAgICAgICAgICAgIHRleHRTdmcuc2V0QXR0cmlidXRlKCdmb250LXdlaWdodCcsIGJ1bGxldFNjcmVlbi5zdHlsZS5mb250V2VpZ2h0KTtcbiAgICAgICAgICAgIHRleHRTdmcuc2V0QXR0cmlidXRlKCdmaWxsJywgYnVsbGV0U2NyZWVuLnN0eWxlLmNvbG9yKTtcbiAgICAgICAgICAgIEhlbHBlci5jbGVhbkVsZW1lbnQodGV4dFN2Zyk7XG4gICAgICAgICAgICB0ZXh0U3ZnLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGJ1bGxldFNjcmVlbi50ZXh0KSk7XG4gICAgICAgICAgICBpZiAoYnVsbGV0U2NyZWVuLnN0eWxlLmJvcmRlckNvbG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0ZXh0U3ZnLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgYnVsbGV0U2NyZWVuLmJvcmRlckNvbG9yKTtcbiAgICAgICAgICAgICAgICB0ZXh0U3ZnLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgMC41KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGJ1bGxldFNjcmVlbi5zdHlsZS5zaGFkb3dCbHVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgZmlsdGVySWQgPSBgYnVsbGV0U2NyZWVuRW5naW5lX3N2Z0ZpbHRlcl9zaGFkb3dfJHtidWxsZXRTY3JlZW4uc3R5bGUuc2hhZG93Qmx1cn1gO1xuICAgICAgICAgICAgICAgIGxldCBmaWx0ZXJTdmcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChmaWx0ZXJJZCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlclN2ZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJTdmcgPSBjcmVhdGVFbGVtZW50U1ZHKCdmaWx0ZXInKTtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyU3ZnLmlkID0gZmlsdGVySWQ7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclN2Zy5zZXRBdHRyaWJ1dGUoJ3gnLCAnLTEwMCUnKTtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyU3ZnLnNldEF0dHJpYnV0ZSgneScsICctMTAwJScpO1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJTdmcuc2V0QXR0cmlidXRlKCd3aWR0aCcsICczMDAlJyk7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclN2Zy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICczMDAlJyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmZU9mZnNldFN2ZyA9IGNyZWF0ZUVsZW1lbnRTVkcoJ2ZlT2Zmc2V0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGZlT2Zmc2V0U3ZnLnNldEF0dHJpYnV0ZSgncmVzdWx0JywgJ29mZk91dCcpO1xuICAgICAgICAgICAgICAgICAgICBmZU9mZnNldFN2Zy5zZXRBdHRyaWJ1dGUoJ2luJywgJ1NvdXJjZUFscGhhJyk7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclN2Zy5hcHBlbmRDaGlsZChmZU9mZnNldFN2Zyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmZUdhdXNzaWFuQmx1clN2ZyA9IGNyZWF0ZUVsZW1lbnRTVkcoJ2ZlR2F1c3NpYW5CbHVyJyk7XG4gICAgICAgICAgICAgICAgICAgIGZlR2F1c3NpYW5CbHVyU3ZnLnNldEF0dHJpYnV0ZSgncmVzdWx0JywgJ2JsdXJPdXQnKTtcbiAgICAgICAgICAgICAgICAgICAgZmVHYXVzc2lhbkJsdXJTdmcuc2V0QXR0cmlidXRlKCdpbicsICdvZmZPdXQnKTtcbiAgICAgICAgICAgICAgICAgICAgZmVHYXVzc2lhbkJsdXJTdmcuc2V0QXR0cmlidXRlKCdzdGREZXZpYXRpb24nLCBidWxsZXRTY3JlZW4uc3R5bGUuc2hhZG93Qmx1cik7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclN2Zy5hcHBlbmRDaGlsZChmZUdhdXNzaWFuQmx1clN2Zyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmZUJsZW5kU3ZnID0gY3JlYXRlRWxlbWVudFNWRygnZmVCbGVuZCcpO1xuICAgICAgICAgICAgICAgICAgICBmZUJsZW5kU3ZnLnNldEF0dHJpYnV0ZSgnaW4nLCAnU291cmNlR3JhcGhpYycpO1xuICAgICAgICAgICAgICAgICAgICBmZUJsZW5kU3ZnLnNldEF0dHJpYnV0ZSgnaW4yJywgJ2JsdXJPdXQnKTtcbiAgICAgICAgICAgICAgICAgICAgZmVCbGVuZFN2Zy5zZXRBdHRyaWJ1dGUoJ21vZGUnLCAnbm9ybWFsJyk7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclN2Zy5hcHBlbmRDaGlsZChmZUJsZW5kU3ZnKTtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyU3ZnLmJ1bGxldFNjcmVlbkNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgX2RlZnNTdmcuYXBwZW5kQ2hpbGQoZmlsdGVyU3ZnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmlsdGVyU3ZnLmJ1bGxldFNjcmVlbkNvdW50Kys7XG4gICAgICAgICAgICAgICAgdGV4dFN2Zy5zZXRBdHRyaWJ1dGUoJ2ZpbHRlcicsIGB1cmwoIyR7ZmlsdGVySWR9KWApO1xuICAgICAgICAgICAgICAgIGJ1bGxldFNjcmVlbk9uU2NyZWVuLmZpbHRlcklkID0gZmlsdGVySWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJ1bGxldFNjcmVlbk9uU2NyZWVuLnN2Zy50ZXh0ID0gdGV4dFN2ZztcbiAgICAgICAgICAgIHRleHRTdmcuYnVsbGV0U2NyZWVuT25TY3JlZW4gPSBidWxsZXRTY3JlZW5PblNjcmVlbjtcbiAgICAgICAgICAgIGluc2VydEVsZW1lbnQodGV4dFN2Zyk7XG4gICAgICAgICAgICBidWxsZXRTY3JlZW5PblNjcmVlbi53aWR0aCA9IHRleHRTdmcuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCk7IC8v5by55bmV55qE5a695bqm77ya5YOP57SgXG5cbiAgICAgICAgICAgIGlmIChidWxsZXRTY3JlZW4uc3R5bGUuYm94Q29sb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCByZWN0U3ZnID0gdHlwZW9mIGJ1bGxldFNjcmVlbk9uU2NyZWVuLnN2Zy5yZWN0ID09PSAnb2JqZWN0JyA/IGJ1bGxldFNjcmVlbk9uU2NyZWVuLnN2Zy5yZWN0IDogY3JlYXRlRWxlbWVudFNWRygncmVjdCcpO1xuICAgICAgICAgICAgICAgIHJlY3RTdmcuc2V0QXR0cmlidXRlKCd4JywgLTMpO1xuICAgICAgICAgICAgICAgIHJlY3RTdmcuc2V0QXR0cmlidXRlKCd5JywgLTMpO1xuICAgICAgICAgICAgICAgIHJlY3RTdmcuc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKTtcbiAgICAgICAgICAgICAgICByZWN0U3ZnLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgYnVsbGV0U2NyZWVuT25TY3JlZW4uaGVpZ2h0ICsgNyk7XG4gICAgICAgICAgICAgICAgcmVjdFN2Zy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgYnVsbGV0U2NyZWVuT25TY3JlZW4ud2lkdGggKyA3KTtcbiAgICAgICAgICAgICAgICByZWN0U3ZnLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgYnVsbGV0U2NyZWVuLnN0eWxlLmJveENvbG9yKTtcbiAgICAgICAgICAgICAgICByZWN0U3ZnLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgMSk7XG4gICAgICAgICAgICAgICAgYnVsbGV0U2NyZWVuT25TY3JlZW4uc3ZnLnJlY3QgPSByZWN0U3ZnO1xuICAgICAgICAgICAgICAgIHJlY3RTdmcuYnVsbGV0U2NyZWVuT25TY3JlZW4gPSBidWxsZXRTY3JlZW5PblNjcmVlbjtcbiAgICAgICAgICAgICAgICBfc3ZnLmluc2VydEJlZm9yZShyZWN0U3ZnLCB0ZXh0U3ZnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIOWIoOmZpOW8ueW5leWFg+e0oFxuICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBidWxsZXRTY3JlZW5PblNjcmVlbiAtIOWxj+W5leW8ueW5leWvueixoVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlbGV0ZSA9IGZ1bmN0aW9uIChidWxsZXRTY3JlZW5PblNjcmVlbikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBidWxsZXRTY3JlZW5PblNjcmVlbi5maWx0ZXJJZCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGxldCBmaWx0ZXJTdmcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChidWxsZXRTY3JlZW5PblNjcmVlbi5maWx0ZXJJZCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlclN2ZyAhPSBudWxsICYmIC0tZmlsdGVyU3ZnLmJ1bGxldFNjcmVlbkNvdW50ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICBfZGVmc1N2Zy5yZW1vdmVDaGlsZChmaWx0ZXJTdmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggaW4gYnVsbGV0U2NyZWVuT25TY3JlZW4uc3ZnKSB7XG4gICAgICAgICAgICAgICAgX3N2Zy5yZW1vdmVDaGlsZChidWxsZXRTY3JlZW5PblNjcmVlbi5zdmdbaW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDph43mlrDmt7vliqDlvLnluZVcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBidWxsZXRTY3JlZW5PblNjcmVlbiAtIOWxj+W5leW8ueW5leWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZUNyZWF0QW5kZ2V0V2lkdGggPSBmdW5jdGlvbiAoYnVsbGV0U2NyZWVuT25TY3JlZW4pIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlKGJ1bGxldFNjcmVlbk9uU2NyZWVuKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRBbmRnZXRXaWR0aChidWxsZXRTY3JlZW5PblNjcmVlbik7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgX3NldFNpemUgPSB0aGlzLnNldFNpemU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7lsLrlr7hcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfc2V0U2l6ZSgpO1xuICAgICAgICAgICAgX3N2Zy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGVsZW1lbnRTaXplLmhlaWdodCk7XG4gICAgICAgICAgICBfc3ZnLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBlbGVtZW50U2l6ZS53aWR0aCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICog5re75YqgRGl2XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEByZXR1cm5zIHtFbGVtZW50fSBEaXZcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgICAgICBsZXQgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7IC8vRElWXG4gICAgICAgICAgICBIZWxwZXIuY2xlYW5FbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICAgICAgZGl2LnN0eWxlLnBhZGRpbmcgPSAnMCc7XG4gICAgICAgICAgICBkaXYuc3R5bGUubWFyZ2luID0gJzAnO1xuICAgICAgICAgICAgX3N2ZyA9IGNyZWF0ZUVsZW1lbnRTVkcoJ3N2ZycpOyAvL1NWR1xuICAgICAgICAgICAgX2RlZnNTdmcgPSBjcmVhdGVFbGVtZW50U1ZHKCdkZWZzJyk7IC8vZGVmc1xuICAgICAgICAgICAgX3N2Zy5hcHBlbmRDaGlsZChfZGVmc1N2Zyk7XG4gICAgICAgICAgICBfc3ZnLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgZWxlbWVudFNpemUuaGVpZ2h0KTtcbiAgICAgICAgICAgIF9zdmcuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGVsZW1lbnRTaXplLndpZHRoKTtcbiAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZChfc3ZnKTtcbiAgICAgICAgICAgIGxldCBldmVudERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpOyAvL0RJVlxuICAgICAgICAgICAgZXZlbnREaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgZXZlbnREaXYuc3R5bGUudG9wID1cbiAgICAgICAgICAgICAgICBldmVudERpdi5zdHlsZS5yaWdodCA9XG4gICAgICAgICAgICAgICAgZXZlbnREaXYuc3R5bGUuYm90dG9tID1cbiAgICAgICAgICAgICAgICBldmVudERpdi5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKGV2ZW50RGl2KTtcbiAgICAgICAgICAgIHJlZ2lzdGVyRXZlbnQoZXZlbnREaXYpOyAvL+azqOWGjOS6i+S7tuWTjeW6lOeoi+W6j1xuICAgICAgICAgICAgcmV0dXJuIGRpdjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmtY/op4jlmajmlK/mjIHmo4DmtYtcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHRocm93cyB7b3BlbkJTRS5Ccm93c2VyTm90U3VwcG9ydEVycm9yfSDmtY/op4jlmajkuI3mlK/mjIHnibnlrprmuLLmn5PmqKHlvI/ml7blvJXlj5HplJnor69cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHN1cHBvcnRDaGVjaygpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICE9ICdmdW5jdGlvbicpIHRocm93IG5ldyBCcm93c2VyTm90U3VwcG9ydEVycm9yKCdjcmVhdGVFbGVtZW50TlMgRnVuY3Rpb24nKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3JlYXRlRWxlbWVudFNWRygnc3ZnJykuY3JlYXRlU1ZHUmVjdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgQnJvd3Nlck5vdFN1cHBvcnRFcnJvcignU1ZHJyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgX2NoZWNrV2hldGhlckhpZGUgPSB0aGlzLmNoZWNrV2hldGhlckhpZGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDms6jlhozkuovku7blk43lupTnqIvluo9cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0g5YWD57SgXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiByZWdpc3RlckV2ZW50KGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldEJ1bGxldFNjcmVlbk9uU2NyZWVuQnlMb2NhdGlvbihsb2NhdGlvbikge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0U3ZncyA9IF9zdmcuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RleHQnKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IHRleHRTdmdzLmxlbmd0aCAtIDE7IGluZGV4ID4gMDsgaW5kZXgtLSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYnVsbGV0U2NyZWVuT25TY3JlZW4gPSB0ZXh0U3Znc1tpbmRleF0uYnVsbGV0U2NyZWVuT25TY3JlZW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChfY2hlY2tXaGV0aGVySGlkZShidWxsZXRTY3JlZW5PblNjcmVlbikpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHgxID0gYnVsbGV0U2NyZWVuT25TY3JlZW4ueCAtIDQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCB4MiA9IHgxICsgYnVsbGV0U2NyZWVuT25TY3JlZW4ud2lkdGggKyA4O1xuICAgICAgICAgICAgICAgICAgICBsZXQgeTEgPSBidWxsZXRTY3JlZW5PblNjcmVlbi5hY3R1YWxZIC0gNDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHkyID0geTEgKyBidWxsZXRTY3JlZW5PblNjcmVlbi5oZWlnaHQgKyA4O1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYXRpb24ueCA+PSB4MSAmJiBsb2NhdGlvbi54IDw9IHgyICYmIGxvY2F0aW9uLnkgPj0geTEgJiYgbG9jYXRpb24ueSA8PSB5MilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBidWxsZXRTY3JlZW5PblNjcmVlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRMb2NhdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0T2Zmc2V0VG9wKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldFRvcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldFRvcCArPSBlbGVtZW50Lm9mZnNldFRvcDtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoKGVsZW1lbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudCkgIT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXRUb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldE9mZnNldExlZnQoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0TGVmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldExlZnQgKz0gZWxlbWVudC5vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgoZWxlbWVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50KSAhPSBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldExlZnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZS5vZmZzZXRYID09PSAndW5kZWZpbmVkJyB8fCBlLm9mZnNldFggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlLmxheWVyWCA9PT0gJ3VuZGVmaW5lZCcgfHwgZS5sYXllclggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZS5wYWdlWCA9PT0gJ3VuZGVmaW5lZCcgfHwgZS5wYWdlWCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkb2MgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucGFnZVggPSBlLmNsaWVudFggKyAoZG9jICYmIGRvYy5zY3JvbGxMZWZ0IHx8IGJvZHkgJiYgYm9keS5zY3JvbGxMZWZ0IHx8IDApIC0gKGRvYyAmJiBkb2MuY2xpZW50TGVmdCB8fCBib2R5ICYmIGJvZHkuY2xpZW50TGVmdCB8fCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnBhZ2VZID0gZS5jbGllbnRZICsgKGRvYyAmJiBkb2Muc2Nyb2xsVG9wIHx8IGJvZHkgJiYgYm9keS5zY3JvbGxUb3AgfHwgMCkgLSAoZG9jICYmIGRvYy5jbGllbnRUb3AgfHwgYm9keSAmJiBib2R5LmNsaWVudFRvcCB8fCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGUubGF5ZXJYID0gZS5wYWdlWCAtIGdldE9mZnNldExlZnQoZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5sYXllclkgPSBlLnBhZ2VZIC0gZ2V0T2Zmc2V0VG9wKGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlLm9mZnNldFggPSBlLmxheWVyWCAtIGUudGFyZ2V0LmNsaWVudExlZnQ7XG4gICAgICAgICAgICAgICAgICAgIGUub2Zmc2V0WSA9IGUubGF5ZXJZIC0gZS50YXJnZXQuY2xpZW50VG9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB4OiBlLm9mZnNldFgsXG4gICAgICAgICAgICAgICAgICAgIHk6IGUub2Zmc2V0WVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8v5LiK5LiL5paH6I+c5Y2VXG4gICAgICAgICAgICBlbGVtZW50Lm9uY29udGV4dG1lbnUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGxldCBidWxsZXRTY3JlZW5PblNjcmVlbiA9IGdldEJ1bGxldFNjcmVlbk9uU2NyZWVuQnlMb2NhdGlvbihnZXRMb2NhdGlvbihlKSk7XG4gICAgICAgICAgICAgICAgaWYgKGJ1bGxldFNjcmVlbk9uU2NyZWVuKVxuICAgICAgICAgICAgICAgICAgICBldmVudFRyaWdnZXIoJ2NvbnRleHRtZW51JywgYnVsbGV0U2NyZWVuT25TY3JlZW4sIGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvL+WNleWHu1xuICAgICAgICAgICAgZWxlbWVudC5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgYnVsbGV0U2NyZWVuT25TY3JlZW4gPSBnZXRCdWxsZXRTY3JlZW5PblNjcmVlbkJ5TG9jYXRpb24oZ2V0TG9jYXRpb24oZSkpO1xuICAgICAgICAgICAgICAgIGlmIChidWxsZXRTY3JlZW5PblNjcmVlbilcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRUcmlnZ2VyKCdjbGljaycsIGJ1bGxldFNjcmVlbk9uU2NyZWVuLCBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy/pvKDmoIfnp7vliqhcbiAgICAgICAgICAgIGVsZW1lbnQub25tb3VzZW1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGxldCBidWxsZXRTY3JlZW5PblNjcmVlbiA9IGdldEJ1bGxldFNjcmVlbk9uU2NyZWVuQnlMb2NhdGlvbihnZXRMb2NhdGlvbihlKSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdGV4dFN2ZyBvZiBfc3ZnLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0ZXh0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IF9idWxsZXRTY3JlZW5PblNjcmVlbiA9IHRleHRTdmcuYnVsbGV0U2NyZWVuT25TY3JlZW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChfYnVsbGV0U2NyZWVuT25TY3JlZW4gIT0gYnVsbGV0U2NyZWVuT25TY3JlZW4gJiYgX2J1bGxldFNjcmVlbk9uU2NyZWVuLm1vdXNlaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9idWxsZXRTY3JlZW5PblNjcmVlbi5tb3VzZWluID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmN1cnNvciA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRUcmlnZ2VyKCdtb3VzZWxlYXZlJywgX2J1bGxldFNjcmVlbk9uU2NyZWVuLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYnVsbGV0U2NyZWVuT25TY3JlZW4gPT09IG51bGwgfHwgYnVsbGV0U2NyZWVuT25TY3JlZW4ubW91c2VpbikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGJ1bGxldFNjcmVlbk9uU2NyZWVuLm1vdXNlaW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuY3Vyc29yID0gb3B0aW9ucy5jdXJzb3JPbk1vdXNlT3ZlcjtcbiAgICAgICAgICAgICAgICBldmVudFRyaWdnZXIoJ21vdXNlZW50ZXInLCBidWxsZXRTY3JlZW5PblNjcmVlbiwgZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy/pvKDmoIfnprvlvIBcbiAgICAgICAgICAgIGVsZW1lbnQub25tb3VzZW91dCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdGV4dFN2ZyBvZiBfc3ZnLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0ZXh0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IF9idWxsZXRTY3JlZW5PblNjcmVlbiA9IHRleHRTdmcuYnVsbGV0U2NyZWVuT25TY3JlZW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChfYnVsbGV0U2NyZWVuT25TY3JlZW4ubW91c2Vpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2J1bGxldFNjcmVlbk9uU2NyZWVuLm1vdXNlaW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuY3Vyc29yID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFRyaWdnZXIoJ21vdXNlbGVhdmUnLCBfYnVsbGV0U2NyZWVuT25TY3JlZW4sIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIm+W7uiBTVkcg5YWD57SgXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBxdWFsaWZpZWROYW1lIC0gRWxlbWVudCDlkI3np7BcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSDpgInpoblcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRTVkcocXVhbGlmaWVkTmFtZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBxdWFsaWZpZWROYW1lLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmjIkgbGF5ZXIg5o+S5YWl5YWD57SgXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIOWFg+e0oFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaW5zZXJ0RWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgICAgICBsZXQgZWxlbWVudHMgPSBfc3ZnLmdldEVsZW1lbnRzQnlUYWdOYW1lKGVsZW1lbnQudGFnTmFtZSk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSBfc3ZnLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICAgICAgZm9yIChpbmRleCA9IGVsZW1lbnRzLmxlbmd0aCAtIDE7IGluZGV4ID4gMDsgaW5kZXgtLSkge1xuICAgICAgICAgICAgICAgIGxldCBfbGF5ZXIgPSBlbGVtZW50c1tpbmRleF0uYnVsbGV0U2NyZWVuT25TY3JlZW4uYnVsbGV0U2NyZWVuLmxheWVyO1xuICAgICAgICAgICAgICAgIGlmIChfbGF5ZXIgPD0gZWxlbWVudC5idWxsZXRTY3JlZW5PblNjcmVlbi5idWxsZXRTY3JlZW4ubGF5ZXIpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCsraW5kZXggPT09IGVsZW1lbnRzLmxlbmd0aCkgX3N2Zy5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgICAgIGVsc2UgX3N2Zy5pbnNlcnRCZWZvcmUoZWxlbWVudCwgZWxlbWVudHNbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgU1ZHUmVuZGVyZXIgfTsiLCJpbXBvcnQgeyBDYW52YXNCYXNlUmVuZGVyZXIgfSBmcm9tICcuL2NhbnZhc0Jhc2VSZW5kZXJlcidcbmltcG9ydCB7IEJyb3dzZXJOb3RTdXBwb3J0RXJyb3IgfSBmcm9tICcuLi8uLi9icm93c2VyTm90U3VwcG9ydEVycm9yJ1xuXG4vKipcbiAqIFdlYkdMIOa4suafk+WZqOexu1xuICovXG5jbGFzcyBXZWJHTFJlbmRlcmVyIGV4dGVuZHMgQ2FudmFzQmFzZVJlbmRlcmVyIHtcbiAgICAvKipcbiAgICAgKiDlrp7kvovljJbkuIDkuKogV2ViR0wg5riy5p+T5Zmo57G7XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGVsZW1lbnQgLSBFbGVtZW50IOWFg+e0oFxuICAgICAqIEBwYXJhbSB7b3BlbkJTRX5PcHRpb25zfSBvcHRpb25zIC0g5YWo5bGA6YCJ6aG5XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGVsZW1lbnRTaXplIC0g5YWD57Sg5aSn5bCPXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRUcmlnZ2VyIC0g5LqL5Lu25byV5Y+R5pa55rOVXG4gICAgICogQHRocm93cyB7b3BlbkJTRS5Ccm93c2VyTm90U3VwcG9ydEVycm9yfSDmtY/op4jlmajkuI3mlK/mjIHnibnlrprmuLLmn5PmqKHlvI/ml7blvJXlj5HplJnor69cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBvcHRpb25zLCBlbGVtZW50U2l6ZSwgZXZlbnRUcmlnZ2VyKSB7XG4gICAgICAgIHN1cHBvcnRDaGVjaygpOyAvL+a1j+iniOWZqOaUr+aMgeajgOa1i1xuICAgICAgICBzdXBlcihlbGVtZW50LCBvcHRpb25zLCBlbGVtZW50U2l6ZSwgZXZlbnRUcmlnZ2VyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWxj+W5leS4iueahOW8ueW5lVxuICAgICAgICAgKiBAcHJpdmF0ZSBAdHlwZSB7TGlua2VkTGlzdH1cbiAgICAgICAgICovXG4gICAgICAgIGxldCBfYnVsbGV0U2NyZWVuc09uU2NyZWVuID0gdGhpcy5nZXRCdWxsZXRTY3JlZW5zT25TY3JlZW4oKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlYkdMIOS4iuS4i+aWh+WvueixoVxuICAgICAgICAgKiBAcHJpdmF0ZSBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IF93ZWJnbENvbnRleHQ7XG4gICAgICAgIGxldCBfcG9zaXRpb25BdHRyaWJ1dGVMb2NhdGlvbjtcbiAgICAgICAgbGV0IF9yZXNvbHV0aW9uVW5pZm9ybUxvY2F0aW9uO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FudmFzIOWFg+e0oFxuICAgICAgICAgKiBAcHJpdmF0ZSBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IF9jYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xuICAgICAgICBpbml0KCk7XG5cbiAgICAgICAgbGV0IF9jbGVhblNjcmVlbiA9IHRoaXMuY2xlYW5TY3JlZW47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmuIXpmaTlsY/luZXlhoXlrrlcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsZWFuU2NyZWVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX2NsZWFuU2NyZWVuKCk7XG4gICAgICAgICAgICBfd2ViZ2xDb250ZXh0LmNsZWFyKF93ZWJnbENvbnRleHQuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICog57uY5Yi25Ye95pWwXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbGV0IGRldmljZVBpeGVsUmF0aW8gPSB0aGlzLmdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICAgICAgICAgIC8vIOa4heepuueUu+W4g1xuICAgICAgICAgICAgX3dlYmdsQ29udGV4dC5jbGVhcihfd2ViZ2xDb250ZXh0LkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICAgICAgX2J1bGxldFNjcmVlbnNPblNjcmVlbi5mb3JFYWNoKChidWxsZXRTY3JlZW5PblNjcmVlbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrV2hldGhlckhpZGUoYnVsbGV0U2NyZWVuT25TY3JlZW4pKSByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8g5Zub5Liq6aG254K55Z2Q5qCHXG4gICAgICAgICAgICAgICAgbGV0IHgxID0gKGJ1bGxldFNjcmVlbk9uU2NyZWVuLnggLSA0KSAqIGRldmljZVBpeGVsUmF0aW87XG4gICAgICAgICAgICAgICAgbGV0IHgyID0geDEgKyAoYnVsbGV0U2NyZWVuT25TY3JlZW4ud2lkdGggKyA4KSAqIGRldmljZVBpeGVsUmF0aW87XG4gICAgICAgICAgICAgICAgbGV0IHkxID0gKGJ1bGxldFNjcmVlbk9uU2NyZWVuLmFjdHVhbFkgLSA0KSAqIGRldmljZVBpeGVsUmF0aW87XG4gICAgICAgICAgICAgICAgbGV0IHkyID0geTEgKyAoYnVsbGV0U2NyZWVuT25TY3JlZW4uaGVpZ2h0ICsgOCkgKiBkZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICAgICAgICAgIC8v57uR5a6a57q555CGXG4gICAgICAgICAgICAgICAgX3dlYmdsQ29udGV4dC5iaW5kVGV4dHVyZShfd2ViZ2xDb250ZXh0LlRFWFRVUkVfMkQsIGJ1bGxldFNjcmVlbk9uU2NyZWVuLnRleHR1cmUyRCk7XG4gICAgICAgICAgICAgICAgLy/nu5HlrprojIPlm7RcbiAgICAgICAgICAgICAgICBsZXQgcG9zaXRpb25CdWZmZXIgPSBfd2ViZ2xDb250ZXh0LmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgIC8vIOWwhue7keWumueCuee7keWumuWIsOe8k+WGsuaVsOaNru+8iHBvc2l0aW9uQnVmZmVy77yJXG4gICAgICAgICAgICAgICAgX3dlYmdsQ29udGV4dC5iaW5kQnVmZmVyKF93ZWJnbENvbnRleHQuQVJSQVlfQlVGRkVSLCBwb3NpdGlvbkJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgX3dlYmdsQ29udGV4dC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShfcG9zaXRpb25BdHRyaWJ1dGVMb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgLy8g5ZGK6K+J5bGe5oCn5oCO5LmI5LuOcG9zaXRpb25CdWZmZXLkuK3or7vlj5bmlbDmja4gKEFSUkFZX0JVRkZFUilcbiAgICAgICAgICAgICAgICBfd2ViZ2xDb250ZXh0LnZlcnRleEF0dHJpYlBvaW50ZXIoX3Bvc2l0aW9uQXR0cmlidXRlTG9jYXRpb24sIDIsIC8vc2l6ZSDmr4/mrKHov63ku6Pov5DooYzmj5Dlj5bkuKTkuKrljZXkvY3mlbDmja5cbiAgICAgICAgICAgICAgICAgICAgX3dlYmdsQ29udGV4dC5GTE9BVCwgLy90eXBlIOavj+S4quWNleS9jeeahOaVsOaNruexu+Wei+aYrzMy5L2N5rWu54K55Z6LXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLCAvL25vcm1hbGl6ZSDkuI3pnIDopoHlvZLkuIDljJbmlbDmja5cbiAgICAgICAgICAgICAgICAgICAgMCwgLy9zdHJpZGUgMCA9IOenu+WKqOWNleS9jeaVsOmHjyAqIOavj+S4quWNleS9jeWNoOeUqOWGheWtmO+8iHNpemVvZih0eXBlKe+8iVxuICAgICAgICAgICAgICAgICAgICAvLyDmr4/mrKHov63ku6Pov5DooYzov5DliqjlpJrlsJHlhoXlrZjliLDkuIvkuIDkuKrmlbDmja7lvIDlp4vngrlcbiAgICAgICAgICAgICAgICAgICAgMCAvL29mZnNldCDku47nvJPlhrLotbflp4vkvY3nva7lvIDlp4vor7vlj5ZcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIF93ZWJnbENvbnRleHQuYnVmZmVyRGF0YShfd2ViZ2xDb250ZXh0LkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShbeDEsIHkxLFxuICAgICAgICAgICAgICAgICAgICB4MiwgeTEsXG4gICAgICAgICAgICAgICAgICAgIHgxLCB5MixcbiAgICAgICAgICAgICAgICAgICAgeDEsIHkyLFxuICAgICAgICAgICAgICAgICAgICB4MiwgeTEsXG4gICAgICAgICAgICAgICAgICAgIHgyLCB5Ml0pLCBfd2ViZ2xDb250ZXh0LlNUQVRJQ19EUkFXKTtcbiAgICAgICAgICAgICAgICAvL+e7mOWItlxuICAgICAgICAgICAgICAgIF93ZWJnbENvbnRleHQuZHJhd0FycmF5cyhfd2ViZ2xDb250ZXh0LlRSSUFOR0xFUywgLy9wcmltaXRpdmVUeXBlXG4gICAgICAgICAgICAgICAgICAgIDAsIC8vb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgIDYgLy9jb3VudFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBfY3JlYXRBbmRnZXRXaWR0aCA9IHRoaXMuY3JlYXRBbmRnZXRXaWR0aDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIm+W7uuW8ueW5leWFg+e0oFxuICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGJ1bGxldFNjcmVlbk9uU2NyZWVuIC0g5bGP5bmV5by55bmV5a+56LGhXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWF0QW5kZ2V0V2lkdGggPSBmdW5jdGlvbiAoYnVsbGV0U2NyZWVuT25TY3JlZW4pIHtcbiAgICAgICAgICAgIF9jcmVhdEFuZGdldFdpZHRoKGJ1bGxldFNjcmVlbk9uU2NyZWVuKTtcbiAgICAgICAgICAgIGxldCB0ZXh0dXJlID0gX3dlYmdsQ29udGV4dC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgICAgICBfd2ViZ2xDb250ZXh0LmJpbmRUZXh0dXJlKF93ZWJnbENvbnRleHQuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgICAgICAgICAvLyDorr7nva7lj4LmlbBcbiAgICAgICAgICAgIF93ZWJnbENvbnRleHQudGV4UGFyYW1ldGVyaShfd2ViZ2xDb250ZXh0LlRFWFRVUkVfMkQsIF93ZWJnbENvbnRleHQuVEVYVFVSRV9NSU5fRklMVEVSLCBfd2ViZ2xDb250ZXh0Lk5FQVJFU1QpO1xuICAgICAgICAgICAgX3dlYmdsQ29udGV4dC50ZXhQYXJhbWV0ZXJpKF93ZWJnbENvbnRleHQuVEVYVFVSRV8yRCwgX3dlYmdsQ29udGV4dC5URVhUVVJFX01BR19GSUxURVIsIF93ZWJnbENvbnRleHQuTkVBUkVTVCk7XG4gICAgICAgICAgICBfd2ViZ2xDb250ZXh0LnRleFBhcmFtZXRlcmkoX3dlYmdsQ29udGV4dC5URVhUVVJFXzJELCBfd2ViZ2xDb250ZXh0LlRFWFRVUkVfV1JBUF9TLCBfd2ViZ2xDb250ZXh0LkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgX3dlYmdsQ29udGV4dC50ZXhQYXJhbWV0ZXJpKF93ZWJnbENvbnRleHQuVEVYVFVSRV8yRCwgX3dlYmdsQ29udGV4dC5URVhUVVJFX1dSQVBfVCwgX3dlYmdsQ29udGV4dC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgICAgIF93ZWJnbENvbnRleHQudGV4SW1hZ2UyRChfd2ViZ2xDb250ZXh0LlRFWFRVUkVfMkQsIDAsIF93ZWJnbENvbnRleHQuUkdCQSwgX3dlYmdsQ29udGV4dC5SR0JBLCBfd2ViZ2xDb250ZXh0LlVOU0lHTkVEX0JZVEUsIGJ1bGxldFNjcmVlbk9uU2NyZWVuLmhpZGVDYW52YXMpO1xuICAgICAgICAgICAgYnVsbGV0U2NyZWVuT25TY3JlZW4udGV4dHVyZTJEID0gdGV4dHVyZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBfc2V0U2l6ZSA9IHRoaXMuc2V0U2l6ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9ruWwuuWvuFxuICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF9zZXRTaXplKCk7XG4gICAgICAgICAgICBfd2ViZ2xDb250ZXh0LnZpZXdwb3J0KDAsIDAsIF9jYW52YXMud2lkdGgsIF9jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIF93ZWJnbENvbnRleHQudW5pZm9ybTJmKF9yZXNvbHV0aW9uVW5pZm9ybUxvY2F0aW9uLCBfY2FudmFzLndpZHRoLCBfY2FudmFzLmhlaWdodCk7IC8vIOiuvue9ruWFqOWxgOWPmOmHjyDliIbovqjnjodcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliJ3lp4vljJZcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgICAgICAvLyDliJvlu7rnnYDoibLlmajmlrnms5XvvIzovpPlhaXlj4LmlbDvvJrmuLLmn5PkuIrkuIvmlofvvIznnYDoibLlmajnsbvlnovvvIzmlbDmja7mupBcbiAgICAgICAgICAgIGxldCBjcmVhdGVTaGFkZXIgPSBmdW5jdGlvbiAoZ2wsIHR5cGUsIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGxldCBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7IC8vIOWIm+W7uuedgOiJsuWZqOWvueixoVxuICAgICAgICAgICAgICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZSk7IC8vIOaPkOS+m+aVsOaNrua6kFxuICAgICAgICAgICAgICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTsgLy8g57yW6K+RIC0+IOeUn+aIkOedgOiJsuWZqFxuICAgICAgICAgICAgICAgIGxldCBzdWNjZXNzID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpO1xuICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaGFkZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdsLmRlbGV0ZVNoYWRlcihzaGFkZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIOWIm+W7uuedgOiJsueoi+W6j++8jOi+k+WFpeWPguaVsO+8mua4suafk+S4iuS4i+aWh++8jOmhtueCueedgOiJsuWZqO+8jOeJh+auteedgOiJsuWZqFxuICAgICAgICAgICAgbGV0IGNyZWF0ZVByb2dyYW0gPSBmdW5jdGlvbiAoZ2wsIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICAgICAgICAgICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgICAgICAgICAgICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICAgICAgICAgICAgICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICAgICAgICAgIGxldCBzdWNjZXNzID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUyk7XG4gICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2dyYW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy/pobbngrnnnYDoibLlmajku6PnoIFcbiAgICAgICAgICAgIGxldCB2ZXJ0ZXhTaGFkZXJTb3VyY2UgPSAnYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjsnO1xuICAgICAgICAgICAgdmVydGV4U2hhZGVyU291cmNlICs9ICdhdHRyaWJ1dGUgdmVjMiBhX3RleGNvb3JkOyc7XG4gICAgICAgICAgICB2ZXJ0ZXhTaGFkZXJTb3VyY2UgKz0gJ3VuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247JztcbiAgICAgICAgICAgIHZlcnRleFNoYWRlclNvdXJjZSArPSAndmFyeWluZyB2ZWMyIHZfdGV4Y29vcmQ7JztcbiAgICAgICAgICAgIHZlcnRleFNoYWRlclNvdXJjZSArPSAndm9pZCBtYWluKCkgeyc7XG4gICAgICAgICAgICAvLyDku47lg4/ntKDlnZDmoIfovazmjaLliLAgMC4wIOWIsCAxLjBcbiAgICAgICAgICAgIHZlcnRleFNoYWRlclNvdXJjZSArPSAndmVjMiB6ZXJvVG9PbmUgPSBhX3Bvc2l0aW9uIC8gdV9yZXNvbHV0aW9uOyc7XG4gICAgICAgICAgICAvLyDlho3mioogMC0+MSDovazmjaIgMC0+MlxuICAgICAgICAgICAgdmVydGV4U2hhZGVyU291cmNlICs9ICd2ZWMyIHplcm9Ub1R3byA9IHplcm9Ub09uZSAqIDIuMDsnO1xuICAgICAgICAgICAgLy8g5oqKIDAtPjIg6L2s5o2i5YiwIC0xLT4rMSAo6KOB5Ymq56m66Ze0KVxuICAgICAgICAgICAgdmVydGV4U2hhZGVyU291cmNlICs9ICd2ZWMyIGNsaXBTcGFjZSA9IHplcm9Ub1R3byAtIDEuMDsnO1xuICAgICAgICAgICAgdmVydGV4U2hhZGVyU291cmNlICs9ICdnbF9Qb3NpdGlvbiA9IHZlYzQoY2xpcFNwYWNlICogdmVjMigxLCAtMSksIDAsIDEpOyc7XG4gICAgICAgICAgICAvLyDkvKDpgJLnurnnkIblnZDmoIfliLDniYfmlq3nnYDoibLlmahcbiAgICAgICAgICAgIHZlcnRleFNoYWRlclNvdXJjZSArPSAndl90ZXhjb29yZCA9IGFfdGV4Y29vcmQ7JztcbiAgICAgICAgICAgIHZlcnRleFNoYWRlclNvdXJjZSArPSAnfSc7XG4gICAgICAgICAgICAvL+eJh+auteedgOiJsuWZqOS7o+eggVxuICAgICAgICAgICAgbGV0IGZyYWdtZW50U2hhZGVyU291cmNlID0gJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0Oyc7XG4gICAgICAgICAgICAvLyDku47pobbngrnnnYDoibLlmajkuK3kvKDlhaXnmoTlgLxcbiAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyU291cmNlICs9ICd2YXJ5aW5nIHZlYzIgdl90ZXhjb29yZDsnO1xuICAgICAgICAgICAgLy8g57q555CGXG4gICAgICAgICAgICBmcmFnbWVudFNoYWRlclNvdXJjZSArPSAndW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlOyc7XG4gICAgICAgICAgICBmcmFnbWVudFNoYWRlclNvdXJjZSArPSAndm9pZCBtYWluKCkgeyc7XG4gICAgICAgICAgICBmcmFnbWVudFNoYWRlclNvdXJjZSArPSAnZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl90ZXhjb29yZCk7JztcbiAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyU291cmNlICs9ICd9JztcbiAgICAgICAgICAgIF93ZWJnbENvbnRleHQgPSBfY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJyk7XG4gICAgICAgICAgICBfd2ViZ2xDb250ZXh0LmVuYWJsZShfd2ViZ2xDb250ZXh0LkJMRU5EKTsgLy/lvIDlkK/mt7flkIjlip/og71cbiAgICAgICAgICAgIF93ZWJnbENvbnRleHQuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTsgLy/orr7nva7muIXpmaTpopzoibJcbiAgICAgICAgICAgIF93ZWJnbENvbnRleHQuYmxlbmRGdW5jKF93ZWJnbENvbnRleHQuU1JDX0FMUEhBLCBfd2ViZ2xDb250ZXh0Lk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuICAgICAgICAgICAgbGV0IHZlcnRleFNoYWRlciA9IGNyZWF0ZVNoYWRlcihfd2ViZ2xDb250ZXh0LCBfd2ViZ2xDb250ZXh0LlZFUlRFWF9TSEFERVIsIHZlcnRleFNoYWRlclNvdXJjZSk7IC8v5Yib5bu66aG254K5552A6Imy5ZmoXG4gICAgICAgICAgICBsZXQgZnJhZ21lbnRTaGFkZXIgPSBjcmVhdGVTaGFkZXIoX3dlYmdsQ29udGV4dCwgX3dlYmdsQ29udGV4dC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50U2hhZGVyU291cmNlKTsgLy/liJvlu7rniYfmrrXnnYDoibLlmahcbiAgICAgICAgICAgIGxldCBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbShfd2ViZ2xDb250ZXh0LCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyKTsgLy/liJvlu7rnnYDoibLnqIvluo9cbiAgICAgICAgICAgIF93ZWJnbENvbnRleHQudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgICAgIF9wb3NpdGlvbkF0dHJpYnV0ZUxvY2F0aW9uID0gX3dlYmdsQ29udGV4dC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3NpdGlvbicpO1xuICAgICAgICAgICAgbGV0IHRleGNvb3JkQXR0cmlidXRlTG9jYXRpb24gPSBfd2ViZ2xDb250ZXh0LmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3RleGNvb3JkJyk7XG4gICAgICAgICAgICBfcmVzb2x1dGlvblVuaWZvcm1Mb2NhdGlvbiA9IF93ZWJnbENvbnRleHQuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3Jlc29sdXRpb24nKTtcbiAgICAgICAgICAgIF93ZWJnbENvbnRleHQudmlld3BvcnQoMCwgMCwgX2NhbnZhcy53aWR0aCwgX2NhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgX3dlYmdsQ29udGV4dC51bmlmb3JtMmYoX3Jlc29sdXRpb25Vbmlmb3JtTG9jYXRpb24sIF9jYW52YXMud2lkdGgsIF9jYW52YXMuaGVpZ2h0KTsgLy8g6K6+572u5YWo5bGA5Y+Y6YePIOWIhui+qOeOh1xuICAgICAgICAgICAgLy/nu5HlrprojIPlm7RcbiAgICAgICAgICAgIGxldCB0ZXhjb29yZEJ1ZmZlciA9IF93ZWJnbENvbnRleHQuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgICAgICAvLyDlsIbnu5Hlrprngrnnu5HlrprliLDnvJPlhrLmlbDmja7vvIh0ZXhjb29yZEJ1ZmZlcu+8iVxuICAgICAgICAgICAgX3dlYmdsQ29udGV4dC5iaW5kQnVmZmVyKF93ZWJnbENvbnRleHQuQVJSQVlfQlVGRkVSLCB0ZXhjb29yZEJ1ZmZlcik7XG4gICAgICAgICAgICBfd2ViZ2xDb250ZXh0LmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRleGNvb3JkQXR0cmlidXRlTG9jYXRpb24pO1xuICAgICAgICAgICAgLy8g5Lul5rWu54K55Z6L5qC85byP5Lyg6YCS57q555CG5Z2Q5qCHXG4gICAgICAgICAgICBfd2ViZ2xDb250ZXh0LnZlcnRleEF0dHJpYlBvaW50ZXIodGV4Y29vcmRBdHRyaWJ1dGVMb2NhdGlvbiwgMiwgLy9zaXplIOavj+asoei/reS7o+i/kOihjOaPkOWPluS4pOS4quWNleS9jeaVsOaNrlxuICAgICAgICAgICAgICAgIF93ZWJnbENvbnRleHQuRkxPQVQsIC8vdHlwZSDmr4/kuKrljZXkvY3nmoTmlbDmja7nsbvlnovmmK8zMuS9jea1rueCueWei1xuICAgICAgICAgICAgICAgIGZhbHNlLCAvL25vcm1hbGl6ZSDkuI3pnIDopoHlvZLkuIDljJbmlbDmja4gXG4gICAgICAgICAgICAgICAgMCwgLy9zdHJpZGUgMCA9IOenu+WKqOWNleS9jeaVsOmHjyAqIOavj+S4quWNleS9jeWNoOeUqOWGheWtmO+8iHNpemVvZih0eXBlKe+8iVxuICAgICAgICAgICAgICAgIC8vIOavj+asoei/reS7o+i/kOihjOi/kOWKqOWkmuWwkeWGheWtmOWIsOS4i+S4gOS4quaVsOaNruW8gOWni+eCuVxuICAgICAgICAgICAgICAgIDAgLy9vZmZzZXQg5LuO57yT5Yay6LW35aeL5L2N572u5byA5aeL6K+75Y+WXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgX3dlYmdsQ29udGV4dC5idWZmZXJEYXRhKF93ZWJnbENvbnRleHQuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KFswLCAwLFxuICAgICAgICAgICAgICAgIDEsIDAsXG4gICAgICAgICAgICAgICAgMCwgMSxcbiAgICAgICAgICAgICAgICAwLCAxLFxuICAgICAgICAgICAgICAgIDEsIDAsXG4gICAgICAgICAgICAgICAgMSwgMV0pLCBfd2ViZ2xDb250ZXh0LlNUQVRJQ19EUkFXKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmtY/op4jlmajmlK/mjIHmo4DmtYtcbiAgICAgICAgICogQHRocm93cyB7b3BlbkJTRS5Ccm93c2VyTm90U3VwcG9ydEVycm9yfSDmtY/op4jlmajkuI3mlK/mjIHnibnlrprmuLLmn5PmqKHlvI/ml7blvJXlj5HplJnor69cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHN1cHBvcnRDaGVjaygpIHtcbiAgICAgICAgICAgIGxldCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgLy9jYW52YXPlr7nosaFcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FudmFzLmdldENvbnRleHQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEJyb3dzZXJOb3RTdXBwb3J0RXJyb3IoJ0NhbnZhcycpO1xuICAgICAgICAgICAgbGV0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0ID09PSBudWxsKSB0aHJvdyBuZXcgQnJvd3Nlck5vdFN1cHBvcnRFcnJvcignQ2FudmFzIDJEJyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuZmlsbFRleHQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEJyb3dzZXJOb3RTdXBwb3J0RXJyb3IoJ0NhbnZhcyAyRCBmaWxsVGV4dCBGdW5jdGlvbicpO1xuICAgICAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7IC8vY2FudmFz5a+56LGhXG4gICAgICAgICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJyk7XG4gICAgICAgICAgICBpZiAoY29udGV4dCA9PT0gbnVsbCkgdGhyb3cgbmV3IEJyb3dzZXJOb3RTdXBwb3J0RXJyb3IoJ1dlYkdMJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IFdlYkdMUmVuZGVyZXIgfTsiLCJtb2R1bGUuZXhwb3J0cz17XG4gICAgXCJFVkVOVF9OQU1FX05PVF9GT1VORF9FUlJPUlwiOiBcIkV2ZW50IG5hbWUgbm90IGZvdW5kLlwiLFxuICAgIFwiRVZFTlRfQUxSRUFEWV9FWElTVFNfRVJST1JcIjogXCJFdmVudCBhbHJlYWR5IGV4aXN0cy5cIixcbiAgICBcIlBBUkFNRVRFUlNfVFlQRV9FUlJPUlwiOiBcIlBhcmFtZXRlcnMgdHlwZSBlcnJvci5cIixcbiAgICBcIlJFTkRFUl9NT0RFX0VSUk9SXCI6IFwiVGhlIHJlbmRlciBtb2RlIFxcXCJ7cmVuZGVyTW9kZX1cXFwiIGlzIHVuZGVmaW5lZC5cIixcbiAgICBcIkJST1dTRVJfTk9UX1NVUFBPUlRfRVJST1JcIjogXCJUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBcXFwie21lc3NhZ2V9XFxcIi5cIixcbiAgICBcIlJFUVVFU1RBTklNQVRJT05GUkFNRV9OT1RfU1VQUE9SVF9XQVJOXCI6IFwiWW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgbWV0aG9kIFxcXCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWVcXFwiIGFuZCB3aWxsIHN3aXRjaCB0byBtZXRob2QgXFxcInNldFRpbWVvdXRcXFwiLCB3aGljaCBtYXkgYWZmZWN0IHBlcmZvcm1hbmNlLlwiLFxuICAgIFwiREVWSUNFUElYRUxSQVRJT19OT1RfU1VQUE9SVF9XQVJOXCI6IFwiWW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdmFyaWFibGUgXFxcImRldmljZVBpeGVsUmF0aW9cXFwiLCB3aGljaCBtYXkgY2F1c2UgY2FudmFzIHVuYWJsZSB0byBkaXNwbGF5IHByb3Blcmx5IGluIGhpZ2ggRFBJIG1vZGUuIEl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBDU1MzIHJlbmRlciBtb2RlLlwiLFxuICAgIFwiTE9BREVEX0lORk9cIjogXCIlY3tuYW1lfSVjIG5vdyBsb2FkZWQuXFxuXFxuJWNWZXJzaW9uOiB7dmVyc2lvbn1cXG5CdWlsZCBEYXRlOiB7YnVpbGREYXRlfVxcblxcbiVje2Rlc2NyaXB0aW9ufVxcbkhvbWU6IHtob21lfVwiLFxuICAgIFwiTE9BREVEX0lORk9fSUVcIjogXCJ7bmFtZX0gbm93IGxvYWRlZC5cXG5cXG5WZXJzaW9uOiB7dmVyc2lvbn1cXG5CdWlsZCBEYXRlOiB7YnVpbGREYXRlfVxcblxcbntkZXNjcmlwdGlvbn1cXG5Ib21lOiB7aG9tZX1cIlxufSIsImltcG9ydCAqIGFzIFJlc291cmNlcyBmcm9tICcuL3Jlc291cmNlcy5qc29uJ1xuXG4vKipcbiAqIOaVsOaNruWhq+WFhe+8iOWNoOS9jeespuaLvOaOpe+8iVxuICogQHBhcmFtIHtvYmplY3R8Li4uc3RyaW5nfSBzaWduIC0g5LiA57uE5a2X56ym5Liy5oiW5LiA5Liq5a+56LGhXG4gKi9cbmZ1bmN0aW9uIGZpbGxEYXRhKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcztcbiAgICB2YXIgcGFyYW0gPSBhcmd1bWVudHNbMF0sIHN0ciA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiAocGFyYW0pID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcGFyYW0pXG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShuZXcgUmVnRXhwKFwiXFxcXHtcIiArIGtleSArIFwiXFxcXH1cIiwgXCJnXCIpLCBwYXJhbVtrZXldKTtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcXFxce1wiICsgaSArIFwiXFxcXH1cIiwgXCJnXCIpLCBhcmd1bWVudHNbaV0pO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbn1cblxuZm9yIChsZXQga2V5IGluIFJlc291cmNlcykge1xuICAgIGlmICh0eXBlb2YgUmVzb3VyY2VzW2tleV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIFJlc291cmNlc1trZXldID0gbmV3IFN0cmluZyhSZXNvdXJjZXNba2V5XSk7XG4gICAgICAgIFJlc291cmNlc1trZXldLmZpbGxEYXRhID0gZmlsbERhdGE7XG4gICAgfVxufVxuXG5leHBvcnQgeyBSZXNvdXJjZXMgfSIsImltcG9ydCB7IEhlbHBlciB9IGZyb20gJy4vbGliL2hlbHBlcidcbmltcG9ydCB7IEJ1bGxldFNjcmVlbkVuZ2luZSB9IGZyb20gJy4vYnVsbGV0U2NyZWVuRW5naW5lJ1xuaW1wb3J0IHsgQnJvd3Nlck5vdFN1cHBvcnRFcnJvciB9IGZyb20gJy4vYnJvd3Nlck5vdFN1cHBvcnRFcnJvcidcbmltcG9ydCB7IEJ1bGxldFNjcmVlblR5cGUgfSBmcm9tICcuL2J1bGxldFNjcmVlblR5cGUnXG5pbXBvcnQgeyBDb250ZXh0bWVudSB9IGZyb20gJy4vY29udGV4dG1lbnUnXG5pbXBvcnQgKiBhcyBidWlsZCBmcm9tICcuL2J1aWxkLmpzb24nXG5cbi8qKlxuICog6I635Y+W54mI5pys5L+h5oGv44CCXG4gKiBAYWxpYXMgb3BlbkJTRS5nZXRWZXJzaW9uXG4gKiBAcmV0dXJucyB7b3BlbkJTRX5WZXJzaW9uSW5mb30g54mI5pys5L+h5oGv77ya5LiA5LiqIHtAbGluayBvcGVuQlNFflZlcnNpb25JbmZvfSDnu5PmnoTjgIJcbiAqL1xuZnVuY3Rpb24gZ2V0VmVyc2lvbigpIHtcbiAgICByZXR1cm4gSGVscGVyLmNsb25lKGJ1aWxkKTtcbn1cblxuZXhwb3J0IHsgQnVsbGV0U2NyZWVuRW5naW5lLCBCcm93c2VyTm90U3VwcG9ydEVycm9yLCBCdWxsZXRTY3JlZW5UeXBlLCBDb250ZXh0bWVudSwgZ2V0VmVyc2lvbiB9XG5cbi8qKlxuICog5YWo5bGA6YCJ6aG5XG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBvcGVuQlNFfk9wdGlvbnNcbiAqIEBkZXNjcmlwdGlvbiBPcHRpb24g57uT5p6E55So5LqO5a2Y5pS+5YWo5bGA6YCJ6aG544CCXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3ZlcnRpY2FsSW50ZXJ2YWw9OF0gLSDlvLnluZXlnoLnm7TooYzpl7Tot51cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdmVydGljYWxJbnRlcnZhbD0xXSAtIOW8ueW5leaSreaUvumAn+W6pu+8iOWAjeaVsO+8iVxuICogQHByb3BlcnR5IHtvcGVuQlNFfmNsb2NrQ2FsbGJhY2t9IFtjbG9jaz10aW1lID0+IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRUaW1lXSAtIOaXtumXtOWfuuWHhu+8muatpOaXtumXtOWfuuWHhuWPr+aMh+WQkeS4gOS4quaWueazleeUqOS6juiOt+WPluaSreaUvuWZqOW9k+WJjei/m+W6pu+8jOi/meS4quaWueazlei/lOWbnuWAvOWNs+S4uuaSreaUvui/m+W6pu+8iOWNleS9je+8muavq+enku+8ieOAglxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzY2FsaW5nPTFdIOW8ueW5lee8qeaUvuavlOS+i++8iOWAjeaVsO+8iVxuICogQHByb3BlcnR5IHtvcGVuQlNFfkJ1bGxldFNjcmVlblN0eWxlfSBbZGVmYXVsdFN0eWxlXSDpu5jorqTlvLnluZXmoLflvI/vvJrkuIDkuKoge0BsaW5rIG9wZW5CU0V+QnVsbGV0U2NyZWVuU3R5bGV9IOe7k+aehOOAglxuICogQHByb3BlcnR5IHtvcGVuQlNFLkJ1bGxldFNjcmVlblR5cGV9IFtoaWRkZW5UeXBlcz0wXSDpmpDol4/nmoTlvLnluZXnsbvlnovvvJrkuIDkuKoge0BsaW5rIG9wZW5CU0UuQnVsbGV0U2NyZWVuVHlwZX0g5p6a5Li+44CC5bCG6KaB6ZqQ6JeP55qE5by55bmV57G75Z6L55u45Yqg77yMMOS4uuS4jemakOiXj+S7u+S9leexu+Wei+eahOW8ueW5leOAglxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvcGFjaXR5PTEuMF0g5by55bmV5LiN6YCP5piO5bqm77ya5Y+W5YC86IyD5Zu0IDAuMCDliLAgMS4w77yMMC4wIOWFqOmAj+aYju+8mzEuMCDkuI3pgI/mmI7jgIJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY3Vyc29yT25Nb3VzZU92ZXI9J3BvaW50ZXInXSDpvKDmoIfnu4/ov4fmoLflvI/vvJrlvZPpvKDmoIfnu4/ov4flvLnluZXml7bnmoTmoLflvI/vvIzlj6/orr7nva7nmoTlgLzlj6/lj4LogIMgTUROIFtjdXJzb3JdIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9DU1MvY3Vyc29yfSDjgIJcbiAqL1xuXG4vKipcbiAqIOaXtumXtOWfuuWHhuWbnuiwg+aWueazlVxuICogQGNhbGxiYWNrIG9wZW5CU0V+Y2xvY2tDYWxsYmFja1xuICogQGRlc2NyaXB0aW9uIENsb2NrQ2FsbGJhY2sg5Zue6LCD5pa55rOV55So5LqO5pKt5pS+5Zmo5b2T5YmN6L+b5bqm44CCXG4gKiBAcmV0dXJucyB7bnVtYmVyfSDmkq3mlL7ov5vluqbvvJrljZXkvY3vvJrmr6vnp5LjgIJcbiAqL1xuXG4vKipcbiAqIOWNleadoeW8ueW5leaVsOaNrlxuICogQHR5cGVkZWYge29iamVjdH0gb3BlbkJTRX5CdWxsZXRTY3JlZW5cbiAqIEBkZXNjcmlwdGlvbiBCdWxsZXRTY3JlZW4g57uT5p6E55So5LqO5a2Y5pS+5Y2V5p2h5by55bmV5pWw5o2u44CCXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdGV4dCDlvLnluZXmlofmnKxcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NhbkRpc2NhcmQ9dHJ1ZV0g5piv5ZCm5YWB6K645Lii5byD77ya77yI5q2k5Y+C5pWw5Zyo5LqL5Lu25Lit5L+u5pS55peg5pWI77yJ5Zyo5by55bmV6L+H5aSa5pe277yM56iL5bqP5bCG6Ieq5Yqo5Lii5byD5LiA5Lqb5bu26L+f6L+H6auY55qE5by55bmV44CC5q2k6YCJ6aG55Li6IGZhbHNlIOaXtuacrOadoeW8ueW5leaXoOiuuuWmguS9lemDveS4jeS8muiiq+S4ouW8g++8jOS9v+eUqOacrOmAiemhueeahOWcuuaZr+WmguacrOeUqOaIt+WPkemAgeeahOW8ueW5leOAgu+8iOazqOaEj++8muS4jeimgeWwhuWkquWkmueahOW8ueW5leeahCBjYW5EaXNjYXJkIOiuvuS4uiBmYWxzZe+8jCDlkKbliJnkvJrlm6DotoXml7bnmoTlvLnluZXkuI3kvJrooqvkuKLlvIPogIzpgKDmiJDmhI/lpJbnmoTpl67popjjgILvvIlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc3RhcnRUaW1lPW9wdGlvbnMuY2xvY2soKV0g5by55bmV6L+b5YWl5pe26Ze077ya77yI5q2k5Y+C5pWw5Zyo5LqL5Lu25Lit5L+u5pS55peg5pWI77yJ5Y2V5L2N77ya5q+r56eS77yM6buY6K6k5Li6W+aXtumXtOWfuuWHhu+8iG9wdGlvbnMuY2xvY2vvvIlde0BsaW5rIG9wZW5CU0V+T3B0aW9uc33lvZPliY3ml7bpl7TjgIJcbiAqIEBwcm9wZXJ0eSB7b3BlbkJTRS5CdWxsZXRTY3JlZW5UeXBlfSBbdHlwZT1vcGVuQlNFLkJ1bGxldFNjcmVlblR5cGUucmlnaHRUb0xlZnRdIOW8ueW5leexu+Wei++8mu+8iOatpOWPguaVsOWcqOS6i+S7tuS4reS/ruaUueaXoOaViO+8ieS4gOS4quexu+Wei+S4uiB7QGxpbmsgb3BlbkJTRS5CdWxsZXRTY3JlZW5UeXBlfSDnmoTmnprkuL7jgIJcbiAqIEBwcm9wZXJ0eSB7b3BlbkJTRX5CdWxsZXRTY3JlZW5TdHlsZX0gc3R5bGUg5by55bmV5qC35byP77ya5LiA5LiqIHtAbGluayBvcGVuQlNFfkJ1bGxldFNjcmVlblN0eWxlfSDnu5PmnoTjgILorr7nva7mraTpgInpobnkuK3nmoTku7vkvZXkuIDkuKrlgLzvvIzlsIbopobnm5blr7nlupTnmoTlhajlsYDorr7nva7jgIJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbGF5ZXI9MF0g5by55bmV5bGC57qn77ya5q2k5Y+C5pWw6LaK5aSn77yM5by55bmV6LaK6Z2g5YmN44CC5LiA5p2h5by55bmV5Zyo5q+U5a6D5bGC57qn5bCP55qE5by55bmV5YmN6Z2i77yM5Zyo5q+U5a6D5bGC57qn5aSn55qE5by55bmV5ZCO6Z2i44CC5aaC5p6c5bGC57qn55u45ZCM5oyJ54Wn6L+b5YWl5pe26Ze056Gu5a6a5bGC57qn6aG65bqP44CCXG4gKiBAcHJvcGVydHkge2FueX0gbW9yZS4uLiDlhbbku5boh6rlrprkuYnlrZfmrrXvvJrvvIjlnKjkuovku7bkuK3kv67mlLnkv67mlLnmraTlj4LmlbDml6DpnIDlsIYgZS5yZWRyYXcg6K6+572u5Li6IHRydWXvvInkvovlpoIgdXVpZCDjgIEgaWQg562J44CC77yI5rOo5oSP77ya5Zug5Li65Zyo5LqL5Lu25ZON5bqU5pa55rOV5Lit6L+U5Zue55qE5by55bmV5a+56LGh5piv5Y6f5a+56LGh5YWL6ZqG55qE77yM5omA5Lul5peg5rOV55u05o6l5q+U6L6D77yM5b+F6aG75L2/55So6Ieq5a6a5LmJ5a2X5q615ZSv5LiA5qCH6K+G5LiA5p2h5by55bmV44CC77yJXG4gKi9cblxuLyoqXG4gKiDlvLnluZXmoLflvI9cbiAqIEB0eXBlZGVmIHtvYmplY3R9IG9wZW5CU0V+QnVsbGV0U2NyZWVuU3R5bGVcbiAqIEBkZXNjcmlwdGlvbiBCdWxsZXRTY3JlZW5TdHlsZSDnu5PmnoTnlKjkuo7lrZjmlL7lvLnluZXmoLflvI/kv6Hmga/jgIJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc2hhZG93Qmx1cj0yXSDlvLnluZXpmLTlvbHnmoTmqKHns4rnuqfliKvvvJow5Li65LiN5pi+56S66Zi05b2x44CCXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2ZvbnRXZWlnaHQ9XCI2MDBcIl0g5a2X5L2T57KX57uG77ya5Y+v6YCJ5YC877yabGlnaHRlcu+8muabtOe7hu+8m25vcm1hbO+8muagh+WHhu+8m2JvbGTvvJrnspfkvZPvvJtib2xkZXI6IOabtOeyl++8mzEwMOOAgTIwMOOAgTMwMOOAgTQwMOOAgTUwMOOAgTYwMOOAgTcwMOOAgTgwMOOAgTkwMO+8muWumuS5ieeUseeyl+WIsOe7hueahOWtl+espu+8iDQwMCDnrYnlkIzkuo4gbm9ybWFs77ybNzAwIOetieWQjOS6jiBib2xk77yJ44CCXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2ZvbnRGYW1pbHk9XCJzYW5zLXNlcmlmXCJdIOWtl+S9k+ezu+WIl++8muW8ueW5leeahOWtl+S9k+aXj+WQjeensOaIli/lj4rnsbvml4/lkI3np7DnmoTkuIDkuKrkvJjlhYjooajjgILvvIjms6jmhI/vvJrlpoLmnpzkvb/nlKjkuobnlKjigJxAZm9udC1mYWNl4oCd5a6a5LmJ55qE5a2X5L2T77yM6K+356Gu5L+d5Zyo5L2/55So5YmN5a6M5YWo5Yqg6L295a6M5oiQ77yM5ZCm5YiZ5by55bmV5Y+v6IO95peg5rOV5pi+56S644CC5aaC5p6c6KaB6aKE5Yqg6L296L+Z5Lqb5a2X5L2T77yM5bu66K6u5L2/55SoIFtXZWIgRm9udCBMb2FkZXJde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS90eXBla2l0L3dlYmZvbnRsb2FkZXJ9IOOAgu+8iVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzaXplPTE5XSDlrZfkvZPlpKflsI/vvJrljZXkvY3vvJrlg4/ntKDjgIJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYm94Q29sb3JdIOWkluahhuminOiJsu+8muWPgueFp0NTU+minOiJsuiuvue9ruaWueazle+8jOS4uiBudWxsIOS4jeaYvuekuuWkluahhuOAglxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjb2xvcj1cIndoaXRlXCJdIOW8ueW5leminOiJsu+8muWPgueFp0NTU+minOiJsuiuvue9ruaWueazle+8jOS4uiBudWxsIOS4jeaYvuekuuatpOW8ueW5leOAglxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtib3JkZXJDb2xvcl0g5o+P6L656aKc6Imy77ya5Y+C54WnQ1NT6aKc6Imy6K6+572u5pa55rOV77yM5Li6IG51bGwg5rKh5pyJ5o+P6L6544CCXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3NwZWVkPTAuMTVdIOW8ueW5lemAn+W6pu+8mu+8iOWcqOS6i+S7tuS4reS/ruaUueS/ruaUueatpOWPguaVsOaXoOmcgOWwhiBlLnJlZHJhdyDorr7nva7kuLogdHJ1Ze+8ieWNleS9je+8muWDj+e0oC/mr6vnp5LvvIzku4XlvLnluZXnsbvlnovkuLow44CBMeaXtuacieaViOOAglxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZXNpZGVuY2VUaW1lPTUwMDBdIOW8ueW5leWBnOeVmeaXtumXtO+8mu+8iOatpOWPguaVsOWcqOS6i+S7tuS4reS/ruaUueaXoOaViO+8ieWNleS9je+8muavq+enku+8jOS7heW8ueW5leexu+WeizLjgIEz5pe25pyJ5pWI44CCXG4gKi9cblxuLyoqXG4gKiDlvLnluZXkuovku7ZcbiAqIEB0eXBlZGVmIHtvYmplY3R9IG9wZW5CU0V+QnVsbGV0U2NyZWVuRXZlbnRcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGdldEJ1bGxldFNjcmVlbigpIC0g6I635Y+W5byV5Y+R5LqL5Lu255qE5by55bmV5by55bmV55qE5pWw5o2u77yacmV0dW46IHtAbGluayBvcGVuQlNFfkJ1bGxldFNjcmVlbn0g5byV5Y+R5LqL5Lu255qE5by55bmV55qE5pWw5o2u77ya5LiA5LiqIHtAbGluayBvcGVuQlNFfkJ1bGxldFNjcmVlbn0g57uT5p6E44CC77yI5rOo5oSP77ya5LiN6KaB6K+V5Zu+5LiOW+a3u+WKoOW8ueW5lV17QGxpbmsgb3BlbkJTRS5CdWxsZXRTY3JlZW5FbmdpbmUjYWRkQnVsbGV0U2NyZWVufeaXtuWIm+W7uueahOWvueixoei/m+ihjOavlOi+g++8jOi/meS4quWvueixoeaYr+WFi+mahuW+l+WIsOeahO+8jOW5tuS4jeebuOetieOAguato+ehrueahOaWueazleaYr+WcqOa3u+WKoOW8ueW5leaXtuS4gOW5tuaPkuWFpSBpZCDnrYnoh6rlrprkuYnlrZfmrrXmnaXllK/kuIDmoIfor4bkuIDmnaHlvLnluZXjgILvvIlcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHNldEJ1bGxldFNjcmVlbihidWxsZXRTY3JlZW4scmVkcmF3KSAtIOiuvue9ruW8leWPkeS6i+S7tueahOW8ueW5leW8ueW5leeahOaVsOaNru+8mnBhcmFtczoge0BsaW5rIG9wZW5CU0V+QnVsbGV0U2NyZWVufSBidWxsZXRTY3JlZW4gLSDlvJXlj5Hkuovku7bnmoTlvLnluZXnmoTmlbDmja7vvJrkuIDkuKoge0BsaW5rIG9wZW5CU0V+QnVsbGV0U2NyZWVufSDnu5PmnoTjgILorr7nva7mraTlj4LmlbDku6Xkvr/liqjmgIHosIPmlbTlvLnluZXmoLflvI/vvIzkvYbmmK/kuIDkupvlj4LmlbDlnKjkuovku7bkuK3kv67mlLnml6DmlYjvvIzmn6XnnIvmraTnu5PmnoTnmoTor7TmmI7ku6Xkuobop6Por6bmg4XjgIIgYm9vbGVhbiBbcmVkcmF3PWZhbHNlXSAtIOaYr+WQpumHjee7mOW8ueW5le+8muatpOWPguaVsOWcqOavj+asoeW8leWPkeS6i+S7tuaXtueahOWIneWni+WAvOS4uiBmYWxzZSDvvIzlpoLmnpzkv67mlLnkuoYgYnVsbGV0U2NyZWVuIOS4reeahOWAvO+8jOatpOWPguaVsOW/hemhu+iuvuS4uiB0cnVlIOOAglxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gZ2V0UGxheVN0YXRlKCkgLSDojrflj5blvJXlj5Hkuovku7bnmoTlvLnluZXnmoTmkq3mlL7nirbmgIHvvJpyZXR1bjogYm9vbGVhbiDlj5blvJXlj5Hkuovku7bnmoTlvLnluZXmmK/lkKblnKjmkq3mlL4v56e75Yqo77ya5aaC5p6c6K6+572u5Li6IHRydWUg5YiZ6K+l5by55bmV5pqC5YGc77yM55u05Yiw5bCG5q2k5Y+C5pWw6K6+5Li6IGZhbHNlIOaIluiwg+eUqCB7QGxpbmsgb3BlbkJTRS5CdWxsZXRTY3JlZW5FbmdpbmUjcGxheUFsbEJ1bGxldFNjcmVlbnN9IOaWueazleOAglxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gc2V0UGxheVN0YXRlKHBsYXkpIC0g6K6+572u5byV5Y+R5LqL5Lu255qE5by55bmV55qE5pKt5pS+54q25oCB77yacGFyYW1zOiBib29sZWFuIHBhbHkgLSDmmK/lkKbnu6fnu63mkq3mlL4v56e75Yqo5byV5Y+R5LqL5Lu255qE5by55bmV77ya6K+75Y+W5q2k5Y+C5pWw5Y+v5Yik5pat6L+Z5p2h5by55bmV5piv5ZCm5aSE5LqO5pqC5YGc54q25oCB44CCXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSAtIOS6i+S7tuexu+Wei++8iOS6i+S7tuWQjeensO+8iVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNjcmVlblggLSDlvZPkuovku7blj5HnlJ/ml7bvvIzpvKDmoIfnm7jlr7nkuo7mmL7npLrlmajlsY/nmoQgWCDlnZDmoIfjgIJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzY3JlZW5ZIC0g5b2T5LqL5Lu25Y+R55Sf5pe277yM6byg5qCH55u45a+55LqO5pi+56S65Zmo5bGP55qEIFkg5Z2Q5qCH44CCXG4gKiBAcHJvcGVydHkge251bWJlcn0gY2xpZW50WCAtIOW9k+S6i+S7tuWPkeeUn+aXtu+8jOm8oOagh+ebuOWvueS6jua1j+iniOWZqOacieaViOWMuuWfn+eahCBYIOWdkOagh+OAglxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBhZ2VYIC0g5b2T5LqL5Lu25Y+R55Sf5pe277yM6byg5qCH55u45a+55LqO6aG16Z2i55qEIFgg5Z2Q5qCH44CCXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGFnZVkgLSDlvZPkuovku7blj5HnlJ/ml7bvvIzpvKDmoIfnm7jlr7nkuo7pobXpnaLnmoQgWSDlnZDmoIfjgIJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwYWdlWSAtIOW9k+S6i+S7tuWPkeeUn+aXtu+8jOm8oOagh+ebuOWvueS6jumhtemdoueahCBZIOWdkOagh+OAglxuICovXG5cbi8qKlxuICog6LCD6K+V5L+h5oGvXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBvcGVuQlNFfkRlYnVnSW5mb1xuICogQGRlc2NyaXB0aW9uIERlYnVnSW5mbyDnu5PmnoTnlKjkuo7lrZjmlL7osIPor5Xkv6Hmga/jgIJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lIFvml7bpl7Tln7rlh4bvvIhvcHRpb25zLmNsb2Nr77yJXXtAbGluayBvcGVuQlNFfk9wdGlvbnN95b2T5YmN5pe26Ze044CCXG4gKiBAcHJvcGVydHkge251bWJlcn0gYnVsbGV0U2NyZWVuc09uU2NyZWVuQ291bnQg5a6e5pe25by55bmV5oC75pWwXG4gKiBAcHJvcGVydHkge251bWJlcn0gYnVsbGV0U2NyZWVuc0NvdW50IOWJqeS9meW8ueW5leaAu+aVsFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRlbGF5IOW7tui/n++8muWNleS9je+8muavq+enkuOAglxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRlbGF5QnVsbGV0U2NyZWVuc0NvdW50IOS4ouW8g+W8ueW5leaVsO+8muWboOW7tui/n+i/h+mrmOiAjOS4ouW8g+eahOW8ueW5leaAu+aVsOOAglxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZwcyDluKfpopHvvJrljZXkvY3vvJrluKcv56eS44CCXG4gKi9cblxuLyoqXG4gKiDniYjmnKzkv6Hmga9cbiAqIEB0eXBlZGVmIHtvYmplY3R9IG9wZW5CU0V+VmVyc2lvbkluZm9cbiAqIEBkZXNjcmlwdGlvbiBWZXJzaW9uSW5mbyDnu5PmnoTnlKjkuo7lrZjmlL7niYjmnKzkv6Hmga/jgIJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2ZXJzaW9uIOeJiOacrOWPt1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGJ1aWxkRGF0ZSDmnoTlu7rml6XmnJ/vvJrml7bljLrvvJpVVEPjgIJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIOWQjeensFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uIOaPj+i/sFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGhvbWUg5Li76aG1XG4gKi8iLCIvKiFcbiAqIHBlcmZlY3Qtc2Nyb2xsYmFyIHYxLjQuMFxuICogKGMpIDIwMTggSHl1bmplIEp1blxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZ2V0KGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIHNldChlbGVtZW50LCBvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIHZhciB2YWwgPSBvYmpba2V5XTtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhbCA9IHZhbCArIFwicHhcIjtcbiAgICB9XG4gICAgZWxlbWVudC5zdHlsZVtrZXldID0gdmFsO1xuICB9XG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5mdW5jdGlvbiBkaXYoY2xhc3NOYW1lKSB7XG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgcmV0dXJuIGRpdjtcbn1cblxudmFyIGVsTWF0Y2hlcyA9XG4gIHR5cGVvZiBFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxuICAoRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fFxuICAgIEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuICAgIEVsZW1lbnQucHJvdG90eXBlLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuICAgIEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yKTtcblxuZnVuY3Rpb24gbWF0Y2hlcyhlbGVtZW50LCBxdWVyeSkge1xuICBpZiAoIWVsTWF0Y2hlcykge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gZWxlbWVudCBtYXRjaGluZyBtZXRob2Qgc3VwcG9ydGVkJyk7XG4gIH1cblxuICByZXR1cm4gZWxNYXRjaGVzLmNhbGwoZWxlbWVudCwgcXVlcnkpO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5yZW1vdmUpIHtcbiAgICBlbGVtZW50LnJlbW92ZSgpO1xuICB9IGVsc2Uge1xuICAgIGlmIChlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcXVlcnlDaGlsZHJlbihlbGVtZW50LCBzZWxlY3Rvcikge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGVsZW1lbnQuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gbWF0Y2hlcyhjaGlsZCwgc2VsZWN0b3IpOyB9XG4gICk7XG59XG5cbnZhciBjbHMgPSB7XG4gIG1haW46ICdwcycsXG4gIGVsZW1lbnQ6IHtcbiAgICB0aHVtYjogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIChcInBzX190aHVtYi1cIiArIHgpOyB9LFxuICAgIHJhaWw6IGZ1bmN0aW9uICh4KSB7IHJldHVybiAoXCJwc19fcmFpbC1cIiArIHgpOyB9LFxuICAgIGNvbnN1bWluZzogJ3BzX19jaGlsZC0tY29uc3VtZScsXG4gIH0sXG4gIHN0YXRlOiB7XG4gICAgZm9jdXM6ICdwcy0tZm9jdXMnLFxuICAgIGNsaWNraW5nOiAncHMtLWNsaWNraW5nJyxcbiAgICBhY3RpdmU6IGZ1bmN0aW9uICh4KSB7IHJldHVybiAoXCJwcy0tYWN0aXZlLVwiICsgeCk7IH0sXG4gICAgc2Nyb2xsaW5nOiBmdW5jdGlvbiAoeCkgeyByZXR1cm4gKFwicHMtLXNjcm9sbGluZy1cIiArIHgpOyB9LFxuICB9LFxufTtcblxuLypcbiAqIEhlbHBlciBtZXRob2RzXG4gKi9cbnZhciBzY3JvbGxpbmdDbGFzc1RpbWVvdXQgPSB7IHg6IG51bGwsIHk6IG51bGwgfTtcblxuZnVuY3Rpb24gYWRkU2Nyb2xsaW5nQ2xhc3MoaSwgeCkge1xuICB2YXIgY2xhc3NMaXN0ID0gaS5lbGVtZW50LmNsYXNzTGlzdDtcbiAgdmFyIGNsYXNzTmFtZSA9IGNscy5zdGF0ZS5zY3JvbGxpbmcoeCk7XG5cbiAgaWYgKGNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpKSB7XG4gICAgY2xlYXJUaW1lb3V0KHNjcm9sbGluZ0NsYXNzVGltZW91dFt4XSk7XG4gIH0gZWxzZSB7XG4gICAgY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVNjcm9sbGluZ0NsYXNzKGksIHgpIHtcbiAgc2Nyb2xsaW5nQ2xhc3NUaW1lb3V0W3hdID0gc2V0VGltZW91dChcbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBpLmlzQWxpdmUgJiYgaS5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xzLnN0YXRlLnNjcm9sbGluZyh4KSk7IH0sXG4gICAgaS5zZXR0aW5ncy5zY3JvbGxpbmdUaHJlc2hvbGRcbiAgKTtcbn1cblxuZnVuY3Rpb24gc2V0U2Nyb2xsaW5nQ2xhc3NJbnN0YW50bHkoaSwgeCkge1xuICBhZGRTY3JvbGxpbmdDbGFzcyhpLCB4KTtcbiAgcmVtb3ZlU2Nyb2xsaW5nQ2xhc3MoaSwgeCk7XG59XG5cbnZhciBFdmVudEVsZW1lbnQgPSBmdW5jdGlvbiBFdmVudEVsZW1lbnQoZWxlbWVudCkge1xuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICB0aGlzLmhhbmRsZXJzID0ge307XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBpc0VtcHR5OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbkV2ZW50RWxlbWVudC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIGJpbmQgKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICBpZiAodHlwZW9mIHRoaXMuaGFuZGxlcnNbZXZlbnROYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLmhhbmRsZXJzW2V2ZW50TmFtZV0gPSBbXTtcbiAgfVxuICB0aGlzLmhhbmRsZXJzW2V2ZW50TmFtZV0ucHVzaChoYW5kbGVyKTtcbiAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVsZW1lbnQucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uIHVuYmluZCAoZXZlbnROYW1lLCB0YXJnZXQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLmhhbmRsZXJzW2V2ZW50TmFtZV0gPSB0aGlzLmhhbmRsZXJzW2V2ZW50TmFtZV0uZmlsdGVyKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgaWYgKHRhcmdldCAmJiBoYW5kbGVyICE9PSB0YXJnZXQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0aGlzJDEuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG59O1xuXG5FdmVudEVsZW1lbnQucHJvdG90eXBlLnVuYmluZEFsbCA9IGZ1bmN0aW9uIHVuYmluZEFsbCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgbmFtZSBpbiB0aGlzJDEuaGFuZGxlcnMpIHtcbiAgICB0aGlzJDEudW5iaW5kKG5hbWUpO1xuICB9XG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuaXNFbXB0eS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuaGFuZGxlcnMpLmV2ZXJ5KFxuICAgIGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHRoaXMkMS5oYW5kbGVyc1trZXldLmxlbmd0aCA9PT0gMDsgfVxuICApO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEV2ZW50RWxlbWVudC5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG52YXIgRXZlbnRNYW5hZ2VyID0gZnVuY3Rpb24gRXZlbnRNYW5hZ2VyKCkge1xuICB0aGlzLmV2ZW50RWxlbWVudHMgPSBbXTtcbn07XG5cbkV2ZW50TWFuYWdlci5wcm90b3R5cGUuZXZlbnRFbGVtZW50ID0gZnVuY3Rpb24gZXZlbnRFbGVtZW50IChlbGVtZW50KSB7XG4gIHZhciBlZSA9IHRoaXMuZXZlbnRFbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24gKGVlKSB7IHJldHVybiBlZS5lbGVtZW50ID09PSBlbGVtZW50OyB9KVswXTtcbiAgaWYgKCFlZSkge1xuICAgIGVlID0gbmV3IEV2ZW50RWxlbWVudChlbGVtZW50KTtcbiAgICB0aGlzLmV2ZW50RWxlbWVudHMucHVzaChlZSk7XG4gIH1cbiAgcmV0dXJuIGVlO1xufTtcblxuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gYmluZCAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gIHRoaXMuZXZlbnRFbGVtZW50KGVsZW1lbnQpLmJpbmQoZXZlbnROYW1lLCBoYW5kbGVyKTtcbn07XG5cbkV2ZW50TWFuYWdlci5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gdW5iaW5kIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgdmFyIGVlID0gdGhpcy5ldmVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGVlLnVuYmluZChldmVudE5hbWUsIGhhbmRsZXIpO1xuXG4gIGlmIChlZS5pc0VtcHR5KSB7XG4gICAgLy8gcmVtb3ZlXG4gICAgdGhpcy5ldmVudEVsZW1lbnRzLnNwbGljZSh0aGlzLmV2ZW50RWxlbWVudHMuaW5kZXhPZihlZSksIDEpO1xuICB9XG59O1xuXG5FdmVudE1hbmFnZXIucHJvdG90eXBlLnVuYmluZEFsbCA9IGZ1bmN0aW9uIHVuYmluZEFsbCAoKSB7XG4gIHRoaXMuZXZlbnRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnVuYmluZEFsbCgpOyB9KTtcbiAgdGhpcy5ldmVudEVsZW1lbnRzID0gW107XG59O1xuXG5FdmVudE1hbmFnZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgdmFyIGVlID0gdGhpcy5ldmVudEVsZW1lbnQoZWxlbWVudCk7XG4gIHZhciBvbmNlSGFuZGxlciA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICBlZS51bmJpbmQoZXZlbnROYW1lLCBvbmNlSGFuZGxlcik7XG4gICAgaGFuZGxlcihldnQpO1xuICB9O1xuICBlZS5iaW5kKGV2ZW50TmFtZSwgb25jZUhhbmRsZXIpO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlRXZlbnQobmFtZSkge1xuICBpZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBuZXcgQ3VzdG9tRXZlbnQobmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQobmFtZSwgZmFsc2UsIGZhbHNlLCB1bmRlZmluZWQpO1xuICAgIHJldHVybiBldnQ7XG4gIH1cbn1cblxudmFyIHByb2Nlc3NTY3JvbGxEaWZmID0gZnVuY3Rpb24oXG4gIGksXG4gIGF4aXMsXG4gIGRpZmYsXG4gIHVzZVNjcm9sbGluZ0NsYXNzLFxuICBmb3JjZUZpcmVSZWFjaEV2ZW50XG4pIHtcbiAgaWYgKCB1c2VTY3JvbGxpbmdDbGFzcyA9PT0gdm9pZCAwICkgdXNlU2Nyb2xsaW5nQ2xhc3MgPSB0cnVlO1xuICBpZiAoIGZvcmNlRmlyZVJlYWNoRXZlbnQgPT09IHZvaWQgMCApIGZvcmNlRmlyZVJlYWNoRXZlbnQgPSBmYWxzZTtcblxuICB2YXIgZmllbGRzO1xuICBpZiAoYXhpcyA9PT0gJ3RvcCcpIHtcbiAgICBmaWVsZHMgPSBbXG4gICAgICAnY29udGVudEhlaWdodCcsXG4gICAgICAnY29udGFpbmVySGVpZ2h0JyxcbiAgICAgICdzY3JvbGxUb3AnLFxuICAgICAgJ3knLFxuICAgICAgJ3VwJyxcbiAgICAgICdkb3duJyBdO1xuICB9IGVsc2UgaWYgKGF4aXMgPT09ICdsZWZ0Jykge1xuICAgIGZpZWxkcyA9IFtcbiAgICAgICdjb250ZW50V2lkdGgnLFxuICAgICAgJ2NvbnRhaW5lcldpZHRoJyxcbiAgICAgICdzY3JvbGxMZWZ0JyxcbiAgICAgICd4JyxcbiAgICAgICdsZWZ0JyxcbiAgICAgICdyaWdodCcgXTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgcHJvcGVyIGF4aXMgc2hvdWxkIGJlIHByb3ZpZGVkJyk7XG4gIH1cblxuICBwcm9jZXNzU2Nyb2xsRGlmZiQxKGksIGRpZmYsIGZpZWxkcywgdXNlU2Nyb2xsaW5nQ2xhc3MsIGZvcmNlRmlyZVJlYWNoRXZlbnQpO1xufTtcblxuZnVuY3Rpb24gcHJvY2Vzc1Njcm9sbERpZmYkMShcbiAgaSxcbiAgZGlmZixcbiAgcmVmLFxuICB1c2VTY3JvbGxpbmdDbGFzcyxcbiAgZm9yY2VGaXJlUmVhY2hFdmVudFxuKSB7XG4gIHZhciBjb250ZW50SGVpZ2h0ID0gcmVmWzBdO1xuICB2YXIgY29udGFpbmVySGVpZ2h0ID0gcmVmWzFdO1xuICB2YXIgc2Nyb2xsVG9wID0gcmVmWzJdO1xuICB2YXIgeSA9IHJlZlszXTtcbiAgdmFyIHVwID0gcmVmWzRdO1xuICB2YXIgZG93biA9IHJlZls1XTtcbiAgaWYgKCB1c2VTY3JvbGxpbmdDbGFzcyA9PT0gdm9pZCAwICkgdXNlU2Nyb2xsaW5nQ2xhc3MgPSB0cnVlO1xuICBpZiAoIGZvcmNlRmlyZVJlYWNoRXZlbnQgPT09IHZvaWQgMCApIGZvcmNlRmlyZVJlYWNoRXZlbnQgPSBmYWxzZTtcblxuICB2YXIgZWxlbWVudCA9IGkuZWxlbWVudDtcblxuICAvLyByZXNldCByZWFjaFxuICBpLnJlYWNoW3ldID0gbnVsbDtcblxuICAvLyAxIGZvciBzdWJwaXhlbCByb3VuZGluZ1xuICBpZiAoZWxlbWVudFtzY3JvbGxUb3BdIDwgMSkge1xuICAgIGkucmVhY2hbeV0gPSAnc3RhcnQnO1xuICB9XG5cbiAgLy8gMSBmb3Igc3VicGl4ZWwgcm91bmRpbmdcbiAgaWYgKGVsZW1lbnRbc2Nyb2xsVG9wXSA+IGlbY29udGVudEhlaWdodF0gLSBpW2NvbnRhaW5lckhlaWdodF0gLSAxKSB7XG4gICAgaS5yZWFjaFt5XSA9ICdlbmQnO1xuICB9XG5cbiAgaWYgKGRpZmYpIHtcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoY3JlYXRlRXZlbnQoKFwicHMtc2Nyb2xsLVwiICsgeSkpKTtcblxuICAgIGlmIChkaWZmIDwgMCkge1xuICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGNyZWF0ZUV2ZW50KChcInBzLXNjcm9sbC1cIiArIHVwKSkpO1xuICAgIH0gZWxzZSBpZiAoZGlmZiA+IDApIHtcbiAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChjcmVhdGVFdmVudCgoXCJwcy1zY3JvbGwtXCIgKyBkb3duKSkpO1xuICAgIH1cblxuICAgIGlmICh1c2VTY3JvbGxpbmdDbGFzcykge1xuICAgICAgc2V0U2Nyb2xsaW5nQ2xhc3NJbnN0YW50bHkoaSwgeSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGkucmVhY2hbeV0gJiYgKGRpZmYgfHwgZm9yY2VGaXJlUmVhY2hFdmVudCkpIHtcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoY3JlYXRlRXZlbnQoKFwicHMtXCIgKyB5ICsgXCItcmVhY2gtXCIgKyAoaS5yZWFjaFt5XSkpKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdG9JbnQoeCkge1xuICByZXR1cm4gcGFyc2VJbnQoeCwgMTApIHx8IDA7XG59XG5cbmZ1bmN0aW9uIGlzRWRpdGFibGUoZWwpIHtcbiAgcmV0dXJuIChcbiAgICBtYXRjaGVzKGVsLCAnaW5wdXQsW2NvbnRlbnRlZGl0YWJsZV0nKSB8fFxuICAgIG1hdGNoZXMoZWwsICdzZWxlY3QsW2NvbnRlbnRlZGl0YWJsZV0nKSB8fFxuICAgIG1hdGNoZXMoZWwsICd0ZXh0YXJlYSxbY29udGVudGVkaXRhYmxlXScpIHx8XG4gICAgbWF0Y2hlcyhlbCwgJ2J1dHRvbixbY29udGVudGVkaXRhYmxlXScpXG4gICk7XG59XG5cbmZ1bmN0aW9uIG91dGVyV2lkdGgoZWxlbWVudCkge1xuICB2YXIgc3R5bGVzID0gZ2V0KGVsZW1lbnQpO1xuICByZXR1cm4gKFxuICAgIHRvSW50KHN0eWxlcy53aWR0aCkgK1xuICAgIHRvSW50KHN0eWxlcy5wYWRkaW5nTGVmdCkgK1xuICAgIHRvSW50KHN0eWxlcy5wYWRkaW5nUmlnaHQpICtcbiAgICB0b0ludChzdHlsZXMuYm9yZGVyTGVmdFdpZHRoKSArXG4gICAgdG9JbnQoc3R5bGVzLmJvcmRlclJpZ2h0V2lkdGgpXG4gICk7XG59XG5cbnZhciBlbnYgPSB7XG4gIGlzV2ViS2l0OlxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLFxuICBzdXBwb3J0c1RvdWNoOlxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fFxuICAgICAgKHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2Ygd2luZG93LkRvY3VtZW50VG91Y2gpKSxcbiAgc3VwcG9ydHNJZVBvaW50ZXI6XG4gICAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMsXG4gIGlzQ2hyb21lOlxuICAgIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgL0Nocm9tZS9pLnRlc3QobmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQpLFxufTtcblxudmFyIHVwZGF0ZUdlb21ldHJ5ID0gZnVuY3Rpb24oaSkge1xuICB2YXIgZWxlbWVudCA9IGkuZWxlbWVudDtcbiAgdmFyIHJvdW5kZWRTY3JvbGxUb3AgPSBNYXRoLmZsb29yKGVsZW1lbnQuc2Nyb2xsVG9wKTtcblxuICBpLmNvbnRhaW5lcldpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgaS5jb250YWluZXJIZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgaS5jb250ZW50V2lkdGggPSBlbGVtZW50LnNjcm9sbFdpZHRoO1xuICBpLmNvbnRlbnRIZWlnaHQgPSBlbGVtZW50LnNjcm9sbEhlaWdodDtcblxuICBpZiAoIWVsZW1lbnQuY29udGFpbnMoaS5zY3JvbGxiYXJYUmFpbCkpIHtcbiAgICAvLyBjbGVhbiB1cCBhbmQgYXBwZW5kXG4gICAgcXVlcnlDaGlsZHJlbihlbGVtZW50LCBjbHMuZWxlbWVudC5yYWlsKCd4JykpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7IHJldHVybiByZW1vdmUoZWwpOyB9XG4gICAgKTtcbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKGkuc2Nyb2xsYmFyWFJhaWwpO1xuICB9XG4gIGlmICghZWxlbWVudC5jb250YWlucyhpLnNjcm9sbGJhcllSYWlsKSkge1xuICAgIC8vIGNsZWFuIHVwIGFuZCBhcHBlbmRcbiAgICBxdWVyeUNoaWxkcmVuKGVsZW1lbnQsIGNscy5lbGVtZW50LnJhaWwoJ3knKSkuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIHJlbW92ZShlbCk7IH1cbiAgICApO1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoaS5zY3JvbGxiYXJZUmFpbCk7XG4gIH1cblxuICBpZiAoXG4gICAgIWkuc2V0dGluZ3Muc3VwcHJlc3NTY3JvbGxYICYmXG4gICAgaS5jb250YWluZXJXaWR0aCArIGkuc2V0dGluZ3Muc2Nyb2xsWE1hcmdpbk9mZnNldCA8IGkuY29udGVudFdpZHRoXG4gICkge1xuICAgIGkuc2Nyb2xsYmFyWEFjdGl2ZSA9IHRydWU7XG4gICAgaS5yYWlsWFdpZHRoID0gaS5jb250YWluZXJXaWR0aCAtIGkucmFpbFhNYXJnaW5XaWR0aDtcbiAgICBpLnJhaWxYUmF0aW8gPSBpLmNvbnRhaW5lcldpZHRoIC8gaS5yYWlsWFdpZHRoO1xuICAgIGkuc2Nyb2xsYmFyWFdpZHRoID0gZ2V0VGh1bWJTaXplKFxuICAgICAgaSxcbiAgICAgIHRvSW50KGkucmFpbFhXaWR0aCAqIGkuY29udGFpbmVyV2lkdGggLyBpLmNvbnRlbnRXaWR0aClcbiAgICApO1xuICAgIGkuc2Nyb2xsYmFyWExlZnQgPSB0b0ludChcbiAgICAgIChpLm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCArIGVsZW1lbnQuc2Nyb2xsTGVmdCkgKlxuICAgICAgICAoaS5yYWlsWFdpZHRoIC0gaS5zY3JvbGxiYXJYV2lkdGgpIC9cbiAgICAgICAgKGkuY29udGVudFdpZHRoIC0gaS5jb250YWluZXJXaWR0aClcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGkuc2Nyb2xsYmFyWEFjdGl2ZSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKFxuICAgICFpLnNldHRpbmdzLnN1cHByZXNzU2Nyb2xsWSAmJlxuICAgIGkuY29udGFpbmVySGVpZ2h0ICsgaS5zZXR0aW5ncy5zY3JvbGxZTWFyZ2luT2Zmc2V0IDwgaS5jb250ZW50SGVpZ2h0XG4gICkge1xuICAgIGkuc2Nyb2xsYmFyWUFjdGl2ZSA9IHRydWU7XG4gICAgaS5yYWlsWUhlaWdodCA9IGkuY29udGFpbmVySGVpZ2h0IC0gaS5yYWlsWU1hcmdpbkhlaWdodDtcbiAgICBpLnJhaWxZUmF0aW8gPSBpLmNvbnRhaW5lckhlaWdodCAvIGkucmFpbFlIZWlnaHQ7XG4gICAgaS5zY3JvbGxiYXJZSGVpZ2h0ID0gZ2V0VGh1bWJTaXplKFxuICAgICAgaSxcbiAgICAgIHRvSW50KGkucmFpbFlIZWlnaHQgKiBpLmNvbnRhaW5lckhlaWdodCAvIGkuY29udGVudEhlaWdodClcbiAgICApO1xuICAgIGkuc2Nyb2xsYmFyWVRvcCA9IHRvSW50KFxuICAgICAgcm91bmRlZFNjcm9sbFRvcCAqXG4gICAgICAgIChpLnJhaWxZSGVpZ2h0IC0gaS5zY3JvbGxiYXJZSGVpZ2h0KSAvXG4gICAgICAgIChpLmNvbnRlbnRIZWlnaHQgLSBpLmNvbnRhaW5lckhlaWdodClcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGkuc2Nyb2xsYmFyWUFjdGl2ZSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKGkuc2Nyb2xsYmFyWExlZnQgPj0gaS5yYWlsWFdpZHRoIC0gaS5zY3JvbGxiYXJYV2lkdGgpIHtcbiAgICBpLnNjcm9sbGJhclhMZWZ0ID0gaS5yYWlsWFdpZHRoIC0gaS5zY3JvbGxiYXJYV2lkdGg7XG4gIH1cbiAgaWYgKGkuc2Nyb2xsYmFyWVRvcCA+PSBpLnJhaWxZSGVpZ2h0IC0gaS5zY3JvbGxiYXJZSGVpZ2h0KSB7XG4gICAgaS5zY3JvbGxiYXJZVG9wID0gaS5yYWlsWUhlaWdodCAtIGkuc2Nyb2xsYmFyWUhlaWdodDtcbiAgfVxuXG4gIHVwZGF0ZUNzcyhlbGVtZW50LCBpKTtcblxuICBpZiAoaS5zY3JvbGxiYXJYQWN0aXZlKSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNscy5zdGF0ZS5hY3RpdmUoJ3gnKSk7XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNscy5zdGF0ZS5hY3RpdmUoJ3gnKSk7XG4gICAgaS5zY3JvbGxiYXJYV2lkdGggPSAwO1xuICAgIGkuc2Nyb2xsYmFyWExlZnQgPSAwO1xuICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IDA7XG4gIH1cbiAgaWYgKGkuc2Nyb2xsYmFyWUFjdGl2ZSkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbHMuc3RhdGUuYWN0aXZlKCd5JykpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbHMuc3RhdGUuYWN0aXZlKCd5JykpO1xuICAgIGkuc2Nyb2xsYmFyWUhlaWdodCA9IDA7XG4gICAgaS5zY3JvbGxiYXJZVG9wID0gMDtcbiAgICBlbGVtZW50LnNjcm9sbFRvcCA9IDA7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldFRodW1iU2l6ZShpLCB0aHVtYlNpemUpIHtcbiAgaWYgKGkuc2V0dGluZ3MubWluU2Nyb2xsYmFyTGVuZ3RoKSB7XG4gICAgdGh1bWJTaXplID0gTWF0aC5tYXgodGh1bWJTaXplLCBpLnNldHRpbmdzLm1pblNjcm9sbGJhckxlbmd0aCk7XG4gIH1cbiAgaWYgKGkuc2V0dGluZ3MubWF4U2Nyb2xsYmFyTGVuZ3RoKSB7XG4gICAgdGh1bWJTaXplID0gTWF0aC5taW4odGh1bWJTaXplLCBpLnNldHRpbmdzLm1heFNjcm9sbGJhckxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIHRodW1iU2l6ZTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ3NzKGVsZW1lbnQsIGkpIHtcbiAgdmFyIHhSYWlsT2Zmc2V0ID0geyB3aWR0aDogaS5yYWlsWFdpZHRoIH07XG4gIHZhciByb3VuZGVkU2Nyb2xsVG9wID0gTWF0aC5mbG9vcihlbGVtZW50LnNjcm9sbFRvcCk7XG5cbiAgaWYgKGkuaXNSdGwpIHtcbiAgICB4UmFpbE9mZnNldC5sZWZ0ID1cbiAgICAgIGkubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ICtcbiAgICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCArXG4gICAgICBpLmNvbnRhaW5lcldpZHRoIC1cbiAgICAgIGkuY29udGVudFdpZHRoO1xuICB9IGVsc2Uge1xuICAgIHhSYWlsT2Zmc2V0LmxlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQ7XG4gIH1cbiAgaWYgKGkuaXNTY3JvbGxiYXJYVXNpbmdCb3R0b20pIHtcbiAgICB4UmFpbE9mZnNldC5ib3R0b20gPSBpLnNjcm9sbGJhclhCb3R0b20gLSByb3VuZGVkU2Nyb2xsVG9wO1xuICB9IGVsc2Uge1xuICAgIHhSYWlsT2Zmc2V0LnRvcCA9IGkuc2Nyb2xsYmFyWFRvcCArIHJvdW5kZWRTY3JvbGxUb3A7XG4gIH1cbiAgc2V0KGkuc2Nyb2xsYmFyWFJhaWwsIHhSYWlsT2Zmc2V0KTtcblxuICB2YXIgeVJhaWxPZmZzZXQgPSB7IHRvcDogcm91bmRlZFNjcm9sbFRvcCwgaGVpZ2h0OiBpLnJhaWxZSGVpZ2h0IH07XG4gIGlmIChpLmlzU2Nyb2xsYmFyWVVzaW5nUmlnaHQpIHtcbiAgICBpZiAoaS5pc1J0bCkge1xuICAgICAgeVJhaWxPZmZzZXQucmlnaHQgPVxuICAgICAgICBpLmNvbnRlbnRXaWR0aCAtXG4gICAgICAgIChpLm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCArIGVsZW1lbnQuc2Nyb2xsTGVmdCkgLVxuICAgICAgICBpLnNjcm9sbGJhcllSaWdodCAtXG4gICAgICAgIGkuc2Nyb2xsYmFyWU91dGVyV2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHlSYWlsT2Zmc2V0LnJpZ2h0ID0gaS5zY3JvbGxiYXJZUmlnaHQgLSBlbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpLmlzUnRsKSB7XG4gICAgICB5UmFpbE9mZnNldC5sZWZ0ID1cbiAgICAgICAgaS5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQgK1xuICAgICAgICBlbGVtZW50LnNjcm9sbExlZnQgK1xuICAgICAgICBpLmNvbnRhaW5lcldpZHRoICogMiAtXG4gICAgICAgIGkuY29udGVudFdpZHRoIC1cbiAgICAgICAgaS5zY3JvbGxiYXJZTGVmdCAtXG4gICAgICAgIGkuc2Nyb2xsYmFyWU91dGVyV2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHlSYWlsT2Zmc2V0LmxlZnQgPSBpLnNjcm9sbGJhcllMZWZ0ICsgZWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgIH1cbiAgfVxuICBzZXQoaS5zY3JvbGxiYXJZUmFpbCwgeVJhaWxPZmZzZXQpO1xuXG4gIHNldChpLnNjcm9sbGJhclgsIHtcbiAgICBsZWZ0OiBpLnNjcm9sbGJhclhMZWZ0LFxuICAgIHdpZHRoOiBpLnNjcm9sbGJhclhXaWR0aCAtIGkucmFpbEJvcmRlclhXaWR0aCxcbiAgfSk7XG4gIHNldChpLnNjcm9sbGJhclksIHtcbiAgICB0b3A6IGkuc2Nyb2xsYmFyWVRvcCxcbiAgICBoZWlnaHQ6IGkuc2Nyb2xsYmFyWUhlaWdodCAtIGkucmFpbEJvcmRlcllXaWR0aCxcbiAgfSk7XG59XG5cbnZhciBjbGlja1JhaWwgPSBmdW5jdGlvbihpKSB7XG4gIGkuZXZlbnQuYmluZChpLnNjcm9sbGJhclksICdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5zdG9wUHJvcGFnYXRpb24oKTsgfSk7XG4gIGkuZXZlbnQuYmluZChpLnNjcm9sbGJhcllSYWlsLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgcG9zaXRpb25Ub3AgPVxuICAgICAgZS5wYWdlWSAtXG4gICAgICB3aW5kb3cucGFnZVlPZmZzZXQgLVxuICAgICAgaS5zY3JvbGxiYXJZUmFpbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgdmFyIGRpcmVjdGlvbiA9IHBvc2l0aW9uVG9wID4gaS5zY3JvbGxiYXJZVG9wID8gMSA6IC0xO1xuXG4gICAgaS5lbGVtZW50LnNjcm9sbFRvcCArPSBkaXJlY3Rpb24gKiBpLmNvbnRhaW5lckhlaWdodDtcbiAgICB1cGRhdGVHZW9tZXRyeShpKTtcblxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0pO1xuXG4gIGkuZXZlbnQuYmluZChpLnNjcm9sbGJhclgsICdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5zdG9wUHJvcGFnYXRpb24oKTsgfSk7XG4gIGkuZXZlbnQuYmluZChpLnNjcm9sbGJhclhSYWlsLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgcG9zaXRpb25MZWZ0ID1cbiAgICAgIGUucGFnZVggLVxuICAgICAgd2luZG93LnBhZ2VYT2Zmc2V0IC1cbiAgICAgIGkuc2Nyb2xsYmFyWFJhaWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICB2YXIgZGlyZWN0aW9uID0gcG9zaXRpb25MZWZ0ID4gaS5zY3JvbGxiYXJYTGVmdCA/IDEgOiAtMTtcblxuICAgIGkuZWxlbWVudC5zY3JvbGxMZWZ0ICs9IGRpcmVjdGlvbiAqIGkuY29udGFpbmVyV2lkdGg7XG4gICAgdXBkYXRlR2VvbWV0cnkoaSk7XG5cbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9KTtcbn07XG5cbnZhciBkcmFnVGh1bWIgPSBmdW5jdGlvbihpKSB7XG4gIGJpbmRNb3VzZVNjcm9sbEhhbmRsZXIoaSwgW1xuICAgICdjb250YWluZXJXaWR0aCcsXG4gICAgJ2NvbnRlbnRXaWR0aCcsXG4gICAgJ3BhZ2VYJyxcbiAgICAncmFpbFhXaWR0aCcsXG4gICAgJ3Njcm9sbGJhclgnLFxuICAgICdzY3JvbGxiYXJYV2lkdGgnLFxuICAgICdzY3JvbGxMZWZ0JyxcbiAgICAneCcsXG4gICAgJ3Njcm9sbGJhclhSYWlsJyBdKTtcbiAgYmluZE1vdXNlU2Nyb2xsSGFuZGxlcihpLCBbXG4gICAgJ2NvbnRhaW5lckhlaWdodCcsXG4gICAgJ2NvbnRlbnRIZWlnaHQnLFxuICAgICdwYWdlWScsXG4gICAgJ3JhaWxZSGVpZ2h0JyxcbiAgICAnc2Nyb2xsYmFyWScsXG4gICAgJ3Njcm9sbGJhcllIZWlnaHQnLFxuICAgICdzY3JvbGxUb3AnLFxuICAgICd5JyxcbiAgICAnc2Nyb2xsYmFyWVJhaWwnIF0pO1xufTtcblxuZnVuY3Rpb24gYmluZE1vdXNlU2Nyb2xsSGFuZGxlcihcbiAgaSxcbiAgcmVmXG4pIHtcbiAgdmFyIGNvbnRhaW5lckhlaWdodCA9IHJlZlswXTtcbiAgdmFyIGNvbnRlbnRIZWlnaHQgPSByZWZbMV07XG4gIHZhciBwYWdlWSA9IHJlZlsyXTtcbiAgdmFyIHJhaWxZSGVpZ2h0ID0gcmVmWzNdO1xuICB2YXIgc2Nyb2xsYmFyWSA9IHJlZls0XTtcbiAgdmFyIHNjcm9sbGJhcllIZWlnaHQgPSByZWZbNV07XG4gIHZhciBzY3JvbGxUb3AgPSByZWZbNl07XG4gIHZhciB5ID0gcmVmWzddO1xuICB2YXIgc2Nyb2xsYmFyWVJhaWwgPSByZWZbOF07XG5cbiAgdmFyIGVsZW1lbnQgPSBpLmVsZW1lbnQ7XG5cbiAgdmFyIHN0YXJ0aW5nU2Nyb2xsVG9wID0gbnVsbDtcbiAgdmFyIHN0YXJ0aW5nTW91c2VQYWdlWSA9IG51bGw7XG4gIHZhciBzY3JvbGxCeSA9IG51bGw7XG5cbiAgZnVuY3Rpb24gbW91c2VNb3ZlSGFuZGxlcihlKSB7XG4gICAgZWxlbWVudFtzY3JvbGxUb3BdID1cbiAgICAgIHN0YXJ0aW5nU2Nyb2xsVG9wICsgc2Nyb2xsQnkgKiAoZVtwYWdlWV0gLSBzdGFydGluZ01vdXNlUGFnZVkpO1xuICAgIGFkZFNjcm9sbGluZ0NsYXNzKGksIHkpO1xuICAgIHVwZGF0ZUdlb21ldHJ5KGkpO1xuXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZVVwSGFuZGxlcigpIHtcbiAgICByZW1vdmVTY3JvbGxpbmdDbGFzcyhpLCB5KTtcbiAgICBpW3Njcm9sbGJhcllSYWlsXS5jbGFzc0xpc3QucmVtb3ZlKGNscy5zdGF0ZS5jbGlja2luZyk7XG4gICAgaS5ldmVudC51bmJpbmQoaS5vd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgbW91c2VNb3ZlSGFuZGxlcik7XG4gIH1cblxuICBpLmV2ZW50LmJpbmQoaVtzY3JvbGxiYXJZXSwgJ21vdXNlZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgc3RhcnRpbmdTY3JvbGxUb3AgPSBlbGVtZW50W3Njcm9sbFRvcF07XG4gICAgc3RhcnRpbmdNb3VzZVBhZ2VZID0gZVtwYWdlWV07XG4gICAgc2Nyb2xsQnkgPVxuICAgICAgKGlbY29udGVudEhlaWdodF0gLSBpW2NvbnRhaW5lckhlaWdodF0pIC9cbiAgICAgIChpW3JhaWxZSGVpZ2h0XSAtIGlbc2Nyb2xsYmFyWUhlaWdodF0pO1xuXG4gICAgaS5ldmVudC5iaW5kKGkub3duZXJEb2N1bWVudCwgJ21vdXNlbW92ZScsIG1vdXNlTW92ZUhhbmRsZXIpO1xuICAgIGkuZXZlbnQub25jZShpLm93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgbW91c2VVcEhhbmRsZXIpO1xuXG4gICAgaVtzY3JvbGxiYXJZUmFpbF0uY2xhc3NMaXN0LmFkZChjbHMuc3RhdGUuY2xpY2tpbmcpO1xuXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xufVxuXG52YXIga2V5Ym9hcmQgPSBmdW5jdGlvbihpKSB7XG4gIHZhciBlbGVtZW50ID0gaS5lbGVtZW50O1xuXG4gIHZhciBlbGVtZW50SG92ZXJlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGNoZXMoZWxlbWVudCwgJzpob3ZlcicpOyB9O1xuICB2YXIgc2Nyb2xsYmFyRm9jdXNlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGNoZXMoaS5zY3JvbGxiYXJYLCAnOmZvY3VzJykgfHwgbWF0Y2hlcyhpLnNjcm9sbGJhclksICc6Zm9jdXMnKTsgfTtcblxuICBmdW5jdGlvbiBzaG91bGRQcmV2ZW50RGVmYXVsdChkZWx0YVgsIGRlbHRhWSkge1xuICAgIHZhciBzY3JvbGxUb3AgPSBNYXRoLmZsb29yKGVsZW1lbnQuc2Nyb2xsVG9wKTtcbiAgICBpZiAoZGVsdGFYID09PSAwKSB7XG4gICAgICBpZiAoIWkuc2Nyb2xsYmFyWUFjdGl2ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIChzY3JvbGxUb3AgPT09IDAgJiYgZGVsdGFZID4gMCkgfHxcbiAgICAgICAgKHNjcm9sbFRvcCA+PSBpLmNvbnRlbnRIZWlnaHQgLSBpLmNvbnRhaW5lckhlaWdodCAmJiBkZWx0YVkgPCAwKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiAhaS5zZXR0aW5ncy53aGVlbFByb3BhZ2F0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzY3JvbGxMZWZ0ID0gZWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgIGlmIChkZWx0YVkgPT09IDApIHtcbiAgICAgIGlmICghaS5zY3JvbGxiYXJYQWN0aXZlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgKHNjcm9sbExlZnQgPT09IDAgJiYgZGVsdGFYIDwgMCkgfHxcbiAgICAgICAgKHNjcm9sbExlZnQgPj0gaS5jb250ZW50V2lkdGggLSBpLmNvbnRhaW5lcldpZHRoICYmIGRlbHRhWCA+IDApXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuICFpLnNldHRpbmdzLndoZWVsUHJvcGFnYXRpb247XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaS5ldmVudC5iaW5kKGkub3duZXJEb2N1bWVudCwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChcbiAgICAgIChlLmlzRGVmYXVsdFByZXZlbnRlZCAmJiBlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB8fFxuICAgICAgZS5kZWZhdWx0UHJldmVudGVkXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFlbGVtZW50SG92ZXJlZCgpICYmICFzY3JvbGxiYXJGb2N1c2VkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRcbiAgICAgID8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudFxuICAgICAgOiBpLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoYWN0aXZlRWxlbWVudCkge1xuICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQudGFnTmFtZSA9PT0gJ0lGUkFNRScpIHtcbiAgICAgICAgYWN0aXZlRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQuY29udGVudERvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBnbyBkZWVwZXIgaWYgZWxlbWVudCBpcyBhIHdlYmNvbXBvbmVudFxuICAgICAgICB3aGlsZSAoYWN0aXZlRWxlbWVudC5zaGFkb3dSb290KSB7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNFZGl0YWJsZShhY3RpdmVFbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlbHRhWCA9IDA7XG4gICAgdmFyIGRlbHRhWSA9IDA7XG5cbiAgICBzd2l0Y2ggKGUud2hpY2gpIHtcbiAgICAgIGNhc2UgMzc6IC8vIGxlZnRcbiAgICAgICAgaWYgKGUubWV0YUtleSkge1xuICAgICAgICAgIGRlbHRhWCA9IC1pLmNvbnRlbnRXaWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChlLmFsdEtleSkge1xuICAgICAgICAgIGRlbHRhWCA9IC1pLmNvbnRhaW5lcldpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbHRhWCA9IC0zMDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzg6IC8vIHVwXG4gICAgICAgIGlmIChlLm1ldGFLZXkpIHtcbiAgICAgICAgICBkZWx0YVkgPSBpLmNvbnRlbnRIZWlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5hbHRLZXkpIHtcbiAgICAgICAgICBkZWx0YVkgPSBpLmNvbnRhaW5lckhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWx0YVkgPSAzMDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzk6IC8vIHJpZ2h0XG4gICAgICAgIGlmIChlLm1ldGFLZXkpIHtcbiAgICAgICAgICBkZWx0YVggPSBpLmNvbnRlbnRXaWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChlLmFsdEtleSkge1xuICAgICAgICAgIGRlbHRhWCA9IGkuY29udGFpbmVyV2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsdGFYID0gMzA7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQwOiAvLyBkb3duXG4gICAgICAgIGlmIChlLm1ldGFLZXkpIHtcbiAgICAgICAgICBkZWx0YVkgPSAtaS5jb250ZW50SGVpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKGUuYWx0S2V5KSB7XG4gICAgICAgICAgZGVsdGFZID0gLWkuY29udGFpbmVySGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbHRhWSA9IC0zMDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzI6IC8vIHNwYWNlIGJhclxuICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAgIGRlbHRhWSA9IGkuY29udGFpbmVySGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbHRhWSA9IC1pLmNvbnRhaW5lckhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzM6IC8vIHBhZ2UgdXBcbiAgICAgICAgZGVsdGFZID0gaS5jb250YWluZXJIZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzNDogLy8gcGFnZSBkb3duXG4gICAgICAgIGRlbHRhWSA9IC1pLmNvbnRhaW5lckhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM2OiAvLyBob21lXG4gICAgICAgIGRlbHRhWSA9IGkuY29udGVudEhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM1OiAvLyBlbmRcbiAgICAgICAgZGVsdGFZID0gLWkuY29udGVudEhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGkuc2V0dGluZ3Muc3VwcHJlc3NTY3JvbGxYICYmIGRlbHRhWCAhPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaS5zZXR0aW5ncy5zdXBwcmVzc1Njcm9sbFkgJiYgZGVsdGFZICE9PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5zY3JvbGxUb3AgLT0gZGVsdGFZO1xuICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCArPSBkZWx0YVg7XG4gICAgdXBkYXRlR2VvbWV0cnkoaSk7XG5cbiAgICBpZiAoc2hvdWxkUHJldmVudERlZmF1bHQoZGVsdGFYLCBkZWx0YVkpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciB3aGVlbCA9IGZ1bmN0aW9uKGkpIHtcbiAgdmFyIGVsZW1lbnQgPSBpLmVsZW1lbnQ7XG5cbiAgZnVuY3Rpb24gc2hvdWxkUHJldmVudERlZmF1bHQoZGVsdGFYLCBkZWx0YVkpIHtcbiAgICB2YXIgcm91bmRlZFNjcm9sbFRvcCA9IE1hdGguZmxvb3IoZWxlbWVudC5zY3JvbGxUb3ApO1xuICAgIHZhciBpc1RvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wID09PSAwO1xuICAgIHZhciBpc0JvdHRvbSA9XG4gICAgICByb3VuZGVkU2Nyb2xsVG9wICsgZWxlbWVudC5vZmZzZXRIZWlnaHQgPT09IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuICAgIHZhciBpc0xlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQgPT09IDA7XG4gICAgdmFyIGlzUmlnaHQgPVxuICAgICAgZWxlbWVudC5zY3JvbGxMZWZ0ICsgZWxlbWVudC5vZmZzZXRXaWR0aCA9PT0gZWxlbWVudC5zY3JvbGxXaWR0aDtcblxuICAgIHZhciBoaXRzQm91bmQ7XG5cbiAgICAvLyBwaWNrIGF4aXMgd2l0aCBwcmltYXJ5IGRpcmVjdGlvblxuICAgIGlmIChNYXRoLmFicyhkZWx0YVkpID4gTWF0aC5hYnMoZGVsdGFYKSkge1xuICAgICAgaGl0c0JvdW5kID0gaXNUb3AgfHwgaXNCb3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpdHNCb3VuZCA9IGlzTGVmdCB8fCBpc1JpZ2h0O1xuICAgIH1cblxuICAgIHJldHVybiBoaXRzQm91bmQgPyAhaS5zZXR0aW5ncy53aGVlbFByb3BhZ2F0aW9uIDogdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERlbHRhRnJvbUV2ZW50KGUpIHtcbiAgICB2YXIgZGVsdGFYID0gZS5kZWx0YVg7XG4gICAgdmFyIGRlbHRhWSA9IC0xICogZS5kZWx0YVk7XG5cbiAgICBpZiAodHlwZW9mIGRlbHRhWCA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGRlbHRhWSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIE9TIFggU2FmYXJpXG4gICAgICBkZWx0YVggPSAtMSAqIGUud2hlZWxEZWx0YVggLyA2O1xuICAgICAgZGVsdGFZID0gZS53aGVlbERlbHRhWSAvIDY7XG4gICAgfVxuXG4gICAgaWYgKGUuZGVsdGFNb2RlICYmIGUuZGVsdGFNb2RlID09PSAxKSB7XG4gICAgICAvLyBGaXJlZm94IGluIGRlbHRhTW9kZSAxOiBMaW5lIHNjcm9sbGluZ1xuICAgICAgZGVsdGFYICo9IDEwO1xuICAgICAgZGVsdGFZICo9IDEwO1xuICAgIH1cblxuICAgIGlmIChkZWx0YVggIT09IGRlbHRhWCAmJiBkZWx0YVkgIT09IGRlbHRhWSAvKiBOYU4gY2hlY2tzICovKSB7XG4gICAgICAvLyBJRSBpbiBzb21lIG1vdXNlIGRyaXZlcnNcbiAgICAgIGRlbHRhWCA9IDA7XG4gICAgICBkZWx0YVkgPSBlLndoZWVsRGVsdGE7XG4gICAgfVxuXG4gICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgIC8vIHJldmVyc2UgYXhpcyB3aXRoIHNoaWZ0IGtleVxuICAgICAgcmV0dXJuIFstZGVsdGFZLCAtZGVsdGFYXTtcbiAgICB9XG4gICAgcmV0dXJuIFtkZWx0YVgsIGRlbHRhWV07XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRCZUNvbnN1bWVkQnlDaGlsZCh0YXJnZXQsIGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgLy8gRklYTUU6IHRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciA8c2VsZWN0PiBpc3N1ZSBpbiBGRiBhbmQgSUUgIzU3MVxuICAgIGlmICghZW52LmlzV2ViS2l0ICYmIGVsZW1lbnQucXVlcnlTZWxlY3Rvcignc2VsZWN0OmZvY3VzJykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghZWxlbWVudC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGN1cnNvciA9IHRhcmdldDtcblxuICAgIHdoaWxlIChjdXJzb3IgJiYgY3Vyc29yICE9PSBlbGVtZW50KSB7XG4gICAgICBpZiAoY3Vyc29yLmNsYXNzTGlzdC5jb250YWlucyhjbHMuZWxlbWVudC5jb25zdW1pbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3R5bGUgPSBnZXQoY3Vyc29yKTtcbiAgICAgIHZhciBvdmVyZmxvdyA9IFtzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1ldLmpvaW4oXG4gICAgICAgICcnXG4gICAgICApO1xuXG4gICAgICAvLyBpZiBzY3JvbGxhYmxlXG4gICAgICBpZiAob3ZlcmZsb3cubWF0Y2goLyhzY3JvbGx8YXV0bykvKSkge1xuICAgICAgICB2YXIgbWF4U2Nyb2xsVG9wID0gY3Vyc29yLnNjcm9sbEhlaWdodCAtIGN1cnNvci5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGlmIChtYXhTY3JvbGxUb3AgPiAwKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIShjdXJzb3Iuc2Nyb2xsVG9wID09PSAwICYmIGRlbHRhWSA+IDApICYmXG4gICAgICAgICAgICAhKGN1cnNvci5zY3JvbGxUb3AgPT09IG1heFNjcm9sbFRvcCAmJiBkZWx0YVkgPCAwKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBtYXhTY3JvbGxMZWZ0ID0gY3Vyc29yLnNjcm9sbFdpZHRoIC0gY3Vyc29yLmNsaWVudFdpZHRoO1xuICAgICAgICBpZiAobWF4U2Nyb2xsTGVmdCA+IDApIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhKGN1cnNvci5zY3JvbGxMZWZ0ID09PSAwICYmIGRlbHRhWCA8IDApICYmXG4gICAgICAgICAgICAhKGN1cnNvci5zY3JvbGxMZWZ0ID09PSBtYXhTY3JvbGxMZWZ0ICYmIGRlbHRhWCA+IDApXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3Vyc29yID0gY3Vyc29yLnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91c2V3aGVlbEhhbmRsZXIoZSkge1xuICAgIHZhciByZWYgPSBnZXREZWx0YUZyb21FdmVudChlKTtcbiAgICB2YXIgZGVsdGFYID0gcmVmWzBdO1xuICAgIHZhciBkZWx0YVkgPSByZWZbMV07XG5cbiAgICBpZiAoc2hvdWxkQmVDb25zdW1lZEJ5Q2hpbGQoZS50YXJnZXQsIGRlbHRhWCwgZGVsdGFZKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzaG91bGRQcmV2ZW50ID0gZmFsc2U7XG4gICAgaWYgKCFpLnNldHRpbmdzLnVzZUJvdGhXaGVlbEF4ZXMpIHtcbiAgICAgIC8vIGRlbHRhWCB3aWxsIG9ubHkgYmUgdXNlZCBmb3IgaG9yaXpvbnRhbCBzY3JvbGxpbmcgYW5kIGRlbHRhWSB3aWxsXG4gICAgICAvLyBvbmx5IGJlIHVzZWQgZm9yIHZlcnRpY2FsIHNjcm9sbGluZyAtIHRoaXMgaXMgdGhlIGRlZmF1bHRcbiAgICAgIGVsZW1lbnQuc2Nyb2xsVG9wIC09IGRlbHRhWSAqIGkuc2V0dGluZ3Mud2hlZWxTcGVlZDtcbiAgICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCArPSBkZWx0YVggKiBpLnNldHRpbmdzLndoZWVsU3BlZWQ7XG4gICAgfSBlbHNlIGlmIChpLnNjcm9sbGJhcllBY3RpdmUgJiYgIWkuc2Nyb2xsYmFyWEFjdGl2ZSkge1xuICAgICAgLy8gb25seSB2ZXJ0aWNhbCBzY3JvbGxiYXIgaXMgYWN0aXZlIGFuZCB1c2VCb3RoV2hlZWxBeGVzIG9wdGlvbiBpc1xuICAgICAgLy8gYWN0aXZlLCBzbyBsZXQncyBzY3JvbGwgdmVydGljYWwgYmFyIHVzaW5nIGJvdGggbW91c2Ugd2hlZWwgYXhlc1xuICAgICAgaWYgKGRlbHRhWSkge1xuICAgICAgICBlbGVtZW50LnNjcm9sbFRvcCAtPSBkZWx0YVkgKiBpLnNldHRpbmdzLndoZWVsU3BlZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNjcm9sbFRvcCArPSBkZWx0YVggKiBpLnNldHRpbmdzLndoZWVsU3BlZWQ7XG4gICAgICB9XG4gICAgICBzaG91bGRQcmV2ZW50ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGkuc2Nyb2xsYmFyWEFjdGl2ZSAmJiAhaS5zY3JvbGxiYXJZQWN0aXZlKSB7XG4gICAgICAvLyB1c2VCb3RoV2hlZWxBeGVzIGFuZCBvbmx5IGhvcml6b250YWwgYmFyIGlzIGFjdGl2ZSwgc28gdXNlIGJvdGhcbiAgICAgIC8vIHdoZWVsIGF4ZXMgZm9yIGhvcml6b250YWwgYmFyXG4gICAgICBpZiAoZGVsdGFYKSB7XG4gICAgICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCArPSBkZWx0YVggKiBpLnNldHRpbmdzLndoZWVsU3BlZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNjcm9sbExlZnQgLT0gZGVsdGFZICogaS5zZXR0aW5ncy53aGVlbFNwZWVkO1xuICAgICAgfVxuICAgICAgc2hvdWxkUHJldmVudCA9IHRydWU7XG4gICAgfVxuXG4gICAgdXBkYXRlR2VvbWV0cnkoaSk7XG5cbiAgICBzaG91bGRQcmV2ZW50ID0gc2hvdWxkUHJldmVudCB8fCBzaG91bGRQcmV2ZW50RGVmYXVsdChkZWx0YVgsIGRlbHRhWSk7XG4gICAgaWYgKHNob3VsZFByZXZlbnQgJiYgIWUuY3RybEtleSkge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHdpbmRvdy5vbndoZWVsICE9PSAndW5kZWZpbmVkJykge1xuICAgIGkuZXZlbnQuYmluZChlbGVtZW50LCAnd2hlZWwnLCBtb3VzZXdoZWVsSGFuZGxlcik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdy5vbm1vdXNld2hlZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdtb3VzZXdoZWVsJywgbW91c2V3aGVlbEhhbmRsZXIpO1xuICB9XG59O1xuXG52YXIgdG91Y2ggPSBmdW5jdGlvbihpKSB7XG4gIGlmICghZW52LnN1cHBvcnRzVG91Y2ggJiYgIWVudi5zdXBwb3J0c0llUG9pbnRlcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gaS5lbGVtZW50O1xuXG4gIGZ1bmN0aW9uIHNob3VsZFByZXZlbnQoZGVsdGFYLCBkZWx0YVkpIHtcbiAgICB2YXIgc2Nyb2xsVG9wID0gTWF0aC5mbG9vcihlbGVtZW50LnNjcm9sbFRvcCk7XG4gICAgdmFyIHNjcm9sbExlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgdmFyIG1hZ25pdHVkZVggPSBNYXRoLmFicyhkZWx0YVgpO1xuICAgIHZhciBtYWduaXR1ZGVZID0gTWF0aC5hYnMoZGVsdGFZKTtcblxuICAgIGlmIChtYWduaXR1ZGVZID4gbWFnbml0dWRlWCkge1xuICAgICAgLy8gdXNlciBpcyBwZXJoYXBzIHRyeWluZyB0byBzd2lwZSB1cC9kb3duIHRoZSBwYWdlXG5cbiAgICAgIGlmIChcbiAgICAgICAgKGRlbHRhWSA8IDAgJiYgc2Nyb2xsVG9wID09PSBpLmNvbnRlbnRIZWlnaHQgLSBpLmNvbnRhaW5lckhlaWdodCkgfHxcbiAgICAgICAgKGRlbHRhWSA+IDAgJiYgc2Nyb2xsVG9wID09PSAwKVxuICAgICAgKSB7XG4gICAgICAgIC8vIHNldCBwcmV2ZW50IGZvciBtb2JpbGUgQ2hyb21lIHJlZnJlc2hcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5zY3JvbGxZID09PSAwICYmIGRlbHRhWSA+IDAgJiYgZW52LmlzQ2hyb21lO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWFnbml0dWRlWCA+IG1hZ25pdHVkZVkpIHtcbiAgICAgIC8vIHVzZXIgaXMgcGVyaGFwcyB0cnlpbmcgdG8gc3dpcGUgbGVmdC9yaWdodCBhY3Jvc3MgdGhlIHBhZ2VcblxuICAgICAgaWYgKFxuICAgICAgICAoZGVsdGFYIDwgMCAmJiBzY3JvbGxMZWZ0ID09PSBpLmNvbnRlbnRXaWR0aCAtIGkuY29udGFpbmVyV2lkdGgpIHx8XG4gICAgICAgIChkZWx0YVggPiAwICYmIHNjcm9sbExlZnQgPT09IDApXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseVRvdWNoTW92ZShkaWZmZXJlbmNlWCwgZGlmZmVyZW5jZVkpIHtcbiAgICBlbGVtZW50LnNjcm9sbFRvcCAtPSBkaWZmZXJlbmNlWTtcbiAgICBlbGVtZW50LnNjcm9sbExlZnQgLT0gZGlmZmVyZW5jZVg7XG5cbiAgICB1cGRhdGVHZW9tZXRyeShpKTtcbiAgfVxuXG4gIHZhciBzdGFydE9mZnNldCA9IHt9O1xuICB2YXIgc3RhcnRUaW1lID0gMDtcbiAgdmFyIHNwZWVkID0ge307XG4gIHZhciBlYXNpbmdMb29wID0gbnVsbDtcblxuICBmdW5jdGlvbiBnZXRUb3VjaChlKSB7XG4gICAgaWYgKGUudGFyZ2V0VG91Y2hlcykge1xuICAgICAgcmV0dXJuIGUudGFyZ2V0VG91Y2hlc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTWF5YmUgSUUgcG9pbnRlclxuICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkSGFuZGxlKGUpIHtcbiAgICBpZiAoZS5wb2ludGVyVHlwZSAmJiBlLnBvaW50ZXJUeXBlID09PSAncGVuJyAmJiBlLmJ1dHRvbnMgPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGUudGFyZ2V0VG91Y2hlcyAmJiBlLnRhcmdldFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgZS5wb2ludGVyVHlwZSAmJlxuICAgICAgZS5wb2ludGVyVHlwZSAhPT0gJ21vdXNlJyAmJlxuICAgICAgZS5wb2ludGVyVHlwZSAhPT0gZS5NU1BPSU5URVJfVFlQRV9NT1VTRVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoU3RhcnQoZSkge1xuICAgIGlmICghc2hvdWxkSGFuZGxlKGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRvdWNoID0gZ2V0VG91Y2goZSk7XG5cbiAgICBzdGFydE9mZnNldC5wYWdlWCA9IHRvdWNoLnBhZ2VYO1xuICAgIHN0YXJ0T2Zmc2V0LnBhZ2VZID0gdG91Y2gucGFnZVk7XG5cbiAgICBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgIGlmIChlYXNpbmdMb29wICE9PSBudWxsKSB7XG4gICAgICBjbGVhckludGVydmFsKGVhc2luZ0xvb3ApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEJlQ29uc3VtZWRCeUNoaWxkKHRhcmdldCwgZGVsdGFYLCBkZWx0YVkpIHtcbiAgICBpZiAoIWVsZW1lbnQuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBjdXJzb3IgPSB0YXJnZXQ7XG5cbiAgICB3aGlsZSAoY3Vyc29yICYmIGN1cnNvciAhPT0gZWxlbWVudCkge1xuICAgICAgaWYgKGN1cnNvci5jbGFzc0xpc3QuY29udGFpbnMoY2xzLmVsZW1lbnQuY29uc3VtaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0eWxlID0gZ2V0KGN1cnNvcik7XG4gICAgICB2YXIgb3ZlcmZsb3cgPSBbc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZXS5qb2luKFxuICAgICAgICAnJ1xuICAgICAgKTtcblxuICAgICAgLy8gaWYgc2Nyb2xsYWJsZVxuICAgICAgaWYgKG92ZXJmbG93Lm1hdGNoKC8oc2Nyb2xsfGF1dG8pLykpIHtcbiAgICAgICAgdmFyIG1heFNjcm9sbFRvcCA9IGN1cnNvci5zY3JvbGxIZWlnaHQgLSBjdXJzb3IuY2xpZW50SGVpZ2h0O1xuICAgICAgICBpZiAobWF4U2Nyb2xsVG9wID4gMCkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICEoY3Vyc29yLnNjcm9sbFRvcCA9PT0gMCAmJiBkZWx0YVkgPiAwKSAmJlxuICAgICAgICAgICAgIShjdXJzb3Iuc2Nyb2xsVG9wID09PSBtYXhTY3JvbGxUb3AgJiYgZGVsdGFZIDwgMClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF4U2Nyb2xsTGVmdCA9IGN1cnNvci5zY3JvbGxMZWZ0IC0gY3Vyc29yLmNsaWVudFdpZHRoO1xuICAgICAgICBpZiAobWF4U2Nyb2xsTGVmdCA+IDApIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhKGN1cnNvci5zY3JvbGxMZWZ0ID09PSAwICYmIGRlbHRhWCA8IDApICYmXG4gICAgICAgICAgICAhKGN1cnNvci5zY3JvbGxMZWZ0ID09PSBtYXhTY3JvbGxMZWZ0ICYmIGRlbHRhWCA+IDApXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3Vyc29yID0gY3Vyc29yLnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hNb3ZlKGUpIHtcbiAgICBpZiAoc2hvdWxkSGFuZGxlKGUpKSB7XG4gICAgICB2YXIgdG91Y2ggPSBnZXRUb3VjaChlKTtcblxuICAgICAgdmFyIGN1cnJlbnRPZmZzZXQgPSB7IHBhZ2VYOiB0b3VjaC5wYWdlWCwgcGFnZVk6IHRvdWNoLnBhZ2VZIH07XG5cbiAgICAgIHZhciBkaWZmZXJlbmNlWCA9IGN1cnJlbnRPZmZzZXQucGFnZVggLSBzdGFydE9mZnNldC5wYWdlWDtcbiAgICAgIHZhciBkaWZmZXJlbmNlWSA9IGN1cnJlbnRPZmZzZXQucGFnZVkgLSBzdGFydE9mZnNldC5wYWdlWTtcblxuICAgICAgaWYgKHNob3VsZEJlQ29uc3VtZWRCeUNoaWxkKGUudGFyZ2V0LCBkaWZmZXJlbmNlWCwgZGlmZmVyZW5jZVkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYXBwbHlUb3VjaE1vdmUoZGlmZmVyZW5jZVgsIGRpZmZlcmVuY2VZKTtcbiAgICAgIHN0YXJ0T2Zmc2V0ID0gY3VycmVudE9mZnNldDtcblxuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICAgIHZhciB0aW1lR2FwID0gY3VycmVudFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBpZiAodGltZUdhcCA+IDApIHtcbiAgICAgICAgc3BlZWQueCA9IGRpZmZlcmVuY2VYIC8gdGltZUdhcDtcbiAgICAgICAgc3BlZWQueSA9IGRpZmZlcmVuY2VZIC8gdGltZUdhcDtcbiAgICAgICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRQcmV2ZW50KGRpZmZlcmVuY2VYLCBkaWZmZXJlbmNlWSkpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0b3VjaEVuZCgpIHtcbiAgICBpZiAoaS5zZXR0aW5ncy5zd2lwZUVhc2luZykge1xuICAgICAgY2xlYXJJbnRlcnZhbChlYXNpbmdMb29wKTtcbiAgICAgIGVhc2luZ0xvb3AgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGkuaXNJbml0aWFsaXplZCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoZWFzaW5nTG9vcCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzcGVlZC54ICYmICFzcGVlZC55KSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChlYXNpbmdMb29wKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTWF0aC5hYnMoc3BlZWQueCkgPCAwLjAxICYmIE1hdGguYWJzKHNwZWVkLnkpIDwgMC4wMSkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoZWFzaW5nTG9vcCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYXBwbHlUb3VjaE1vdmUoc3BlZWQueCAqIDMwLCBzcGVlZC55ICogMzApO1xuXG4gICAgICAgIHNwZWVkLnggKj0gMC44O1xuICAgICAgICBzcGVlZC55ICo9IDAuODtcbiAgICAgIH0sIDEwKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZW52LnN1cHBvcnRzVG91Y2gpIHtcbiAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ3RvdWNoc3RhcnQnLCB0b3VjaFN0YXJ0KTtcbiAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ3RvdWNobW92ZScsIHRvdWNoTW92ZSk7XG4gICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICd0b3VjaGVuZCcsIHRvdWNoRW5kKTtcbiAgfSBlbHNlIGlmIChlbnYuc3VwcG9ydHNJZVBvaW50ZXIpIHtcbiAgICBpZiAod2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdwb2ludGVyZG93bicsIHRvdWNoU3RhcnQpO1xuICAgICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdwb2ludGVybW92ZScsIHRvdWNoTW92ZSk7XG4gICAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ3BvaW50ZXJ1cCcsIHRvdWNoRW5kKTtcbiAgICB9IGVsc2UgaWYgKHdpbmRvdy5NU1BvaW50ZXJFdmVudCkge1xuICAgICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdNU1BvaW50ZXJEb3duJywgdG91Y2hTdGFydCk7XG4gICAgICBpLmV2ZW50LmJpbmQoZWxlbWVudCwgJ01TUG9pbnRlck1vdmUnLCB0b3VjaE1vdmUpO1xuICAgICAgaS5ldmVudC5iaW5kKGVsZW1lbnQsICdNU1BvaW50ZXJVcCcsIHRvdWNoRW5kKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBkZWZhdWx0U2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICBoYW5kbGVyczogWydjbGljay1yYWlsJywgJ2RyYWctdGh1bWInLCAna2V5Ym9hcmQnLCAnd2hlZWwnLCAndG91Y2gnXSxcbiAgbWF4U2Nyb2xsYmFyTGVuZ3RoOiBudWxsLFxuICBtaW5TY3JvbGxiYXJMZW5ndGg6IG51bGwsXG4gIHNjcm9sbGluZ1RocmVzaG9sZDogMTAwMCxcbiAgc2Nyb2xsWE1hcmdpbk9mZnNldDogMCxcbiAgc2Nyb2xsWU1hcmdpbk9mZnNldDogMCxcbiAgc3VwcHJlc3NTY3JvbGxYOiBmYWxzZSxcbiAgc3VwcHJlc3NTY3JvbGxZOiBmYWxzZSxcbiAgc3dpcGVFYXNpbmc6IHRydWUsXG4gIHVzZUJvdGhXaGVlbEF4ZXM6IGZhbHNlLFxuICB3aGVlbFByb3BhZ2F0aW9uOiB0cnVlLFxuICB3aGVlbFNwZWVkOiAxLFxufSk7IH07XG5cbnZhciBoYW5kbGVycyA9IHtcbiAgJ2NsaWNrLXJhaWwnOiBjbGlja1JhaWwsXG4gICdkcmFnLXRodW1iJzogZHJhZ1RodW1iLFxuICBrZXlib2FyZDoga2V5Ym9hcmQsXG4gIHdoZWVsOiB3aGVlbCxcbiAgdG91Y2g6IHRvdWNoLFxufTtcblxudmFyIFBlcmZlY3RTY3JvbGxiYXIgPSBmdW5jdGlvbiBQZXJmZWN0U2Nyb2xsYmFyKGVsZW1lbnQsIHVzZXJTZXR0aW5ncykge1xuICB2YXIgdGhpcyQxID0gdGhpcztcbiAgaWYgKCB1c2VyU2V0dGluZ3MgPT09IHZvaWQgMCApIHVzZXJTZXR0aW5ncyA9IHt9O1xuXG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbGVtZW50KTtcbiAgfVxuXG4gIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5ub2RlTmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm8gZWxlbWVudCBpcyBzcGVjaWZpZWQgdG8gaW5pdGlhbGl6ZSBQZXJmZWN0U2Nyb2xsYmFyJyk7XG4gIH1cblxuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXG4gIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbHMubWFpbik7XG5cbiAgdGhpcy5zZXR0aW5ncyA9IGRlZmF1bHRTZXR0aW5ncygpO1xuICBmb3IgKHZhciBrZXkgaW4gdXNlclNldHRpbmdzKSB7XG4gICAgdGhpcyQxLnNldHRpbmdzW2tleV0gPSB1c2VyU2V0dGluZ3Nba2V5XTtcbiAgfVxuXG4gIHRoaXMuY29udGFpbmVyV2lkdGggPSBudWxsO1xuICB0aGlzLmNvbnRhaW5lckhlaWdodCA9IG51bGw7XG4gIHRoaXMuY29udGVudFdpZHRoID0gbnVsbDtcbiAgdGhpcy5jb250ZW50SGVpZ2h0ID0gbnVsbDtcblxuICB2YXIgZm9jdXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xzLnN0YXRlLmZvY3VzKTsgfTtcbiAgdmFyIGJsdXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xzLnN0YXRlLmZvY3VzKTsgfTtcblxuICB0aGlzLmlzUnRsID0gZ2V0KGVsZW1lbnQpLmRpcmVjdGlvbiA9PT0gJ3J0bCc7XG4gIHRoaXMuaXNOZWdhdGl2ZVNjcm9sbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9yaWdpbmFsU2Nyb2xsTGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICBlbGVtZW50LnNjcm9sbExlZnQgPSAtMTtcbiAgICByZXN1bHQgPSBlbGVtZW50LnNjcm9sbExlZnQgPCAwO1xuICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IG9yaWdpbmFsU2Nyb2xsTGVmdDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KSgpO1xuICB0aGlzLm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCA9IHRoaXMuaXNOZWdhdGl2ZVNjcm9sbFxuICAgID8gZWxlbWVudC5zY3JvbGxXaWR0aCAtIGVsZW1lbnQuY2xpZW50V2lkdGhcbiAgICA6IDA7XG4gIHRoaXMuZXZlbnQgPSBuZXcgRXZlbnRNYW5hZ2VyKCk7XG4gIHRoaXMub3duZXJEb2N1bWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcblxuICB0aGlzLnNjcm9sbGJhclhSYWlsID0gZGl2KGNscy5lbGVtZW50LnJhaWwoJ3gnKSk7XG4gIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5zY3JvbGxiYXJYUmFpbCk7XG4gIHRoaXMuc2Nyb2xsYmFyWCA9IGRpdihjbHMuZWxlbWVudC50aHVtYigneCcpKTtcbiAgdGhpcy5zY3JvbGxiYXJYUmFpbC5hcHBlbmRDaGlsZCh0aGlzLnNjcm9sbGJhclgpO1xuICB0aGlzLnNjcm9sbGJhclguc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIDApO1xuICB0aGlzLmV2ZW50LmJpbmQodGhpcy5zY3JvbGxiYXJYLCAnZm9jdXMnLCBmb2N1cyk7XG4gIHRoaXMuZXZlbnQuYmluZCh0aGlzLnNjcm9sbGJhclgsICdibHVyJywgYmx1cik7XG4gIHRoaXMuc2Nyb2xsYmFyWEFjdGl2ZSA9IG51bGw7XG4gIHRoaXMuc2Nyb2xsYmFyWFdpZHRoID0gbnVsbDtcbiAgdGhpcy5zY3JvbGxiYXJYTGVmdCA9IG51bGw7XG4gIHZhciByYWlsWFN0eWxlID0gZ2V0KHRoaXMuc2Nyb2xsYmFyWFJhaWwpO1xuICB0aGlzLnNjcm9sbGJhclhCb3R0b20gPSBwYXJzZUludChyYWlsWFN0eWxlLmJvdHRvbSwgMTApO1xuICBpZiAoaXNOYU4odGhpcy5zY3JvbGxiYXJYQm90dG9tKSkge1xuICAgIHRoaXMuaXNTY3JvbGxiYXJYVXNpbmdCb3R0b20gPSBmYWxzZTtcbiAgICB0aGlzLnNjcm9sbGJhclhUb3AgPSB0b0ludChyYWlsWFN0eWxlLnRvcCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pc1Njcm9sbGJhclhVc2luZ0JvdHRvbSA9IHRydWU7XG4gIH1cbiAgdGhpcy5yYWlsQm9yZGVyWFdpZHRoID1cbiAgICB0b0ludChyYWlsWFN0eWxlLmJvcmRlckxlZnRXaWR0aCkgKyB0b0ludChyYWlsWFN0eWxlLmJvcmRlclJpZ2h0V2lkdGgpO1xuICAvLyBTZXQgcmFpbCB0byBkaXNwbGF5OmJsb2NrIHRvIGNhbGN1bGF0ZSBtYXJnaW5zXG4gIHNldCh0aGlzLnNjcm9sbGJhclhSYWlsLCB7IGRpc3BsYXk6ICdibG9jaycgfSk7XG4gIHRoaXMucmFpbFhNYXJnaW5XaWR0aCA9XG4gICAgdG9JbnQocmFpbFhTdHlsZS5tYXJnaW5MZWZ0KSArIHRvSW50KHJhaWxYU3R5bGUubWFyZ2luUmlnaHQpO1xuICBzZXQodGhpcy5zY3JvbGxiYXJYUmFpbCwgeyBkaXNwbGF5OiAnJyB9KTtcbiAgdGhpcy5yYWlsWFdpZHRoID0gbnVsbDtcbiAgdGhpcy5yYWlsWFJhdGlvID0gbnVsbDtcblxuICB0aGlzLnNjcm9sbGJhcllSYWlsID0gZGl2KGNscy5lbGVtZW50LnJhaWwoJ3knKSk7XG4gIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5zY3JvbGxiYXJZUmFpbCk7XG4gIHRoaXMuc2Nyb2xsYmFyWSA9IGRpdihjbHMuZWxlbWVudC50aHVtYigneScpKTtcbiAgdGhpcy5zY3JvbGxiYXJZUmFpbC5hcHBlbmRDaGlsZCh0aGlzLnNjcm9sbGJhclkpO1xuICB0aGlzLnNjcm9sbGJhclkuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIDApO1xuICB0aGlzLmV2ZW50LmJpbmQodGhpcy5zY3JvbGxiYXJZLCAnZm9jdXMnLCBmb2N1cyk7XG4gIHRoaXMuZXZlbnQuYmluZCh0aGlzLnNjcm9sbGJhclksICdibHVyJywgYmx1cik7XG4gIHRoaXMuc2Nyb2xsYmFyWUFjdGl2ZSA9IG51bGw7XG4gIHRoaXMuc2Nyb2xsYmFyWUhlaWdodCA9IG51bGw7XG4gIHRoaXMuc2Nyb2xsYmFyWVRvcCA9IG51bGw7XG4gIHZhciByYWlsWVN0eWxlID0gZ2V0KHRoaXMuc2Nyb2xsYmFyWVJhaWwpO1xuICB0aGlzLnNjcm9sbGJhcllSaWdodCA9IHBhcnNlSW50KHJhaWxZU3R5bGUucmlnaHQsIDEwKTtcbiAgaWYgKGlzTmFOKHRoaXMuc2Nyb2xsYmFyWVJpZ2h0KSkge1xuICAgIHRoaXMuaXNTY3JvbGxiYXJZVXNpbmdSaWdodCA9IGZhbHNlO1xuICAgIHRoaXMuc2Nyb2xsYmFyWUxlZnQgPSB0b0ludChyYWlsWVN0eWxlLmxlZnQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaXNTY3JvbGxiYXJZVXNpbmdSaWdodCA9IHRydWU7XG4gIH1cbiAgdGhpcy5zY3JvbGxiYXJZT3V0ZXJXaWR0aCA9IHRoaXMuaXNSdGwgPyBvdXRlcldpZHRoKHRoaXMuc2Nyb2xsYmFyWSkgOiBudWxsO1xuICB0aGlzLnJhaWxCb3JkZXJZV2lkdGggPVxuICAgIHRvSW50KHJhaWxZU3R5bGUuYm9yZGVyVG9wV2lkdGgpICsgdG9JbnQocmFpbFlTdHlsZS5ib3JkZXJCb3R0b21XaWR0aCk7XG4gIHNldCh0aGlzLnNjcm9sbGJhcllSYWlsLCB7IGRpc3BsYXk6ICdibG9jaycgfSk7XG4gIHRoaXMucmFpbFlNYXJnaW5IZWlnaHQgPVxuICAgIHRvSW50KHJhaWxZU3R5bGUubWFyZ2luVG9wKSArIHRvSW50KHJhaWxZU3R5bGUubWFyZ2luQm90dG9tKTtcbiAgc2V0KHRoaXMuc2Nyb2xsYmFyWVJhaWwsIHsgZGlzcGxheTogJycgfSk7XG4gIHRoaXMucmFpbFlIZWlnaHQgPSBudWxsO1xuICB0aGlzLnJhaWxZUmF0aW8gPSBudWxsO1xuXG4gIHRoaXMucmVhY2ggPSB7XG4gICAgeDpcbiAgICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA8PSAwXG4gICAgICAgID8gJ3N0YXJ0J1xuICAgICAgICA6IGVsZW1lbnQuc2Nyb2xsTGVmdCA+PSB0aGlzLmNvbnRlbnRXaWR0aCAtIHRoaXMuY29udGFpbmVyV2lkdGhcbiAgICAgICAgICA/ICdlbmQnXG4gICAgICAgICAgOiBudWxsLFxuICAgIHk6XG4gICAgICBlbGVtZW50LnNjcm9sbFRvcCA8PSAwXG4gICAgICAgID8gJ3N0YXJ0J1xuICAgICAgICA6IGVsZW1lbnQuc2Nyb2xsVG9wID49IHRoaXMuY29udGVudEhlaWdodCAtIHRoaXMuY29udGFpbmVySGVpZ2h0XG4gICAgICAgICAgPyAnZW5kJ1xuICAgICAgICAgIDogbnVsbCxcbiAgfTtcblxuICB0aGlzLmlzQWxpdmUgPSB0cnVlO1xuXG4gIHRoaXMuc2V0dGluZ3MuaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlck5hbWUpIHsgcmV0dXJuIGhhbmRsZXJzW2hhbmRsZXJOYW1lXSh0aGlzJDEpOyB9KTtcblxuICB0aGlzLmxhc3RTY3JvbGxUb3AgPSBNYXRoLmZsb29yKGVsZW1lbnQuc2Nyb2xsVG9wKTsgLy8gZm9yIG9uU2Nyb2xsIG9ubHlcbiAgdGhpcy5sYXN0U2Nyb2xsTGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdDsgLy8gZm9yIG9uU2Nyb2xsIG9ubHlcbiAgdGhpcy5ldmVudC5iaW5kKHRoaXMuZWxlbWVudCwgJ3Njcm9sbCcsIGZ1bmN0aW9uIChlKSB7IHJldHVybiB0aGlzJDEub25TY3JvbGwoZSk7IH0pO1xuICB1cGRhdGVHZW9tZXRyeSh0aGlzKTtcbn07XG5cblBlcmZlY3RTY3JvbGxiYXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIGlmICghdGhpcy5pc0FsaXZlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gUmVjYWxjdWF0ZSBuZWdhdGl2ZSBzY3JvbGxMZWZ0IGFkanVzdG1lbnRcbiAgdGhpcy5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQgPSB0aGlzLmlzTmVnYXRpdmVTY3JvbGxcbiAgICA/IHRoaXMuZWxlbWVudC5zY3JvbGxXaWR0aCAtIHRoaXMuZWxlbWVudC5jbGllbnRXaWR0aFxuICAgIDogMDtcblxuICAvLyBSZWNhbGN1bGF0ZSByYWlsIG1hcmdpbnNcbiAgc2V0KHRoaXMuc2Nyb2xsYmFyWFJhaWwsIHsgZGlzcGxheTogJ2Jsb2NrJyB9KTtcbiAgc2V0KHRoaXMuc2Nyb2xsYmFyWVJhaWwsIHsgZGlzcGxheTogJ2Jsb2NrJyB9KTtcbiAgdGhpcy5yYWlsWE1hcmdpbldpZHRoID1cbiAgICB0b0ludChnZXQodGhpcy5zY3JvbGxiYXJYUmFpbCkubWFyZ2luTGVmdCkgK1xuICAgIHRvSW50KGdldCh0aGlzLnNjcm9sbGJhclhSYWlsKS5tYXJnaW5SaWdodCk7XG4gIHRoaXMucmFpbFlNYXJnaW5IZWlnaHQgPVxuICAgIHRvSW50KGdldCh0aGlzLnNjcm9sbGJhcllSYWlsKS5tYXJnaW5Ub3ApICtcbiAgICB0b0ludChnZXQodGhpcy5zY3JvbGxiYXJZUmFpbCkubWFyZ2luQm90dG9tKTtcblxuICAvLyBIaWRlIHNjcm9sbGJhcnMgbm90IHRvIGFmZmVjdCBzY3JvbGxXaWR0aCBhbmQgc2Nyb2xsSGVpZ2h0XG4gIHNldCh0aGlzLnNjcm9sbGJhclhSYWlsLCB7IGRpc3BsYXk6ICdub25lJyB9KTtcbiAgc2V0KHRoaXMuc2Nyb2xsYmFyWVJhaWwsIHsgZGlzcGxheTogJ25vbmUnIH0pO1xuXG4gIHVwZGF0ZUdlb21ldHJ5KHRoaXMpO1xuXG4gIHByb2Nlc3NTY3JvbGxEaWZmKHRoaXMsICd0b3AnLCAwLCBmYWxzZSwgdHJ1ZSk7XG4gIHByb2Nlc3NTY3JvbGxEaWZmKHRoaXMsICdsZWZ0JywgMCwgZmFsc2UsIHRydWUpO1xuXG4gIHNldCh0aGlzLnNjcm9sbGJhclhSYWlsLCB7IGRpc3BsYXk6ICcnIH0pO1xuICBzZXQodGhpcy5zY3JvbGxiYXJZUmFpbCwgeyBkaXNwbGF5OiAnJyB9KTtcbn07XG5cblBlcmZlY3RTY3JvbGxiYXIucHJvdG90eXBlLm9uU2Nyb2xsID0gZnVuY3Rpb24gb25TY3JvbGwgKGUpIHtcbiAgaWYgKCF0aGlzLmlzQWxpdmUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB1cGRhdGVHZW9tZXRyeSh0aGlzKTtcbiAgcHJvY2Vzc1Njcm9sbERpZmYodGhpcywgJ3RvcCcsIHRoaXMuZWxlbWVudC5zY3JvbGxUb3AgLSB0aGlzLmxhc3RTY3JvbGxUb3ApO1xuICBwcm9jZXNzU2Nyb2xsRGlmZihcbiAgICB0aGlzLFxuICAgICdsZWZ0JyxcbiAgICB0aGlzLmVsZW1lbnQuc2Nyb2xsTGVmdCAtIHRoaXMubGFzdFNjcm9sbExlZnRcbiAgKTtcblxuICB0aGlzLmxhc3RTY3JvbGxUb3AgPSBNYXRoLmZsb29yKHRoaXMuZWxlbWVudC5zY3JvbGxUb3ApO1xuICB0aGlzLmxhc3RTY3JvbGxMZWZ0ID0gdGhpcy5lbGVtZW50LnNjcm9sbExlZnQ7XG59O1xuXG5QZXJmZWN0U2Nyb2xsYmFyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSAoKSB7XG4gIGlmICghdGhpcy5pc0FsaXZlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5ldmVudC51bmJpbmRBbGwoKTtcbiAgcmVtb3ZlKHRoaXMuc2Nyb2xsYmFyWCk7XG4gIHJlbW92ZSh0aGlzLnNjcm9sbGJhclkpO1xuICByZW1vdmUodGhpcy5zY3JvbGxiYXJYUmFpbCk7XG4gIHJlbW92ZSh0aGlzLnNjcm9sbGJhcllSYWlsKTtcbiAgdGhpcy5yZW1vdmVQc0NsYXNzZXMoKTtcblxuICAvLyB1bnNldCBlbGVtZW50c1xuICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICB0aGlzLnNjcm9sbGJhclggPSBudWxsO1xuICB0aGlzLnNjcm9sbGJhclkgPSBudWxsO1xuICB0aGlzLnNjcm9sbGJhclhSYWlsID0gbnVsbDtcbiAgdGhpcy5zY3JvbGxiYXJZUmFpbCA9IG51bGw7XG5cbiAgdGhpcy5pc0FsaXZlID0gZmFsc2U7XG59O1xuXG5QZXJmZWN0U2Nyb2xsYmFyLnByb3RvdHlwZS5yZW1vdmVQc0NsYXNzZXMgPSBmdW5jdGlvbiByZW1vdmVQc0NsYXNzZXMgKCkge1xuICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5lbGVtZW50LmNsYXNzTmFtZVxuICAgIC5zcGxpdCgnICcpXG4gICAgLmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW5hbWUubWF0Y2goL15wcyhbLV9dLit8KSQvKTsgfSlcbiAgICAuam9pbignICcpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQZXJmZWN0U2Nyb2xsYmFyO1xuIiwiLyohIHRvb2x0aXBzdGVyIHY0LjIuNiAqLyFmdW5jdGlvbihhLGIpe1wiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wianF1ZXJ5XCJdLGZ1bmN0aW9uKGEpe3JldHVybiBiKGEpfSk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9YihyZXF1aXJlKFwianF1ZXJ5XCIpKTpiKGpRdWVyeSl9KHRoaXMsZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihhKXt0aGlzLiRjb250YWluZXIsdGhpcy5jb25zdHJhaW50cz1udWxsLHRoaXMuX18kdG9vbHRpcCx0aGlzLl9faW5pdChhKX1mdW5jdGlvbiBjKGIsYyl7dmFyIGQ9ITA7cmV0dXJuIGEuZWFjaChiLGZ1bmN0aW9uKGEsZSl7cmV0dXJuIHZvaWQgMD09PWNbYV18fGJbYV0hPT1jW2FdPyhkPSExLCExKTp2b2lkIDB9KSxkfWZ1bmN0aW9uIGQoYil7dmFyIGM9Yi5hdHRyKFwiaWRcIiksZD1jP2gud2luZG93LmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGMpOm51bGw7cmV0dXJuIGQ/ZD09PWJbMF06YS5jb250YWlucyhoLndpbmRvdy5kb2N1bWVudC5ib2R5LGJbMF0pfWZ1bmN0aW9uIGUoKXtpZighZylyZXR1cm4hMTt2YXIgYT1nLmRvY3VtZW50LmJvZHl8fGcuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LGI9YS5zdHlsZSxjPVwidHJhbnNpdGlvblwiLGQ9W1wiTW96XCIsXCJXZWJraXRcIixcIktodG1sXCIsXCJPXCIsXCJtc1wiXTtpZihcInN0cmluZ1wiPT10eXBlb2YgYltjXSlyZXR1cm4hMDtjPWMuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrYy5zdWJzdHIoMSk7Zm9yKHZhciBlPTA7ZTxkLmxlbmd0aDtlKyspaWYoXCJzdHJpbmdcIj09dHlwZW9mIGJbZFtlXStjXSlyZXR1cm4hMDtyZXR1cm4hMX12YXIgZj17YW5pbWF0aW9uOlwiZmFkZVwiLGFuaW1hdGlvbkR1cmF0aW9uOjM1MCxjb250ZW50Om51bGwsY29udGVudEFzSFRNTDohMSxjb250ZW50Q2xvbmluZzohMSxkZWJ1ZzohMCxkZWxheTozMDAsZGVsYXlUb3VjaDpbMzAwLDUwMF0sZnVuY3Rpb25Jbml0Om51bGwsZnVuY3Rpb25CZWZvcmU6bnVsbCxmdW5jdGlvblJlYWR5Om51bGwsZnVuY3Rpb25BZnRlcjpudWxsLGZ1bmN0aW9uRm9ybWF0Om51bGwsSUVtaW46NixpbnRlcmFjdGl2ZTohMSxtdWx0aXBsZTohMSxwYXJlbnQ6bnVsbCxwbHVnaW5zOltcInNpZGVUaXBcIl0scmVwb3NpdGlvbk9uU2Nyb2xsOiExLHJlc3RvcmF0aW9uOlwibm9uZVwiLHNlbGZEZXN0cnVjdGlvbjohMCx0aGVtZTpbXSx0aW1lcjowLHRyYWNrZXJJbnRlcnZhbDo1MDAsdHJhY2tPcmlnaW46ITEsdHJhY2tUb29sdGlwOiExLHRyaWdnZXI6XCJob3ZlclwiLHRyaWdnZXJDbG9zZTp7Y2xpY2s6ITEsbW91c2VsZWF2ZTohMSxvcmlnaW5DbGljazohMSxzY3JvbGw6ITEsdGFwOiExLHRvdWNobGVhdmU6ITF9LHRyaWdnZXJPcGVuOntjbGljazohMSxtb3VzZWVudGVyOiExLHRhcDohMSx0b3VjaHN0YXJ0OiExfSx1cGRhdGVBbmltYXRpb246XCJyb3RhdGVcIix6SW5kZXg6OTk5OTk5OX0sZz1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzpudWxsLGg9e2hhc1RvdWNoQ2FwYWJpbGl0eTohKCFnfHwhKFwib250b3VjaHN0YXJ0XCJpbiBnfHxnLkRvY3VtZW50VG91Y2gmJmcuZG9jdW1lbnQgaW5zdGFuY2VvZiBnLkRvY3VtZW50VG91Y2h8fGcubmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzKSksaGFzVHJhbnNpdGlvbnM6ZSgpLElFOiExLHNlbVZlcjpcIjQuMi42XCIsd2luZG93Omd9LGk9ZnVuY3Rpb24oKXt0aGlzLl9fJGVtaXR0ZXJQcml2YXRlPWEoe30pLHRoaXMuX18kZW1pdHRlclB1YmxpYz1hKHt9KSx0aGlzLl9faW5zdGFuY2VzTGF0ZXN0QXJyPVtdLHRoaXMuX19wbHVnaW5zPXt9LHRoaXMuX2Vudj1ofTtpLnByb3RvdHlwZT17X19icmlkZ2U6ZnVuY3Rpb24oYixjLGQpe2lmKCFjW2RdKXt2YXIgZT1mdW5jdGlvbigpe307ZS5wcm90b3R5cGU9Yjt2YXIgZz1uZXcgZTtnLl9faW5pdCYmZy5fX2luaXQoYyksYS5lYWNoKGIsZnVuY3Rpb24oYSxiKXswIT1hLmluZGV4T2YoXCJfX1wiKSYmKGNbYV0/Zi5kZWJ1ZyYmY29uc29sZS5sb2coXCJUaGUgXCIrYStcIiBtZXRob2Qgb2YgdGhlIFwiK2QrXCIgcGx1Z2luIGNvbmZsaWN0cyB3aXRoIGFub3RoZXIgcGx1Z2luIG9yIG5hdGl2ZSBtZXRob2RzXCIpOihjW2FdPWZ1bmN0aW9uKCl7cmV0dXJuIGdbYV0uYXBwbHkoZyxBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzKSl9LGNbYV0uYnJpZGdlZD1nKSl9KSxjW2RdPWd9cmV0dXJuIHRoaXN9LF9fc2V0V2luZG93OmZ1bmN0aW9uKGEpe3JldHVybiBoLndpbmRvdz1hLHRoaXN9LF9nZXRSdWxlcjpmdW5jdGlvbihhKXtyZXR1cm4gbmV3IGIoYSl9LF9vZmY6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fXyRlbWl0dGVyUHJpdmF0ZS5vZmYuYXBwbHkodGhpcy5fXyRlbWl0dGVyUHJpdmF0ZSxBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzKSksdGhpc30sX29uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX18kZW1pdHRlclByaXZhdGUub24uYXBwbHkodGhpcy5fXyRlbWl0dGVyUHJpdmF0ZSxBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzKSksdGhpc30sX29uZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9fJGVtaXR0ZXJQcml2YXRlLm9uZS5hcHBseSh0aGlzLl9fJGVtaXR0ZXJQcml2YXRlLEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmd1bWVudHMpKSx0aGlzfSxfcGx1Z2luOmZ1bmN0aW9uKGIpe3ZhciBjPXRoaXM7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGIpe3ZhciBkPWIsZT1udWxsO3JldHVybiBkLmluZGV4T2YoXCIuXCIpPjA/ZT1jLl9fcGx1Z2luc1tkXTphLmVhY2goYy5fX3BsdWdpbnMsZnVuY3Rpb24oYSxiKXtyZXR1cm4gYi5uYW1lLnN1YnN0cmluZyhiLm5hbWUubGVuZ3RoLWQubGVuZ3RoLTEpPT1cIi5cIitkPyhlPWIsITEpOnZvaWQgMH0pLGV9aWYoYi5uYW1lLmluZGV4T2YoXCIuXCIpPDApdGhyb3cgbmV3IEVycm9yKFwiUGx1Z2lucyBtdXN0IGJlIG5hbWVzcGFjZWRcIik7cmV0dXJuIGMuX19wbHVnaW5zW2IubmFtZV09YixiLmNvcmUmJmMuX19icmlkZ2UoYi5jb3JlLGMsYi5uYW1lKSx0aGlzfSxfdHJpZ2dlcjpmdW5jdGlvbigpe3ZhciBhPUFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmd1bWVudHMpO3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBhWzBdJiYoYVswXT17dHlwZTphWzBdfSksdGhpcy5fXyRlbWl0dGVyUHJpdmF0ZS50cmlnZ2VyLmFwcGx5KHRoaXMuX18kZW1pdHRlclByaXZhdGUsYSksdGhpcy5fXyRlbWl0dGVyUHVibGljLnRyaWdnZXIuYXBwbHkodGhpcy5fXyRlbWl0dGVyUHVibGljLGEpLHRoaXN9LGluc3RhbmNlczpmdW5jdGlvbihiKXt2YXIgYz1bXSxkPWJ8fFwiLnRvb2x0aXBzdGVyZWRcIjtyZXR1cm4gYShkKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIGI9YSh0aGlzKSxkPWIuZGF0YShcInRvb2x0aXBzdGVyLW5zXCIpO2QmJmEuZWFjaChkLGZ1bmN0aW9uKGEsZCl7Yy5wdXNoKGIuZGF0YShkKSl9KX0pLGN9LGluc3RhbmNlc0xhdGVzdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9faW5zdGFuY2VzTGF0ZXN0QXJyfSxvZmY6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fXyRlbWl0dGVyUHVibGljLm9mZi5hcHBseSh0aGlzLl9fJGVtaXR0ZXJQdWJsaWMsQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cykpLHRoaXN9LG9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX18kZW1pdHRlclB1YmxpYy5vbi5hcHBseSh0aGlzLl9fJGVtaXR0ZXJQdWJsaWMsQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cykpLHRoaXN9LG9uZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9fJGVtaXR0ZXJQdWJsaWMub25lLmFwcGx5KHRoaXMuX18kZW1pdHRlclB1YmxpYyxBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzKSksdGhpc30sb3JpZ2luczpmdW5jdGlvbihiKXt2YXIgYz1iP2IrXCIgXCI6XCJcIjtyZXR1cm4gYShjK1wiLnRvb2x0aXBzdGVyZWRcIikudG9BcnJheSgpfSxzZXREZWZhdWx0czpmdW5jdGlvbihiKXtyZXR1cm4gYS5leHRlbmQoZixiKSx0aGlzfSx0cmlnZ2VySGFuZGxlcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9fJGVtaXR0ZXJQdWJsaWMudHJpZ2dlckhhbmRsZXIuYXBwbHkodGhpcy5fXyRlbWl0dGVyUHVibGljLEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmd1bWVudHMpKSx0aGlzfX0sYS50b29sdGlwc3Rlcj1uZXcgaSxhLlRvb2x0aXBzdGVyPWZ1bmN0aW9uKGIsYyl7dGhpcy5fX2NhbGxiYWNrcz17Y2xvc2U6W10sb3BlbjpbXX0sdGhpcy5fX2Nsb3NpbmdUaW1lLHRoaXMuX19Db250ZW50LHRoaXMuX19jb250ZW50QmNyLHRoaXMuX19kZXN0cm95ZWQ9ITEsdGhpcy5fXyRlbWl0dGVyUHJpdmF0ZT1hKHt9KSx0aGlzLl9fJGVtaXR0ZXJQdWJsaWM9YSh7fSksdGhpcy5fX2VuYWJsZWQ9ITAsdGhpcy5fX2dhcmJhZ2VDb2xsZWN0b3IsdGhpcy5fX0dlb21ldHJ5LHRoaXMuX19sYXN0UG9zaXRpb24sdGhpcy5fX25hbWVzcGFjZT1cInRvb2x0aXBzdGVyLVwiK01hdGgucm91bmQoMWU2Kk1hdGgucmFuZG9tKCkpLHRoaXMuX19vcHRpb25zLHRoaXMuX18kb3JpZ2luUGFyZW50cyx0aGlzLl9fcG9pbnRlcklzT3Zlck9yaWdpbj0hMSx0aGlzLl9fcHJldmlvdXNUaGVtZXM9W10sdGhpcy5fX3N0YXRlPVwiY2xvc2VkXCIsdGhpcy5fX3RpbWVvdXRzPXtjbG9zZTpbXSxvcGVuOm51bGx9LHRoaXMuX190b3VjaEV2ZW50cz1bXSx0aGlzLl9fdHJhY2tlcj1udWxsLHRoaXMuXyRvcmlnaW4sdGhpcy5fJHRvb2x0aXAsdGhpcy5fX2luaXQoYixjKX0sYS5Ub29sdGlwc3Rlci5wcm90b3R5cGU9e19faW5pdDpmdW5jdGlvbihiLGMpe3ZhciBkPXRoaXM7aWYoZC5fJG9yaWdpbj1hKGIpLGQuX19vcHRpb25zPWEuZXh0ZW5kKCEwLHt9LGYsYyksZC5fX29wdGlvbnNGb3JtYXQoKSwhaC5JRXx8aC5JRT49ZC5fX29wdGlvbnMuSUVtaW4pe3ZhciBlPW51bGw7aWYodm9pZCAwPT09ZC5fJG9yaWdpbi5kYXRhKFwidG9vbHRpcHN0ZXItaW5pdGlhbFRpdGxlXCIpJiYoZT1kLl8kb3JpZ2luLmF0dHIoXCJ0aXRsZVwiKSx2b2lkIDA9PT1lJiYoZT1udWxsKSxkLl8kb3JpZ2luLmRhdGEoXCJ0b29sdGlwc3Rlci1pbml0aWFsVGl0bGVcIixlKSksbnVsbCE9PWQuX19vcHRpb25zLmNvbnRlbnQpZC5fX2NvbnRlbnRTZXQoZC5fX29wdGlvbnMuY29udGVudCk7ZWxzZXt2YXIgZyxpPWQuXyRvcmlnaW4uYXR0cihcImRhdGEtdG9vbHRpcC1jb250ZW50XCIpO2kmJihnPWEoaSkpLGcmJmdbMF0/ZC5fX2NvbnRlbnRTZXQoZy5maXJzdCgpKTpkLl9fY29udGVudFNldChlKX1kLl8kb3JpZ2luLnJlbW92ZUF0dHIoXCJ0aXRsZVwiKS5hZGRDbGFzcyhcInRvb2x0aXBzdGVyZWRcIiksZC5fX3ByZXBhcmVPcmlnaW4oKSxkLl9fcHJlcGFyZUdDKCksYS5lYWNoKGQuX19vcHRpb25zLnBsdWdpbnMsZnVuY3Rpb24oYSxiKXtkLl9wbHVnKGIpfSksaC5oYXNUb3VjaENhcGFiaWxpdHkmJmEoaC53aW5kb3cuZG9jdW1lbnQuYm9keSkub24oXCJ0b3VjaG1vdmUuXCIrZC5fX25hbWVzcGFjZStcIi10cmlnZ2VyT3BlblwiLGZ1bmN0aW9uKGEpe2QuX3RvdWNoUmVjb3JkRXZlbnQoYSl9KSxkLl9vbihcImNyZWF0ZWRcIixmdW5jdGlvbigpe2QuX19wcmVwYXJlVG9vbHRpcCgpfSkuX29uKFwicmVwb3NpdGlvbmVkXCIsZnVuY3Rpb24oYSl7ZC5fX2xhc3RQb3NpdGlvbj1hLnBvc2l0aW9ufSl9ZWxzZSBkLl9fb3B0aW9ucy5kaXNhYmxlZD0hMH0sX19jb250ZW50SW5zZXJ0OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWEuXyR0b29sdGlwLmZpbmQoXCIudG9vbHRpcHN0ZXItY29udGVudFwiKSxjPWEuX19Db250ZW50LGQ9ZnVuY3Rpb24oYSl7Yz1hfTtyZXR1cm4gYS5fdHJpZ2dlcih7dHlwZTpcImZvcm1hdFwiLGNvbnRlbnQ6YS5fX0NvbnRlbnQsZm9ybWF0OmR9KSxhLl9fb3B0aW9ucy5mdW5jdGlvbkZvcm1hdCYmKGM9YS5fX29wdGlvbnMuZnVuY3Rpb25Gb3JtYXQuY2FsbChhLGEse29yaWdpbjphLl8kb3JpZ2luWzBdfSxhLl9fQ29udGVudCkpLFwic3RyaW5nXCIhPXR5cGVvZiBjfHxhLl9fb3B0aW9ucy5jb250ZW50QXNIVE1MP2IuZW1wdHkoKS5hcHBlbmQoYyk6Yi50ZXh0KGMpLGF9LF9fY29udGVudFNldDpmdW5jdGlvbihiKXtyZXR1cm4gYiBpbnN0YW5jZW9mIGEmJnRoaXMuX19vcHRpb25zLmNvbnRlbnRDbG9uaW5nJiYoYj1iLmNsb25lKCEwKSksdGhpcy5fX0NvbnRlbnQ9Yix0aGlzLl90cmlnZ2VyKHt0eXBlOlwidXBkYXRlZFwiLGNvbnRlbnQ6Yn0pLHRoaXN9LF9fZGVzdHJveUVycm9yOmZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKFwiVGhpcyB0b29sdGlwIGhhcyBiZWVuIGRlc3Ryb3llZCBhbmQgY2Fubm90IGV4ZWN1dGUgeW91ciBtZXRob2QgY2FsbC5cIil9LF9fZ2VvbWV0cnk6ZnVuY3Rpb24oKXt2YXIgYj10aGlzLGM9Yi5fJG9yaWdpbixkPWIuXyRvcmlnaW4uaXMoXCJhcmVhXCIpO2lmKGQpe3ZhciBlPWIuXyRvcmlnaW4ucGFyZW50KCkuYXR0cihcIm5hbWVcIik7Yz1hKCdpbWdbdXNlbWFwPVwiIycrZSsnXCJdJyl9dmFyIGY9Y1swXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxnPWEoaC53aW5kb3cuZG9jdW1lbnQpLGk9YShoLndpbmRvdyksaj1jLGs9e2F2YWlsYWJsZTp7ZG9jdW1lbnQ6bnVsbCx3aW5kb3c6bnVsbH0sZG9jdW1lbnQ6e3NpemU6e2hlaWdodDpnLmhlaWdodCgpLHdpZHRoOmcud2lkdGgoKX19LHdpbmRvdzp7c2Nyb2xsOntsZWZ0Omgud2luZG93LnNjcm9sbFh8fGgud2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LHRvcDpoLndpbmRvdy5zY3JvbGxZfHxoLndpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wfSxzaXplOntoZWlnaHQ6aS5oZWlnaHQoKSx3aWR0aDppLndpZHRoKCl9fSxvcmlnaW46e2ZpeGVkTGluZWFnZTohMSxvZmZzZXQ6e30sc2l6ZTp7aGVpZ2h0OmYuYm90dG9tLWYudG9wLHdpZHRoOmYucmlnaHQtZi5sZWZ0fSx1c2VtYXBJbWFnZTpkP2NbMF06bnVsbCx3aW5kb3dPZmZzZXQ6e2JvdHRvbTpmLmJvdHRvbSxsZWZ0OmYubGVmdCxyaWdodDpmLnJpZ2h0LHRvcDpmLnRvcH19fTtpZihkKXt2YXIgbD1iLl8kb3JpZ2luLmF0dHIoXCJzaGFwZVwiKSxtPWIuXyRvcmlnaW4uYXR0cihcImNvb3Jkc1wiKTtpZihtJiYobT1tLnNwbGl0KFwiLFwiKSxhLm1hcChtLGZ1bmN0aW9uKGEsYil7bVtiXT1wYXJzZUludChhKX0pKSxcImRlZmF1bHRcIiE9bClzd2l0Y2gobCl7Y2FzZVwiY2lyY2xlXCI6dmFyIG49bVswXSxvPW1bMV0scD1tWzJdLHE9by1wLHI9bi1wO2sub3JpZ2luLnNpemUuaGVpZ2h0PTIqcCxrLm9yaWdpbi5zaXplLndpZHRoPWsub3JpZ2luLnNpemUuaGVpZ2h0LGsub3JpZ2luLndpbmRvd09mZnNldC5sZWZ0Kz1yLGsub3JpZ2luLndpbmRvd09mZnNldC50b3ArPXE7YnJlYWs7Y2FzZVwicmVjdFwiOnZhciBzPW1bMF0sdD1tWzFdLHU9bVsyXSx2PW1bM107ay5vcmlnaW4uc2l6ZS5oZWlnaHQ9di10LGsub3JpZ2luLnNpemUud2lkdGg9dS1zLGsub3JpZ2luLndpbmRvd09mZnNldC5sZWZ0Kz1zLGsub3JpZ2luLndpbmRvd09mZnNldC50b3ArPXQ7YnJlYWs7Y2FzZVwicG9seVwiOmZvcih2YXIgdz0wLHg9MCx5PTAsej0wLEE9XCJldmVuXCIsQj0wO0I8bS5sZW5ndGg7QisrKXt2YXIgQz1tW0JdO1wiZXZlblwiPT1BPyhDPnkmJih5PUMsMD09PUImJih3PXkpKSx3PkMmJih3PUMpLEE9XCJvZGRcIik6KEM+eiYmKHo9QywxPT1CJiYoeD16KSkseD5DJiYoeD1DKSxBPVwiZXZlblwiKX1rLm9yaWdpbi5zaXplLmhlaWdodD16LXgsay5vcmlnaW4uc2l6ZS53aWR0aD15LXcsay5vcmlnaW4ud2luZG93T2Zmc2V0LmxlZnQrPXcsay5vcmlnaW4ud2luZG93T2Zmc2V0LnRvcCs9eH19dmFyIEQ9ZnVuY3Rpb24oYSl7ay5vcmlnaW4uc2l6ZS5oZWlnaHQ9YS5oZWlnaHQsay5vcmlnaW4ud2luZG93T2Zmc2V0LmxlZnQ9YS5sZWZ0LGsub3JpZ2luLndpbmRvd09mZnNldC50b3A9YS50b3Asay5vcmlnaW4uc2l6ZS53aWR0aD1hLndpZHRofTtmb3IoYi5fdHJpZ2dlcih7dHlwZTpcImdlb21ldHJ5XCIsZWRpdDpELGdlb21ldHJ5OntoZWlnaHQ6ay5vcmlnaW4uc2l6ZS5oZWlnaHQsbGVmdDprLm9yaWdpbi53aW5kb3dPZmZzZXQubGVmdCx0b3A6ay5vcmlnaW4ud2luZG93T2Zmc2V0LnRvcCx3aWR0aDprLm9yaWdpbi5zaXplLndpZHRofX0pLGsub3JpZ2luLndpbmRvd09mZnNldC5yaWdodD1rLm9yaWdpbi53aW5kb3dPZmZzZXQubGVmdCtrLm9yaWdpbi5zaXplLndpZHRoLGsub3JpZ2luLndpbmRvd09mZnNldC5ib3R0b209ay5vcmlnaW4ud2luZG93T2Zmc2V0LnRvcCtrLm9yaWdpbi5zaXplLmhlaWdodCxrLm9yaWdpbi5vZmZzZXQubGVmdD1rLm9yaWdpbi53aW5kb3dPZmZzZXQubGVmdCtrLndpbmRvdy5zY3JvbGwubGVmdCxrLm9yaWdpbi5vZmZzZXQudG9wPWsub3JpZ2luLndpbmRvd09mZnNldC50b3Aray53aW5kb3cuc2Nyb2xsLnRvcCxrLm9yaWdpbi5vZmZzZXQuYm90dG9tPWsub3JpZ2luLm9mZnNldC50b3Aray5vcmlnaW4uc2l6ZS5oZWlnaHQsay5vcmlnaW4ub2Zmc2V0LnJpZ2h0PWsub3JpZ2luLm9mZnNldC5sZWZ0K2sub3JpZ2luLnNpemUud2lkdGgsay5hdmFpbGFibGUuZG9jdW1lbnQ9e2JvdHRvbTp7aGVpZ2h0OmsuZG9jdW1lbnQuc2l6ZS5oZWlnaHQtay5vcmlnaW4ub2Zmc2V0LmJvdHRvbSx3aWR0aDprLmRvY3VtZW50LnNpemUud2lkdGh9LGxlZnQ6e2hlaWdodDprLmRvY3VtZW50LnNpemUuaGVpZ2h0LHdpZHRoOmsub3JpZ2luLm9mZnNldC5sZWZ0fSxyaWdodDp7aGVpZ2h0OmsuZG9jdW1lbnQuc2l6ZS5oZWlnaHQsd2lkdGg6ay5kb2N1bWVudC5zaXplLndpZHRoLWsub3JpZ2luLm9mZnNldC5yaWdodH0sdG9wOntoZWlnaHQ6ay5vcmlnaW4ub2Zmc2V0LnRvcCx3aWR0aDprLmRvY3VtZW50LnNpemUud2lkdGh9fSxrLmF2YWlsYWJsZS53aW5kb3c9e2JvdHRvbTp7aGVpZ2h0Ok1hdGgubWF4KGsud2luZG93LnNpemUuaGVpZ2h0LU1hdGgubWF4KGsub3JpZ2luLndpbmRvd09mZnNldC5ib3R0b20sMCksMCksd2lkdGg6ay53aW5kb3cuc2l6ZS53aWR0aH0sbGVmdDp7aGVpZ2h0Omsud2luZG93LnNpemUuaGVpZ2h0LHdpZHRoOk1hdGgubWF4KGsub3JpZ2luLndpbmRvd09mZnNldC5sZWZ0LDApfSxyaWdodDp7aGVpZ2h0Omsud2luZG93LnNpemUuaGVpZ2h0LHdpZHRoOk1hdGgubWF4KGsud2luZG93LnNpemUud2lkdGgtTWF0aC5tYXgoay5vcmlnaW4ud2luZG93T2Zmc2V0LnJpZ2h0LDApLDApfSx0b3A6e2hlaWdodDpNYXRoLm1heChrLm9yaWdpbi53aW5kb3dPZmZzZXQudG9wLDApLHdpZHRoOmsud2luZG93LnNpemUud2lkdGh9fTtcImh0bWxcIiE9alswXS50YWdOYW1lLnRvTG93ZXJDYXNlKCk7KXtpZihcImZpeGVkXCI9PWouY3NzKFwicG9zaXRpb25cIikpe2sub3JpZ2luLmZpeGVkTGluZWFnZT0hMDticmVha31qPWoucGFyZW50KCl9cmV0dXJuIGt9LF9fb3B0aW9uc0Zvcm1hdDpmdW5jdGlvbigpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0aGlzLl9fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbiYmKHRoaXMuX19vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uPVt0aGlzLl9fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbix0aGlzLl9fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbl0pLFwibnVtYmVyXCI9PXR5cGVvZiB0aGlzLl9fb3B0aW9ucy5kZWxheSYmKHRoaXMuX19vcHRpb25zLmRlbGF5PVt0aGlzLl9fb3B0aW9ucy5kZWxheSx0aGlzLl9fb3B0aW9ucy5kZWxheV0pLFwibnVtYmVyXCI9PXR5cGVvZiB0aGlzLl9fb3B0aW9ucy5kZWxheVRvdWNoJiYodGhpcy5fX29wdGlvbnMuZGVsYXlUb3VjaD1bdGhpcy5fX29wdGlvbnMuZGVsYXlUb3VjaCx0aGlzLl9fb3B0aW9ucy5kZWxheVRvdWNoXSksXCJzdHJpbmdcIj09dHlwZW9mIHRoaXMuX19vcHRpb25zLnRoZW1lJiYodGhpcy5fX29wdGlvbnMudGhlbWU9W3RoaXMuX19vcHRpb25zLnRoZW1lXSksbnVsbD09PXRoaXMuX19vcHRpb25zLnBhcmVudD90aGlzLl9fb3B0aW9ucy5wYXJlbnQ9YShoLndpbmRvdy5kb2N1bWVudC5ib2R5KTpcInN0cmluZ1wiPT10eXBlb2YgdGhpcy5fX29wdGlvbnMucGFyZW50JiYodGhpcy5fX29wdGlvbnMucGFyZW50PWEodGhpcy5fX29wdGlvbnMucGFyZW50KSksXCJob3ZlclwiPT10aGlzLl9fb3B0aW9ucy50cmlnZ2VyPyh0aGlzLl9fb3B0aW9ucy50cmlnZ2VyT3Blbj17bW91c2VlbnRlcjohMCx0b3VjaHN0YXJ0OiEwfSx0aGlzLl9fb3B0aW9ucy50cmlnZ2VyQ2xvc2U9e21vdXNlbGVhdmU6ITAsb3JpZ2luQ2xpY2s6ITAsdG91Y2hsZWF2ZTohMH0pOlwiY2xpY2tcIj09dGhpcy5fX29wdGlvbnMudHJpZ2dlciYmKHRoaXMuX19vcHRpb25zLnRyaWdnZXJPcGVuPXtjbGljazohMCx0YXA6ITB9LHRoaXMuX19vcHRpb25zLnRyaWdnZXJDbG9zZT17Y2xpY2s6ITAsdGFwOiEwfSksdGhpcy5fdHJpZ2dlcihcIm9wdGlvbnNcIiksdGhpc30sX19wcmVwYXJlR0M6ZnVuY3Rpb24oKXt2YXIgYj10aGlzO3JldHVybiBiLl9fb3B0aW9ucy5zZWxmRGVzdHJ1Y3Rpb24/Yi5fX2dhcmJhZ2VDb2xsZWN0b3I9c2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXt2YXIgYz0obmV3IERhdGUpLmdldFRpbWUoKTtiLl9fdG91Y2hFdmVudHM9YS5ncmVwKGIuX190b3VjaEV2ZW50cyxmdW5jdGlvbihhLGIpe3JldHVybiBjLWEudGltZT42ZTR9KSxkKGIuXyRvcmlnaW4pfHxiLmNsb3NlKGZ1bmN0aW9uKCl7Yi5kZXN0cm95KCl9KX0sMmU0KTpjbGVhckludGVydmFsKGIuX19nYXJiYWdlQ29sbGVjdG9yKSxifSxfX3ByZXBhcmVPcmlnaW46ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2lmKGEuXyRvcmlnaW4ub2ZmKFwiLlwiK2EuX19uYW1lc3BhY2UrXCItdHJpZ2dlck9wZW5cIiksaC5oYXNUb3VjaENhcGFiaWxpdHkmJmEuXyRvcmlnaW4ub24oXCJ0b3VjaHN0YXJ0LlwiK2EuX19uYW1lc3BhY2UrXCItdHJpZ2dlck9wZW4gdG91Y2hlbmQuXCIrYS5fX25hbWVzcGFjZStcIi10cmlnZ2VyT3BlbiB0b3VjaGNhbmNlbC5cIithLl9fbmFtZXNwYWNlK1wiLXRyaWdnZXJPcGVuXCIsZnVuY3Rpb24oYil7YS5fdG91Y2hSZWNvcmRFdmVudChiKX0pLGEuX19vcHRpb25zLnRyaWdnZXJPcGVuLmNsaWNrfHxhLl9fb3B0aW9ucy50cmlnZ2VyT3Blbi50YXAmJmguaGFzVG91Y2hDYXBhYmlsaXR5KXt2YXIgYj1cIlwiO2EuX19vcHRpb25zLnRyaWdnZXJPcGVuLmNsaWNrJiYoYis9XCJjbGljay5cIithLl9fbmFtZXNwYWNlK1wiLXRyaWdnZXJPcGVuIFwiKSxhLl9fb3B0aW9ucy50cmlnZ2VyT3Blbi50YXAmJmguaGFzVG91Y2hDYXBhYmlsaXR5JiYoYis9XCJ0b3VjaGVuZC5cIithLl9fbmFtZXNwYWNlK1wiLXRyaWdnZXJPcGVuXCIpLGEuXyRvcmlnaW4ub24oYixmdW5jdGlvbihiKXthLl90b3VjaElzTWVhbmluZ2Z1bEV2ZW50KGIpJiZhLl9vcGVuKGIpfSl9aWYoYS5fX29wdGlvbnMudHJpZ2dlck9wZW4ubW91c2VlbnRlcnx8YS5fX29wdGlvbnMudHJpZ2dlck9wZW4udG91Y2hzdGFydCYmaC5oYXNUb3VjaENhcGFiaWxpdHkpe3ZhciBiPVwiXCI7YS5fX29wdGlvbnMudHJpZ2dlck9wZW4ubW91c2VlbnRlciYmKGIrPVwibW91c2VlbnRlci5cIithLl9fbmFtZXNwYWNlK1wiLXRyaWdnZXJPcGVuIFwiKSxhLl9fb3B0aW9ucy50cmlnZ2VyT3Blbi50b3VjaHN0YXJ0JiZoLmhhc1RvdWNoQ2FwYWJpbGl0eSYmKGIrPVwidG91Y2hzdGFydC5cIithLl9fbmFtZXNwYWNlK1wiLXRyaWdnZXJPcGVuXCIpLGEuXyRvcmlnaW4ub24oYixmdW5jdGlvbihiKXshYS5fdG91Y2hJc1RvdWNoRXZlbnQoYikmJmEuX3RvdWNoSXNFbXVsYXRlZEV2ZW50KGIpfHwoYS5fX3BvaW50ZXJJc092ZXJPcmlnaW49ITAsYS5fb3BlblNob3J0bHkoYikpfSl9aWYoYS5fX29wdGlvbnMudHJpZ2dlckNsb3NlLm1vdXNlbGVhdmV8fGEuX19vcHRpb25zLnRyaWdnZXJDbG9zZS50b3VjaGxlYXZlJiZoLmhhc1RvdWNoQ2FwYWJpbGl0eSl7dmFyIGI9XCJcIjthLl9fb3B0aW9ucy50cmlnZ2VyQ2xvc2UubW91c2VsZWF2ZSYmKGIrPVwibW91c2VsZWF2ZS5cIithLl9fbmFtZXNwYWNlK1wiLXRyaWdnZXJPcGVuIFwiKSxhLl9fb3B0aW9ucy50cmlnZ2VyQ2xvc2UudG91Y2hsZWF2ZSYmaC5oYXNUb3VjaENhcGFiaWxpdHkmJihiKz1cInRvdWNoZW5kLlwiK2EuX19uYW1lc3BhY2UrXCItdHJpZ2dlck9wZW4gdG91Y2hjYW5jZWwuXCIrYS5fX25hbWVzcGFjZStcIi10cmlnZ2VyT3BlblwiKSxhLl8kb3JpZ2luLm9uKGIsZnVuY3Rpb24oYil7YS5fdG91Y2hJc01lYW5pbmdmdWxFdmVudChiKSYmKGEuX19wb2ludGVySXNPdmVyT3JpZ2luPSExKX0pfXJldHVybiBhfSxfX3ByZXBhcmVUb29sdGlwOmZ1bmN0aW9uKCl7dmFyIGI9dGhpcyxjPWIuX19vcHRpb25zLmludGVyYWN0aXZlP1wiYXV0b1wiOlwiXCI7cmV0dXJuIGIuXyR0b29sdGlwLmF0dHIoXCJpZFwiLGIuX19uYW1lc3BhY2UpLmNzcyh7XCJwb2ludGVyLWV2ZW50c1wiOmMsekluZGV4OmIuX19vcHRpb25zLnpJbmRleH0pLGEuZWFjaChiLl9fcHJldmlvdXNUaGVtZXMsZnVuY3Rpb24oYSxjKXtiLl8kdG9vbHRpcC5yZW1vdmVDbGFzcyhjKX0pLGEuZWFjaChiLl9fb3B0aW9ucy50aGVtZSxmdW5jdGlvbihhLGMpe2IuXyR0b29sdGlwLmFkZENsYXNzKGMpfSksYi5fX3ByZXZpb3VzVGhlbWVzPWEubWVyZ2UoW10sYi5fX29wdGlvbnMudGhlbWUpLGJ9LF9fc2Nyb2xsSGFuZGxlcjpmdW5jdGlvbihiKXt2YXIgYz10aGlzO2lmKGMuX19vcHRpb25zLnRyaWdnZXJDbG9zZS5zY3JvbGwpYy5fY2xvc2UoYik7ZWxzZSBpZihkKGMuXyRvcmlnaW4pJiZkKGMuXyR0b29sdGlwKSl7dmFyIGU9bnVsbDtpZihiLnRhcmdldD09PWgud2luZG93LmRvY3VtZW50KWMuX19HZW9tZXRyeS5vcmlnaW4uZml4ZWRMaW5lYWdlfHxjLl9fb3B0aW9ucy5yZXBvc2l0aW9uT25TY3JvbGwmJmMucmVwb3NpdGlvbihiKTtlbHNle2U9Yy5fX2dlb21ldHJ5KCk7dmFyIGY9ITE7aWYoXCJmaXhlZFwiIT1jLl8kb3JpZ2luLmNzcyhcInBvc2l0aW9uXCIpJiZjLl9fJG9yaWdpblBhcmVudHMuZWFjaChmdW5jdGlvbihiLGMpe3ZhciBkPWEoYyksZz1kLmNzcyhcIm92ZXJmbG93LXhcIiksaD1kLmNzcyhcIm92ZXJmbG93LXlcIik7aWYoXCJ2aXNpYmxlXCIhPWd8fFwidmlzaWJsZVwiIT1oKXt2YXIgaT1jLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2lmKFwidmlzaWJsZVwiIT1nJiYoZS5vcmlnaW4ud2luZG93T2Zmc2V0LmxlZnQ8aS5sZWZ0fHxlLm9yaWdpbi53aW5kb3dPZmZzZXQucmlnaHQ+aS5yaWdodCkpcmV0dXJuIGY9ITAsITE7aWYoXCJ2aXNpYmxlXCIhPWgmJihlLm9yaWdpbi53aW5kb3dPZmZzZXQudG9wPGkudG9wfHxlLm9yaWdpbi53aW5kb3dPZmZzZXQuYm90dG9tPmkuYm90dG9tKSlyZXR1cm4gZj0hMCwhMX1yZXR1cm5cImZpeGVkXCI9PWQuY3NzKFwicG9zaXRpb25cIik/ITE6dm9pZCAwfSksZiljLl8kdG9vbHRpcC5jc3MoXCJ2aXNpYmlsaXR5XCIsXCJoaWRkZW5cIik7ZWxzZSBpZihjLl8kdG9vbHRpcC5jc3MoXCJ2aXNpYmlsaXR5XCIsXCJ2aXNpYmxlXCIpLGMuX19vcHRpb25zLnJlcG9zaXRpb25PblNjcm9sbCljLnJlcG9zaXRpb24oYik7ZWxzZXt2YXIgZz1lLm9yaWdpbi5vZmZzZXQubGVmdC1jLl9fR2VvbWV0cnkub3JpZ2luLm9mZnNldC5sZWZ0LGk9ZS5vcmlnaW4ub2Zmc2V0LnRvcC1jLl9fR2VvbWV0cnkub3JpZ2luLm9mZnNldC50b3A7Yy5fJHRvb2x0aXAuY3NzKHtsZWZ0OmMuX19sYXN0UG9zaXRpb24uY29vcmQubGVmdCtnLHRvcDpjLl9fbGFzdFBvc2l0aW9uLmNvb3JkLnRvcCtpfSl9fWMuX3RyaWdnZXIoe3R5cGU6XCJzY3JvbGxcIixldmVudDpiLGdlbzplfSl9cmV0dXJuIGN9LF9fc3RhdGVTZXQ6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuX19zdGF0ZT1hLHRoaXMuX3RyaWdnZXIoe3R5cGU6XCJzdGF0ZVwiLHN0YXRlOmF9KSx0aGlzfSxfX3RpbWVvdXRzQ2xlYXI6ZnVuY3Rpb24oKXtyZXR1cm4gY2xlYXJUaW1lb3V0KHRoaXMuX190aW1lb3V0cy5vcGVuKSx0aGlzLl9fdGltZW91dHMub3Blbj1udWxsLGEuZWFjaCh0aGlzLl9fdGltZW91dHMuY2xvc2UsZnVuY3Rpb24oYSxiKXtjbGVhclRpbWVvdXQoYil9KSx0aGlzLl9fdGltZW91dHMuY2xvc2U9W10sdGhpc30sX190cmFja2VyU3RhcnQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5fJHRvb2x0aXAuZmluZChcIi50b29sdGlwc3Rlci1jb250ZW50XCIpO3JldHVybiBhLl9fb3B0aW9ucy50cmFja1Rvb2x0aXAmJihhLl9fY29udGVudEJjcj1iWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSxhLl9fdHJhY2tlcj1zZXRJbnRlcnZhbChmdW5jdGlvbigpe2lmKGQoYS5fJG9yaWdpbikmJmQoYS5fJHRvb2x0aXApKXtpZihhLl9fb3B0aW9ucy50cmFja09yaWdpbil7dmFyIGU9YS5fX2dlb21ldHJ5KCksZj0hMTtjKGUub3JpZ2luLnNpemUsYS5fX0dlb21ldHJ5Lm9yaWdpbi5zaXplKSYmKGEuX19HZW9tZXRyeS5vcmlnaW4uZml4ZWRMaW5lYWdlP2MoZS5vcmlnaW4ud2luZG93T2Zmc2V0LGEuX19HZW9tZXRyeS5vcmlnaW4ud2luZG93T2Zmc2V0KSYmKGY9ITApOmMoZS5vcmlnaW4ub2Zmc2V0LGEuX19HZW9tZXRyeS5vcmlnaW4ub2Zmc2V0KSYmKGY9ITApKSxmfHwoYS5fX29wdGlvbnMudHJpZ2dlckNsb3NlLm1vdXNlbGVhdmU/YS5fY2xvc2UoKTphLnJlcG9zaXRpb24oKSl9aWYoYS5fX29wdGlvbnMudHJhY2tUb29sdGlwKXt2YXIgZz1iWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2cuaGVpZ2h0PT09YS5fX2NvbnRlbnRCY3IuaGVpZ2h0JiZnLndpZHRoPT09YS5fX2NvbnRlbnRCY3Iud2lkdGh8fChhLnJlcG9zaXRpb24oKSxhLl9fY29udGVudEJjcj1nKX19ZWxzZSBhLl9jbG9zZSgpfSxhLl9fb3B0aW9ucy50cmFja2VySW50ZXJ2YWwpLGF9LF9jbG9zZTpmdW5jdGlvbihiLGMsZCl7dmFyIGU9dGhpcyxmPSEwO2lmKGUuX3RyaWdnZXIoe3R5cGU6XCJjbG9zZVwiLGV2ZW50OmIsc3RvcDpmdW5jdGlvbigpe2Y9ITF9fSksZnx8ZCl7YyYmZS5fX2NhbGxiYWNrcy5jbG9zZS5wdXNoKGMpLGUuX19jYWxsYmFja3Mub3Blbj1bXSxlLl9fdGltZW91dHNDbGVhcigpO3ZhciBnPWZ1bmN0aW9uKCl7YS5lYWNoKGUuX19jYWxsYmFja3MuY2xvc2UsZnVuY3Rpb24oYSxjKXtjLmNhbGwoZSxlLHtldmVudDpiLG9yaWdpbjplLl8kb3JpZ2luWzBdfSl9KSxlLl9fY2FsbGJhY2tzLmNsb3NlPVtdfTtpZihcImNsb3NlZFwiIT1lLl9fc3RhdGUpe3ZhciBpPSEwLGo9bmV3IERhdGUsaz1qLmdldFRpbWUoKSxsPWsrZS5fX29wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb25bMV07aWYoXCJkaXNhcHBlYXJpbmdcIj09ZS5fX3N0YXRlJiZsPmUuX19jbG9zaW5nVGltZSYmZS5fX29wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb25bMV0+MCYmKGk9ITEpLGkpe2UuX19jbG9zaW5nVGltZT1sLFwiZGlzYXBwZWFyaW5nXCIhPWUuX19zdGF0ZSYmZS5fX3N0YXRlU2V0KFwiZGlzYXBwZWFyaW5nXCIpO3ZhciBtPWZ1bmN0aW9uKCl7Y2xlYXJJbnRlcnZhbChlLl9fdHJhY2tlciksZS5fdHJpZ2dlcih7dHlwZTpcImNsb3NpbmdcIixldmVudDpifSksZS5fJHRvb2x0aXAub2ZmKFwiLlwiK2UuX19uYW1lc3BhY2UrXCItdHJpZ2dlckNsb3NlXCIpLnJlbW92ZUNsYXNzKFwidG9vbHRpcHN0ZXItZHlpbmdcIiksYShoLndpbmRvdykub2ZmKFwiLlwiK2UuX19uYW1lc3BhY2UrXCItdHJpZ2dlckNsb3NlXCIpLGUuX18kb3JpZ2luUGFyZW50cy5lYWNoKGZ1bmN0aW9uKGIsYyl7YShjKS5vZmYoXCJzY3JvbGwuXCIrZS5fX25hbWVzcGFjZStcIi10cmlnZ2VyQ2xvc2VcIil9KSxlLl9fJG9yaWdpblBhcmVudHM9bnVsbCxhKGgud2luZG93LmRvY3VtZW50LmJvZHkpLm9mZihcIi5cIitlLl9fbmFtZXNwYWNlK1wiLXRyaWdnZXJDbG9zZVwiKSxlLl8kb3JpZ2luLm9mZihcIi5cIitlLl9fbmFtZXNwYWNlK1wiLXRyaWdnZXJDbG9zZVwiKSxlLl9vZmYoXCJkaXNtaXNzYWJsZVwiKSxlLl9fc3RhdGVTZXQoXCJjbG9zZWRcIiksZS5fdHJpZ2dlcih7dHlwZTpcImFmdGVyXCIsZXZlbnQ6Yn0pLGUuX19vcHRpb25zLmZ1bmN0aW9uQWZ0ZXImJmUuX19vcHRpb25zLmZ1bmN0aW9uQWZ0ZXIuY2FsbChlLGUse2V2ZW50OmIsb3JpZ2luOmUuXyRvcmlnaW5bMF19KSxnKCl9O2guaGFzVHJhbnNpdGlvbnM/KGUuXyR0b29sdGlwLmNzcyh7XCItbW96LWFuaW1hdGlvbi1kdXJhdGlvblwiOmUuX19vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uWzFdK1wibXNcIixcIi1tcy1hbmltYXRpb24tZHVyYXRpb25cIjplLl9fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvblsxXStcIm1zXCIsXCItby1hbmltYXRpb24tZHVyYXRpb25cIjplLl9fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvblsxXStcIm1zXCIsXCItd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvblwiOmUuX19vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uWzFdK1wibXNcIixcImFuaW1hdGlvbi1kdXJhdGlvblwiOmUuX19vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uWzFdK1wibXNcIixcInRyYW5zaXRpb24tZHVyYXRpb25cIjplLl9fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvblsxXStcIm1zXCJ9KSxlLl8kdG9vbHRpcC5jbGVhclF1ZXVlKCkucmVtb3ZlQ2xhc3MoXCJ0b29sdGlwc3Rlci1zaG93XCIpLmFkZENsYXNzKFwidG9vbHRpcHN0ZXItZHlpbmdcIiksZS5fX29wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb25bMV0+MCYmZS5fJHRvb2x0aXAuZGVsYXkoZS5fX29wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb25bMV0pLGUuXyR0b29sdGlwLnF1ZXVlKG0pKTplLl8kdG9vbHRpcC5zdG9wKCkuZmFkZU91dChlLl9fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvblsxXSxtKX19ZWxzZSBnKCl9cmV0dXJuIGV9LF9vZmY6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fXyRlbWl0dGVyUHJpdmF0ZS5vZmYuYXBwbHkodGhpcy5fXyRlbWl0dGVyUHJpdmF0ZSxBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzKSksdGhpc30sX29uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX18kZW1pdHRlclByaXZhdGUub24uYXBwbHkodGhpcy5fXyRlbWl0dGVyUHJpdmF0ZSxBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzKSksdGhpc30sX29uZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9fJGVtaXR0ZXJQcml2YXRlLm9uZS5hcHBseSh0aGlzLl9fJGVtaXR0ZXJQcml2YXRlLEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmd1bWVudHMpKSx0aGlzfSxfb3BlbjpmdW5jdGlvbihiLGMpe3ZhciBlPXRoaXM7aWYoIWUuX19kZXN0cm95aW5nJiZkKGUuXyRvcmlnaW4pJiZlLl9fZW5hYmxlZCl7dmFyIGY9ITA7aWYoXCJjbG9zZWRcIj09ZS5fX3N0YXRlJiYoZS5fdHJpZ2dlcih7dHlwZTpcImJlZm9yZVwiLGV2ZW50OmIsc3RvcDpmdW5jdGlvbigpe2Y9ITF9fSksZiYmZS5fX29wdGlvbnMuZnVuY3Rpb25CZWZvcmUmJihmPWUuX19vcHRpb25zLmZ1bmN0aW9uQmVmb3JlLmNhbGwoZSxlLHtldmVudDpiLG9yaWdpbjplLl8kb3JpZ2luWzBdfSkpKSxmIT09ITEmJm51bGwhPT1lLl9fQ29udGVudCl7YyYmZS5fX2NhbGxiYWNrcy5vcGVuLnB1c2goYyksZS5fX2NhbGxiYWNrcy5jbG9zZT1bXSxlLl9fdGltZW91dHNDbGVhcigpO3ZhciBnLGk9ZnVuY3Rpb24oKXtcInN0YWJsZVwiIT1lLl9fc3RhdGUmJmUuX19zdGF0ZVNldChcInN0YWJsZVwiKSxhLmVhY2goZS5fX2NhbGxiYWNrcy5vcGVuLGZ1bmN0aW9uKGEsYil7Yi5jYWxsKGUsZSx7b3JpZ2luOmUuXyRvcmlnaW5bMF0sdG9vbHRpcDplLl8kdG9vbHRpcFswXX0pfSksZS5fX2NhbGxiYWNrcy5vcGVuPVtdfTtpZihcImNsb3NlZFwiIT09ZS5fX3N0YXRlKWc9MCxcImRpc2FwcGVhcmluZ1wiPT09ZS5fX3N0YXRlPyhlLl9fc3RhdGVTZXQoXCJhcHBlYXJpbmdcIiksaC5oYXNUcmFuc2l0aW9ucz8oZS5fJHRvb2x0aXAuY2xlYXJRdWV1ZSgpLnJlbW92ZUNsYXNzKFwidG9vbHRpcHN0ZXItZHlpbmdcIikuYWRkQ2xhc3MoXCJ0b29sdGlwc3Rlci1zaG93XCIpLGUuX19vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uWzBdPjAmJmUuXyR0b29sdGlwLmRlbGF5KGUuX19vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uWzBdKSxlLl8kdG9vbHRpcC5xdWV1ZShpKSk6ZS5fJHRvb2x0aXAuc3RvcCgpLmZhZGVJbihpKSk6XCJzdGFibGVcIj09ZS5fX3N0YXRlJiZpKCk7ZWxzZXtpZihlLl9fc3RhdGVTZXQoXCJhcHBlYXJpbmdcIiksZz1lLl9fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvblswXSxlLl9fY29udGVudEluc2VydCgpLGUucmVwb3NpdGlvbihiLCEwKSxoLmhhc1RyYW5zaXRpb25zPyhlLl8kdG9vbHRpcC5hZGRDbGFzcyhcInRvb2x0aXBzdGVyLVwiK2UuX19vcHRpb25zLmFuaW1hdGlvbikuYWRkQ2xhc3MoXCJ0b29sdGlwc3Rlci1pbml0aWFsXCIpLmNzcyh7XCItbW96LWFuaW1hdGlvbi1kdXJhdGlvblwiOmUuX19vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uWzBdK1wibXNcIixcIi1tcy1hbmltYXRpb24tZHVyYXRpb25cIjplLl9fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvblswXStcIm1zXCIsXCItby1hbmltYXRpb24tZHVyYXRpb25cIjplLl9fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvblswXStcIm1zXCIsXCItd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvblwiOmUuX19vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uWzBdK1wibXNcIixcImFuaW1hdGlvbi1kdXJhdGlvblwiOmUuX19vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uWzBdK1wibXNcIixcInRyYW5zaXRpb24tZHVyYXRpb25cIjplLl9fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvblswXStcIm1zXCJ9KSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XCJjbG9zZWRcIiE9ZS5fX3N0YXRlJiYoZS5fJHRvb2x0aXAuYWRkQ2xhc3MoXCJ0b29sdGlwc3Rlci1zaG93XCIpLnJlbW92ZUNsYXNzKFwidG9vbHRpcHN0ZXItaW5pdGlhbFwiKSxlLl9fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvblswXT4wJiZlLl8kdG9vbHRpcC5kZWxheShlLl9fb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvblswXSksZS5fJHRvb2x0aXAucXVldWUoaSkpfSwwKSk6ZS5fJHRvb2x0aXAuY3NzKFwiZGlzcGxheVwiLFwibm9uZVwiKS5mYWRlSW4oZS5fX29wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb25bMF0saSksZS5fX3RyYWNrZXJTdGFydCgpLGEoaC53aW5kb3cpLm9uKFwicmVzaXplLlwiK2UuX19uYW1lc3BhY2UrXCItdHJpZ2dlckNsb3NlXCIsZnVuY3Rpb24oYil7dmFyIGM9YShkb2N1bWVudC5hY3RpdmVFbGVtZW50KTsoYy5pcyhcImlucHV0XCIpfHxjLmlzKFwidGV4dGFyZWFcIikpJiZhLmNvbnRhaW5zKGUuXyR0b29sdGlwWzBdLGNbMF0pfHxlLnJlcG9zaXRpb24oYil9KS5vbihcInNjcm9sbC5cIitlLl9fbmFtZXNwYWNlK1wiLXRyaWdnZXJDbG9zZVwiLGZ1bmN0aW9uKGEpe2UuX19zY3JvbGxIYW5kbGVyKGEpfSksZS5fXyRvcmlnaW5QYXJlbnRzPWUuXyRvcmlnaW4ucGFyZW50cygpLGUuX18kb3JpZ2luUGFyZW50cy5lYWNoKGZ1bmN0aW9uKGIsYyl7YShjKS5vbihcInNjcm9sbC5cIitlLl9fbmFtZXNwYWNlK1wiLXRyaWdnZXJDbG9zZVwiLGZ1bmN0aW9uKGEpe2UuX19zY3JvbGxIYW5kbGVyKGEpfSl9KSxlLl9fb3B0aW9ucy50cmlnZ2VyQ2xvc2UubW91c2VsZWF2ZXx8ZS5fX29wdGlvbnMudHJpZ2dlckNsb3NlLnRvdWNobGVhdmUmJmguaGFzVG91Y2hDYXBhYmlsaXR5KXtlLl9vbihcImRpc21pc3NhYmxlXCIsZnVuY3Rpb24oYSl7YS5kaXNtaXNzYWJsZT9hLmRlbGF5PyhtPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLl9jbG9zZShhLmV2ZW50KX0sYS5kZWxheSksZS5fX3RpbWVvdXRzLmNsb3NlLnB1c2gobSkpOmUuX2Nsb3NlKGEpOmNsZWFyVGltZW91dChtKX0pO3ZhciBqPWUuXyRvcmlnaW4saz1cIlwiLGw9XCJcIixtPW51bGw7ZS5fX29wdGlvbnMuaW50ZXJhY3RpdmUmJihqPWouYWRkKGUuXyR0b29sdGlwKSksZS5fX29wdGlvbnMudHJpZ2dlckNsb3NlLm1vdXNlbGVhdmUmJihrKz1cIm1vdXNlZW50ZXIuXCIrZS5fX25hbWVzcGFjZStcIi10cmlnZ2VyQ2xvc2UgXCIsbCs9XCJtb3VzZWxlYXZlLlwiK2UuX19uYW1lc3BhY2UrXCItdHJpZ2dlckNsb3NlIFwiKSxlLl9fb3B0aW9ucy50cmlnZ2VyQ2xvc2UudG91Y2hsZWF2ZSYmaC5oYXNUb3VjaENhcGFiaWxpdHkmJihrKz1cInRvdWNoc3RhcnQuXCIrZS5fX25hbWVzcGFjZStcIi10cmlnZ2VyQ2xvc2VcIixsKz1cInRvdWNoZW5kLlwiK2UuX19uYW1lc3BhY2UrXCItdHJpZ2dlckNsb3NlIHRvdWNoY2FuY2VsLlwiK2UuX19uYW1lc3BhY2UrXCItdHJpZ2dlckNsb3NlXCIpLGoub24obCxmdW5jdGlvbihhKXtpZihlLl90b3VjaElzVG91Y2hFdmVudChhKXx8IWUuX3RvdWNoSXNFbXVsYXRlZEV2ZW50KGEpKXt2YXIgYj1cIm1vdXNlbGVhdmVcIj09YS50eXBlP2UuX19vcHRpb25zLmRlbGF5OmUuX19vcHRpb25zLmRlbGF5VG91Y2g7ZS5fdHJpZ2dlcih7ZGVsYXk6YlsxXSxkaXNtaXNzYWJsZTohMCxldmVudDphLHR5cGU6XCJkaXNtaXNzYWJsZVwifSl9fSkub24oayxmdW5jdGlvbihhKXshZS5fdG91Y2hJc1RvdWNoRXZlbnQoYSkmJmUuX3RvdWNoSXNFbXVsYXRlZEV2ZW50KGEpfHxlLl90cmlnZ2VyKHtkaXNtaXNzYWJsZTohMSxldmVudDphLHR5cGU6XCJkaXNtaXNzYWJsZVwifSl9KX1lLl9fb3B0aW9ucy50cmlnZ2VyQ2xvc2Uub3JpZ2luQ2xpY2smJmUuXyRvcmlnaW4ub24oXCJjbGljay5cIitlLl9fbmFtZXNwYWNlK1wiLXRyaWdnZXJDbG9zZVwiLGZ1bmN0aW9uKGEpe2UuX3RvdWNoSXNUb3VjaEV2ZW50KGEpfHxlLl90b3VjaElzRW11bGF0ZWRFdmVudChhKXx8ZS5fY2xvc2UoYSl9KSwoZS5fX29wdGlvbnMudHJpZ2dlckNsb3NlLmNsaWNrfHxlLl9fb3B0aW9ucy50cmlnZ2VyQ2xvc2UudGFwJiZoLmhhc1RvdWNoQ2FwYWJpbGl0eSkmJnNldFRpbWVvdXQoZnVuY3Rpb24oKXtpZihcImNsb3NlZFwiIT1lLl9fc3RhdGUpe3ZhciBiPVwiXCIsYz1hKGgud2luZG93LmRvY3VtZW50LmJvZHkpO2UuX19vcHRpb25zLnRyaWdnZXJDbG9zZS5jbGljayYmKGIrPVwiY2xpY2suXCIrZS5fX25hbWVzcGFjZStcIi10cmlnZ2VyQ2xvc2UgXCIpLGUuX19vcHRpb25zLnRyaWdnZXJDbG9zZS50YXAmJmguaGFzVG91Y2hDYXBhYmlsaXR5JiYoYis9XCJ0b3VjaGVuZC5cIitlLl9fbmFtZXNwYWNlK1wiLXRyaWdnZXJDbG9zZVwiKSxjLm9uKGIsZnVuY3Rpb24oYil7ZS5fdG91Y2hJc01lYW5pbmdmdWxFdmVudChiKSYmKGUuX3RvdWNoUmVjb3JkRXZlbnQoYiksZS5fX29wdGlvbnMuaW50ZXJhY3RpdmUmJmEuY29udGFpbnMoZS5fJHRvb2x0aXBbMF0sYi50YXJnZXQpfHxlLl9jbG9zZShiKSl9KSxlLl9fb3B0aW9ucy50cmlnZ2VyQ2xvc2UudGFwJiZoLmhhc1RvdWNoQ2FwYWJpbGl0eSYmYy5vbihcInRvdWNoc3RhcnQuXCIrZS5fX25hbWVzcGFjZStcIi10cmlnZ2VyQ2xvc2VcIixmdW5jdGlvbihhKXtlLl90b3VjaFJlY29yZEV2ZW50KGEpfSl9fSwwKSxlLl90cmlnZ2VyKFwicmVhZHlcIiksZS5fX29wdGlvbnMuZnVuY3Rpb25SZWFkeSYmZS5fX29wdGlvbnMuZnVuY3Rpb25SZWFkeS5jYWxsKGUsZSx7b3JpZ2luOmUuXyRvcmlnaW5bMF0sdG9vbHRpcDplLl8kdG9vbHRpcFswXX0pfWlmKGUuX19vcHRpb25zLnRpbWVyPjApe3ZhciBtPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLl9jbG9zZSgpfSxlLl9fb3B0aW9ucy50aW1lcitnKTtlLl9fdGltZW91dHMuY2xvc2UucHVzaChtKX19fXJldHVybiBlfSxfb3BlblNob3J0bHk6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPSEwO2lmKFwic3RhYmxlXCIhPWIuX19zdGF0ZSYmXCJhcHBlYXJpbmdcIiE9Yi5fX3N0YXRlJiYhYi5fX3RpbWVvdXRzLm9wZW4mJihiLl90cmlnZ2VyKHt0eXBlOlwic3RhcnRcIixldmVudDphLHN0b3A6ZnVuY3Rpb24oKXtjPSExfX0pLGMpKXt2YXIgZD0wPT1hLnR5cGUuaW5kZXhPZihcInRvdWNoXCIpP2IuX19vcHRpb25zLmRlbGF5VG91Y2g6Yi5fX29wdGlvbnMuZGVsYXk7ZFswXT9iLl9fdGltZW91dHMub3Blbj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yi5fX3RpbWVvdXRzLm9wZW49bnVsbCxiLl9fcG9pbnRlcklzT3Zlck9yaWdpbiYmYi5fdG91Y2hJc01lYW5pbmdmdWxFdmVudChhKT8oYi5fdHJpZ2dlcihcInN0YXJ0ZW5kXCIpLGIuX29wZW4oYSkpOmIuX3RyaWdnZXIoXCJzdGFydGNhbmNlbFwiKX0sZFswXSk6KGIuX3RyaWdnZXIoXCJzdGFydGVuZFwiKSxiLl9vcGVuKGEpKX1yZXR1cm4gYn0sX29wdGlvbnNFeHRyYWN0OmZ1bmN0aW9uKGIsYyl7dmFyIGQ9dGhpcyxlPWEuZXh0ZW5kKCEwLHt9LGMpLGY9ZC5fX29wdGlvbnNbYl07cmV0dXJuIGZ8fChmPXt9LGEuZWFjaChjLGZ1bmN0aW9uKGEsYil7dmFyIGM9ZC5fX29wdGlvbnNbYV07dm9pZCAwIT09YyYmKGZbYV09Yyl9KSksYS5lYWNoKGUsZnVuY3Rpb24oYixjKXt2b2lkIDAhPT1mW2JdJiYoXCJvYmplY3RcIiE9dHlwZW9mIGN8fGMgaW5zdGFuY2VvZiBBcnJheXx8bnVsbD09Y3x8XCJvYmplY3RcIiE9dHlwZW9mIGZbYl18fGZbYl1pbnN0YW5jZW9mIEFycmF5fHxudWxsPT1mW2JdP2VbYl09ZltiXTphLmV4dGVuZChlW2JdLGZbYl0pKX0pLGV9LF9wbHVnOmZ1bmN0aW9uKGIpe3ZhciBjPWEudG9vbHRpcHN0ZXIuX3BsdWdpbihiKTtpZighYyl0aHJvdyBuZXcgRXJyb3IoJ1RoZSBcIicrYisnXCIgcGx1Z2luIGlzIG5vdCBkZWZpbmVkJyk7cmV0dXJuIGMuaW5zdGFuY2UmJmEudG9vbHRpcHN0ZXIuX19icmlkZ2UoYy5pbnN0YW5jZSx0aGlzLGMubmFtZSksdGhpc30sX3RvdWNoSXNFbXVsYXRlZEV2ZW50OmZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0hMSxjPShuZXcgRGF0ZSkuZ2V0VGltZSgpLGQ9dGhpcy5fX3RvdWNoRXZlbnRzLmxlbmd0aC0xO2Q+PTA7ZC0tKXt2YXIgZT10aGlzLl9fdG91Y2hFdmVudHNbZF07aWYoIShjLWUudGltZTw1MDApKWJyZWFrO2UudGFyZ2V0PT09YS50YXJnZXQmJihiPSEwKX1yZXR1cm4gYn0sX3RvdWNoSXNNZWFuaW5nZnVsRXZlbnQ6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuX3RvdWNoSXNUb3VjaEV2ZW50KGEpJiYhdGhpcy5fdG91Y2hTd2lwZWQoYS50YXJnZXQpfHwhdGhpcy5fdG91Y2hJc1RvdWNoRXZlbnQoYSkmJiF0aGlzLl90b3VjaElzRW11bGF0ZWRFdmVudChhKX0sX3RvdWNoSXNUb3VjaEV2ZW50OmZ1bmN0aW9uKGEpe3JldHVybiAwPT1hLnR5cGUuaW5kZXhPZihcInRvdWNoXCIpfSxfdG91Y2hSZWNvcmRFdmVudDpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5fdG91Y2hJc1RvdWNoRXZlbnQoYSkmJihhLnRpbWU9KG5ldyBEYXRlKS5nZXRUaW1lKCksdGhpcy5fX3RvdWNoRXZlbnRzLnB1c2goYSkpLHRoaXN9LF90b3VjaFN3aXBlZDpmdW5jdGlvbihhKXtmb3IodmFyIGI9ITEsYz10aGlzLl9fdG91Y2hFdmVudHMubGVuZ3RoLTE7Yz49MDtjLS0pe3ZhciBkPXRoaXMuX190b3VjaEV2ZW50c1tjXTtpZihcInRvdWNobW92ZVwiPT1kLnR5cGUpe2I9ITA7YnJlYWt9aWYoXCJ0b3VjaHN0YXJ0XCI9PWQudHlwZSYmYT09PWQudGFyZ2V0KWJyZWFrfXJldHVybiBifSxfdHJpZ2dlcjpmdW5jdGlvbigpe3ZhciBiPUFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmd1bWVudHMpO3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBiWzBdJiYoYlswXT17dHlwZTpiWzBdfSksYlswXS5pbnN0YW5jZT10aGlzLGJbMF0ub3JpZ2luPXRoaXMuXyRvcmlnaW4/dGhpcy5fJG9yaWdpblswXTpudWxsLGJbMF0udG9vbHRpcD10aGlzLl8kdG9vbHRpcD90aGlzLl8kdG9vbHRpcFswXTpudWxsLHRoaXMuX18kZW1pdHRlclByaXZhdGUudHJpZ2dlci5hcHBseSh0aGlzLl9fJGVtaXR0ZXJQcml2YXRlLGIpLGEudG9vbHRpcHN0ZXIuX3RyaWdnZXIuYXBwbHkoYS50b29sdGlwc3RlcixiKSx0aGlzLl9fJGVtaXR0ZXJQdWJsaWMudHJpZ2dlci5hcHBseSh0aGlzLl9fJGVtaXR0ZXJQdWJsaWMsYiksdGhpc30sX3VucGx1ZzpmdW5jdGlvbihiKXt2YXIgYz10aGlzO2lmKGNbYl0pe3ZhciBkPWEudG9vbHRpcHN0ZXIuX3BsdWdpbihiKTtkLmluc3RhbmNlJiZhLmVhY2goZC5pbnN0YW5jZSxmdW5jdGlvbihhLGQpe2NbYV0mJmNbYV0uYnJpZGdlZD09PWNbYl0mJmRlbGV0ZSBjW2FdfSksY1tiXS5fX2Rlc3Ryb3kmJmNbYl0uX19kZXN0cm95KCksZGVsZXRlIGNbYl19cmV0dXJuIGN9LGNsb3NlOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLl9fZGVzdHJveWVkP3RoaXMuX19kZXN0cm95RXJyb3IoKTp0aGlzLl9jbG9zZShudWxsLGEpLHRoaXN9LGNvbnRlbnQ6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztpZih2b2lkIDA9PT1hKXJldHVybiBiLl9fQ29udGVudDtpZihiLl9fZGVzdHJveWVkKWIuX19kZXN0cm95RXJyb3IoKTtlbHNlIGlmKGIuX19jb250ZW50U2V0KGEpLG51bGwhPT1iLl9fQ29udGVudCl7aWYoXCJjbG9zZWRcIiE9PWIuX19zdGF0ZSYmKGIuX19jb250ZW50SW5zZXJ0KCksYi5yZXBvc2l0aW9uKCksYi5fX29wdGlvbnMudXBkYXRlQW5pbWF0aW9uKSlpZihoLmhhc1RyYW5zaXRpb25zKXt2YXIgYz1iLl9fb3B0aW9ucy51cGRhdGVBbmltYXRpb247Yi5fJHRvb2x0aXAuYWRkQ2xhc3MoXCJ0b29sdGlwc3Rlci11cGRhdGUtXCIrYyksc2V0VGltZW91dChmdW5jdGlvbigpe1wiY2xvc2VkXCIhPWIuX19zdGF0ZSYmYi5fJHRvb2x0aXAucmVtb3ZlQ2xhc3MoXCJ0b29sdGlwc3Rlci11cGRhdGUtXCIrYyl9LDFlMyl9ZWxzZSBiLl8kdG9vbHRpcC5mYWRlVG8oMjAwLC41LGZ1bmN0aW9uKCl7XCJjbG9zZWRcIiE9Yi5fX3N0YXRlJiZiLl8kdG9vbHRpcC5mYWRlVG8oMjAwLDEpfSl9ZWxzZSBiLl9jbG9zZSgpO3JldHVybiBifSxkZXN0cm95OmZ1bmN0aW9uKCl7dmFyIGI9dGhpcztpZihiLl9fZGVzdHJveWVkKWIuX19kZXN0cm95RXJyb3IoKTtlbHNle1wiY2xvc2VkXCIhPWIuX19zdGF0ZT9iLm9wdGlvbihcImFuaW1hdGlvbkR1cmF0aW9uXCIsMCkuX2Nsb3NlKG51bGwsbnVsbCwhMCk6Yi5fX3RpbWVvdXRzQ2xlYXIoKSxiLl90cmlnZ2VyKFwiZGVzdHJveVwiKSxiLl9fZGVzdHJveWVkPSEwLGIuXyRvcmlnaW4ucmVtb3ZlRGF0YShiLl9fbmFtZXNwYWNlKS5vZmYoXCIuXCIrYi5fX25hbWVzcGFjZStcIi10cmlnZ2VyT3BlblwiKSxhKGgud2luZG93LmRvY3VtZW50LmJvZHkpLm9mZihcIi5cIitiLl9fbmFtZXNwYWNlK1wiLXRyaWdnZXJPcGVuXCIpO3ZhciBjPWIuXyRvcmlnaW4uZGF0YShcInRvb2x0aXBzdGVyLW5zXCIpO2lmKGMpaWYoMT09PWMubGVuZ3RoKXt2YXIgZD1udWxsO1wicHJldmlvdXNcIj09Yi5fX29wdGlvbnMucmVzdG9yYXRpb24/ZD1iLl8kb3JpZ2luLmRhdGEoXCJ0b29sdGlwc3Rlci1pbml0aWFsVGl0bGVcIik6XCJjdXJyZW50XCI9PWIuX19vcHRpb25zLnJlc3RvcmF0aW9uJiYoZD1cInN0cmluZ1wiPT10eXBlb2YgYi5fX0NvbnRlbnQ/Yi5fX0NvbnRlbnQ6YShcIjxkaXY+PC9kaXY+XCIpLmFwcGVuZChiLl9fQ29udGVudCkuaHRtbCgpKSxkJiZiLl8kb3JpZ2luLmF0dHIoXCJ0aXRsZVwiLGQpLGIuXyRvcmlnaW4ucmVtb3ZlQ2xhc3MoXCJ0b29sdGlwc3RlcmVkXCIpLGIuXyRvcmlnaW4ucmVtb3ZlRGF0YShcInRvb2x0aXBzdGVyLW5zXCIpLnJlbW92ZURhdGEoXCJ0b29sdGlwc3Rlci1pbml0aWFsVGl0bGVcIil9ZWxzZSBjPWEuZ3JlcChjLGZ1bmN0aW9uKGEsYyl7cmV0dXJuIGEhPT1iLl9fbmFtZXNwYWNlfSksYi5fJG9yaWdpbi5kYXRhKFwidG9vbHRpcHN0ZXItbnNcIixjKTtiLl90cmlnZ2VyKFwiZGVzdHJveWVkXCIpLGIuX29mZigpLGIub2ZmKCksYi5fX0NvbnRlbnQ9bnVsbCxiLl9fJGVtaXR0ZXJQcml2YXRlPW51bGwsYi5fXyRlbWl0dGVyUHVibGljPW51bGwsYi5fX29wdGlvbnMucGFyZW50PW51bGwsYi5fJG9yaWdpbj1udWxsLGIuXyR0b29sdGlwPW51bGwsYS50b29sdGlwc3Rlci5fX2luc3RhbmNlc0xhdGVzdEFycj1hLmdyZXAoYS50b29sdGlwc3Rlci5fX2luc3RhbmNlc0xhdGVzdEFycixmdW5jdGlvbihhLGMpe3JldHVybiBiIT09YX0pLGNsZWFySW50ZXJ2YWwoYi5fX2dhcmJhZ2VDb2xsZWN0b3IpfXJldHVybiBifSxkaXNhYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX19kZXN0cm95ZWQ/KHRoaXMuX19kZXN0cm95RXJyb3IoKSx0aGlzKToodGhpcy5fY2xvc2UoKSx0aGlzLl9fZW5hYmxlZD0hMSx0aGlzKX0sZWxlbWVudE9yaWdpbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9fZGVzdHJveWVkP3ZvaWQgdGhpcy5fX2Rlc3Ryb3lFcnJvcigpOnRoaXMuXyRvcmlnaW5bMF19LGVsZW1lbnRUb29sdGlwOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuXyR0b29sdGlwP3RoaXMuXyR0b29sdGlwWzBdOm51bGx9LGVuYWJsZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9fZW5hYmxlZD0hMCx0aGlzfSxoaWRlOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmNsb3NlKGEpfSxpbnN0YW5jZTpmdW5jdGlvbigpe3JldHVybiB0aGlzfSxvZmY6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fX2Rlc3Ryb3llZHx8dGhpcy5fXyRlbWl0dGVyUHVibGljLm9mZi5hcHBseSh0aGlzLl9fJGVtaXR0ZXJQdWJsaWMsQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cykpLHRoaXN9LG9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX19kZXN0cm95ZWQ/dGhpcy5fX2Rlc3Ryb3lFcnJvcigpOnRoaXMuX18kZW1pdHRlclB1YmxpYy5vbi5hcHBseSh0aGlzLl9fJGVtaXR0ZXJQdWJsaWMsQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cykpLHRoaXN9LG9uZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9fZGVzdHJveWVkP3RoaXMuX19kZXN0cm95RXJyb3IoKTp0aGlzLl9fJGVtaXR0ZXJQdWJsaWMub25lLmFwcGx5KHRoaXMuX18kZW1pdHRlclB1YmxpYyxBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzKSksdGhpc30sb3BlbjpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5fX2Rlc3Ryb3llZD90aGlzLl9fZGVzdHJveUVycm9yKCk6dGhpcy5fb3BlbihudWxsLGEpLHRoaXN9LG9wdGlvbjpmdW5jdGlvbihiLGMpe3JldHVybiB2b2lkIDA9PT1jP3RoaXMuX19vcHRpb25zW2JdOih0aGlzLl9fZGVzdHJveWVkP3RoaXMuX19kZXN0cm95RXJyb3IoKToodGhpcy5fX29wdGlvbnNbYl09Yyx0aGlzLl9fb3B0aW9uc0Zvcm1hdCgpLGEuaW5BcnJheShiLFtcInRyaWdnZXJcIixcInRyaWdnZXJDbG9zZVwiLFwidHJpZ2dlck9wZW5cIl0pPj0wJiZ0aGlzLl9fcHJlcGFyZU9yaWdpbigpLFwic2VsZkRlc3RydWN0aW9uXCI9PT1iJiZ0aGlzLl9fcHJlcGFyZUdDKCkpLHRoaXMpfSxyZXBvc2l0aW9uOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcztyZXR1cm4gYy5fX2Rlc3Ryb3llZD9jLl9fZGVzdHJveUVycm9yKCk6XCJjbG9zZWRcIiE9Yy5fX3N0YXRlJiZkKGMuXyRvcmlnaW4pJiYoYnx8ZChjLl8kdG9vbHRpcCkpJiYoYnx8Yy5fJHRvb2x0aXAuZGV0YWNoKCksYy5fX0dlb21ldHJ5PWMuX19nZW9tZXRyeSgpLGMuX3RyaWdnZXIoe3R5cGU6XCJyZXBvc2l0aW9uXCIsZXZlbnQ6YSxoZWxwZXI6e2dlbzpjLl9fR2VvbWV0cnl9fSkpLGN9LHNob3c6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMub3BlbihhKX0sc3RhdHVzOmZ1bmN0aW9uKCl7cmV0dXJue2Rlc3Ryb3llZDp0aGlzLl9fZGVzdHJveWVkLGVuYWJsZWQ6dGhpcy5fX2VuYWJsZWQsb3BlbjpcImNsb3NlZFwiIT09dGhpcy5fX3N0YXRlLHN0YXRlOnRoaXMuX19zdGF0ZX19LHRyaWdnZXJIYW5kbGVyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX19kZXN0cm95ZWQ/dGhpcy5fX2Rlc3Ryb3lFcnJvcigpOnRoaXMuX18kZW1pdHRlclB1YmxpYy50cmlnZ2VySGFuZGxlci5hcHBseSh0aGlzLl9fJGVtaXR0ZXJQdWJsaWMsQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cykpLHRoaXN9fSxhLmZuLnRvb2x0aXBzdGVyPWZ1bmN0aW9uKCl7dmFyIGI9QXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cyksYz1cIllvdSBhcmUgdXNpbmcgYSBzaW5nbGUgSFRNTCBlbGVtZW50IGFzIGNvbnRlbnQgZm9yIHNldmVyYWwgdG9vbHRpcHMuIFlvdSBwcm9iYWJseSB3YW50IHRvIHNldCB0aGUgY29udGVudENsb25pbmcgb3B0aW9uIHRvIFRSVUUuXCI7aWYoMD09PXRoaXMubGVuZ3RoKXJldHVybiB0aGlzO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBiWzBdKXt2YXIgZD1cIiMqJH4mXCI7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBlPWEodGhpcykuZGF0YShcInRvb2x0aXBzdGVyLW5zXCIpLGY9ZT9hKHRoaXMpLmRhdGEoZVswXSk6bnVsbDtpZighZil0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2FsbGVkIFRvb2x0aXBzdGVyJ3MgXFxcIlwiK2JbMF0rJ1wiIG1ldGhvZCBvbiBhbiB1bmluaXRpYWxpemVkIGVsZW1lbnQnKTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBmW2JbMF1dKXRocm93IG5ldyBFcnJvcignVW5rbm93biBtZXRob2QgXCInK2JbMF0rJ1wiJyk7dGhpcy5sZW5ndGg+MSYmXCJjb250ZW50XCI9PWJbMF0mJihiWzFdaW5zdGFuY2VvZiBhfHxcIm9iamVjdFwiPT10eXBlb2YgYlsxXSYmbnVsbCE9YlsxXSYmYlsxXS50YWdOYW1lKSYmIWYuX19vcHRpb25zLmNvbnRlbnRDbG9uaW5nJiZmLl9fb3B0aW9ucy5kZWJ1ZyYmY29uc29sZS5sb2coYyk7dmFyIGc9ZltiWzBdXShiWzFdLGJbMl0pO3JldHVybiBnIT09Znx8XCJpbnN0YW5jZVwiPT09YlswXT8oZD1nLCExKTp2b2lkIDB9KSxcIiMqJH4mXCIhPT1kP2Q6dGhpc31hLnRvb2x0aXBzdGVyLl9faW5zdGFuY2VzTGF0ZXN0QXJyPVtdO3ZhciBlPWJbMF0mJnZvaWQgMCE9PWJbMF0ubXVsdGlwbGUsZz1lJiZiWzBdLm11bHRpcGxlfHwhZSYmZi5tdWx0aXBsZSxoPWJbMF0mJnZvaWQgMCE9PWJbMF0uY29udGVudCxpPWgmJmJbMF0uY29udGVudHx8IWgmJmYuY29udGVudCxqPWJbMF0mJnZvaWQgMCE9PWJbMF0uY29udGVudENsb25pbmcsaz1qJiZiWzBdLmNvbnRlbnRDbG9uaW5nfHwhaiYmZi5jb250ZW50Q2xvbmluZyxsPWJbMF0mJnZvaWQgMCE9PWJbMF0uZGVidWcsbT1sJiZiWzBdLmRlYnVnfHwhbCYmZi5kZWJ1ZztyZXR1cm4gdGhpcy5sZW5ndGg+MSYmKGkgaW5zdGFuY2VvZiBhfHxcIm9iamVjdFwiPT10eXBlb2YgaSYmbnVsbCE9aSYmaS50YWdOYW1lKSYmIWsmJm0mJmNvbnNvbGUubG9nKGMpLHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBjPSExLGQ9YSh0aGlzKSxlPWQuZGF0YShcInRvb2x0aXBzdGVyLW5zXCIpLGY9bnVsbDtlP2c/Yz0hMDptJiYoY29uc29sZS5sb2coXCJUb29sdGlwc3Rlcjogb25lIG9yIG1vcmUgdG9vbHRpcHMgYXJlIGFscmVhZHkgYXR0YWNoZWQgdG8gdGhlIGVsZW1lbnQgYmVsb3cuIElnbm9yaW5nLlwiKSxjb25zb2xlLmxvZyh0aGlzKSk6Yz0hMCxjJiYoZj1uZXcgYS5Ub29sdGlwc3Rlcih0aGlzLGJbMF0pLGV8fChlPVtdKSxlLnB1c2goZi5fX25hbWVzcGFjZSksZC5kYXRhKFwidG9vbHRpcHN0ZXItbnNcIixlKSxkLmRhdGEoZi5fX25hbWVzcGFjZSxmKSxmLl9fb3B0aW9ucy5mdW5jdGlvbkluaXQmJmYuX19vcHRpb25zLmZ1bmN0aW9uSW5pdC5jYWxsKGYsZix7b3JpZ2luOnRoaXN9KSxmLl90cmlnZ2VyKFwiaW5pdFwiKSksYS50b29sdGlwc3Rlci5fX2luc3RhbmNlc0xhdGVzdEFyci5wdXNoKGYpfSksdGhpc30sYi5wcm90b3R5cGU9e19faW5pdDpmdW5jdGlvbihiKXt0aGlzLl9fJHRvb2x0aXA9Yix0aGlzLl9fJHRvb2x0aXAuY3NzKHtsZWZ0OjAsb3ZlcmZsb3c6XCJoaWRkZW5cIixwb3NpdGlvbjpcImFic29sdXRlXCIsdG9wOjB9KS5maW5kKFwiLnRvb2x0aXBzdGVyLWNvbnRlbnRcIikuY3NzKFwib3ZlcmZsb3dcIixcImF1dG9cIiksdGhpcy4kY29udGFpbmVyPWEoJzxkaXYgY2xhc3M9XCJ0b29sdGlwc3Rlci1ydWxlclwiPjwvZGl2PicpLmFwcGVuZCh0aGlzLl9fJHRvb2x0aXApLmFwcGVuZFRvKGgud2luZG93LmRvY3VtZW50LmJvZHkpfSxfX2ZvcmNlUmVkcmF3OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5fXyR0b29sdGlwLnBhcmVudCgpO3RoaXMuX18kdG9vbHRpcC5kZXRhY2goKSx0aGlzLl9fJHRvb2x0aXAuYXBwZW5kVG8oYSl9LGNvbnN0cmFpbjpmdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLmNvbnN0cmFpbnRzPXt3aWR0aDphLGhlaWdodDpifSx0aGlzLl9fJHRvb2x0aXAuY3NzKHtkaXNwbGF5OlwiYmxvY2tcIixoZWlnaHQ6XCJcIixvdmVyZmxvdzpcImF1dG9cIix3aWR0aDphfSksdGhpc30sZGVzdHJveTpmdW5jdGlvbigpe3RoaXMuX18kdG9vbHRpcC5kZXRhY2goKS5maW5kKFwiLnRvb2x0aXBzdGVyLWNvbnRlbnRcIikuY3NzKHtkaXNwbGF5OlwiXCIsb3ZlcmZsb3c6XCJcIn0pLHRoaXMuJGNvbnRhaW5lci5yZW1vdmUoKX0sZnJlZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cmFpbnRzPW51bGwsdGhpcy5fXyR0b29sdGlwLmNzcyh7ZGlzcGxheTpcIlwiLGhlaWdodDpcIlwiLG92ZXJmbG93OlwidmlzaWJsZVwiLHdpZHRoOlwiXCJ9KSx0aGlzfSxtZWFzdXJlOmZ1bmN0aW9uKCl7dGhpcy5fX2ZvcmNlUmVkcmF3KCk7dmFyIGE9dGhpcy5fXyR0b29sdGlwWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGI9e3NpemU6e2hlaWdodDphLmhlaWdodHx8YS5ib3R0b20tYS50b3Asd2lkdGg6YS53aWR0aHx8YS5yaWdodC1hLmxlZnR9fTtpZih0aGlzLmNvbnN0cmFpbnRzKXt2YXIgYz10aGlzLl9fJHRvb2x0aXAuZmluZChcIi50b29sdGlwc3Rlci1jb250ZW50XCIpLGQ9dGhpcy5fXyR0b29sdGlwLm91dGVySGVpZ2h0KCksZT1jWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGY9e2hlaWdodDpkPD10aGlzLmNvbnN0cmFpbnRzLmhlaWdodCx3aWR0aDphLndpZHRoPD10aGlzLmNvbnN0cmFpbnRzLndpZHRoJiZlLndpZHRoPj1jWzBdLnNjcm9sbFdpZHRoLTF9O2IuZml0cz1mLmhlaWdodCYmZi53aWR0aH1yZXR1cm4gaC5JRSYmaC5JRTw9MTEmJmIuc2l6ZS53aWR0aCE9PWgud2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCYmKGIuc2l6ZS53aWR0aD1NYXRoLmNlaWwoYi5zaXplLndpZHRoKSsxKSxifX07dmFyIGo9bmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpOy0xIT1qLmluZGV4T2YoXCJtc2llXCIpP2guSUU9cGFyc2VJbnQoai5zcGxpdChcIm1zaWVcIilbMV0pOi0xIT09ai50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJ0cmlkZW50XCIpJiYtMSE9PWouaW5kZXhPZihcIiBydjoxMVwiKT9oLklFPTExOi0xIT1qLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImVkZ2UvXCIpJiYoaC5JRT1wYXJzZUludChqLnRvTG93ZXJDYXNlKCkuc3BsaXQoXCJlZGdlL1wiKVsxXSkpO3ZhciBrPVwidG9vbHRpcHN0ZXIuc2lkZVRpcFwiO3JldHVybiBhLnRvb2x0aXBzdGVyLl9wbHVnaW4oe25hbWU6ayxpbnN0YW5jZTp7X19kZWZhdWx0czpmdW5jdGlvbigpe3JldHVybnthcnJvdzohMCxkaXN0YW5jZTo2LGZ1bmN0aW9uUG9zaXRpb246bnVsbCxtYXhXaWR0aDpudWxsLG1pbkludGVyc2VjdGlvbjoxNixtaW5XaWR0aDowLHBvc2l0aW9uOm51bGwsc2lkZTpcInRvcFwiLHZpZXdwb3J0QXdhcmU6ITB9fSxfX2luaXQ6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztiLl9faW5zdGFuY2U9YSxiLl9fbmFtZXNwYWNlPVwidG9vbHRpcHN0ZXItc2lkZVRpcC1cIitNYXRoLnJvdW5kKDFlNipNYXRoLnJhbmRvbSgpKSxiLl9fcHJldmlvdXNTdGF0ZT1cImNsb3NlZFwiLGIuX19vcHRpb25zLGIuX19vcHRpb25zRm9ybWF0KCksYi5fX2luc3RhbmNlLl9vbihcInN0YXRlLlwiK2IuX19uYW1lc3BhY2UsZnVuY3Rpb24oYSl7XCJjbG9zZWRcIj09YS5zdGF0ZT9iLl9fY2xvc2UoKTpcImFwcGVhcmluZ1wiPT1hLnN0YXRlJiZcImNsb3NlZFwiPT1iLl9fcHJldmlvdXNTdGF0ZSYmYi5fX2NyZWF0ZSgpLGIuX19wcmV2aW91c1N0YXRlPWEuc3RhdGV9KSxiLl9faW5zdGFuY2UuX29uKFwib3B0aW9ucy5cIitiLl9fbmFtZXNwYWNlLGZ1bmN0aW9uKCl7Yi5fX29wdGlvbnNGb3JtYXQoKX0pLGIuX19pbnN0YW5jZS5fb24oXCJyZXBvc2l0aW9uLlwiK2IuX19uYW1lc3BhY2UsZnVuY3Rpb24oYSl7Yi5fX3JlcG9zaXRpb24oYS5ldmVudCxhLmhlbHBlcil9KX0sX19jbG9zZTpmdW5jdGlvbigpe3RoaXMuX19pbnN0YW5jZS5jb250ZW50KClpbnN0YW5jZW9mIGEmJnRoaXMuX19pbnN0YW5jZS5jb250ZW50KCkuZGV0YWNoKCksdGhpcy5fX2luc3RhbmNlLl8kdG9vbHRpcC5yZW1vdmUoKSx0aGlzLl9faW5zdGFuY2UuXyR0b29sdGlwPW51bGx9LF9fY3JlYXRlOmZ1bmN0aW9uKCl7dmFyIGI9YSgnPGRpdiBjbGFzcz1cInRvb2x0aXBzdGVyLWJhc2UgdG9vbHRpcHN0ZXItc2lkZXRpcFwiPjxkaXYgY2xhc3M9XCJ0b29sdGlwc3Rlci1ib3hcIj48ZGl2IGNsYXNzPVwidG9vbHRpcHN0ZXItY29udGVudFwiPjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XCJ0b29sdGlwc3Rlci1hcnJvd1wiPjxkaXYgY2xhc3M9XCJ0b29sdGlwc3Rlci1hcnJvdy11bmNyb3BwZWRcIj48ZGl2IGNsYXNzPVwidG9vbHRpcHN0ZXItYXJyb3ctYm9yZGVyXCI+PC9kaXY+PGRpdiBjbGFzcz1cInRvb2x0aXBzdGVyLWFycm93LWJhY2tncm91bmRcIj48L2Rpdj48L2Rpdj48L2Rpdj48L2Rpdj4nKTt0aGlzLl9fb3B0aW9ucy5hcnJvd3x8Yi5maW5kKFwiLnRvb2x0aXBzdGVyLWJveFwiKS5jc3MoXCJtYXJnaW5cIiwwKS5lbmQoKS5maW5kKFwiLnRvb2x0aXBzdGVyLWFycm93XCIpLmhpZGUoKSx0aGlzLl9fb3B0aW9ucy5taW5XaWR0aCYmYi5jc3MoXCJtaW4td2lkdGhcIix0aGlzLl9fb3B0aW9ucy5taW5XaWR0aCtcInB4XCIpLHRoaXMuX19vcHRpb25zLm1heFdpZHRoJiZiLmNzcyhcIm1heC13aWR0aFwiLHRoaXMuX19vcHRpb25zLm1heFdpZHRoK1wicHhcIiksXG50aGlzLl9faW5zdGFuY2UuXyR0b29sdGlwPWIsdGhpcy5fX2luc3RhbmNlLl90cmlnZ2VyKFwiY3JlYXRlZFwiKX0sX19kZXN0cm95OmZ1bmN0aW9uKCl7dGhpcy5fX2luc3RhbmNlLl9vZmYoXCIuXCIrc2VsZi5fX25hbWVzcGFjZSl9LF9fb3B0aW9uc0Zvcm1hdDpmdW5jdGlvbigpe3ZhciBiPXRoaXM7aWYoYi5fX29wdGlvbnM9Yi5fX2luc3RhbmNlLl9vcHRpb25zRXh0cmFjdChrLGIuX19kZWZhdWx0cygpKSxiLl9fb3B0aW9ucy5wb3NpdGlvbiYmKGIuX19vcHRpb25zLnNpZGU9Yi5fX29wdGlvbnMucG9zaXRpb24pLFwib2JqZWN0XCIhPXR5cGVvZiBiLl9fb3B0aW9ucy5kaXN0YW5jZSYmKGIuX19vcHRpb25zLmRpc3RhbmNlPVtiLl9fb3B0aW9ucy5kaXN0YW5jZV0pLGIuX19vcHRpb25zLmRpc3RhbmNlLmxlbmd0aDw0JiYodm9pZCAwPT09Yi5fX29wdGlvbnMuZGlzdGFuY2VbMV0mJihiLl9fb3B0aW9ucy5kaXN0YW5jZVsxXT1iLl9fb3B0aW9ucy5kaXN0YW5jZVswXSksdm9pZCAwPT09Yi5fX29wdGlvbnMuZGlzdGFuY2VbMl0mJihiLl9fb3B0aW9ucy5kaXN0YW5jZVsyXT1iLl9fb3B0aW9ucy5kaXN0YW5jZVswXSksdm9pZCAwPT09Yi5fX29wdGlvbnMuZGlzdGFuY2VbM10mJihiLl9fb3B0aW9ucy5kaXN0YW5jZVszXT1iLl9fb3B0aW9ucy5kaXN0YW5jZVsxXSksYi5fX29wdGlvbnMuZGlzdGFuY2U9e3RvcDpiLl9fb3B0aW9ucy5kaXN0YW5jZVswXSxyaWdodDpiLl9fb3B0aW9ucy5kaXN0YW5jZVsxXSxib3R0b206Yi5fX29wdGlvbnMuZGlzdGFuY2VbMl0sbGVmdDpiLl9fb3B0aW9ucy5kaXN0YW5jZVszXX0pLFwic3RyaW5nXCI9PXR5cGVvZiBiLl9fb3B0aW9ucy5zaWRlKXt2YXIgYz17dG9wOlwiYm90dG9tXCIscmlnaHQ6XCJsZWZ0XCIsYm90dG9tOlwidG9wXCIsbGVmdDpcInJpZ2h0XCJ9O2IuX19vcHRpb25zLnNpZGU9W2IuX19vcHRpb25zLnNpZGUsY1tiLl9fb3B0aW9ucy5zaWRlXV0sXCJsZWZ0XCI9PWIuX19vcHRpb25zLnNpZGVbMF18fFwicmlnaHRcIj09Yi5fX29wdGlvbnMuc2lkZVswXT9iLl9fb3B0aW9ucy5zaWRlLnB1c2goXCJ0b3BcIixcImJvdHRvbVwiKTpiLl9fb3B0aW9ucy5zaWRlLnB1c2goXCJyaWdodFwiLFwibGVmdFwiKX02PT09YS50b29sdGlwc3Rlci5fZW52LklFJiZiLl9fb3B0aW9ucy5hcnJvdyE9PSEwJiYoYi5fX29wdGlvbnMuYXJyb3c9ITEpfSxfX3JlcG9zaXRpb246ZnVuY3Rpb24oYixjKXt2YXIgZCxlPXRoaXMsZj1lLl9fdGFyZ2V0RmluZChjKSxnPVtdO2UuX19pbnN0YW5jZS5fJHRvb2x0aXAuZGV0YWNoKCk7dmFyIGg9ZS5fX2luc3RhbmNlLl8kdG9vbHRpcC5jbG9uZSgpLGk9YS50b29sdGlwc3Rlci5fZ2V0UnVsZXIoaCksaj0hMSxrPWUuX19pbnN0YW5jZS5vcHRpb24oXCJhbmltYXRpb25cIik7c3dpdGNoKGsmJmgucmVtb3ZlQ2xhc3MoXCJ0b29sdGlwc3Rlci1cIitrKSxhLmVhY2goW1wid2luZG93XCIsXCJkb2N1bWVudFwiXSxmdW5jdGlvbihkLGspe3ZhciBsPW51bGw7aWYoZS5fX2luc3RhbmNlLl90cmlnZ2VyKHtjb250YWluZXI6ayxoZWxwZXI6YyxzYXRpc2ZpZWQ6aix0YWtlVGVzdDpmdW5jdGlvbihhKXtsPWF9LHJlc3VsdHM6Zyx0eXBlOlwicG9zaXRpb25UZXN0XCJ9KSwxPT1sfHwwIT1sJiYwPT1qJiYoXCJ3aW5kb3dcIiE9a3x8ZS5fX29wdGlvbnMudmlld3BvcnRBd2FyZSkpZm9yKHZhciBkPTA7ZDxlLl9fb3B0aW9ucy5zaWRlLmxlbmd0aDtkKyspe3ZhciBtPXtob3Jpem9udGFsOjAsdmVydGljYWw6MH0sbj1lLl9fb3B0aW9ucy5zaWRlW2RdO1widG9wXCI9PW58fFwiYm90dG9tXCI9PW4/bS52ZXJ0aWNhbD1lLl9fb3B0aW9ucy5kaXN0YW5jZVtuXTptLmhvcml6b250YWw9ZS5fX29wdGlvbnMuZGlzdGFuY2Vbbl0sZS5fX3NpZGVDaGFuZ2UoaCxuKSxhLmVhY2goW1wibmF0dXJhbFwiLFwiY29uc3RyYWluZWRcIl0sZnVuY3Rpb24oYSxkKXtpZihsPW51bGwsZS5fX2luc3RhbmNlLl90cmlnZ2VyKHtjb250YWluZXI6ayxldmVudDpiLGhlbHBlcjpjLG1vZGU6ZCxyZXN1bHRzOmcsc2F0aXNmaWVkOmosc2lkZTpuLHRha2VUZXN0OmZ1bmN0aW9uKGEpe2w9YX0sdHlwZTpcInBvc2l0aW9uVGVzdFwifSksMT09bHx8MCE9bCYmMD09ail7dmFyIGg9e2NvbnRhaW5lcjprLGRpc3RhbmNlOm0sZml0czpudWxsLG1vZGU6ZCxvdXRlclNpemU6bnVsbCxzaWRlOm4sc2l6ZTpudWxsLHRhcmdldDpmW25dLHdob2xlOm51bGx9LG89XCJuYXR1cmFsXCI9PWQ/aS5mcmVlKCk6aS5jb25zdHJhaW4oYy5nZW8uYXZhaWxhYmxlW2tdW25dLndpZHRoLW0uaG9yaXpvbnRhbCxjLmdlby5hdmFpbGFibGVba11bbl0uaGVpZ2h0LW0udmVydGljYWwpLHA9by5tZWFzdXJlKCk7aWYoaC5zaXplPXAuc2l6ZSxoLm91dGVyU2l6ZT17aGVpZ2h0OnAuc2l6ZS5oZWlnaHQrbS52ZXJ0aWNhbCx3aWR0aDpwLnNpemUud2lkdGgrbS5ob3Jpem9udGFsfSxcIm5hdHVyYWxcIj09ZD9jLmdlby5hdmFpbGFibGVba11bbl0ud2lkdGg+PWgub3V0ZXJTaXplLndpZHRoJiZjLmdlby5hdmFpbGFibGVba11bbl0uaGVpZ2h0Pj1oLm91dGVyU2l6ZS5oZWlnaHQ/aC5maXRzPSEwOmguZml0cz0hMTpoLmZpdHM9cC5maXRzLFwid2luZG93XCI9PWsmJihoLmZpdHM/XCJ0b3BcIj09bnx8XCJib3R0b21cIj09bj9oLndob2xlPWMuZ2VvLm9yaWdpbi53aW5kb3dPZmZzZXQucmlnaHQ+PWUuX19vcHRpb25zLm1pbkludGVyc2VjdGlvbiYmYy5nZW8ud2luZG93LnNpemUud2lkdGgtYy5nZW8ub3JpZ2luLndpbmRvd09mZnNldC5sZWZ0Pj1lLl9fb3B0aW9ucy5taW5JbnRlcnNlY3Rpb246aC53aG9sZT1jLmdlby5vcmlnaW4ud2luZG93T2Zmc2V0LmJvdHRvbT49ZS5fX29wdGlvbnMubWluSW50ZXJzZWN0aW9uJiZjLmdlby53aW5kb3cuc2l6ZS5oZWlnaHQtYy5nZW8ub3JpZ2luLndpbmRvd09mZnNldC50b3A+PWUuX19vcHRpb25zLm1pbkludGVyc2VjdGlvbjpoLndob2xlPSExKSxnLnB1c2goaCksaC53aG9sZSlqPSEwO2Vsc2UgaWYoXCJuYXR1cmFsXCI9PWgubW9kZSYmKGguZml0c3x8aC5zaXplLndpZHRoPD1jLmdlby5hdmFpbGFibGVba11bbl0ud2lkdGgpKXJldHVybiExfX0pfX0pLGUuX19pbnN0YW5jZS5fdHJpZ2dlcih7ZWRpdDpmdW5jdGlvbihhKXtnPWF9LGV2ZW50OmIsaGVscGVyOmMscmVzdWx0czpnLHR5cGU6XCJwb3NpdGlvblRlc3RlZFwifSksZy5zb3J0KGZ1bmN0aW9uKGEsYil7aWYoYS53aG9sZSYmIWIud2hvbGUpcmV0dXJuLTE7aWYoIWEud2hvbGUmJmIud2hvbGUpcmV0dXJuIDE7aWYoYS53aG9sZSYmYi53aG9sZSl7dmFyIGM9ZS5fX29wdGlvbnMuc2lkZS5pbmRleE9mKGEuc2lkZSksZD1lLl9fb3B0aW9ucy5zaWRlLmluZGV4T2YoYi5zaWRlKTtyZXR1cm4gZD5jPy0xOmM+ZD8xOlwibmF0dXJhbFwiPT1hLm1vZGU/LTE6MX1pZihhLmZpdHMmJiFiLmZpdHMpcmV0dXJuLTE7aWYoIWEuZml0cyYmYi5maXRzKXJldHVybiAxO2lmKGEuZml0cyYmYi5maXRzKXt2YXIgYz1lLl9fb3B0aW9ucy5zaWRlLmluZGV4T2YoYS5zaWRlKSxkPWUuX19vcHRpb25zLnNpZGUuaW5kZXhPZihiLnNpZGUpO3JldHVybiBkPmM/LTE6Yz5kPzE6XCJuYXR1cmFsXCI9PWEubW9kZT8tMToxfXJldHVyblwiZG9jdW1lbnRcIj09YS5jb250YWluZXImJlwiYm90dG9tXCI9PWEuc2lkZSYmXCJuYXR1cmFsXCI9PWEubW9kZT8tMToxfSksZD1nWzBdLGQuY29vcmQ9e30sZC5zaWRlKXtjYXNlXCJsZWZ0XCI6Y2FzZVwicmlnaHRcIjpkLmNvb3JkLnRvcD1NYXRoLmZsb29yKGQudGFyZ2V0LWQuc2l6ZS5oZWlnaHQvMik7YnJlYWs7Y2FzZVwiYm90dG9tXCI6Y2FzZVwidG9wXCI6ZC5jb29yZC5sZWZ0PU1hdGguZmxvb3IoZC50YXJnZXQtZC5zaXplLndpZHRoLzIpfXN3aXRjaChkLnNpZGUpe2Nhc2VcImxlZnRcIjpkLmNvb3JkLmxlZnQ9Yy5nZW8ub3JpZ2luLndpbmRvd09mZnNldC5sZWZ0LWQub3V0ZXJTaXplLndpZHRoO2JyZWFrO2Nhc2VcInJpZ2h0XCI6ZC5jb29yZC5sZWZ0PWMuZ2VvLm9yaWdpbi53aW5kb3dPZmZzZXQucmlnaHQrZC5kaXN0YW5jZS5ob3Jpem9udGFsO2JyZWFrO2Nhc2VcInRvcFwiOmQuY29vcmQudG9wPWMuZ2VvLm9yaWdpbi53aW5kb3dPZmZzZXQudG9wLWQub3V0ZXJTaXplLmhlaWdodDticmVhaztjYXNlXCJib3R0b21cIjpkLmNvb3JkLnRvcD1jLmdlby5vcmlnaW4ud2luZG93T2Zmc2V0LmJvdHRvbStkLmRpc3RhbmNlLnZlcnRpY2FsfVwid2luZG93XCI9PWQuY29udGFpbmVyP1widG9wXCI9PWQuc2lkZXx8XCJib3R0b21cIj09ZC5zaWRlP2QuY29vcmQubGVmdDwwP2MuZ2VvLm9yaWdpbi53aW5kb3dPZmZzZXQucmlnaHQtdGhpcy5fX29wdGlvbnMubWluSW50ZXJzZWN0aW9uPj0wP2QuY29vcmQubGVmdD0wOmQuY29vcmQubGVmdD1jLmdlby5vcmlnaW4ud2luZG93T2Zmc2V0LnJpZ2h0LXRoaXMuX19vcHRpb25zLm1pbkludGVyc2VjdGlvbi0xOmQuY29vcmQubGVmdD5jLmdlby53aW5kb3cuc2l6ZS53aWR0aC1kLnNpemUud2lkdGgmJihjLmdlby5vcmlnaW4ud2luZG93T2Zmc2V0LmxlZnQrdGhpcy5fX29wdGlvbnMubWluSW50ZXJzZWN0aW9uPD1jLmdlby53aW5kb3cuc2l6ZS53aWR0aD9kLmNvb3JkLmxlZnQ9Yy5nZW8ud2luZG93LnNpemUud2lkdGgtZC5zaXplLndpZHRoOmQuY29vcmQubGVmdD1jLmdlby5vcmlnaW4ud2luZG93T2Zmc2V0LmxlZnQrdGhpcy5fX29wdGlvbnMubWluSW50ZXJzZWN0aW9uKzEtZC5zaXplLndpZHRoKTpkLmNvb3JkLnRvcDwwP2MuZ2VvLm9yaWdpbi53aW5kb3dPZmZzZXQuYm90dG9tLXRoaXMuX19vcHRpb25zLm1pbkludGVyc2VjdGlvbj49MD9kLmNvb3JkLnRvcD0wOmQuY29vcmQudG9wPWMuZ2VvLm9yaWdpbi53aW5kb3dPZmZzZXQuYm90dG9tLXRoaXMuX19vcHRpb25zLm1pbkludGVyc2VjdGlvbi0xOmQuY29vcmQudG9wPmMuZ2VvLndpbmRvdy5zaXplLmhlaWdodC1kLnNpemUuaGVpZ2h0JiYoYy5nZW8ub3JpZ2luLndpbmRvd09mZnNldC50b3ArdGhpcy5fX29wdGlvbnMubWluSW50ZXJzZWN0aW9uPD1jLmdlby53aW5kb3cuc2l6ZS5oZWlnaHQ/ZC5jb29yZC50b3A9Yy5nZW8ud2luZG93LnNpemUuaGVpZ2h0LWQuc2l6ZS5oZWlnaHQ6ZC5jb29yZC50b3A9Yy5nZW8ub3JpZ2luLndpbmRvd09mZnNldC50b3ArdGhpcy5fX29wdGlvbnMubWluSW50ZXJzZWN0aW9uKzEtZC5zaXplLmhlaWdodCk6KGQuY29vcmQubGVmdD5jLmdlby53aW5kb3cuc2l6ZS53aWR0aC1kLnNpemUud2lkdGgmJihkLmNvb3JkLmxlZnQ9Yy5nZW8ud2luZG93LnNpemUud2lkdGgtZC5zaXplLndpZHRoKSxkLmNvb3JkLmxlZnQ8MCYmKGQuY29vcmQubGVmdD0wKSksZS5fX3NpZGVDaGFuZ2UoaCxkLnNpZGUpLGMudG9vbHRpcENsb25lPWhbMF0sYy50b29sdGlwUGFyZW50PWUuX19pbnN0YW5jZS5vcHRpb24oXCJwYXJlbnRcIikucGFyZW50WzBdLGMubW9kZT1kLm1vZGUsYy53aG9sZT1kLndob2xlLGMub3JpZ2luPWUuX19pbnN0YW5jZS5fJG9yaWdpblswXSxjLnRvb2x0aXA9ZS5fX2luc3RhbmNlLl8kdG9vbHRpcFswXSxkZWxldGUgZC5jb250YWluZXIsZGVsZXRlIGQuZml0cyxkZWxldGUgZC5tb2RlLGRlbGV0ZSBkLm91dGVyU2l6ZSxkZWxldGUgZC53aG9sZSxkLmRpc3RhbmNlPWQuZGlzdGFuY2UuaG9yaXpvbnRhbHx8ZC5kaXN0YW5jZS52ZXJ0aWNhbDt2YXIgbD1hLmV4dGVuZCghMCx7fSxkKTtpZihlLl9faW5zdGFuY2UuX3RyaWdnZXIoe2VkaXQ6ZnVuY3Rpb24oYSl7ZD1hfSxldmVudDpiLGhlbHBlcjpjLHBvc2l0aW9uOmwsdHlwZTpcInBvc2l0aW9uXCJ9KSxlLl9fb3B0aW9ucy5mdW5jdGlvblBvc2l0aW9uKXt2YXIgbT1lLl9fb3B0aW9ucy5mdW5jdGlvblBvc2l0aW9uLmNhbGwoZSxlLl9faW5zdGFuY2UsYyxsKTttJiYoZD1tKX1pLmRlc3Ryb3koKTt2YXIgbixvO1widG9wXCI9PWQuc2lkZXx8XCJib3R0b21cIj09ZC5zaWRlPyhuPXtwcm9wOlwibGVmdFwiLHZhbDpkLnRhcmdldC1kLmNvb3JkLmxlZnR9LG89ZC5zaXplLndpZHRoLXRoaXMuX19vcHRpb25zLm1pbkludGVyc2VjdGlvbik6KG49e3Byb3A6XCJ0b3BcIix2YWw6ZC50YXJnZXQtZC5jb29yZC50b3B9LG89ZC5zaXplLmhlaWdodC10aGlzLl9fb3B0aW9ucy5taW5JbnRlcnNlY3Rpb24pLG4udmFsPHRoaXMuX19vcHRpb25zLm1pbkludGVyc2VjdGlvbj9uLnZhbD10aGlzLl9fb3B0aW9ucy5taW5JbnRlcnNlY3Rpb246bi52YWw+byYmKG4udmFsPW8pO3ZhciBwO3A9Yy5nZW8ub3JpZ2luLmZpeGVkTGluZWFnZT9jLmdlby5vcmlnaW4ud2luZG93T2Zmc2V0OntsZWZ0OmMuZ2VvLm9yaWdpbi53aW5kb3dPZmZzZXQubGVmdCtjLmdlby53aW5kb3cuc2Nyb2xsLmxlZnQsdG9wOmMuZ2VvLm9yaWdpbi53aW5kb3dPZmZzZXQudG9wK2MuZ2VvLndpbmRvdy5zY3JvbGwudG9wfSxkLmNvb3JkPXtsZWZ0OnAubGVmdCsoZC5jb29yZC5sZWZ0LWMuZ2VvLm9yaWdpbi53aW5kb3dPZmZzZXQubGVmdCksdG9wOnAudG9wKyhkLmNvb3JkLnRvcC1jLmdlby5vcmlnaW4ud2luZG93T2Zmc2V0LnRvcCl9LGUuX19zaWRlQ2hhbmdlKGUuX19pbnN0YW5jZS5fJHRvb2x0aXAsZC5zaWRlKSxjLmdlby5vcmlnaW4uZml4ZWRMaW5lYWdlP2UuX19pbnN0YW5jZS5fJHRvb2x0aXAuY3NzKFwicG9zaXRpb25cIixcImZpeGVkXCIpOmUuX19pbnN0YW5jZS5fJHRvb2x0aXAuY3NzKFwicG9zaXRpb25cIixcIlwiKSxlLl9faW5zdGFuY2UuXyR0b29sdGlwLmNzcyh7bGVmdDpkLmNvb3JkLmxlZnQsdG9wOmQuY29vcmQudG9wLGhlaWdodDpkLnNpemUuaGVpZ2h0LHdpZHRoOmQuc2l6ZS53aWR0aH0pLmZpbmQoXCIudG9vbHRpcHN0ZXItYXJyb3dcIikuY3NzKHtsZWZ0OlwiXCIsdG9wOlwiXCJ9KS5jc3Mobi5wcm9wLG4udmFsKSxlLl9faW5zdGFuY2UuXyR0b29sdGlwLmFwcGVuZFRvKGUuX19pbnN0YW5jZS5vcHRpb24oXCJwYXJlbnRcIikpLGUuX19pbnN0YW5jZS5fdHJpZ2dlcih7dHlwZTpcInJlcG9zaXRpb25lZFwiLGV2ZW50OmIscG9zaXRpb246ZH0pfSxfX3NpZGVDaGFuZ2U6ZnVuY3Rpb24oYSxiKXthLnJlbW92ZUNsYXNzKFwidG9vbHRpcHN0ZXItYm90dG9tXCIpLnJlbW92ZUNsYXNzKFwidG9vbHRpcHN0ZXItbGVmdFwiKS5yZW1vdmVDbGFzcyhcInRvb2x0aXBzdGVyLXJpZ2h0XCIpLnJlbW92ZUNsYXNzKFwidG9vbHRpcHN0ZXItdG9wXCIpLmFkZENsYXNzKFwidG9vbHRpcHN0ZXItXCIrYil9LF9fdGFyZ2V0RmluZDpmdW5jdGlvbihhKXt2YXIgYj17fSxjPXRoaXMuX19pbnN0YW5jZS5fJG9yaWdpblswXS5nZXRDbGllbnRSZWN0cygpO2lmKGMubGVuZ3RoPjEpe3ZhciBkPXRoaXMuX19pbnN0YW5jZS5fJG9yaWdpbi5jc3MoXCJvcGFjaXR5XCIpOzE9PWQmJih0aGlzLl9faW5zdGFuY2UuXyRvcmlnaW4uY3NzKFwib3BhY2l0eVwiLC45OSksYz10aGlzLl9faW5zdGFuY2UuXyRvcmlnaW5bMF0uZ2V0Q2xpZW50UmVjdHMoKSx0aGlzLl9faW5zdGFuY2UuXyRvcmlnaW4uY3NzKFwib3BhY2l0eVwiLDEpKX1pZihjLmxlbmd0aDwyKWIudG9wPU1hdGguZmxvb3IoYS5nZW8ub3JpZ2luLndpbmRvd09mZnNldC5sZWZ0K2EuZ2VvLm9yaWdpbi5zaXplLndpZHRoLzIpLGIuYm90dG9tPWIudG9wLGIubGVmdD1NYXRoLmZsb29yKGEuZ2VvLm9yaWdpbi53aW5kb3dPZmZzZXQudG9wK2EuZ2VvLm9yaWdpbi5zaXplLmhlaWdodC8yKSxiLnJpZ2h0PWIubGVmdDtlbHNle3ZhciBlPWNbMF07Yi50b3A9TWF0aC5mbG9vcihlLmxlZnQrKGUucmlnaHQtZS5sZWZ0KS8yKSxlPWMubGVuZ3RoPjI/Y1tNYXRoLmNlaWwoYy5sZW5ndGgvMiktMV06Y1swXSxiLnJpZ2h0PU1hdGguZmxvb3IoZS50b3ArKGUuYm90dG9tLWUudG9wKS8yKSxlPWNbYy5sZW5ndGgtMV0sYi5ib3R0b209TWF0aC5mbG9vcihlLmxlZnQrKGUucmlnaHQtZS5sZWZ0KS8yKSxlPWMubGVuZ3RoPjI/Y1tNYXRoLmNlaWwoKGMubGVuZ3RoKzEpLzIpLTFdOmNbYy5sZW5ndGgtMV0sYi5sZWZ0PU1hdGguZmxvb3IoZS50b3ArKGUuYm90dG9tLWUudG9wKS8yKX1yZXR1cm4gYn19fSksYX0pOyIsImxldCAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5cbi8qKlxuICogQmFuZ3VtaSDliIfmjaLmqKHlnZdcbiAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXIgLSDmkq3mlL7lmajlr7nosaFcbiAqL1xubGV0IENoYW5nZUJhbmd1bWkgPSAocGxheWVyKSA9PiB7XG4gICAgbGV0IF9hdXRvUGxheSA9IGZhbHNlO1xuICAgIHdpbmRvdy51c2VINVBsYXllciA9IChpbmZvKSA9PiB7XG4gICAgICAgICQoJyNBQ0h0bWw1UGxheWVyX2xvYWRpbmdDb3ZlcicpLmNzcygnYmFja2dyb3VuZC1pbWFnZScsIGB1cmwoJHtpbmZvLmJhY2tncm91bmRVcmx9KWApO1xuICAgICAgICBsb2FkQmFuZ3VtaShpbmZvLnNvdXJjZUlkLCBfYXV0b1BsYXkpO1xuICAgICAgICBfYXV0b1BsYXkgPSBmYWxzZTtcbiAgICB9XG4gICAgc2V0TmV4dEJhbmd1bWkocGFnZUluZm8udmlkZW8udmlkZW9zWzBdLnZpZGVvSWQpO1xuXG4gICAgZnVuY3Rpb24gc2V0TmV4dEJhbmd1bWkoaWQpIHtcbiAgICAgICAgLy/liJvlu7rojrflj5bkuIvkuIDkuKrpg6jliIbnmoTmlrnms5VcbiAgICAgICAgaWYgKCQoYC5hYS1pbmZvID4gLmNvbnRhaW5lciA+IC5jb250IGxpW2RhdGEtdmlkPScke2lkfSddYCkubmV4dCgnbGknKS5sZW5ndGggPT09IDApIHBsYXllci5zZXRQbGF5TmV4dFBhcnRGdW4obnVsbCk7XG4gICAgICAgIGVsc2UgcGxheWVyLnNldFBsYXlOZXh0UGFydEZ1bigoKSA9PiB7XG4gICAgICAgICAgICAkKGAuYWEtaW5mbyA+IC5jb250YWluZXIgPiAuY29udCBsaVtkYXRhLXZpZD0nJHtpZH0nXWApLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICgkKHRoaXMpLnBhcmVudCgpLmhhc0NsYXNzKCdoaWRkZW4nKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgX2F1dG9QbGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLm5leHQoJ2xpJykuY2xpY2soKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZEJhbmd1bWkoaWQsIGF1dG9QbGF5KSB7XG4gICAgICAgIHBsYXllci5sb2FkKGlkLCBhdXRvUGxheSk7XG4gICAgICAgIHNldE5leHRCYW5ndW1pKGlkKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IENoYW5nZUJhbmd1bWkgfSIsImltcG9ydCB7IEhlbHBlciB9IGZyb20gJy4vbGliL2hlbHBlcidcbmxldCAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5cbi8qKlxuICog6Z2e5Yi35pawIFBhcnQg5YiH5o2i5qih5Z2XXG4gKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyIC0g5pKt5pS+5Zmo5a+56LGhXG4gKi9cbmxldCBDaGFuZ2VQYXJ0ID0gKHBsYXllcikgPT4ge1xuICAgIC8vdi5oYXBhbWUuY29tXG4gICAgJCgnLnBhcnQtd3JhcCA+IC5zY3JvbGwtZGl2ID4gYScpLmVhY2goKGluZGV4LCBlbGVtZW50KSA9PiB7XG4gICAgICAgICQoZWxlbWVudCkuYXR0cignZGF0YS1ocmVmJywgJChlbGVtZW50KS5hdHRyKCdocmVmJykpO1xuICAgICAgICAkKGVsZW1lbnQpLnJlbW92ZUF0dHIoJ2hyZWYnKTtcbiAgICAgICAgJChlbGVtZW50KS5hdHRyKCdkYXRhLWlkJywgcGFnZUluZm8udmlkZW9MaXN0W2luZGV4XS5pZCk7XG4gICAgfSk7XG4gICAgJCgnLnBhcnQtd3JhcCA+IC5zY3JvbGwtZGl2ID4gKicpLmNsaWNrKChlKSA9PiB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGxldCBsaW5rID0gJChlLnRhcmdldCk7XG4gICAgICAgIGxpbmsuc2libGluZ3MoKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgIGxpbmsuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICBpZiAobGluay5kYXRhKCdpZCcpID09PSBwYWdlSW5mby52aWRlb0lkKSByZXR1cm47XG4gICAgICAgIGhpc3RvcnkucHVzaFN0YXRlKG51bGwsIG51bGwsIGxpbmsuZGF0YSgnaHJlZicpKTtcbiAgICAgICAgZm9yIChsZXQgdmlkZW9JbmZvIG9mIHBhZ2VJbmZvLnZpZGVvTGlzdCkge1xuICAgICAgICAgICAgaWYgKHZpZGVvSW5mby5pZCA9PT0gbGluay5kYXRhKCdpZCcpKSB7XG4gICAgICAgICAgICAgICAgbG9hZFBhcnQodmlkZW9JbmZvLmluZGV4KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGdldE5leHRQYXJ0KCk7XG5cbiAgICBmdW5jdGlvbiBnZXROZXh0UGFydCgpIHtcbiAgICAgICAgLy/liJvlu7rojrflj5bkuIvkuIDkuKrpg6jliIbnmoTmlrnms5VcbiAgICAgICAgaWYgKHBhZ2VJbmZvLlAgKyAxICE9IHBhZ2VJbmZvLnZpZGVvTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBuZXR4UGFydCA9IHBhZ2VJbmZvLlAgKyAxO1xuICAgICAgICAgICAgcGxheWVyLnNldFBsYXlOZXh0UGFydEZ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgYWN0aXZlTGluayhuZXR4UGFydCk7XG4gICAgICAgICAgICAgICAgbG9hZFBhcnQobmV0eFBhcnQsIHRydWUpOyAvL+iHquWKqOaSreaUvlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGxheWVyLnNldFBsYXlOZXh0UGFydEZ1bihudWxsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhY3RpdmVMaW5rKGluZGV4KSB7XG4gICAgICAgIGxldCB2aWRlb0lkID0gcGFnZUluZm8udmlkZW9MaXN0W2luZGV4XS5pZDtcbiAgICAgICAgbGV0IGxpbmsgPSAkKGAucGFydC13cmFwID4gLnNjcm9sbC1kaXYgPiBbZGF0YS1pZD0nJHt2aWRlb0lkfSddYCk7XG4gICAgICAgIGlmIChsaW5rLmxlbmd0aCAhPSAxKSByZXR1cm47XG4gICAgICAgIGxpbmsuc2libGluZ3MoKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgIGxpbmsuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICBoaXN0b3J5LnB1c2hTdGF0ZShudWxsLCBudWxsLCBsaW5rLmRhdGEoJ2hyZWYnKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZFBhcnQoaW5kZXgsIGF1dG9wbGF5ID0gZmFsc2UpIHtcbiAgICAgICAgcGFnZUluZm8uUCA9IGluZGV4O1xuICAgICAgICBwYWdlSW5mby52aWRlb0lkID0gcGFnZUluZm8udmlkZW9MaXN0W2luZGV4XS5pZDtcbiAgICAgICAgcGxheWVyLmxvYWQocGFnZUluZm8udmlkZW9JZCwgYXV0b3BsYXkpO1xuICAgICAgICAvL+iOt+WPluaSreaUvumHj1xuICAgICAgICBnZXRQbGF5Q291bnQoKTtcbiAgICAgICAgZ2V0TmV4dFBhcnQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQbGF5Q291bnQoKSB7XG4gICAgICAgICQuZ2V0SlNPTihgaHR0cDovL3d3dy5hY2Z1bi5jbi9jb250ZW50X3ZpZXcuYXNweD9jb250ZW50SWQ9JHtwYWdlSW5mby5pZH1gLCAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAkKCcudmlldy5mbCA+IC5zcDInKS50ZXh0KEhlbHBlci5zZXBhcmF0ZU51bWJlcihyZXN1bHRbMF0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBDaGFuZ2VQYXJ0IH0iLCJpbXBvcnQgeyBQbGF5ZXIgfSBmcm9tICcuL2xpYi9wbGF5ZXInXG5pbXBvcnQgeyBMb2FkVUkgfSBmcm9tICcuL3VpJ1xuaW1wb3J0IHsgQ2hhbmdlUGFydCB9IGZyb20gJy4vUGFydCdcbmltcG9ydCB7IENoYW5nZUJhbmd1bWkgfSBmcm9tICcuL0Jhbmd1bWknXG5cbmxldCAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5cbndpbmRvdy5INVBsYXllciA9IHtcbiAgICByZXNpemU6ICgpID0+IHt9LFxuICAgIGlzU3VwcG9ydGVkOiAoKSA9PiB0cnVlXG59XG5cbiQoKCkgPT4ge1xuICAgIGxldCB2aWRlb0luZm8gPSB7XG4gICAgICAgIHZpZGVvSWQ6IHBhZ2VJbmZvLnZpZGVvSWQgPyBwYWdlSW5mby52aWRlb0lkIDogKGJnbUluZm8udmlkZW9JZCA/IGJnbUluZm8udmlkZW9JZCA6IHBhZ2VJbmZvLnZpZGVvLnZpZGVvc1swXS52aWRlb0lkKSxcbiAgICAgICAgY292ZXJJbWFnZTogcGFnZUluZm8uY292ZXJJbWFnZSA/IHBhZ2VJbmZvLmNvdmVySW1hZ2UgOiAoYmdtSW5mby5pbWFnZSA/IGJnbUluZm8uaW1hZ2UgOiBwYWdlSW5mby52aWRlby52aWRlb3NbMF0uaW1hZ2UpXG4gICAgfSAvL+inhumikeWfuuacrOS/oeaBr1xuXG4gICAgbGV0IHBsYXllciA9IG5ldyBQbGF5ZXIoJCgnI0FDSHRtbDVQbGF5ZXJfcGxheWVyID4gdmlkZW8nKVswXSwgJCgnI0FDSHRtbDVQbGF5ZXJfYnVsbGV0U2NyZWVucycpWzBdKTtcbiAgICBpZihwYWdlSW5mbyAmJiBwYWdlSW5mby52aWRlb0xpc3QgJiYgcGFnZUluZm8udmlkZW9MaXN0Lmxlbmd0aCA+IDEpIENoYW5nZVBhcnQocGxheWVyKTtcbiAgICBlbHNlIGlmKHBhZ2VJbmZvICYmIHBhZ2VJbmZvLmFsYnVtKSBDaGFuZ2VCYW5ndW1pKHBsYXllcik7XG4gICAgTG9hZFVJKHBsYXllciwgdmlkZW9JbmZvLmNvdmVySW1hZ2UpO1xuICAgIHBsYXllci5sb2FkKHZpZGVvSW5mby52aWRlb0lkLCBHZXRVcmxQYXJhbWV0ZXIoJ2F1dG9wbGF5JykgIT0gbnVsbCk7XG5cbiAgICAvL+iOt+WPliBVUkwg5Y+C5pWwXG4gICAgZnVuY3Rpb24gR2V0VXJsUGFyYW1ldGVyKHBhcmFtZXRlck5hbWUpIHtcbiAgICAgICAgbGV0IHVybCA9IGRvY3VtZW50LmxvY2F0aW9uLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBzcGxpdFVybCA9IHVybC5zcGxpdCgnIycpO1xuICAgICAgICBpZiAoc3BsaXRVcmwubGVuZ3RoID09PSAxKSByZXR1cm4gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgcGFyYW1ldGVyIG9mIHNwbGl0VXJsWzFdLnNwbGl0KCcmJykpIHtcbiAgICAgICAgICAgIGxldCBzcGxpdFBhcmFtZXRlciA9IHBhcmFtZXRlci5zcGxpdCgnPScpO1xuICAgICAgICAgICAgaWYgKHNwbGl0UGFyYW1ldGVyWzBdLnRvTG93ZXJDYXNlKCkgPT09IHBhcmFtZXRlck5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIGlmIChzcGxpdFBhcmFtZXRlci5sZW5ndGggPT0gMSkgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzcGxpdFBhcmFtZXRlclsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufSk7IiwibW9kdWxlLmV4cG9ydHM9W1xuICAgIFwifOKIgFwiLFxuICAgIFwiKMK0776f0JTvvp9gKVwiLFxuICAgIFwiKDvCtNCUYClcIixcbiAgICBcIig9776fz4nvvp8pPVwiLFxuICAgIFwifCDPieODu8K0KVwiLFxuICAgIFwifOKIgGAgKVwiLFxuICAgIFwiKOOBpNC04oqCKVwiLFxuICAgIFwiKO++n9CU776f4omh776f0JTvvp8pPyFcIixcbiAgICBcIih8fHzvvp/QlO++nylcIixcbiAgICBcIigg776f4oiA776fKVwiLFxuICAgIFwiKCrCtOKIgGApXCIsXG4gICAgXCIoKu++n+KIh+++nylcIixcbiAgICBcIijjgIDvvp8gM+++nylcIixcbiAgICBcIiggwrRf44KdYClcIixcbiAgICBcIijjg7viiIDjg7spXCIsXG4gICAgXCIo44Kd4oiA772lKVwiLFxuICAgIFwiKOOAg+KIgOOAgylcIixcbiAgICBcIigq776f4oiA776fKilcIixcbiAgICBcIigg776f4oiA44CCKVwiLFxuICAgIFwiz4Ng4oiAwrQpXCIsXG4gICAgXCLCoO++n+KIgO++nynPg1wiLFxuICAgIFwiKO+8ntC077ycKVwiLFxuICAgIFwiKHx8fO++n9C0776fKVwiLFxuICAgIFwiKCA7776f0LTvvp8pXCIsXG4gICAgXCIoPtC0PClcIixcbiAgICBcIu+9pe++nygg776J0LRg776fKVwiLFxuICAgIFwiKCBU0LRUKVwiLFxuICAgIFwiKO+/o+KIh++/oylcIixcbiAgICBcIijvv6Mz77+jKVwiLFxuICAgIFwiKO+/oyAuIO+/oylcIixcbiAgICBcIijvv6Poibjvv6MpXCIsXG4gICAgXCIoKsK0z4lgKilcIixcbiAgICBcIijCtOODu8+J44O7YClcIixcbiAgICBcIihv776fz4nvvp9vKVwiLFxuICAgIFwiKOODju++n+KIgO++nynjg45cIixcbiAgICBcInzQtO++nyApXCIsXG4gICAgXCLilIPpm7vmn7HilINcIixcbiAgICBcIuKKguW9oeKYhikp0LRgKVwiLFxuICAgIFwiKMK04oiAKCjimIbjg5/jgaRcIixcbiAgICBcIl8oOtC344CN4oigKV9cIixcbiAgICBcIijil4/igLLPiWDil48pwqBcIixcbiAgICBcIijvvaHjg7tgz4nCtO+9pSlcIixcbiAgICBcIijvv6LPie+/oilcIixcbiAgICBcIijjgI3jg7vPieODuynjgI1cIixcbiAgICBcIs6jKCDvv6PilqHvv6N8fClcIixcbiAgICBcIs6jKCDCsCDilrMgwrB8fHwpXCIsXG4gICAgXCIoKi/Pie+8vCopXCIsXG4gICAgXCIo772h44Kdz4nvvaXvvaEp44KeXCIsXG4gICAgXCIo44OO77yd0JTvvJ0p44OO4pS74pSB4pS7XCIsXG4gICAgXCLilK/ilIHilK/jg44oXFxcXCfvvI1cXFxcJ+ODjilcIixcbiAgICBcIig8O+OCnc+JwrfvvIl+4piGXCJcbl0iLCJpbXBvcnQgeyBFdmVudCB9IGZyb20gJy4vZXZlbnQnXG5jb25zdCBjb25maWcgPSB7XG4gICAgc2VydmVyVXJsOiAnd3M6Ly9kYW5tYWt1LmFjZnVuLmNuOjQ0MycsXG4gICAgY2xpZW50SWQ6ICcyYTNrMzc0ODEzNzU0NCcsXG4gICAgY2xpZW50SGFzaDogJzE0MzkwMTg3J1xufTtcblxuY2xhc3MgQUNXZWJTb2NrZXRDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKHVzZXJJZCwgdXNlcklkU0hBMSwgdWRpZCkge1xuICAgICAgICBsZXQgX2V2ZW50ID0gbmV3IEV2ZW50KCk7XG5cbiAgICAgICAgX2V2ZW50LmFkZCgnbG9hZGVycm9yJyk7XG4gICAgICAgIF9ldmVudC5hZGQoJ3N0YXR1c2NoYW5nZWQnKTtcbiAgICAgICAgX2V2ZW50LmFkZCgnb25saW5ldXNlcnNjb3VudGNoYW5nZWQnKTtcbiAgICAgICAgX2V2ZW50LmFkZCgnbmV3YnVsbGV0c2NyZWVucmVjZWl2ZWQnKTtcblxuICAgICAgICB0aGlzLmJpbmQgPSBfZXZlbnQuYmluZDtcbiAgICAgICAgdGhpcy51bmJpbmQgPSBfZXZlbnQudW5iaW5kO1xuICAgICAgICBsZXQgY2xvc2UgPSBmYWxzZTtcbiAgICAgICAgbGV0IF9zdGF0dXMgPSAncmVhZHknO1xuICAgICAgICBsZXQgX3NvY2tldDtcbiAgICAgICAgdGhpcy5jb25uZWN0ID0gZnVuY3Rpb24gKHZpZGVvSWQsIGR1cmF0aW9uKSB7XG4gICAgICAgICAgICBjaGFuZ2VTdGF0dXMoJ2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgICAgIGlmIChfc29ja2V0ID09IG51bGwpXG4gICAgICAgICAgICAgICAgX3NvY2tldCA9IG5ldyBXZWJTb2NrZXQoYCR7Y29uZmlnLnNlcnZlclVybH0vJHt2aWRlb0lkfWApO1xuICAgICAgICAgICAgX3NvY2tldC5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZVN0YXR1cygnY2xvc2VkJyk7XG4gICAgICAgICAgICAgICAgX3NvY2tldCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVDb25uZWN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVDb25uZWN0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVN0YXR1cygncmVjb25uZWN0aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuY29ubmVjdCwgNTAwMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3NvY2tldC5vbmVycm9yID0gKGUpID0+IHRyaWdnZXJMb2FkZXJyb3JFdmVudCgnQ09OTkVDVEVEX0VSUk9SJyksXG4gICAgICAgICAgICAgICAgX3NvY2tldC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXRhID0gSlNPTi5wYXJzZShldnQuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGRhdGEuc3RhdHVzKSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhcnNlSW50KGRhdGEuc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3N0YXR1cyA9PSBcImF1dGhlbnRpY2F0ZWluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9IEpTT04ucGFyc2UoZGF0YS5tc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaWRlbnRpZmllZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVN0YXR1cyhcImNvbm5lY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVN0YXR1cyhcImNvbm5lY3RlZF9kaXNhYmxlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VTdGF0dXMoXCJjb25uZWN0ZWRfbm90SWRlbnRpZmllZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDYwMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2V2ZW50LnRyaWdnZXIoJ29ubGluZXVzZXJzY291bnRjaGFuZ2VkJywgeyBvbmxpbmVVc2Vyc0NvdW50OiBwYXJzZUludChkYXRhLm1zZykgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YS5hY3Rpb24gPT09ICdwb3N0JykgX2V2ZW50LnRyaWdnZXIoJ25ld2J1bGxldHNjcmVlbnJlY2VpdmVkJywgeyBidWxsZXRTY3JlZW5EYXRhOiBKU09OLnBhcnNlKGRhdGEuY29tbWFuZCkgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9zb2NrZXQub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZVN0YXR1cygnYXV0aGVudGljYXRlaW5nJyk7XG4gICAgICAgICAgICAgICAgbGV0IGF1dGhJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICBjbGllbnQ6IGNvbmZpZy5jbGllbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50X2NrOiBjb25maWcuY2xpZW50SGFzaCxcbiAgICAgICAgICAgICAgICAgICAgdmlkOiB2aWRlb0lkLFxuICAgICAgICAgICAgICAgICAgICB2bGVuZ3RoOiBkdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdGltZTogbmV3IERhdGUoKS5nZXRUaW1lKCksXG4gICAgICAgICAgICAgICAgICAgIHVpZDogdXNlcklkLFxuICAgICAgICAgICAgICAgICAgICB1aWRfY2s6IHVzZXJJZFNIQTFcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNlbmRNZXNzYW5lKG51bGwsICdhdXRoJywgbnVsbCwgSlNPTi5zdHJpbmdpZnkoYXV0aEluZm8pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjaGFuZ2VTdGF0dXMoJ2Nsb3NlaW5nJyk7XG4gICAgICAgICAgICBpZiAoX3NvY2tldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2xvc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF9zb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRTdGF0dXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N0YXR1cztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZWZyZXNoT25saW5lVXNlcnNDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghZ2V0SXNDb25uZWN0ZWQoKSkgcmV0dXJuO1xuICAgICAgICAgICAgc2VuZE1lc3NhbmUobnVsbCwgJ29ubGFuTnVtYmVyJywgbnVsbCwgJ1dBTExFIERPRVMgTk9UIEhBVkUgUEVOTklTJyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VuZGJ1bGxldFNjcmVlbiA9IGZ1bmN0aW9uIChzdGltZSwgbW9kZSwgdGltZSwgY29sb3IsIG1lc3NhZ2UsIHNpemUpIHtcbiAgICAgICAgICAgIGlmICghZ2V0SXNDb25uZWN0ZWQoKSkgcmV0dXJuO1xuICAgICAgICAgICAgc2VuZE1lc3NhbmUoJ3dlYicsICdwb3N0JywgdWRpZCwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHVzZXI6IHVzZXJJZCxcbiAgICAgICAgICAgICAgICBzdGltZTogTWF0aC5yb3VuZChzdGltZSkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBtb2RlOiBtb2RlLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgdGltZTogdGltZS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIGlzbG9jazogJzInLFxuICAgICAgICAgICAgICAgIHNpemU6IHNpemUudG9TdHJpbmcoKVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldElzQ29ubmVjdGVkID0gZ2V0SXNDb25uZWN0ZWQ7XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0SXNDb25uZWN0ZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N0YXR1cyA9PT0gJ2Nvbm5lY3RlZCcgfHwgX3N0YXR1cyA9PT0gJ2Nvbm5lY3RlZF9kaXNhYmxlZCcgfHwgX3N0YXR1cyA9PT0gJ2Nvbm5lY3RlZF9ub3RJZGVudGlmaWVkJztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNlbmRNZXNzYW5lKHBsYXRmb3JtLCBhY3Rob24sIHVkaWQsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmIChfc29ja2V0ID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKF9zb2NrZXQucmVhZHlTdGF0ZSAhPSAxKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCBkYXRhID0ge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogYWN0aG9uLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IG1lc3NhZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBsYXRmb3JtID09PSAnc3RyaW5nJykgZGF0YS5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB1ZGlkID09PSAnc3RyaW5nJykgZGF0YS51ZGlkID0gdWRpZDtcbiAgICAgICAgICAgIF9zb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjaGFuZ2VTdGF0dXMobmV3U3RhdHVzKSB7XG4gICAgICAgICAgICBsZXQgb2xkU3RhdHVzID0gX3N0YXR1cztcbiAgICAgICAgICAgIF9zdGF0dXMgPSBuZXdTdGF0dXM7XG4gICAgICAgICAgICBfZXZlbnQudHJpZ2dlcignc3RhdHVzY2hhbmdlZCcsIHtcbiAgICAgICAgICAgICAgICBvbGRTdGF0dXM6IG9sZFN0YXR1cyxcbiAgICAgICAgICAgICAgICBuZXdTdGF0dXM6IG5ld1N0YXR1c1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHRyaWdnZXJMb2FkZXJyb3JFdmVudCh0eXBlKSB7XG4gICAgICAgICAgICBfZXZlbnQudHJpZ2dlcignbG9hZGVycm9yJywge1xuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogUmVzb3VyY2VzW2BXRUJTT0NLRVRDT05ORUNUXyR7dHlwZX1gXS50b1N0cmluZygpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgQUNXZWJTb2NrZXRDbGllbnQgfSIsImltcG9ydCB7IEV2ZW50IH0gZnJvbSAnLi4vZXZlbnQnXG5pbXBvcnQgeyBSZXNvdXJjZXMgfSBmcm9tICcuLi9yZXNvdXJjZXMnXG5sZXQgSGxzID0gcmVxdWlyZSgnaGxzLmpzJyk7XG5sZXQgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuXG5jbGFzcyBBY0Z1blZpZGVvQWRhcHRlciB7XG4gICAgY29uc3RydWN0b3IodmlkZW9FbGVtZW50KSB7XG4gICAgICAgIGxldCBfaGxzO1xuICAgICAgICBsZXQgX3ZpZGVvRGF0YTtcbiAgICAgICAgbGV0IF9sb2FkZWQgPSAwO1xuICAgICAgICBsZXQgX2V2ZW50ID0gbmV3IEV2ZW50KCk7XG4gICAgICAgIF9ldmVudC5hZGQoJ2xvYWRzdWNjZXNzJyk7XG4gICAgICAgIF9ldmVudC5hZGQoJ3ZpZGVvbG9hZHN1Y2Nlc3MnKTtcbiAgICAgICAgX2V2ZW50LmFkZCgnbG9hZGVycm9yJyk7XG4gICAgICAgIF9ldmVudC5hZGQoJ2Rlc3Ryb3knKTtcbiAgICAgICAgX2V2ZW50LmFkZCgncXVhbGl0eXN3aXRjaGluZycpO1xuICAgICAgICBfZXZlbnQuYWRkKCdxdWFsaXR5c3dpdGNoZWQnKTtcblxuICAgICAgICB0aGlzLmJpbmQgPSBfZXZlbnQuYmluZDtcbiAgICAgICAgdGhpcy51bmJpbmQgPSBfZXZlbnQudW5iaW5kO1xuXG4gICAgICAgIC8v6Kej5a+G5L+h5oGvXG4gICAgICAgIGxldCBjb25maWcgPSB7XG4gICAgICAgICAgICBlazoge1xuICAgICAgICAgICAgICAgIGExOiAnYmYnLFxuICAgICAgICAgICAgICAgIGE4OiAnZicsXG4gICAgICAgICAgICAgICAgeDI6ICdLejBtb29aTSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtazoge1xuICAgICAgICAgICAgICAgIGEzOiAnMXo0aScsXG4gICAgICAgICAgICAgICAgYTQ6ICc4NnJ2JyxcbiAgICAgICAgICAgICAgICBhNTogJ2Y0NScsXG4gICAgICAgICAgICAgICAgazM6ICdiNycsXG4gICAgICAgICAgICAgICAgbms6ICdtMXVOOUc2YydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjdHlwZTogJzg2JyxcbiAgICAgICAgICAgIGV2OiA0XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGVjb2RlNjQoYSkge1xuICAgICAgICAgICAgaWYgKCFhKSByZXR1cm4gJyc7XG4gICAgICAgICAgICBhID0gYS50b1N0cmluZygpO1xuICAgICAgICAgICAgdmFyIGIsIGMsIGQsIGUsIGYsIGcsIGgsXG4gICAgICAgICAgICAgICAgaSA9IG5ldyBBcnJheSgtIDEsIC0gMSwgLSAxLCAtIDEsIC0gMSwgLSAxLCAtIDEsIC0gMSwgLSAxLCAtIDEsIC0gMSwgLSAxLCAtIDEsIC0gMSwgLSAxLCAtIDEsIC0gMSwgLSAxLCAtIDEsIC0gMSwgLSAxLCAtIDEsIC0gMSwgLSAxLCAtIDEsIC0gMSwgLSAxLCAtIDEsIC0gMSwgLSAxLCAtIDEsIC0gMSwgLSAxLCAtIDEsIC0gMSwgLSAxLCAtIDEsIC0gMSwgLSAxLCAtIDEsIC0gMSwgLSAxLCAtIDEsIDYyLCAtIDEsIC0gMSwgLSAxLCA2MywgNTIsIDUzLCA1NCwgNTUsIDU2LCA1NywgNTgsIDU5LCA2MCwgNjEsIC0gMSwgLSAxLCAtIDEsIC0gMSwgLSAxLCAtIDEsIC0gMSwgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzLCAyNCwgMjUsIC0gMSwgLSAxLCAtIDEsIC0gMSwgLSAxLCAtIDEsIDI2LCAyNywgMjgsIDI5LCAzMCwgMzEsIDMyLCAzMywgMzQsIDM1LCAzNiwgMzcsIDM4LCAzOSwgNDAsIDQxLCA0MiwgNDMsIDQ0LCA0NSwgNDYsIDQ3LCA0OCwgNDksIDUwLCA1MSwgLSAxLCAtIDEsIC0gMSwgLSAxLCAtIDEpO1xuICAgICAgICAgICAgZm9yIChnID0gYS5sZW5ndGgsIGYgPSAwLCBoID0gJyc7IGYgPCBnOykge1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgYiA9IGlbMjU1ICYgYS5jaGFyQ29kZUF0KGYrKyldXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoZiA8IGcgJiYgLSAxID09IGIpO1xuICAgICAgICAgICAgICAgIGlmICgtIDEgPT0gYikgYnJlYWs7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBjID0gaVsyNTUgJiBhLmNoYXJDb2RlQXQoZisrKV1cbiAgICAgICAgICAgICAgICB9IHdoaWxlIChmIDwgZyAmJiAtIDEgPT0gYyk7XG4gICAgICAgICAgICAgICAgaWYgKC0gMSA9PSBjKSBicmVhaztcbiAgICAgICAgICAgICAgICBoICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYiA8PCAyIHwgKDQ4ICYgYykgPj4gNCk7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoNjEgPT0gKGQgPSAyNTUgJiBhLmNoYXJDb2RlQXQoZisrKSkpIHJldHVybiBoO1xuICAgICAgICAgICAgICAgICAgICBkID0gaVtkXVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGYgPCBnICYmIC0gMSA9PSBkKTtcbiAgICAgICAgICAgICAgICBpZiAoLSAxID09IGQpIGJyZWFrO1xuICAgICAgICAgICAgICAgIGggKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoMTUgJiBjKSA8PCA0IHwgKDYwICYgZCkgPj4gMik7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoNjEgPT0gKGUgPSAyNTUgJiBhLmNoYXJDb2RlQXQoZisrKSkpIHJldHVybiBoO1xuICAgICAgICAgICAgICAgICAgICBlID0gaVtlXVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGYgPCBnICYmIC0gMSA9PSBlKTtcbiAgICAgICAgICAgICAgICBpZiAoLSAxID09IGUpIGJyZWFrO1xuICAgICAgICAgICAgICAgIGggKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoMyAmIGQpIDw8IDYgfCBlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBqaWUoYSwgYikge1xuICAgICAgICAgICAgZm9yICh2YXIgYywgZCA9IFtcbiAgICAgICAgICAgIF0sIGUgPSAwLCBmID0gJycsIGcgPSAwOyBnIDwgMjU2OyBnKyspIGRbZ10gPSBnO1xuICAgICAgICAgICAgZm9yIChnID0gMDsgZyA8IDI1NjsgZysrKSBlID0gKGUgKyBkW2ddICsgYS5jaGFyQ29kZUF0KGcgJSBhLmxlbmd0aCkpICUgMjU2LFxuICAgICAgICAgICAgICAgIGMgPSBkW2ddLFxuICAgICAgICAgICAgICAgIGRbZ10gPSBkW2VdLFxuICAgICAgICAgICAgICAgIGRbZV0gPSBjO1xuICAgICAgICAgICAgZyA9IDAsXG4gICAgICAgICAgICAgICAgZSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBoID0gMDsgaCA8IGIubGVuZ3RoOyBoKyspIGcgPSAoZyArIDEpICUgMjU2LFxuICAgICAgICAgICAgICAgIGUgPSAoZSArIGRbZ10pICUgMjU2LFxuICAgICAgICAgICAgICAgIGMgPSBkW2ddLFxuICAgICAgICAgICAgICAgIGRbZ10gPSBkW2VdLFxuICAgICAgICAgICAgICAgIGRbZV0gPSBjLFxuICAgICAgICAgICAgICAgIGYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiLmNoYXJDb2RlQXQoaCkgXiBkWyhkW2ddICsgZFtlXSkgJSAyNTZdKTtcbiAgICAgICAgICAgIHJldHVybiBmXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yqg6L296YCC6YWN5ZmoXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2aWRlb0lkIC0g6KeG6aKR57yW5Y+3XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxvYWQgPSAodmlkZW9JZCwgcXVhbGl0eUluZGV4ID0gLTEpID0+IHtcbiAgICAgICAgICAgIGlmIChfbG9hZGVkID09PSAxKSB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIGxldCBsb2FkSGxzID0gKHN1Y2Nlc3MpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgaGxzID0gbmV3IEhscyh7XG4gICAgICAgICAgICAgICAgICAgIHhoclNldHVwOiAoeGhyLCB1cmwpID0+IHsgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7IH0sIC8vIOi3qOWfn+ivt+axgu+8jOmZhOWKoCBDb29raWXvvIzlkKbliJnov5Tlm540MDNcbiAgICAgICAgICAgICAgICAgICAgZGVidWc6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBiaW5kIHRoZW0gdG9nZXRoZXJcbiAgICAgICAgICAgICAgICBobHMuYXR0YWNoTWVkaWEodmlkZW9FbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIGhscy5vbihIbHMuRXZlbnRzLkxFVkVMX1NXSVRDSElORywgKGV2ZW50LCBkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIF9ldmVudC50cmlnZ2VyKCdxdWFsaXR5c3dpdGNoaW5nJywge3F1YWxpdHlJbmRleDogZ2V0UXVhbGl0eUluZGV4QnlITFNRdWFsaXR5SW5kZXgoZGF0YS5sZXZlbCl9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGhscy5vbihIbHMuRXZlbnRzLkxFVkVMX1NXSVRDSEVELCAoZXZlbnQsIGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgX2V2ZW50LnRyaWdnZXIoJ3F1YWxpdHlzd2l0Y2hlZCcsIHtxdWFsaXR5SW5kZXg6IGdldFF1YWxpdHlJbmRleEJ5SExTUXVhbGl0eUluZGV4KGRhdGEubGV2ZWwpfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBobHMub24oSGxzLkV2ZW50cy5FUlJPUiwgKGV2ZW50LCBkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoUmVzb3VyY2VzLlZJREVPTE9BRF9ITFNfRVJST1IuZmlsbERhdGEoeyBjb2RlOiBkYXRhLmRldGFpbHMgfSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEhscy5FcnJvclR5cGVzLk5FVFdPUktfRVJST1I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0byByZWNvdmVyIG5ldHdvcmsgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFJlc291cmNlcy5WSURFT0xPQURfSExTX05FVFdPUktfRVJST1IudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhscy5zdGFydExvYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBIbHMuRXJyb3JUeXBlcy5NRURJQV9FUlJPUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFJlc291cmNlcy5WSURFT0xPQURfSExTX01FRElBX0VSUk9SLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBobHMucmVjb3Zlck1lZGlhRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2Fubm90IHJlY292ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGxzLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckxvYWRlcnJvckV2ZW50KCdITFNfT1RIRVJfRVJST1InKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBobHMub24oSGxzLkV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgKCkgPT4gc3VjY2VzcyhobHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBnZXRWaWRlb0RhdGEgPSAoc3VjY2VzcywgZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnR0VUJywgdXJsOiBgaHR0cDovL2FwaS5haXhpZmFuLmNvbS9wbGF5cy95b3VrdS8ke3ZpZGVvSWR9YCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlVHlwZTogMlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdHRVQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ2h0dHA6Ly9wbGF5ZXIuYWNmdW4uY24vanNfZGF0YScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29ucCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduOiByZXN1bHQuZGF0YS5lbWJzaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZDogcmVzdWx0LmRhdGEuc291cmNlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0OiBjb25maWcuY3R5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2OiBjb25maWcuZXZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lbmNyeXB0ID0gJzEnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmRhdGEgPSBKU09OLnBhcnNlKGppZShjb25maWcubWsubmsgKyBjb25maWcuZWsueDIsIGRlY29kZTY0KHJlc3VsdC5kYXRhKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKHJlc3VsdC5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxvYWRWaWRlbyA9IChzdWNjZXNzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHF1YWxpdHlJbmRleCA+PSAwKSBfaGxzLmxvYWRMZXZlbCA9IF9obHMuc3RhcnRMZXZlbCA9IGdldFF1YWxpdHlJbmRleEJ5SExTUXVhbGl0eUluZGV4KHF1YWxpdHlJbmRleCk7XG4gICAgICAgICAgICAgICAgLy/liqDovb3op4bpopFcbiAgICAgICAgICAgICAgICBfaGxzLmxvYWRTb3VyY2UoY3JlYXRlTTNVOExpc3RGaWxlKF92aWRlb0RhdGEuc3RyZWFtKSk7XG4gICAgICAgICAgICAgICAgX2hscy5vbihIbHMuRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgZnVuY3Rpb24gKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvYWRIbHMoKGhscykgPT4ge1xuICAgICAgICAgICAgICAgIF9obHMgPSBobHM7XG4gICAgICAgICAgICAgICAgZ2V0VmlkZW9EYXRhKCh2aWRlb0RhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgX3ZpZGVvRGF0YSA9IHZpZGVvRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgbG9hZFZpZGVvKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sb2FkZWQgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2V2ZW50LnRyaWdnZXIoJ2xvYWRzdWNjZXNzJywge30pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJMb2FkZXJyb3JFdmVudCgnR0VUX0RBVEFfRkFJTEVEJyk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICog5Y246L296KeG6aKRXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoX2xvYWRlZCAhPSAxKSB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIF9sb2FkZWQgPSAwO1xuICAgICAgICAgICAgX2hscy5kZXN0cm95KCk7XG4gICAgICAgICAgICBfZXZlbnQudHJpZ2dlcignZGVzdHJveScsIHt9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5blvZPliY3op4bpopHmuIXmmbDluqZcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn0g6KeG6aKR5riF5pmw5bqm57Si5byVXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFF1YWxpdHlJbmRleCA9ICgpID0+IGdldFF1YWxpdHlJbmRleEJ5SExTUXVhbGl0eUluZGV4KF9obHMuY3VycmVudExldmVsKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W5piv5ZCm5ZCv55So5LqG6Ieq5Yqo6LSo6YeP6YCJ5oupXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldEF1dG9RdWFsaXR5RW5hYmxlZCA9ICgpID0+IF9obHMuYXV0b0xldmVsRW5hYmxlZDtcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W6KeG6aKR5riF5pmw5bqm5YiX6KGoXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IOinhumikea4heaZsOW6pue0ouW8leWIl+ihqO+8iOS7jui0qOmHj+W3ruWIsOi0qOmHj+WlveaOkuW6j++8iVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRRdWFsaXR5SW5kZXhMaXN0ID0gZ2V0UXVhbGl0eUluZGV4TGlzdDtcblxuICAgICAgICAvKipcbiAgICAgICAgICog5YiH5o2i6KeG6aKR6LSo6YePXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldFF1YWxpdHlJbmRleCA9IChxdWFsaXR5SW5kZXgpID0+IHtcbiAgICAgICAgICAgIF9obHMubmV4dExldmVsID0gZ2V0SExTUXVhbGl0eUluZGV4QnlRdWFsaXR5SW5kZXgocXVhbGl0eUluZGV4KTtcbiAgICAgICAgICAgIF9obHMuc3RhcnRMb2FkKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPluWKoOi9veeKtuaAgVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRMb2FkZWRTdGF0ZSA9ICgpID0+IF9sb2FkZWQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIm+W7um0zdTjmlofku7ZcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHN0cmVhbSAtIOa1geS/oeaBr1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlTTNVOExpc3RGaWxlKHN0cmVhbSkge1xuICAgICAgICAgICAgbGV0IG0zdTggPSBbJyNFWFRNM1VcXG4jRVhULVgtVkVSU0lPTjo0XFxuJ107XG4gICAgICAgICAgICBzdHJlYW0uc29ydCgoYSwgYikgPT4gcGFyc2VJbnQoYS5xdWFsaXR5KSA8IHBhcnNlSW50KGIucXVhbGl0eSkgPyAxIDogcGFyc2VJbnQoYS5xdWFsaXR5KSA+IHBhcnNlSW50KGIucXVhbGl0eSkgPyAtMSA6IDApO1xuICAgICAgICAgICAgZm9yIChsZXQgX3N0cmVhbSBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIF9zdHJlYW0ubTN1OCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIG0zdTgucHVzaChgI0VYVC1YLVNUUkVBTS1JTkY6UFJPR1JBTS1JRD0xLEJBTkRXSURUSD0ke01hdGgucm91bmQoX3N0cmVhbS5zaXplIC8gX3N0cmVhbS5kdXJhdGlvbiAqIDgpfSxSRVNPTFVUSU9OPSR7X3N0cmVhbS53aWR0aH14JHtfc3RyZWFtLmhlaWdodH1cXG4ke19zdHJlYW0ubTN1OH1cXG5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKG0zdTgsIHsgdHlwZTogJ2FwcGxpY2F0aW9uL3gtbXBlZ1VSTCcgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdHJpZ2dlckxvYWRlcnJvckV2ZW50KHR5cGUpIHtcbiAgICAgICAgICAgIF9sb2FkZWQgPSAtMTtcbiAgICAgICAgICAgIF9ldmVudC50cmlnZ2VyKCdsb2FkZXJyb3InLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBSZXNvdXJjZXNbYFZJREVPTE9BRF8ke3R5cGV9YF0udG9TdHJpbmcoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+WIEhMUyDnmoTotKjph4/nuqfliKvntKLlvJVcbiAgICAgICAgICogQHBhcmFtIHsqfSBRdWFsaXR5SW5kZXggXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBnZXRITFNRdWFsaXR5SW5kZXhCeVF1YWxpdHlJbmRleChxdWFsaXR5SW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChxdWFsaXR5SW5kZXggPT09IC0xKSByZXR1cm4gLTE7XG4gICAgICAgICAgICBsZXQgcXVhbGl0eUluZGV4TGlzdCA9IGdldFF1YWxpdHlJbmRleExpc3QoKTtcbiAgICAgICAgICAgIGZvciAobGV0IF9xdWFsaXR5SW5kZXggPSBxdWFsaXR5SW5kZXg7IHF1YWxpdHlJbmRleCA+PSAwOyBxdWFsaXR5SW5kZXgtLSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGhsc1F1YWxpdHlJbmRleCA9IDA7IGhsc1F1YWxpdHlJbmRleCA8IHF1YWxpdHlJbmRleExpc3QubGVuZ3RoOyBobHNRdWFsaXR5SW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocXVhbGl0eUluZGV4TGlzdFtobHNRdWFsaXR5SW5kZXhdID09PSBfcXVhbGl0eUluZGV4KSByZXR1cm4gaGxzUXVhbGl0eUluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPlueahOi0qOmHj+e6p+WIq+e0ouW8lVxuICAgICAgICAgKiBAcGFyYW0geyp9IGhsc1F1YWxpdHlJbmRleCBcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGdldFF1YWxpdHlJbmRleEJ5SExTUXVhbGl0eUluZGV4KGhsc1F1YWxpdHlJbmRleCkge1xuICAgICAgICAgICAgbGV0IHF1YWxpdHlJbmRleExpc3QgPSBnZXRRdWFsaXR5SW5kZXhMaXN0KCk7XG4gICAgICAgICAgICByZXR1cm4gcXVhbGl0eUluZGV4TGlzdFtobHNRdWFsaXR5SW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPluinhumikea4heaZsOW6puWIl+ihqFxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHJldHVybnMge0FycmF5fSDop4bpopHmuIXmmbDluqbntKLlvJXliJfooajvvIjku47otKjph4/lt67liLDotKjph4/lpb3mjpLluo/vvIlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGdldFF1YWxpdHlJbmRleExpc3QoKSB7XG4gICAgICAgICAgICBpZiAoX3ZpZGVvRGF0YSA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgcXVhbGl0eUluZGV4TGlzdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgc3RyZWFtIG9mIF92aWRlb0RhdGEuc3RyZWFtKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RyZWFtLm0zdTggPT09ICdzdHJpbmcnKSBxdWFsaXR5SW5kZXhMaXN0LnB1c2gocGFyc2VJbnQoc3RyZWFtLnF1YWxpdHkpIC0gMSk7XG4gICAgICAgICAgICAvL+aOkuW6j1xuICAgICAgICAgICAgcXVhbGl0eUluZGV4TGlzdC5zb3J0KChhLCBiKSA9PiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMCk7XG4gICAgICAgICAgICByZXR1cm4gcXVhbGl0eUluZGV4TGlzdDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgQWNGdW5WaWRlb0FkYXB0ZXIgfSIsImltcG9ydCAqIGFzIG9wZW5CU0UgZnJvbSAnb3BlbmJzZSdcbmltcG9ydCBDb29raWVzIGZyb20gJ2pzLWNvb2tpZSdcbmltcG9ydCB7IEV2ZW50IH0gZnJvbSAnLi9ldmVudCdcbmltcG9ydCB7IEhlbHBlciB9IGZyb20gJy4vaGVscGVyJ1xuaW1wb3J0IHsgQUNXZWJTb2NrZXRDbGllbnQgfSBmcm9tICcuL2FjV2ViU29ja2V0Q2xpZW50J1xuXG5jbGFzcyBCdWxsZXRTY3JlZW4ge1xuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gYnVsbGV0RWxlbWVudCBcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHZpZGVvRWxlbWVudCBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihidWxsZXRFbGVtZW50LCB2aWRlb0VsZW1lbnQpIHtcbiAgICAgICAgbGV0IF9ldmVudCA9IG5ldyBFdmVudCgpO1xuICAgICAgICBsZXQgX2xvYWRlZCA9IDA7XG4gICAgICAgIGxldCBfYnVsbGV0U2NyZWVuQ291bnQgPSAwO1xuICAgICAgICBsZXQgX2J1bGxldFNjcmVlbkxpc3QgPSBbXTtcbiAgICAgICAgbGV0IF92aWRlb0lkID0gbnVsbDtcbiAgICAgICAgbGV0IF9yZWZyZXNoT25saW5lVXNlcnNDb3VudFRpbWVyID0gbnVsbDtcbiAgICAgICAgbGV0IF91c2VySWQgPSBDb29raWVzLmdldCgnYXV0aF9rZXknKTtcblxuICAgICAgICBfZXZlbnQuYWRkKCdsb2Fkc3VjY2VzcycpO1xuICAgICAgICBfZXZlbnQuYWRkKCdsb2FkZXJyb3InKTtcbiAgICAgICAgX2V2ZW50LmFkZCgnYnVsbGV0c2NyZWVuY291bnRjaGFuZ2VkJyk7XG4gICAgICAgIF9ldmVudC5hZGQoJ2FkZGJ1bGxldHNjcmVlbnMnKTtcbiAgICAgICAgX2V2ZW50LmFkZCgnZGVzdHJveScpO1xuXG4gICAgICAgIF9ldmVudC5hZGQoJ2Fjd2Vic29ja2V0c3RhdHVzY2hhbmdlZCcpO1xuICAgICAgICBfZXZlbnQuYWRkKCdvbmxpbmV1c2Vyc2NvdW50Y2hhbmdlZCcpO1xuXG4gICAgICAgIHRoaXMuYmluZCA9IF9ldmVudC5iaW5kO1xuICAgICAgICB0aGlzLnVuYmluZCA9IF9ldmVudC51bmJpbmQ7XG5cbiAgICAgICAgbGV0IGJ1bGxldFNjcmVlbkVuZ2luZSA9IG5ldyBvcGVuQlNFLkJ1bGxldFNjcmVlbkVuZ2luZShidWxsZXRFbGVtZW50LCB7XG4gICAgICAgICAgICBkZWZhdWx0U3R5bGU6IHtcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5OiAnTWljcm9zb2Z0IFlhSGVpIFVJLCBNaWNyb3NvZnQgWWFIZWksIFNpbUhlaSwgSGVpdGkgU0MsIHNhbnMtc2VyaWYnLFxuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAncmdiYSgwLDAsMCwwLjQpJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb2NrOiAoKSA9PiB2aWRlb0VsZW1lbnQuY3VycmVudFRpbWUgKiAxMDAwXG4gICAgICAgIH0sICdjYW52YXMnKTtcblxuICAgICAgICBsZXQgX2FjV2ViU29ja2V0Q2xpZW50ID0gbmV3IEFDV2ViU29ja2V0Q2xpZW50KF91c2VySWQsIENvb2tpZXMuZ2V0KCdhdXRoX2tleV9hY19zaGExJyksIENvb2tpZXMuZ2V0KCdfZGlkJykpO1xuXG4gICAgICAgIF9hY1dlYlNvY2tldENsaWVudC5iaW5kKCdzdGF0dXNjaGFuZ2VkJywgKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChfYWNXZWJTb2NrZXRDbGllbnQuZ2V0SXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgICAgICAgIF9yZWZyZXNoT25saW5lVXNlcnNDb3VudFRpbWVyID0gc2V0SW50ZXJ2YWwoX2FjV2ViU29ja2V0Q2xpZW50LnJlZnJlc2hPbmxpbmVVc2Vyc0NvdW50LCAxMDAwMCk7XG4gICAgICAgICAgICAgICAgX2FjV2ViU29ja2V0Q2xpZW50LnJlZnJlc2hPbmxpbmVVc2Vyc0NvdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGNsZWFySW50ZXJ2YWwoX3JlZnJlc2hPbmxpbmVVc2Vyc0NvdW50VGltZXIpO1xuICAgICAgICAgICAgX2V2ZW50LnRyaWdnZXIoJ2Fjd2Vic29ja2V0c3RhdHVzY2hhbmdlZCcsIGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgX2FjV2ViU29ja2V0Q2xpZW50LmJpbmQoJ29ubGluZXVzZXJzY291bnRjaGFuZ2VkJywgKGUpID0+IHtcbiAgICAgICAgICAgIF9ldmVudC50cmlnZ2VyKCdvbmxpbmV1c2Vyc2NvdW50Y2hhbmdlZCcsIGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgX2FjV2ViU29ja2V0Q2xpZW50LmJpbmQoJ25ld2J1bGxldHNjcmVlbnJlY2VpdmVkJywgKGUpID0+IHtcbiAgICAgICAgICAgIGxldCBzcGVlZCA9IDAuMTAgKyBlLmJ1bGxldFNjcmVlbkRhdGEubWVzc2FnZS5sZW5ndGggLyAyMDA7IC8v5by55bmV6LaK6ZW/77yM6YCf5bqm6LaK5b+rXG4gICAgICAgICAgICBsZXQgYnVsbGV0U2NyZWVuID0ge1xuICAgICAgICAgICAgICAgIHV1aWQ6IGUuYnVsbGV0U2NyZWVuRGF0YS5jb21tZW50aWQsIC8vdXVpZFxuICAgICAgICAgICAgICAgIHVzZXJpZDogZS5idWxsZXRTY3JlZW5EYXRhLnVzZXIsIC8v55So5oi357yW5Y+3XG4gICAgICAgICAgICAgICAgdGV4dDogZS5idWxsZXRTY3JlZW5EYXRhLm1lc3NhZ2UsIC8v5paH5pysXG4gICAgICAgICAgICAgICAgdHlwZTogZ2V0QnVsbGV0U2NyZWVuVHlwZShlLmJ1bGxldFNjcmVlbkRhdGEubW9kZSksIC8v57G75Z6LXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lOiBwYXJzZUZsb2F0KGUuYnVsbGV0U2NyZWVuRGF0YS5zdGltZSkgKiAxMDAwLCAvL+W8gOWni+aXtumXtFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIHNwZWVkOiBzcGVlZCwgLy/pgJ/luqZcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGAjJHtIZWxwZXIucGFkKChlLmJ1bGxldFNjcmVlbkRhdGEuY29sb3IsIDEwKSwgNiwgMTYpfWAsIC8v6aKc6ImyXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IHBhcnNlSW50KGUuYnVsbGV0U2NyZWVuRGF0YS5zaXplLCAxMCksIC8v5a2X5Y+3XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2J1bGxldFNjcmVlbkxpc3QudW5zaGlmdChidWxsZXRTY3JlZW4pO1xuICAgICAgICAgICAgaWYgKGJ1bGxldFNjcmVlbi5zdGFydFRpbWUgPj0gdmlkZW9FbGVtZW50LmN1cnJlbnRUaW1lICogMTAwMCAmJiBlLmJ1bGxldFNjcmVlbkRhdGEudXNlciAhPSBfdXNlcklkKSAvL+W9k+WJjeW8ueW5leW8gOWni+aXtumXtOWwj+S6juWKoOi9veW8gOWni+aXtumXtFxuICAgICAgICAgICAgICAgIGJ1bGxldFNjcmVlbkVuZ2luZS5hZGRCdWxsZXRTY3JlZW4oYnVsbGV0U2NyZWVuKTtcbiAgICAgICAgICAgIF9idWxsZXRTY3JlZW5Db3VudFsyXSsrO1xuICAgICAgICAgICAgdHJpZ2dlcmJ1bGxldFNjcmVlbkNvdW50Q2hhbmdlZEV2ZW50KCk7XG4gICAgICAgICAgICB0cmlnZ2VyQWRkQnVsbGV0U2NyZWVucyhbYnVsbGV0U2NyZWVuXSk7XG4gICAgICAgIH0pO1xuICAgICAgICBfYWNXZWJTb2NrZXRDbGllbnQuYmluZCgnbG9hZGVycm9yJywgKGUpID0+IHtcbiAgICAgICAgICAgIF9ldmVudC50cmlnZ2VyKCdsb2FkZXJyb3InLCBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZpZGVvRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwbGF5aW5nJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFfbG9hZGVkID09PSAxKSByZXR1cm47XG4gICAgICAgICAgICBidWxsZXRTY3JlZW5FbmdpbmUucGxheSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmlkZW9FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3dhaXRpbmcnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIV9sb2FkZWQgPT09IDEpIHJldHVybjtcbiAgICAgICAgICAgIGJ1bGxldFNjcmVlbkVuZ2luZS5wYXVzZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmlkZW9FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BhdXNlJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFfbG9hZGVkID09PSAxKSByZXR1cm47XG4gICAgICAgICAgICBidWxsZXRTY3JlZW5FbmdpbmUucGF1c2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZpZGVvRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsICgpID0+IHtcbiAgICAgICAgICAgIGlmICghX2xvYWRlZCA9PT0gMSkgcmV0dXJuO1xuICAgICAgICAgICAgYnVsbGV0U2NyZWVuRW5naW5lLnN0b3AoKTtcbiAgICAgICAgICAgIGFkZEJ1bGxldFNjcmVlbkxpc3QoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZpZGVvRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWVraW5nJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFfbG9hZGVkID09PSAxKSByZXR1cm47XG4gICAgICAgICAgICBidWxsZXRTY3JlZW5FbmdpbmUuY2xlYW5TY3JlZW4oKTtcbiAgICAgICAgICAgIGJ1bGxldFNjcmVlbkVuZ2luZS5wYXVzZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmlkZW9FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlZWtlZCcsICgpID0+IHtcbiAgICAgICAgICAgIGlmICghX2xvYWRlZCA9PT0gMSkgcmV0dXJuO1xuICAgICAgICAgICAgYWRkQnVsbGV0U2NyZWVuTGlzdCh2aWRlb0VsZW1lbnQuY3VycmVudFRpbWUgKiAxMDAwKTtcbiAgICAgICAgICAgIGlmICghdmlkZW9FbGVtZW50LnBhdXNlZCkgYnVsbGV0U2NyZWVuRW5naW5lLnBsYXkoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZpZGVvRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdyYXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgYnVsbGV0U2NyZWVuRW5naW5lLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgICAgIHBsYXlTcGVlZDogdmlkZW9FbGVtZW50LnBsYXliYWNrUmF0ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliqDovb3lvLnluZVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZpZGVvSWQgLSDop4bpopHnvJblj7dcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubG9hZCA9ICh2aWRlb0lkLCBkdXJhdGlvbikgPT4ge1xuICAgICAgICAgICAgaWYgKF9sb2FkZWQgPT09IDEpIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgZnVuY3Rpb24gbG9hZEJ1bGxldFNjcmVlbihzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgICAgIC8v5by55bmV5pyN5Yqh5Zmo6K6k6K+BXG4gICAgICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0dFVCcsXG4gICAgICAgICAgICAgICAgICAgIHVybDogYGh0dHA6Ly9kYW5tdS5haXhpZmFuLmNvbS9hdXRoLyR7dmlkZW9JZH1gLFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL+iOt+WPluW8ueW5leaAu+aVsFxuICAgICAgICAgICAgICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnR0VUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGBodHRwOi8vZGFubXUuYWl4aWZhbi5jb20vc2l6ZS8ke3ZpZGVvSWR9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9idWxsZXRTY3JlZW5Db3VudCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcmJ1bGxldFNjcmVlbkNvdW50Q2hhbmdlZEV2ZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8v5Yqg6L295by55bmVXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnR0VUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogYGh0dHA6Ly9kYW5tdS5haXhpZmFuLmNvbS9WNC8ke3ZpZGVvSWR9LzQwNzM1NTg0MDAwMDAvMjAwMD9vcmRlcj0tMWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcmVzdWx0SXRlbSBvZiByZXN1bHRbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZEJ1bGxldFNjcmVlbkZyb21SZXN1bHRJdGVtKHJlc3VsdEl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyQWRkQnVsbGV0U2NyZWVucyhfYnVsbGV0U2NyZWVuTGlzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQnVsbGV0U2NyZWVuTGlzdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvYWRCdWxsZXRTY3JlZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIF9sb2FkZWQgPSAxO1xuICAgICAgICAgICAgICAgIF92aWRlb0lkID0gdmlkZW9JZDtcbiAgICAgICAgICAgICAgICBfZXZlbnQudHJpZ2dlcignbG9hZHN1Y2Nlc3MnLCB7fSk7XG4gICAgICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckxvYWRlcnJvckV2ZW50KCdSRVFVRVNUX0JVTExFVFNDUkVFTl9GQUlMRUQnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb25uZWN0ID0gKGR1cmF0aW9uKSA9PiBfYWNXZWJTb2NrZXRDbGllbnQuY29ubmVjdChfdmlkZW9JZCwgZHVyYXRpb24pO1xuXG4gICAgICAgIHRoaXMuZ2V0VmlzaWJpbGl0eSA9IGJ1bGxldFNjcmVlbkVuZ2luZS5nZXRWaXNpYmlsaXR5O1xuXG4gICAgICAgIHRoaXMuZ2V0T3BhY2l0eSA9ICgpID0+IGJ1bGxldFNjcmVlbkVuZ2luZS5nZXRPcHRpb25zKCkub3BhY2l0eTtcbiAgICAgICAgdGhpcy5zZXRPcGFjaXR5ID0gKG9wYWNpdHkpID0+IGJ1bGxldFNjcmVlbkVuZ2luZS5zZXRPcHRpb25zKHsgb3BhY2l0eTogb3BhY2l0eSB9KTtcblxuICAgICAgICB0aGlzLmhpZGUgPSBidWxsZXRTY3JlZW5FbmdpbmUuaGlkZTtcblxuICAgICAgICB0aGlzLnNob3cgPSBidWxsZXRTY3JlZW5FbmdpbmUuc2hvdztcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Y246L295by55bmVXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoX2xvYWRlZCAhPSAxKSB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIF9sb2FkZWQgPSAwO1xuICAgICAgICAgICAgX3ZpZGVvSWQgPSBudWxsO1xuICAgICAgICAgICAgYnVsbGV0U2NyZWVuRW5naW5lLnN0b3AoKTtcbiAgICAgICAgICAgIF9hY1dlYlNvY2tldENsaWVudC5jbG9zZSgpO1xuICAgICAgICAgICAgX2J1bGxldFNjcmVlbkxpc3QgPSBbXTtcbiAgICAgICAgICAgIF9ldmVudC50cmlnZ2VyKCdkZXN0cm95Jywge30pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPluWKoOi9veeKtuaAgVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRMb2FkZWRTdGF0ZSA9ICgpID0+IF9sb2FkZWQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPluW8ueW5leaAu+aVsFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRCdWxsZXRTY3JlZW5Db3VudCA9ICgpID0+IF9idWxsZXRTY3JlZW5Db3VudDtcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W5by55bmV5YiX6KGoXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldEJ1bGxldFNjcmVlbkxpc3QgPSAoKSA9PiBfYnVsbGV0U2NyZWVuTGlzdDtcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W6ZqQ6JeP5by55bmV57G75Z6LXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldEhpZGRlblR5cGVzID0gKCkgPT4gYnVsbGV0U2NyZWVuRW5naW5lLmdldE9wdGlvbnMoKS5oaWRkZW5UeXBlcztcblxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u6ZqQ6JeP5by55bmV57G75Z6LXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldEhpZGRlblR5cGVzID0gKGhpZGRlblR5cGVzKSA9PiBidWxsZXRTY3JlZW5FbmdpbmUuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICBoaWRkZW5UeXBlczogaGlkZGVuVHlwZXNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa4heepuuWxj+W5leW8ueW5lVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGVhblNjcmVlbiA9ICgpID0+IGJ1bGxldFNjcmVlbkVuZ2luZS5jbGVhblNjcmVlbigpO1xuXG4gICAgICAgIHRoaXMuc2VuZGJ1bGxldFNjcmVlbiA9IChzdGFydFRpbWUsIHR5cGVOYW1lLCBjb2xvciwgdGV4dCwgc2l6ZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSBvcGVuQlNFLkJ1bGxldFNjcmVlblR5cGVbdHlwZU5hbWVdO1xuICAgICAgICAgICAgbGV0IHNwZWVkID0gMC4xMCArIHRleHQubGVuZ3RoIC8gMjAwOyAvL+W8ueW5lei2iumVv++8jOmAn+W6pui2iuW/q1xuICAgICAgICAgICAgYnVsbGV0U2NyZWVuRW5naW5lLmFkZEJ1bGxldFNjcmVlbih7XG4gICAgICAgICAgICAgICAgdGV4dDogdGV4dCwgLy/mlofmnKxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLCAvL+exu+Wei1xuICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lICogMTAwMCwgLy/lvIDlp4vml7bpl7RcbiAgICAgICAgICAgICAgICBsYXllcjogMSxcbiAgICAgICAgICAgICAgICBjYW5EaXNjYXJkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBzcGVlZDogc3BlZWQsIC8v6YCf5bqmXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvciwgLy/popzoibJcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogc2l6ZSwgLy/lrZflj7dcbiAgICAgICAgICAgICAgICAgICAgYm94Q29sb3I6ICcjNkVGRkZFJyAvL+i+ueahhuminOiJslxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX2FjV2ViU29ja2V0Q2xpZW50LnNlbmRidWxsZXRTY3JlZW4oXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lLCBnZXRCdWxsZXRTY3JlZW5Nb2RlKHR5cGUpLFxuICAgICAgICAgICAgICAgIG5ldyBEYXRlKCkuZ2V0VGltZSgpLCBwYXJzZUludChjb2xvci5zdWJzdHJpbmcoMSwgY29sb3IubGVuZ3RoIC0gMiksIDE2KSxcbiAgICAgICAgICAgICAgICB0ZXh0LCBzaXplXG4gICAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICog5LuO6K+35rGC57uT5p6c5Yqg6L295by55bmV5YiX6KGoXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZXN1bHRJdGVtIC0g6K+35rGC6L+U5Zue55qE57uT5p6cXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBsb2FkQnVsbGV0U2NyZWVuRnJvbVJlc3VsdEl0ZW0ocmVzdWx0SXRlbSkge1xuICAgICAgICAgICAgLy/kvKDovpPmoLzlvI/vvJrlvIDlp4vml7bpl7TvvIjnm7jlr7nkuo7op4bpopEs56eS77yJLOminOiJsu+8iDE26L+b5Yi2UkdC5YC855qE5Y2B6L+b5Yi26KGo56S677yJLFxuICAgICAgICAgICAgLy/nsbvlnoss5a2X5Y+377yI5YOP57Sg77yJLOWPkemAgeeUqOaIt+eahOe8luWPtyzlj5HpgIHml6XmnJ8s5by55bmV57yW5Y+377yI5pep5pyf6KeG6aKR5Li657yW5Y+377yM5paw6KeG6aKR5Li6VVVJRO+8iVxuICAgICAgICAgICAgbGV0IGluZm8gPSByZXN1bHRJdGVtLmMuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gcmVzdWx0SXRlbS5tO1xuICAgICAgICAgICAgbGV0IHNwZWVkID0gMC4xMCArIHJlc3VsdEl0ZW0ubS5sZW5ndGggLyAyMDA7IC8v5by55bmV6LaK6ZW/77yM6YCf5bqm6LaK5b+rXG4gICAgICAgICAgICBpZiAoc3BlZWQgPiAwLjIwKSBzcGVlZCA9IDAuMjA7XG4gICAgICAgICAgICBfYnVsbGV0U2NyZWVuTGlzdC51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICB1dWlkOiBpbmZvWzZdLCAvL3V1aWRcbiAgICAgICAgICAgICAgICB1c2VyaWQ6IGluZm9bNF0sIC8v55So5oi357yW5Y+3XG4gICAgICAgICAgICAgICAgdGV4dDogdGV4dCwgLy/mlofmnKxcbiAgICAgICAgICAgICAgICB0eXBlOiBnZXRCdWxsZXRTY3JlZW5UeXBlKGluZm9bMl0pLCAvL+exu+Wei1xuICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogcGFyc2VGbG9hdChpbmZvWzBdKSAqIDEwMDAsIC8v5byA5aeL5pe26Ze0XG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgc3BlZWQ6IHNwZWVkLCAvL+mAn+W6plxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogYCMke0hlbHBlci5wYWQocGFyc2VJbnQoaW5mb1sxXSwgMTApLCA2LCAxNil9YCwgLy/popzoibJcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogcGFyc2VJbnQoaW5mb1szXSwgMTApLCAvL+Wtl+WPt1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0QnVsbGV0U2NyZWVuVHlwZShtb2RlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnNlSW50KG1vZGUpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlbkJTRS5CdWxsZXRTY3JlZW5UeXBlLnJpZ2h0VG9MZWZ0OyAvL+a1geW8ueW5lVxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZW5CU0UuQnVsbGV0U2NyZWVuVHlwZS5sZWZ0VG9SaWdodDsgLy/pgIblkJHlvLnluZUg54yc5rWLXG4gICAgICAgICAgICAgICAgLy9jYXNlIDM6XG4gICAgICAgICAgICAgICAgLy90eXBlID0gb3BlbkJTRS5CdWxsZXRTY3JlZW5UeXBlLnJpZ2h0VG9MZWZ0OyAvL+a4uOWuouW8ueW5lSDnjJzmtYtcbiAgICAgICAgICAgICAgICAvL2JyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZW5CU0UuQnVsbGV0U2NyZWVuVHlwZS50b3A7IC8v6aG26YOo5by55bmVXG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlbkJTRS5CdWxsZXRTY3JlZW5UeXBlLmJvdHRvbTsgLy/lupXpg6jlvLnluZVcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlbkJTRS5CdWxsZXRTY3JlZW5UeXBlLnJpZ2h0VG9MZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0QnVsbGV0U2NyZWVuTW9kZSh0eXBlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIG9wZW5CU0UuQnVsbGV0U2NyZWVuVHlwZS5yaWdodFRvTGVmdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7IC8v5rWB5by55bmVXG4gICAgICAgICAgICAgICAgY2FzZSBvcGVuQlNFLkJ1bGxldFNjcmVlblR5cGUubGVmdFRvUmlnaHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAyOyAvL+mAhuWQkeW8ueW5lSDnjJzmtYtcbiAgICAgICAgICAgICAgICBjYXNlIG9wZW5CU0UuQnVsbGV0U2NyZWVuVHlwZS50b3A6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA0OyAvL+mhtumDqOW8ueW5lVxuICAgICAgICAgICAgICAgIGNhc2Ugb3BlbkJTRS5CdWxsZXRTY3JlZW5UeXBlLmJvdHRvbTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDU7IC8v5bqV6YOo5by55bmVXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5by55bmV5Yiw5by55bmV5byV5pOOXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb2FkU3RhcnRUaW1lIC0g5byA5aeL5pe26Ze077yI5Y2V5L2N77ya5q+r56eS77yJXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBhZGRCdWxsZXRTY3JlZW5MaXN0KGxvYWRTdGFydFRpbWUgPSAwKSB7XG4gICAgICAgICAgICBidWxsZXRTY3JlZW5FbmdpbmUuY2xlYW5CdWxsZXRTY3JlZW5MaXN0KCk7IC8v5riF56m65by55bmV5YiX6KGoXG4gICAgICAgICAgICBmb3IgKGxldCBidWxsZXRTY3JlZW4gb2YgX2J1bGxldFNjcmVlbkxpc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnVsbGV0U2NyZWVuLnN0YXJ0VGltZSA8IGxvYWRTdGFydFRpbWUgLSAxMDAwKSBjb250aW51ZTsgLy/lvZPliY3lvLnluZXlvIDlp4vml7bpl7TlsI/kuo7liqDovb3lvIDlp4vml7bpl7RcbiAgICAgICAgICAgICAgICBidWxsZXRTY3JlZW5FbmdpbmUuYWRkQnVsbGV0U2NyZWVuKGJ1bGxldFNjcmVlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB0cmlnZ2VyTG9hZGVycm9yRXZlbnQodHlwZSkge1xuICAgICAgICAgICAgX2xvYWRlZCA9IC0xO1xuICAgICAgICAgICAgX2V2ZW50LnRyaWdnZXIoJ2xvYWRlcnJvcicsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFJlc291cmNlc1tgQlVMTEVUU0NSRUVOTE9BRF8ke3R5cGV9YF0udG9TdHJpbmcoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB0cmlnZ2VyYnVsbGV0U2NyZWVuQ291bnRDaGFuZ2VkRXZlbnQoKSB7XG4gICAgICAgICAgICBfZXZlbnQudHJpZ2dlcignYnVsbGV0c2NyZWVuY291bnRjaGFuZ2VkJywgeyBidWxsZXRTY3JlZW5Db3VudDogSGVscGVyLmNsb25lKF9idWxsZXRTY3JlZW5Db3VudCkgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB0cmlnZ2VyQWRkQnVsbGV0U2NyZWVucyhuZXdCdWxsZXRTY3JlZW5zLCBjbGVhbk9sZCA9IGZhbHNlKSB7XG4gICAgICAgICAgICBfZXZlbnQudHJpZ2dlcignYWRkYnVsbGV0c2NyZWVucycsIHsgbmV3QnVsbGV0U2NyZWVuczogSGVscGVyLmNsb25lKG5ld0J1bGxldFNjcmVlbnMpLCBjbGVhbk9sZDogY2xlYW5PbGQgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL+Wwj+eql+WPo+aSreaUvue8qeWwj+W8ueW5lVxuICAgICAgICBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoYnVsbGV0RWxlbWVudC5jbGllbnRXaWR0aCA8IDMwMCkgYnVsbGV0U2NyZWVuRW5naW5lLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgICAgIHNjYWxpbmc6IDAuNVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlbHNlIGJ1bGxldFNjcmVlbkVuZ2luZS5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgICAgICBzY2FsaW5nOiAxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IEJ1bGxldFNjcmVlbiB9IiwiaW1wb3J0IHsgUmVzb3VyY2VzIH0gZnJvbSAnLi9yZXNvdXJjZXMnXG5pbXBvcnQgeyBIZWxwZXIgfSBmcm9tICcuL2hlbHBlcidcblxuLyoqXG4gKiDkuovku7bmqKHlnovnsbtcbiAqL1xuY2xhc3MgRXZlbnQge1xuICAgIC8qKlxuICAgICAqIOWIm+W7uuS4gOS4quaWsOeahOS6i+S7tuaooeWei+OAglxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICog5LqL5Lu25YiX6KGoXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgZXZlbnRMaXN0ID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqDkuovku7ZcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIOS6i+S7tuWQjeensFxuICAgICAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IOS8oOWFpeeahOWPguaVsOmUmeivr+aIluS6i+S7tuW3suWtmOWcqOaXtuW8leWPkemUmeivr+OAguivt+WPgumYhSBNRE4gW1R5cGVFcnJvcl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvVHlwZUVycm9yfSDjgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWRkID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcihSZXNvdXJjZXMuUEFSQU1FVEVSU19UWVBFX0VSUk9SLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudExpc3RbbmFtZV0gIT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBUeXBlRXJyb3IoUmVzb3VyY2VzLkVWRU5UX0FMUkVBRFlfRVhJU1RTX0VSUk9SLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgZXZlbnRMaXN0W25hbWVdID0gW107XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliKDpmaTkuovku7ZcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIOS6i+S7tuWQjeensFxuICAgICAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IOS8oOWFpeeahOWPguaVsOmUmeivr+aIluS6i+S7tuS4jeWtmOWcqOaXtuW8leWPkemUmeivr+OAguivt+WPgumYhSBNRE4gW1R5cGVFcnJvcl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvVHlwZUVycm9yfSDjgIJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVtb3ZlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcihSZXNvdXJjZXMuUEFSQU1FVEVSU19UWVBFX0VSUk9SLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudExpc3RbbmFtZV0gPT09ICd1bmRlZmluZWQnKSB0aHJvdyBuZXcgVHlwZUVycm9yKFJlc291cmNlcy5FVkVOVF9OQU1FX05PVF9GT1VORF9FUlJPUi50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGRlbGV0ZSAoZXZlbnRMaXN0W25hbWVdKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOe7keWumuS6i+S7tuWkhOeQhueoi+W6j1xuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0g5LqL5Lu25ZCN56ewXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1biAtIOS6i+S7tuWkhOeQhueoi+W6j1xuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSDmt7vliqDlkI7nmoTkuovku7bmlbBcbiAgICAgICAgICogQHRocm93cyB7VHlwZUVycm9yfSDkvKDlhaXnmoTlj4LmlbDplJnor6/miJbkuovku7bkuI3lrZjlnKjml7blvJXlj5HplJnor6/jgILor7flj4LpmIUgTUROIFtUeXBlRXJyb3Jde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1R5cGVFcnJvcn0g44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJpbmQgPSBmdW5jdGlvbiAobmFtZSwgZnVuKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT0gJ3N0cmluZycgfHwgdHlwZW9mIGZ1biAhPSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKFJlc291cmNlcy5QQVJBTUVURVJTX1RZUEVfRVJST1IudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBsZXQgZXZlbnQgPSBldmVudExpc3RbbmFtZV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV2ZW50ID09PSAndW5kZWZpbmVkJykgdGhyb3cgbmV3IFR5cGVFcnJvcihSZXNvdXJjZXMuRVZFTlRfTkFNRV9OT1RfRk9VTkRfRVJST1IudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCBpbiBldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudFtpbmRleF0gPT09IGZ1bilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnVuc2hpZnQoZnVuKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOino+e7keS6i+S7tuWkhOeQhueoi+W6j++8iGZ1buS4uuepuuino+e7keaJgOacieS6i+S7tuWkhOeQhueoi+W6j++8iVxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0g5LqL5Lu25ZCN56ewXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1biAtIOS6i+S7tuWkhOeQhueoi+W6j1xuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSDliKDpmaTlkI7nmoTkuovku7bmlbBcbiAgICAgICAgICogQHRocm93cyB7VHlwZUVycm9yfSDkvKDlhaXnmoTlj4LmlbDplJnor6/miJbkuovku7bkuI3lrZjlnKjml7blvJXlj5HplJnor6/jgILor7flj4LpmIUgTUROIFtUeXBlRXJyb3Jde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1R5cGVFcnJvcn0g44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVuYmluZCA9IGZ1bmN0aW9uIChuYW1lLCBmdW4pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcihSZXNvdXJjZXMuUEFSQU1FVEVSU19UWVBFX0VSUk9SLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgbGV0IGV2ZW50ID0gZXZlbnRMaXN0W25hbWVdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudCA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBUeXBlRXJyb3IoUmVzb3VyY2VzLkVWRU5UX05BTUVfTk9UX0ZPVU5EX0VSUk9SLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmdW4gPT0gJ2Z1bmN0aW9uJykgZm9yIChsZXQgaW5kZXggaW4gZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRbaW5kZXhdID09PSBmdW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3BsaWNlKGZ1biwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGV2ZW50TGlzdFtuYW1lXSA9IFtdO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICog6Kem5Y+R5LqL5Lu2XG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSDkuovku7blkI3np7BcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGUgLSDkuovku7bmlbDmja5cbiAgICAgICAgICogQHRocm93cyB7VHlwZUVycm9yfSDkvKDlhaXnmoTlj4LmlbDplJnor6/miJbkuovku7bkuI3lrZjlnKjml7blvJXlj5HplJnor6/jgILor7flj4LpmIUgTUROIFtUeXBlRXJyb3Jde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1R5cGVFcnJvcn0g44CCXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyaWdnZXIgPSBmdW5jdGlvbiAobmFtZSwgZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9ICdzdHJpbmcnIHx8IEhlbHBlci5fdHlwZW9mKGUpICE9ICdvYmplY3QnKSB0aHJvdyBuZXcgVHlwZUVycm9yKFJlc291cmNlcy5QQVJBTUVURVJTX1RZUEVfRVJST1IudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBsZXQgZXZlbnQgPSBldmVudExpc3RbbmFtZV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV2ZW50ID09PSAndW5kZWZpbmVkJykgdGhyb3cgbmV3IFR5cGVFcnJvcihSZXNvdXJjZXMuRVZFTlRfTkFNRV9OT1RfRk9VTkRfRVJST1IudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBlLnR5cGUgPSBuYW1lO1xuICAgICAgICAgICAgZm9yIChsZXQgZnVuIG9mIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmdW4oZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgeyBFdmVudCB9IiwiaW1wb3J0IHsgUmVzb3VyY2VzIH0gZnJvbSAnLi9yZXNvdXJjZXMnXG5cbi8qKlxuICog6K6+572u5YC8XG4gKiBAYWxpYXMgSGVscGVyLnNldFZhbHVlXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0g5YC8XG4gKiBAcGFyYW0geyp9IGRlZmF1bHRWYWx1ZSAtIOm7mOiupOWAvFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSDnsbvlnotcbiAqIEByZXR1cm5zIHsqfSAtIOWAvFxuICovXG5mdW5jdGlvbiBzZXRWYWx1ZSh2YWx1ZSwgZGVmYXVsdFZhbHVlLCB0eXBlKSB7XG4gICAgbGV0IHJldHVyblZhbHVlO1xuICAgIGlmIChpc0VtcHR5KHZhbHVlKSkgcmV0dXJuVmFsdWUgPSBjbG9uZShkZWZhdWx0VmFsdWUpO1xuICAgIGVsc2UgcmV0dXJuVmFsdWUgPSBjbG9uZSh2YWx1ZSk7XG4gICAgaWYgKCFpc0VtcHR5KHR5cGUpKSBjaGVja1R5cGUocmV0dXJuVmFsdWUsIHR5cGUpO1xuICAgIGVsc2UgaWYgKCFpc0VtcHR5KGRlZmF1bHRWYWx1ZSkpIGNoZWNrVHlwZShyZXR1cm5WYWx1ZSwgX3R5cGVvZihkZWZhdWx0VmFsdWUpKTtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbi8qKlxuICog6K6+572u5aSa5Liq5YC8XG4gKiBAYWxpYXMgSGVscGVyLnNldFZhbHVlc1xuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyAtIOWAvFxuICogQHBhcmFtIHtvYmplY3R9IGRlZmF1bHRWYWx1ZXMgLSDpu5jorqTlgLxcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlcyAtIOexu+Wei1xuICogQHJldHVybnMge29iamVjdH0gLSDlgLxcbiAqL1xuZnVuY3Rpb24gc2V0VmFsdWVzKHZhbHVlcywgZGVmYXVsdFZhbHVlcywgdHlwZXMsIGNsb25lID0gdHJ1ZSkge1xuICAgIGxldCByZXR1cm5WYWx1ZXMgPSBjbG9uZSA/IHNldFZhbHVlKHZhbHVlcywge30pIDogZGVmYXVsdFZhbHVlcztcbiAgICBsZXQgX3ZhbHVlcyA9IGNsb25lID8gcmV0dXJuVmFsdWVzIDogc2V0VmFsdWUodmFsdWVzLCB7fSk7XG4gICAgZm9yIChsZXQga2V5IGluIGRlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgaWYgKF90eXBlb2YoZGVmYXVsdFZhbHVlc1trZXldKSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICByZXR1cm5WYWx1ZXNba2V5XSA9IHNldFZhbHVlcyhfdmFsdWVzW2tleV0sIGRlZmF1bHRWYWx1ZXNba2V5XSwgdHlwZXNba2V5XSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVyblZhbHVlc1trZXldID0gc2V0VmFsdWUoX3ZhbHVlc1trZXldLCBkZWZhdWx0VmFsdWVzW2tleV0sIHR5cGVzW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xufVxuXG4vKipcbiAqIOajgOafpeexu+Wei1xuICogQGFsaWFzIEhlbHBlci5jaGVja1R5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIOWAvFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSDnsbvlnotcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY2FuQmVOdWxsIC0g5Y+v5Lul5Li656m6XG4gKi9cbmZ1bmN0aW9uIGNoZWNrVHlwZSh2YWx1ZSwgdHlwZSwgY2FuQmVOdWxsID0gdHJ1ZSkge1xuICAgIGlmICh0eXBlb2YgdHlwZSAhPSAnc3RyaW5nJyAmJiBfdHlwZW9mKHR5cGUpICE9ICdhcnJheScpIHRocm93IG5ldyBUeXBlRXJyb3IoUmVzb3VyY2VzLlBBUkFNRVRFUlNfVFlQRV9FUlJPUik7XG4gICAgaWYgKGNhbkJlTnVsbCAmJiBpc0VtcHR5KHZhbHVlKSkgcmV0dXJuO1xuICAgIGlmIChfdHlwZW9mKHR5cGUpID09PSAnYXJyYXknKSB7XG4gICAgICAgIGxldCBmbGF0ID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgdHlwZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtICE9ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKFJlc291cmNlcy5QQVJBTUVURVJTX1RZUEVfRVJST1IpO1xuICAgICAgICAgICAgaWYgKF90eXBlb2YodmFsdWUpID09PSBpdGVtKSB7XG4gICAgICAgICAgICAgICAgZmxhdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmbGF0KSB0aHJvdyBuZXcgVHlwZUVycm9yKFJlc291cmNlcy5QQVJBTUVURVJTX1RZUEVfRVJST1IpO1xuICAgIH0gZWxzZSBpZiAoX3R5cGVvZih2YWx1ZSkgIT0gdHlwZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihSZXNvdXJjZXMuUEFSQU1FVEVSU19UWVBFX0VSUk9SKTtcbn1cblxuLyoqXG4gKiDmo4Dmn6XlpJrkuKrlgLxcbiAqIEBhbGlhcyBIZWxwZXIuY2hlY2tUeXBlc1xuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyAtIOWAvFxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVzIC0g57G75Z6LXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIOWAvFxuICovXG5mdW5jdGlvbiBjaGVja1R5cGVzKHZhbHVlcywgdHlwZXMsIGNhbkJlTnVsbCA9IHRydWUpIHtcbiAgICBpZiAoY2FuQmVOdWxsICYmIGlzRW1wdHkodmFsdWVzKSkgcmV0dXJuO1xuICAgIGZvciAobGV0IGtleSBpbiB0eXBlcykge1xuICAgICAgICBpZiAoX3R5cGVvZih0eXBlc1trZXldKSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBjaGVja1R5cGVzKHZhbHVlc1trZXldLCB0eXBlc1trZXldKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY2hlY2tUeXBlKHZhbHVlc1trZXldLCB0eXBlc1trZXldLCBjYW5CZU51bGwpO1xuICAgIH1cbn1cblxuLyoqXG4gKiDmo4Dmn6XmmK/lkKbkuLrnqbpcbiAqIEBhbGlhcyBIZWxwZXIuaXNFbXB0eVxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIOWAvFxuICovXG5mdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB8fFxuICAgICAgICB2YWx1ZSA9PT0gbnVsbFxufVxuXG4vKipcbiAqIOiOt+WPluWvueixoeeahOexu+Wei++8iOWPr+WMuuWIhuaVsOe7hOetie+8iVxuICogQGFsaWFzIEhlbHBlci5fdHlwZW9mXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIOWvueixoVxuICovXG5mdW5jdGlvbiBfdHlwZW9mKG9iamVjdCkge1xuICAgIC8vZWc6IFtPYmplY3QgRnVuY3Rpb25dIC0+IEZ1bmN0aW9uIC0+IGZ1bmN0aW9uXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiAqIOWFi+mahuWvueixoVxuICogQHBhcmFtIHsqfSBvYmplY3QgXG4gKi9cbmZ1bmN0aW9uIGNsb25lKG9iamVjdCkge1xuICAgIGxldCByZXN1bHQsIHR5cGUgPSBfdHlwZW9mKG9iamVjdCk7XG4gICAgLy/noa7lrppyZXN1bHTnmoTnsbvlnotcbiAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHJlc3VsdCA9IHt9O1xuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdhcnJheScpIHJlc3VsdCA9IFtdO1xuICAgIGVsc2UgcmV0dXJuIG9iamVjdDtcbiAgICBmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gY2xvbmUob2JqZWN0W2tleV0pOyAvL+mAkuW9kuiwg+eUqFxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIOagvOW8j+WMluaVsOWtl++8iOWcqOaVsOWtl+WJjeWKoDDvvIlcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gLSDmlbDlrZdcbiAqIEBwYXJhbSB7Kn0gbiAtIOS9jeaVsFxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl4IC0g6KGo56S65pWw5a2X55qE5Z+65pWwXG4gKi9cbmZ1bmN0aW9uIHBhZChudW0sIG4sIHJhZGl4ID0gMTApIHtcbiAgICBudW0gPSBudW0udG9TdHJpbmcocmFkaXgpO1xuICAgIGxldCBsZW4gPSBudW0ubGVuZ3RoO1xuICAgIHdoaWxlIChsZW4rKyA8IG4pIG51bSA9IFwiMFwiICsgbnVtO1xuICAgIHJldHVybiBudW07XG59XG5cbi8qKlxuICog6I635Y+W5pe26Ze055qE5paH5pysXG4gKiBAcGFyYW0geyp9IHNlY29uZCAtIOaXtumXtO+8muWNleS9je+8muenkuOAglxuICovXG5mdW5jdGlvbiBnZXRUaW1lVGV4dChzZWNvbmQpIHtcbiAgICBpZiAodHlwZW9mIHNlY29uZCAhPSAnbnVtYmVyJyB8fCBpc05hTihzZWNvbmQpIHx8IHNlY29uZCA8IDApIHJldHVybiAnMDA6MDAnO1xuICAgIHNlY29uZCA9IE1hdGgucm91bmQoc2Vjb25kKTtcbiAgICBsZXQgaG91ciA9IE1hdGguZmxvb3Ioc2Vjb25kIC8gMzYwMCk7XG4gICAgc2Vjb25kID0gc2Vjb25kICUgMzYwMDtcbiAgICBsZXQgbWludXRlID0gTWF0aC5mbG9vcihzZWNvbmQgLyA2MCk7XG4gICAgc2Vjb25kID0gc2Vjb25kICUgNjA7XG4gICAgcmV0dXJuICgoaG91ciA9PT0gMCkgPyAnJyA6IHBhZChob3VyLCAyKSArICc6JykgKyBwYWQobWludXRlLCAyKSArICc6JyArIHBhZChzZWNvbmQsIDIpO1xufVxuXG4vKipcbiAqIOaKiuaVsOWtl+eUqOmAl+WPt+malOW8gFxuICogQHBhcmFtIHtudW1iZXJ9IG4gLSDopoHliIbpmpTnmoTmlbDlrZdcbiAqL1xuZnVuY3Rpb24gc2VwYXJhdGVOdW1iZXIobikge1xuICAgIHZhciBiID0gcGFyc2VJbnQobikudG9TdHJpbmcoKTtcbiAgICB2YXIgbGVuID0gYi5sZW5ndGg7XG4gICAgaWYgKGxlbiA8PSAzKSB7IHJldHVybiBiOyB9XG4gICAgdmFyIHIgPSBsZW4gJSAzO1xuICAgIHJldHVybiByID4gMCA/IGIuc2xpY2UoMCwgcikgKyBcIixcIiArIGIuc2xpY2UociwgbGVuKS5tYXRjaCgvXFxkezN9L2cpLmpvaW4oXCIsXCIpIDogYi5zbGljZShyLCBsZW4pLm1hdGNoKC9cXGR7M30vZykuam9pbihcIixcIik7XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RGdWxsc2NyZWVuKGVsZW1lbnQpIHtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQucmVxdWVzdEZ1bGxzY3JlZW4gPT09ICdmdW5jdGlvbicpIGVsZW1lbnQucmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbiA9PT0gJ2Z1bmN0aW9uJykgZWxlbWVudC53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgIGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50Lm1velJlcXVlc3RGdWxsU2NyZWVuID09PSAnZnVuY3Rpb24nKSBlbGVtZW50Lm1velJlcXVlc3RGdWxsU2NyZWVuKCk7XG4gICAgZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQubXNSZXF1ZXN0RnVsbHNjcmVlbiA9PT0gJ2Z1bmN0aW9uJykgZWxlbWVudC5tc1JlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQub1JlcXVlc3RGdWxsU2NyZWVuID09PSAnZnVuY3Rpb24nKSBlbGVtZW50Lm9SZXF1ZXN0RnVsbFNjcmVlbigpO1xufVxuXG5mdW5jdGlvbiBleGl0RnVsbHNjcmVlbigpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuID09PSAnZnVuY3Rpb24nKSBkb2N1bWVudC5leGl0RnVsbHNjcmVlbigpO1xuICAgIGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbiA9PT0gJ2Z1bmN0aW9uJykgZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4oKTtcbiAgICBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQubW96Q2FuY2VsRnVsbFNjcmVlbiA9PT0gJ2Z1bmN0aW9uJykgZG9jdW1lbnQubW96Q2FuY2VsRnVsbFNjcmVlbigpO1xuICAgIGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudC5tc0V4aXRGdWxsc2NyZWVuID09PSAnZnVuY3Rpb24nKSBkb2N1bWVudC5tc0V4aXRGdWxsc2NyZWVuKCk7XG4gICAgZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50Lm9FeGl0RnVsbHNjcmVlbiA9PT0gJ2Z1bmN0aW9uJykgZG9jdW1lbnQub0V4aXRGdWxsc2NyZWVuKCk7XG59XG5cbmZ1bmN0aW9uIGFkZFNjcmVlbmNoYW5nZUV2ZW50TGlzdGVuZXIobGlzdGVyZXIsIG9wdGlvbnMpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmdWxsc2NyZWVuY2hhbmdlJywgbGlzdGVyZXIsIG9wdGlvbnMpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UnLCBsaXN0ZXJlciwgb3B0aW9ucyk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW96ZnVsbHNjcmVlbmNoYW5nZScsIGxpc3RlcmVyLCBvcHRpb25zKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdNU0Z1bGxzY3JlZW5DaGFuZ2UnLCBsaXN0ZXJlciwgb3B0aW9ucyk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignb2Z1bGxzY3JlZW5jaGFuZ2UnLCBsaXN0ZXJlciwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGdldEZ1bGxzY3JlZW5FbGVtZW50KCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQgIT0gJ3VuZGVmaW5lZCcpIHJldHVybiBkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudDtcbiAgICBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVsZW1lbnQgIT0gJ3VuZGVmaW5lZCcpIHJldHVybiBkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRWxlbWVudDtcbiAgICBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQubW96RnVsbFNjcmVlbkVsZW1lbnQgIT0gJ3VuZGVmaW5lZCcpIHJldHVybiBkb2N1bWVudC5tb3pGdWxsU2NyZWVuRWxlbWVudDtcbiAgICBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQubXNGdWxsc2NyZWVuRWxlbWVudCAhPSAndW5kZWZpbmVkJykgcmV0dXJuIGRvY3VtZW50Lm1zRnVsbHNjcmVlbkVsZW1lbnQ7XG4gICAgZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50Lm9GdWxsc2NyZWVuRWxlbWVudCAhPSAndW5kZWZpbmVkJykgcmV0dXJuIGRvY3VtZW50Lm9GdWxsc2NyZWVuRWxlbWVudDtcbn1cblxuLyoqXG4gKiDluK7liqnlr7nosaFcbiAqIEBuYW1lc3BhY2VcbiAqL1xuY29uc3QgSGVscGVyID0ge1xuICAgIHNldFZhbHVlOiBzZXRWYWx1ZSxcbiAgICBzZXRWYWx1ZXM6IHNldFZhbHVlcyxcbiAgICBjaGVja1R5cGU6IGNoZWNrVHlwZSxcbiAgICBjaGVja1R5cGVzOiBjaGVja1R5cGVzLFxuICAgIGlzRW1wdHk6IGlzRW1wdHksXG4gICAgX3R5cGVvZjogX3R5cGVvZixcbiAgICBjbG9uZTogY2xvbmUsXG4gICAgcGFkOiBwYWQsXG4gICAgZ2V0VGltZVRleHQ6IGdldFRpbWVUZXh0LFxuICAgIHNlcGFyYXRlTnVtYmVyOiBzZXBhcmF0ZU51bWJlcixcbiAgICByZXF1ZXN0RnVsbHNjcmVlbjogcmVxdWVzdEZ1bGxzY3JlZW4sXG4gICAgZXhpdEZ1bGxzY3JlZW46IGV4aXRGdWxsc2NyZWVuLFxuICAgIGFkZFNjcmVlbmNoYW5nZUV2ZW50TGlzdGVuZXI6IGFkZFNjcmVlbmNoYW5nZUV2ZW50TGlzdGVuZXIsXG4gICAgZ2V0RnVsbHNjcmVlbkVsZW1lbnQ6IGdldEZ1bGxzY3JlZW5FbGVtZW50XG59XG5cbmV4cG9ydCB7IEhlbHBlciB9IiwiaW1wb3J0IHsgQWNGdW5WaWRlb0FkYXB0ZXIgfSBmcm9tICcuL2FkYXB0ZXIvYWNmdW5WaWRlb0FkYXB0ZXInXG5pbXBvcnQgeyBCdWxsZXRTY3JlZW4gfSBmcm9tICcuL2J1bGxldFNjcmVlbidcbmltcG9ydCB7IEhlbHBlciB9IGZyb20gJy4vaGVscGVyJ1xuaW1wb3J0IHsgRXZlbnQgfSBmcm9tICcuL2V2ZW50J1xuXG5jbGFzcyBQbGF5ZXIge1xuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdmlkZW9FbGVtZW50IFxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gYnVsbGV0RWxlbWVudCBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2aWRlb0VsZW1lbnQsIGJ1bGxldEVsZW1lbnQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZSDlrprkuYnvvIjkuIDkupvogIHlvI/mtY/op4jlmajkuI3mlK/mjIEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIO+8iVxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW4gLSDlm57osIPmlrnms5UgXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IHJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nKSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICAgICAgICBlbHNlIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IChmdW4pID0+IHdpbmRvdy5zZXRUaW1lb3V0KGZ1biwgMTcpOyAvLzYwZnBzXG5cbiAgICAgICAgdmlkZW9FbGVtZW50LmNvbnRyb2xzID0gZmFsc2U7XG4gICAgICAgIGxldCBfYWRhcHRlciA9IG5ldyBBY0Z1blZpZGVvQWRhcHRlcih2aWRlb0VsZW1lbnQpO1xuICAgICAgICBsZXQgX2J1bGxldFNjcmVlbiA9IG5ldyBCdWxsZXRTY3JlZW4oYnVsbGV0RWxlbWVudCwgdmlkZW9FbGVtZW50KTtcbiAgICAgICAgbGV0IF9ldmVudCA9IG5ldyBFdmVudCgpO1xuICAgICAgICBsZXQgX3BsYXlOZXh0UGFydEZ1biA9IG51bGw7XG4gICAgICAgIGxldCBfcGxheWJhY2tSYXRlID0gMTtcblxuICAgICAgICBfZXZlbnQuYWRkKCdsb2Fkc3VjY2VzcycpO1xuICAgICAgICBfZXZlbnQuYWRkKCdsb2FkZXJyb3InKTtcblxuICAgICAgICBfZXZlbnQuYWRkKCdjdXJyZW50dGltZWNoYW5nZWQnKTtcbiAgICAgICAgX2V2ZW50LmFkZCgncXVhbGl0eXN3aXRjaGluZycpO1xuICAgICAgICBfZXZlbnQuYWRkKCdxdWFsaXR5c3dpdGNoZWQnKTtcbiAgICAgICAgX2V2ZW50LmFkZCgnYWRhcHRlcmRlc3Ryb3knKTtcblxuICAgICAgICBfZXZlbnQuYWRkKCdidWxsZXRzY3JlZW5jb3VudGNoYW5nZWQnKTtcbiAgICAgICAgX2V2ZW50LmFkZCgnYWRkYnVsbGV0c2NyZWVucycpO1xuICAgICAgICBfZXZlbnQuYWRkKCdidWxsZXRzY3JlZW5kZXN0cm95Jyk7XG4gICAgICAgIF9ldmVudC5hZGQoJ2Fjd2Vic29ja2V0c3RhdHVzY2hhbmdlZCcpO1xuICAgICAgICBfZXZlbnQuYWRkKCdvbmxpbmV1c2Vyc2NvdW50Y2hhbmdlZCcpO1xuXG4gICAgICAgIF9ldmVudC5hZGQoJ2xvYWRzdGFydCcpO1xuICAgICAgICBfZXZlbnQuYWRkKCdwcm9ncmVzcycpO1xuICAgICAgICBfZXZlbnQuYWRkKCdzdXNwZW5kJyk7XG4gICAgICAgIF9ldmVudC5hZGQoJ2Fib3J0Jyk7XG4gICAgICAgIF9ldmVudC5hZGQoJ2Vycm9yJyk7XG4gICAgICAgIF9ldmVudC5hZGQoJ2VtcHRpZWQnKTtcbiAgICAgICAgX2V2ZW50LmFkZCgnc3RhbGxlZCcpO1xuICAgICAgICBfZXZlbnQuYWRkKCdwbGF5Jyk7XG4gICAgICAgIF9ldmVudC5hZGQoJ3BsYXlpbmcnKTtcbiAgICAgICAgX2V2ZW50LmFkZCgncGF1c2UnKTtcbiAgICAgICAgX2V2ZW50LmFkZCgnbG9hZGVkbWV0YWRhdGEnKTtcbiAgICAgICAgX2V2ZW50LmFkZCgnd2FpdGluZycpO1xuICAgICAgICBfZXZlbnQuYWRkKCdjYW5wbGF5Jyk7XG4gICAgICAgIF9ldmVudC5hZGQoJ2NhbnBsYXl0aHJvdWdoJyk7XG4gICAgICAgIF9ldmVudC5hZGQoJ3NlZWtpbmcnKTtcbiAgICAgICAgX2V2ZW50LmFkZCgnc2Vla2VkJyk7XG4gICAgICAgIF9ldmVudC5hZGQoJ3RpbWV1cGRhdGUnKTtcbiAgICAgICAgX2V2ZW50LmFkZCgnZW5kZWQnKTtcbiAgICAgICAgX2V2ZW50LmFkZCgncmF0ZWNoYW5nZWQnKTtcbiAgICAgICAgX2V2ZW50LmFkZCgnZHJ1YXRpb25jaGFuZ2UnKTtcblxuICAgICAgICBfZXZlbnQuYWRkKCd2b2x1bWVvcm11dGVkY2hhbmdlZCcpO1xuXG4gICAgICAgIHRoaXMuYmluZCA9IF9ldmVudC5iaW5kO1xuICAgICAgICB0aGlzLnVuYmluZCA9IF9ldmVudC51bmJpbmQ7XG5cbiAgICAgICAgX2FkYXB0ZXIuYmluZCgnbG9hZHN1Y2Nlc3MnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoX2J1bGxldFNjcmVlbi5nZXRMb2FkZWRTdGF0ZSgpICE9IDApIF9ldmVudC50cmlnZ2VyKCdsb2Fkc3VjY2VzcycsIHt9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX2J1bGxldFNjcmVlbi5iaW5kKCdsb2Fkc3VjY2VzcycsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChfYWRhcHRlci5nZXRMb2FkZWRTdGF0ZSgpID09PSAxKSBfZXZlbnQudHJpZ2dlcignbG9hZHN1Y2Nlc3MnLCB7fSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF9hZGFwdGVyLmJpbmQoJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgICAgICAgICBfZXZlbnQudHJpZ2dlcignYnVsbGV0c2NyZWVuZGVzdHJveScsIHt9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX2J1bGxldFNjcmVlbi5iaW5kKCdkZXN0cm95JywgKCkgPT4ge1xuICAgICAgICAgICAgX2V2ZW50LnRyaWdnZXIoJ2FkYXB0ZXJkZXN0cm95Jywge30pO1xuICAgICAgICB9KTtcblxuICAgICAgICBfYWRhcHRlci5iaW5kKCdsb2FkZXJyb3InLCAoZSkgPT4ge1xuICAgICAgICAgICAgX2V2ZW50LnRyaWdnZXIoJ2xvYWRlcnJvcicsIGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBfYWRhcHRlci5iaW5kKCdxdWFsaXR5c3dpdGNoaW5nJywgKGUpID0+IHtcbiAgICAgICAgICAgIF9ldmVudC50cmlnZ2VyKCdxdWFsaXR5c3dpdGNoaW5nJywgZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF9hZGFwdGVyLmJpbmQoJ3F1YWxpdHlzd2l0Y2hlZCcsIChlKSA9PiB7XG4gICAgICAgICAgICBfZXZlbnQudHJpZ2dlcigncXVhbGl0eXN3aXRjaGVkJywgZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF9idWxsZXRTY3JlZW4uYmluZCgnYnVsbGV0c2NyZWVuY291bnRjaGFuZ2VkJywgKGUpID0+IHtcbiAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBuIG9mIGUuYnVsbGV0U2NyZWVuQ291bnQpIGNvdW50ICs9IG47XG4gICAgICAgICAgICBlLmJ1bGxldFNjcmVlbkNvdW50VGV4dCA9IEhlbHBlci5zZXBhcmF0ZU51bWJlcihjb3VudCk7XG4gICAgICAgICAgICBfZXZlbnQudHJpZ2dlcignYnVsbGV0c2NyZWVuY291bnRjaGFuZ2VkJywgZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF9idWxsZXRTY3JlZW4uYmluZCgnYWRkYnVsbGV0c2NyZWVucycsIChlKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBidWxsZXRTY3JlZW4gb2YgZS5uZXdCdWxsZXRTY3JlZW5zKSBidWxsZXRTY3JlZW4uc3RhcnRUaW1lVGV4dCA9IEhlbHBlci5nZXRUaW1lVGV4dChidWxsZXRTY3JlZW4uc3RhcnRUaW1lIC89IDEwMDApO1xuICAgICAgICAgICAgX2V2ZW50LnRyaWdnZXIoJ2FkZGJ1bGxldHNjcmVlbnMnLCBlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX2J1bGxldFNjcmVlbi5iaW5kKCdsb2FkZXJyb3InLCAoZSkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGAke2UudHlwZX0gJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICBpZiAoX2FkYXB0ZXIuZ2V0TG9hZGVkU3RhdGUoKSA9PT0gMSkgX2V2ZW50LnRyaWdnZXIoJ2xvYWRzdWNjZXNzJywge30pO1xuICAgICAgICB9KTtcblxuICAgICAgICBfYnVsbGV0U2NyZWVuLmJpbmQoJ2Fjd2Vic29ja2V0c3RhdHVzY2hhbmdlZCcsIChlKSA9PiB7XG4gICAgICAgICAgICBfZXZlbnQudHJpZ2dlcignYWN3ZWJzb2NrZXRzdGF0dXNjaGFuZ2VkJywgZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBfYnVsbGV0U2NyZWVuLmJpbmQoJ29ubGluZXVzZXJzY291bnRjaGFuZ2VkJywgKGUpID0+IHtcbiAgICAgICAgICAgIGUub25saW5lVXNlcnNDb3VudFRleHQgPSBIZWxwZXIuc2VwYXJhdGVOdW1iZXIoZS5vbmxpbmVVc2Vyc0NvdW50KTtcbiAgICAgICAgICAgIF9ldmVudC50cmlnZ2VyKCdvbmxpbmV1c2Vyc2NvdW50Y2hhbmdlZCcsIGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2aWRlb0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZHN0YXJ0JywgKCkgPT4ge1xuICAgICAgICAgICAgX2V2ZW50LnRyaWdnZXIoJ2xvYWRzdGFydCcsIHt9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmlkZW9FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgKCkgPT4ge1xuICAgICAgICAgICAgX2V2ZW50LnRyaWdnZXIoJ3Byb2dyZXNzJywge30pO1xuICAgICAgICB9KTtcblxuICAgICAgICB2aWRlb0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc3VzcGVuZCcsICgpID0+IHtcbiAgICAgICAgICAgIF9ldmVudC50cmlnZ2VyKCdzdXNwZW5kJywge30pO1xuICAgICAgICB9KTtcblxuICAgICAgICB2aWRlb0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICBfZXZlbnQudHJpZ2dlcignYWJvcnQnLCB7fSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZpZGVvRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgICAgIF9ldmVudC50cmlnZ2VyKCdlcnJvcicsIHt9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmlkZW9FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2VtcHRpZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICBfZXZlbnQudHJpZ2dlcignZW1wdGllZCcsIHt9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmlkZW9FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3N0YWxsZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICBfZXZlbnQudHJpZ2dlcignc3RhbGxlZCcsIHt9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmlkZW9FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXknLCAoKSA9PiB7XG4gICAgICAgICAgICBfZXZlbnQudHJpZ2dlcigncGxheScsIHt9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmlkZW9FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCAoKSA9PiB7XG4gICAgICAgICAgICBfZXZlbnQudHJpZ2dlcigncGxheWluZycsIHt9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmlkZW9FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BhdXNlJywgKCkgPT4ge1xuICAgICAgICAgICAgX2V2ZW50LnRyaWdnZXIoJ3BhdXNlJywge30pO1xuICAgICAgICB9KTtcblxuICAgICAgICB2aWRlb0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkbWV0YWRhdGEnLCAoKSA9PiB7XG4gICAgICAgICAgICBfYnVsbGV0U2NyZWVuLmNvbm5lY3QoTWF0aC5yb3VuZCh2aWRlb0VsZW1lbnQuZHVyYXRpb24pKTtcbiAgICAgICAgICAgIF9ldmVudC50cmlnZ2VyKCdsb2FkZWRtZXRhZGF0YScsIHt9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmlkZW9FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3dhaXRpbmcnLCAoKSA9PiB7XG4gICAgICAgICAgICBfZXZlbnQudHJpZ2dlcignd2FpdGluZycsIHt9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmlkZW9FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXknLCAoKSA9PiB7XG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQucGxheWJhY2tSYXRlID0gX3BsYXliYWNrUmF0ZTtcbiAgICAgICAgICAgIF9ldmVudC50cmlnZ2VyKCdjYW5wbGF5Jywge30pO1xuICAgICAgICB9KTtcblxuICAgICAgICB2aWRlb0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLCAoKSA9PiB7XG4gICAgICAgICAgICBfZXZlbnQudHJpZ2dlcignY2FucGxheXRocm91Z2gnLCB7fSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZpZGVvRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWVraW5nJywgKCkgPT4ge1xuICAgICAgICAgICAgX2V2ZW50LnRyaWdnZXIoJ3NlZWtpbmcnLCB7fSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZpZGVvRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWVrZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICBfZXZlbnQudHJpZ2dlcignc2Vla2VkJywge30pO1xuICAgICAgICB9KTtcblxuICAgICAgICB2aWRlb0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndGltZXVwZGF0ZScsICgpID0+IHtcbiAgICAgICAgICAgIF9ldmVudC50cmlnZ2VyKCd0aW1ldXBkYXRlJywge30pO1xuICAgICAgICB9KTtcblxuICAgICAgICB2aWRlb0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICBfZXZlbnQudHJpZ2dlcignZW5kZWQnLCB7fSk7XG4gICAgICAgICAgICBpZiAoX3BsYXlOZXh0UGFydEZ1biAhPSBudWxsKSBfcGxheU5leHRQYXJ0RnVuKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZpZGVvRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdyYXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgX2V2ZW50LnRyaWdnZXIoJ3JhdGVjaGFuZ2VkJywgeyBwbGF5YmFja1JhdGU6IHZpZGVvRWxlbWVudC5wbGF5YmFja1JhdGUgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZpZGVvRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdkcnVhdGlvbmNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIF9ldmVudC50cmlnZ2VyKCdkcnVhdGlvbmNoYW5nZScsIHt9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmlkZW9FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3ZvbHVtZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIF9ldmVudC50cmlnZ2VyKCd2b2x1bWVvcm11dGVkY2hhbmdlZCcsIHsgdm9sdW1lOiB2aWRlb0VsZW1lbnQubXV0ZWQgPyAwIDogdmlkZW9FbGVtZW50LnZvbHVtZSwgbXV0ZWQ6IHZpZGVvRWxlbWVudC5tdXRlZCB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5sb2FkID0gKHZpZGVvSWQsIGF1dG9wbGF5ID0gZmFsc2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAgICAgdmlkZW9FbGVtZW50LmF1dG9wbGF5ID0gYXV0b3BsYXk7XG4gICAgICAgICAgICBfYWRhcHRlci5sb2FkKHZpZGVvSWQsIC0xKTtcbiAgICAgICAgICAgIF9idWxsZXRTY3JlZW4ubG9hZCh2aWRlb0lkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChfYWRhcHRlci5nZXRMb2FkZWRTdGF0ZSgpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgX2FkYXB0ZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9idWxsZXRTY3JlZW4uZ2V0TG9hZGVkU3RhdGUoKSA9PT0gMSkgX2J1bGxldFNjcmVlbi5kZXN0cm95KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBsYXkgPSB2aWRlb0VsZW1lbnQucGxheTtcblxuICAgICAgICB0aGlzLnBhdXNlID0gdmlkZW9FbGVtZW50LnBhdXNlO1xuXG4gICAgICAgIHRoaXMuY2hhbmdlUGxheVN0YXRlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZGVvRWxlbWVudC5wYXVzZWQpIHZpZGVvRWxlbWVudC5wbGF5KCk7XG4gICAgICAgICAgICBlbHNlIHZpZGVvRWxlbWVudC5wYXVzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdG9wID0gKCkgPT4ge1xuICAgICAgICAgICAgdmlkZW9FbGVtZW50LnBhdXNlKCk7XG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQuY3VycmVudFRpbWUgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5nZXRQYXVzZWQgPSAoKSA9PiB2aWRlb0VsZW1lbnQucGF1c2VkO1xuXG4gICAgICAgIHRoaXMuZ2V0TG9vcCA9ICgpID0+IHZpZGVvRWxlbWVudC5sb29wO1xuICAgICAgICB0aGlzLnNldExvb3AgPSAobG9vcCkgPT4geyB2aWRlb0VsZW1lbnQubG9vcCA9IGxvb3A7IH1cblxuICAgICAgICB0aGlzLmdldE11dGVkID0gKCkgPT4gdmlkZW9FbGVtZW50Lm11dGVkO1xuICAgICAgICB0aGlzLnNldE11dGVkID0gKG11dGVkKSA9PiB7XG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQubXV0ZWQgPSBtdXRlZDtcbiAgICAgICAgICAgIGlmICh2aWRlb0VsZW1lbnQudm9sdW1lID09PSAwICYmICFtdXRlZCkgdmlkZW9FbGVtZW50LnZvbHVtZSA9IDAuNTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ2V0Vm9sdW1lID0gKCkgPT4gdmlkZW9FbGVtZW50LnZvbHVtZTtcbiAgICAgICAgdGhpcy5zZXRWb2x1bWUgPSAodm9sdW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAodm9sdW1lIDwgMCkgdm9sdW1lID0gMDtcbiAgICAgICAgICAgIGVsc2UgaWYgKHZvbHVtZSA+IDEpIHZvbHVtZSA9IDE7XG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQudm9sdW1lID0gdm9sdW1lO1xuICAgICAgICAgICAgaWYgKHZvbHVtZSA9PT0gMCkgdmlkZW9FbGVtZW50Lm11dGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgdmlkZW9FbGVtZW50Lm11dGVkID0gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRDdXJyZW50VGltZSA9ICgpID0+IHZpZGVvRWxlbWVudC5jdXJyZW50VGltZTtcbiAgICAgICAgdGhpcy5zZXRDdXJyZW50VGltZSA9IChjdXJyZW50VGltZSkgPT4geyBcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGltZSA8IDApIGN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRUaW1lID4gdmlkZW9FbGVtZW50LmR1cmF0aW9uKSBjdXJyZW50VGltZSA9IHZpZGVvRWxlbWVudC5kdXJhdGlvbjtcbiAgICAgICAgICAgIHZpZGVvRWxlbWVudC5jdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lOyBcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ2V0UGxheWJhY2tSYXRlID0gKCkgPT4gX3BsYXliYWNrUmF0ZTtcbiAgICAgICAgdGhpcy5zZXRQbGF5YmFja1JhdGUgPSAocGxheWJhY2tSYXRlKSA9PiB7IF9wbGF5YmFja1JhdGUgPSB2aWRlb0VsZW1lbnQucGxheWJhY2tSYXRlID0gcGxheWJhY2tSYXRlOyB9XG5cbiAgICAgICAgdGhpcy5nZXRCdWxsZXRTY3JlZW5PcGFjaXR5ID0gX2J1bGxldFNjcmVlbi5nZXRPcGFjaXR5O1xuICAgICAgICB0aGlzLnNldEJ1bGxldFNjcmVlbk9wYWNpdHkgPSBfYnVsbGV0U2NyZWVuLnNldE9wYWNpdHk7XG5cbiAgICAgICAgdGhpcy5nZXREdXJhdGlvbiA9ICgpID0+IHZpZGVvRWxlbWVudC5kdXJhdGlvbjtcblxuICAgICAgICB0aGlzLmdldEJ1bGxldFNjcmVlblZpc2liaWxpdHkgPSBfYnVsbGV0U2NyZWVuLmdldFZpc2liaWxpdHk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPlumakOiXj+W8ueW5leexu+Wei1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRCdWxsZXRTY3JlZW5IaWRkZW5UeXBlcyA9IF9idWxsZXRTY3JlZW4uZ2V0SGlkZGVuVHlwZXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7pmpDol4/lvLnluZXnsbvlnotcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0QnVsbGV0U2NyZWVuSGlkZGVuVHlwZXMgPSBfYnVsbGV0U2NyZWVuLnNldEhpZGRlblR5cGVzO1xuXG4gICAgICAgIHRoaXMuaGlkZUJ1bGxldFNjcmVlbiA9IF9idWxsZXRTY3JlZW4uaGlkZTtcblxuICAgICAgICB0aGlzLnNob3dCdWxsZXRTY3JlZW4gPSBfYnVsbGV0U2NyZWVuLnNob3c7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPluW9k+WJjeinhumikea4heaZsOW6plxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHJldHVybnMge251bWJlcn0g6KeG6aKR5riF5pmw5bqm57Si5byVXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFF1YWxpdHlJbmRleCA9IF9hZGFwdGVyLmdldFF1YWxpdHlJbmRleDtcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W5piv5ZCm5ZCv55So5LqG6Ieq5Yqo6LSo6YeP6YCJ5oupXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRBdXRvUXVhbGl0eUVuYWJsZWQgPSBfYWRhcHRlci5nZXRBdXRvUXVhbGl0eUVuYWJsZWQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPluinhumikea4heaZsOW6puWIl+ihqFxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHJldHVybnMge0FycmF5fSDop4bpopHmuIXmmbDluqbntKLlvJXliJfooajvvIjku47otKjph4/lt67liLDotKjph4/lpb3mjpLluo/vvIlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0UXVhbGl0eUluZGV4TGlzdCA9IF9hZGFwdGVyLmdldFF1YWxpdHlJbmRleExpc3Q7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIh+aNouinhumikei0qOmHj1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRRdWFsaXR5SW5kZXggPSBfYWRhcHRlci5zZXRRdWFsaXR5SW5kZXg7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa4heepuuWxj+W5leW8ueW5lVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGVhbkJ1bGxldFNjcmVlbiA9IF9idWxsZXRTY3JlZW4uY2xlYW5TY3JlZW47XG5cblxuICAgICAgICB0aGlzLmNoYW5nZUJ1bGxldFNjcmVlblZpc2liaWxpdHkgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoX2J1bGxldFNjcmVlbi5nZXRWaXNpYmlsaXR5KCkpIF9idWxsZXRTY3JlZW4uaGlkZSgpO1xuICAgICAgICAgICAgZWxzZSBfYnVsbGV0U2NyZWVuLnNob3coKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0UGxheU5leHRQYXJ0RnVuID0gKHBsYXlOZXh0UGFydEZ1bikgPT4ge1xuICAgICAgICAgICAgX3BsYXlOZXh0UGFydEZ1biA9IHBsYXlOZXh0UGFydEZ1bjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ2V0SGFzTmV4dFBhcnQgPSAoKSA9PiBfcGxheU5leHRQYXJ0RnVuICE9IG51bGw7XG5cbiAgICAgICAgdGhpcy5wbGF5TmV4dFBhcnQgPSAoKSA9PiBfcGxheU5leHRQYXJ0RnVuKCk7XG5cbiAgICAgICAgdGhpcy5zZW5kYnVsbGV0U2NyZWVuID0gKGZvcm1EYXRhKSA9PiB7XG4gICAgICAgICAgICBfYnVsbGV0U2NyZWVuLnNlbmRidWxsZXRTY3JlZW4oXG4gICAgICAgICAgICAgICAgdmlkZW9FbGVtZW50LmN1cnJlbnRUaW1lLFxuICAgICAgICAgICAgICAgIGZvcm1EYXRhLmdldCgndHlwZScpLCBmb3JtRGF0YS5nZXQoJ2NvbG9yJyksXG4gICAgICAgICAgICAgICAgZm9ybURhdGEuZ2V0KCd0ZXh0JyksIHBhcnNlSW50KGZvcm1EYXRhLmdldCgnc2l6ZScpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPlue8k+WGsui/m+W6plxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2dldEJ1ZmZlclByb2dyZXNzKCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRUaW1lID0gdmlkZW9FbGVtZW50LmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgbGV0IGR1cmF0aW9uID0gdmlkZW9FbGVtZW50LmR1cmF0aW9uO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHR5cGVvZiBjdXJyZW50VGltZSAhPSAnbnVtYmVyJyB8fCBpc05hTihjdXJyZW50VGltZSkgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgZHVyYXRpb24gIT0gJ251bWJlcicgfHwgaXNOYU4oZHVyYXRpb24pIHx8IGR1cmF0aW9uID09PSAwXG4gICAgICAgICAgICApIHJldHVybiAwO1xuICAgICAgICAgICAgLy/orqHnrpflubborr7nva7lt7LnvJPlrZjov5vluqZcbiAgICAgICAgICAgIC8vYnVmZmVyZWTov5Tlm57nmoTmmK/nvJPlrZjnmoTov5vluqbnmoTliIbmrrXvvIzopoHmn6Xmib7lvZPliY3mraPlnKjmkq3mlL7nmoTliIbmrrXlubbmmL7npLrmraTliIbmrrXnmoTnu5PmnZ/ml7bpl7RcbiAgICAgICAgICAgIC8v77yM5oiW6ICF5pi+56S66KaB5pKt5pS+55qE5LiL5LiA5Liq5YiG5q6155qE57uT5p2f5pe26Ze077yI5YiG5q615byA5aeL5pe26Ze0562J5LqO5b2T5YmN5pKt5pS+5pe26Ze077yJXG4gICAgICAgICAgICBsZXQgYnVmZmVyZWQgPSB2aWRlb0VsZW1lbnQuYnVmZmVyZWQ7XG4gICAgICAgICAgICBpZiAoYnVmZmVyZWQgIT0gbnVsbCAmJiBidWZmZXJlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyZWQuc3RhcnQoaSkgPD0gY3VycmVudFRpbWUgJiYgYnVmZmVyZWQuZW5kKGkpID4gY3VycmVudFRpbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyZWQuZW5kKGkpIC8gZHVyYXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRUaW1lIC8gZHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZXRCdWZmZXJQcm9ncmVzcyA9IF9nZXRCdWZmZXJQcm9ncmVzcztcblxuICAgICAgICBsZXQgdHJpZ2dlckN1cnJlbnRUaW1lQ2hhbmdlZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50VGltZTtcbiAgICAgICAgICAgIGxldCBkdXJhdGlvbjtcbiAgICAgICAgICAgIGxldCBidWZmZXJQcm9ncmVzcyA9IF9nZXRCdWZmZXJQcm9ncmVzcygpO1xuICAgICAgICAgICAgY3VycmVudFRpbWUgPSB2aWRlb0VsZW1lbnQuY3VycmVudFRpbWU7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHZpZGVvRWxlbWVudC5kdXJhdGlvbjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3VycmVudFRpbWUgIT0gJ251bWJlcicgfHwgaXNOYU4oY3VycmVudFRpbWUpKSBjdXJyZW50VGltZSA9IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGR1cmF0aW9uICE9ICdudW1iZXInIHx8IGlzTmFOKGR1cmF0aW9uKSkgZHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgX2V2ZW50LnRyaWdnZXIoJ2N1cnJlbnR0aW1lY2hhbmdlZCcsIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VGltZTogY3VycmVudFRpbWUsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIHBlcmNlbnQ6IGN1cnJlbnRUaW1lID09PSAwID8gMCA6IGN1cnJlbnRUaW1lIC8gZHVyYXRpb24gKiAxMDAsXG4gICAgICAgICAgICAgICAgYnVmZmVyUHJvZ3Jlc3M6IGJ1ZmZlclByb2dyZXNzLFxuICAgICAgICAgICAgICAgIGJ1ZmZlclBlcmNlbnQ6IGJ1ZmZlclByb2dyZXNzICogMTAwLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUaW1lVGV4dDogSGVscGVyLmdldFRpbWVUZXh0KGN1cnJlbnRUaW1lKSxcbiAgICAgICAgICAgICAgICBkdXJhdGlvblRleHQ6IEhlbHBlci5nZXRUaW1lVGV4dChkdXJhdGlvbilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRyaWdnZXJDdXJyZW50VGltZUNoYW5nZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0cmlnZ2VyQ3VycmVudFRpbWVDaGFuZ2VkKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IFBsYXllciB9IiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwiRVZFTlRfTkFNRV9OT1RfRk9VTkRfRVJST1JcIjogXCJFdmVudCBuYW1lIG5vdCBmb3VuZC5cIixcbiAgICBcIkVWRU5UX0FMUkVBRFlfRVhJU1RTX0VSUk9SXCI6IFwiRXZlbnQgYWxyZWFkeSBleGlzdHMuXCIsXG4gICAgXCJQQVJBTUVURVJTX1RZUEVfRVJST1JcIjogXCJQYXJhbWV0ZXJzIHR5cGUgZXJyb3IuXCIsXG4gICAgXCJWSURFT0xPQURfR0VUX0RBVEFfRkFJTEVEXCI6IFwi6KeG6aKR5L+h5oGv5Yqg6L295aSx6LSl44CCXCIsXG4gICAgXCJWSURFT0xPQURfSExTX05FVFdPUktfRVJST1JcIjogXCLnvZHnu5zplJnor6/jgILlsJ3or5XmgaLlpI3jgIJcIixcbiAgICBcIlZJREVPTE9BRF9ITFNfTUVESUFfRVJST1JcIjogXCLlqpLkvZMv6KeG6aKR6ZSZ6K+v44CC5bCd6K+V5oGi5aSN44CCXCIsXG4gICAgXCJWSURFT0xPQURfSExTX09USEVSX0VSUk9SXCI6IFwi5pyq55+l6ZSZ6K+v44CCXCIsXG4gICAgXCJWSURFT0xPQURfSExTX0VSUk9SXCI6IFwiSExTIOmUmeivr+S7o+egge+8mntjb2RlfVwiLFxuICAgIFwiQlVMTEVUU0NSRUVOTE9BRF9SRVFVRVNUX0JVTExFVFNDUkVFTl9GQUlMRURcIjogXCLlvLnluZXojrflj5blpLHotKXjgIJcIixcbiAgICBcIldFQlNPQ0tFVENPTk5FQ1RfQ09OTkVDVEVEX0VSUk9SXCI6IFwi5aWX5o6l5a2X6L+e5o6l6ZSZ6K+v44CCXCJcbn0iLCJpbXBvcnQgKiBhcyBSZXNvdXJjZXMgZnJvbSAnLi9yZXNvdXJjZXMuanNvbidcblxuLyoqXG4gKiDmlbDmja7loavlhYXvvIjljaDkvY3nrKbmi7zmjqXvvIlcbiAqIEBwYXJhbSB7b2JqZWN0fC4uLnN0cmluZ30gc2lnbiAtIOS4gOe7hOWtl+espuS4suaIluS4gOS4quWvueixoVxuICovXG5mdW5jdGlvbiBmaWxsRGF0YSgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gICAgdmFyIHBhcmFtID0gYXJndW1lbnRzWzBdLCBzdHIgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgKHBhcmFtKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHBhcmFtKVxuICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cChcIlxcXFx7XCIgKyBrZXkgKyBcIlxcXFx9XCIsIFwiZ1wiKSwgcGFyYW1ba2V5XSk7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShuZXcgUmVnRXhwKFwiXFxcXHtcIiArIGkgKyBcIlxcXFx9XCIsIFwiZ1wiKSwgYXJndW1lbnRzW2ldKTtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG59XG5cbmZvciAobGV0IGtleSBpbiBSZXNvdXJjZXMpIHtcbiAgICBpZiAodHlwZW9mIFJlc291cmNlc1trZXldID09PSAnc3RyaW5nJykge1xuICAgICAgICBSZXNvdXJjZXNba2V5XSA9IG5ldyBTdHJpbmcoUmVzb3VyY2VzW2tleV0pO1xuICAgICAgICBSZXNvdXJjZXNba2V5XS5maWxsRGF0YSA9IGZpbGxEYXRhO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgUmVzb3VyY2VzIH0iLCJpbXBvcnQgeyBFdmVudCB9IGZyb20gJy4vZXZlbnQnXG5cbmxldCAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5cbmNsYXNzIFNsaWRlQmFyIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBiaWcgPSBmYWxzZSwgdmVydGljYWwgPSBmYWxzZSkge1xuICAgICAgICBsZXQgU2xpZGVCYXJFbGVtZW50ID0gJCgnPGRpdiBjbGFzcz1cIkFDSHRtbDVQbGF5ZXItc2xpZGVCYXJcIj48L2Rpdj4nKTtcbiAgICAgICAgU2xpZGVCYXJFbGVtZW50LmFkZENsYXNzKGJpZyA/ICdiaWcnIDogJ3NtYWxsJyk7XG4gICAgICAgIFNsaWRlQmFyRWxlbWVudC5hZGRDbGFzcyh2ZXJ0aWNhbCA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCcpO1xuICAgICAgICBsZXQgc2xpZGVCYXJGaWxsRWxlbWVudCA9ICQoJzxkaXYgY2xhc3M9XCJBQ0h0bWw1UGxheWVyLXNsaWRlQmFyRmlsbFwiPjwvZGl2PicpO1xuICAgICAgICBsZXQgc2xpZGVCYXJIYW5kU2hhbmsgPSAkKCc8ZGl2IGNsYXNzPVwiQUNIdG1sNVBsYXllci1zbGlkZUJhckhhbmRTaGFua1wiPjwvZGl2PicpO1xuICAgICAgICBzbGlkZUJhckZpbGxFbGVtZW50LmFwcGVuZChzbGlkZUJhckhhbmRTaGFuayk7XG4gICAgICAgIFNsaWRlQmFyRWxlbWVudC5hcHBlbmQoc2xpZGVCYXJGaWxsRWxlbWVudCk7XG4gICAgICAgICQoZWxlbWVudCkuYXBwZW5kKFNsaWRlQmFyRWxlbWVudCk7XG5cbiAgICAgICAgbGV0IG1vdXNlZG93biA9IGZhbHNlO1xuICAgICAgICBzbGlkZUJhckhhbmRTaGFuay5tb3VzZWRvd24oKCkgPT4ge1xuICAgICAgICAgICAgbW91c2Vkb3duID0gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IF92YWx1ZSA9IDA7XG5cbiAgICAgICAgbGV0IF9ldmVudCA9IG5ldyBFdmVudCgpO1xuICAgICAgICBfZXZlbnQuYWRkKCd2YWx1ZWNoYW5nZWQnKTtcbiAgICAgICAgX2V2ZW50LmFkZCgndmFsdWVjaGFuZ2VkYnl1aScpO1xuXG4gICAgICAgIHRoaXMuYmluZCA9IF9ldmVudC5iaW5kO1xuICAgICAgICB0aGlzLnVuYmluZCA9IF9ldmVudC51bmJpbmQ7XG5cbiAgICAgICAgJCgnYm9keScpLm1vdXNldXAoKCkgPT4ge1xuICAgICAgICAgICAgbW91c2Vkb3duID0gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICQoJ2JvZHknKS5tb3VzZWxlYXZlKCgpID0+IHtcbiAgICAgICAgICAgIG1vdXNlZG93biA9IGZhbHNlO1xuICAgICAgICB9KTtcblxuICAgICAgICAkKCdib2R5JykubW91c2Vtb3ZlKChlKSA9PiB7XG4gICAgICAgICAgICBpZiAobW91c2Vkb3duKSB7XG4gICAgICAgICAgICAgICAgaWYgKFNsaWRlQmFyRWxlbWVudC5pbm5lckhlaWdodCgpID09PSAwIHx8IFNsaWRlQmFyRWxlbWVudC5pbm5lcldpZHRoKCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbW91c2Vkb3duID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgWSA9IGUucGFnZVkgLSBTbGlkZUJhckVsZW1lbnQub2Zmc2V0KCkudG9wO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IDEgLSBZIC8gU2xpZGVCYXJFbGVtZW50LmlubmVySGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IFggPSBlLnBhZ2VYIC0gU2xpZGVCYXJFbGVtZW50Lm9mZnNldCgpLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gWCAvIFNsaWRlQmFyRWxlbWVudC5pbm5lcldpZHRoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF92YWx1ZSA9IHZhbHVlID4gMSA/IDEgOiB2YWx1ZSA8IDAgPyAwIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoX3ZhbHVlKTtcbiAgICAgICAgICAgICAgICBfZXZlbnQudHJpZ2dlcigndmFsdWVjaGFuZ2VkYnl1aScsIHsgdmFsdWU6IF92YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgU2xpZGVCYXJFbGVtZW50LmNsaWNrKChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoU2xpZGVCYXJFbGVtZW50LmhlaWdodCgpID09PSAwIHx8IFNsaWRlQmFyRWxlbWVudC53aWR0aCgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbW91c2Vkb3duID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgbGV0IFkgPSBlLnBhZ2VZIC0gU2xpZGVCYXJFbGVtZW50Lm9mZnNldCgpLnRvcDtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IDEgLSBZIC8gU2xpZGVCYXJFbGVtZW50LmlubmVySGVpZ2h0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBYID0gZS5wYWdlWCAtIFNsaWRlQmFyRWxlbWVudC5vZmZzZXQoKS5sZWZ0O1xuICAgICAgICAgICAgICAgIHZhbHVlID0gWCAvIFNsaWRlQmFyRWxlbWVudC5pbm5lcldpZHRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdmFsdWUgPSB2YWx1ZSA+IDEgPyAxIDogdmFsdWUgPCAwID8gMCA6IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5zZXQoX3ZhbHVlKTtcbiAgICAgICAgICAgIF9ldmVudC50cmlnZ2VyKCd2YWx1ZWNoYW5nZWRieXVpJywgeyB2YWx1ZTogX3ZhbHVlIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnNldCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnbnVtYmVyJyB8fCBpc05hTih2YWx1ZSkgfHwgdmFsdWUgPiAxIHx8IHZhbHVlIDwgMCkgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgaWYgKHZlcnRpY2FsKSBzbGlkZUJhckZpbGxFbGVtZW50LmNzcygnaGVpZ2h0JywgdmFsdWUgKiAxMDAgKyAnJScpO1xuICAgICAgICAgICAgZWxzZSBzbGlkZUJhckZpbGxFbGVtZW50LmNzcygnd2lkdGgnLCB2YWx1ZSAqIDEwMCArICclJyk7XG4gICAgICAgICAgICBfZXZlbnQudHJpZ2dlcigndmFsdWVjaGFuZ2VkJywgeyB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdldCA9ICgpID0+IF92YWx1ZTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IFNsaWRlQmFyIH0iLCJpbXBvcnQgeyBIZWxwZXIgfSBmcm9tICcuL2xpYi9oZWxwZXInXG5pbXBvcnQgeyBTbGlkZUJhciB9IGZyb20gJy4vbGliL3NsaWRlQmFyJ1xuaW1wb3J0IEVtb3RpY29ucyBmcm9tICcuL2Vtb3RpY29ucy5qc29uJ1xuaW1wb3J0IFBlcmZlY3RTY3JvbGxiYXIgZnJvbSAncGVyZmVjdC1zY3JvbGxiYXInXG5cbmxldCAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG4kID0gcmVxdWlyZSgndG9vbHRpcHN0ZXInKTtcblxuY29uc3QgcXVhbGl0eU5hbWUgPSBbXG4gICAgJ+agh+a4hScsXG4gICAgJ+mrmOa4hScsXG4gICAgJ+i2hea4hScsXG4gICAgJzEwODBwJ1xuXVxuXG5sZXQgTG9hZFVJID0gKHBsYXllciwgY292ZXJJbWFnZSkgPT4ge1xuXG4gICAgJCgnI3BsYXllcicpLmNzcygncG9zaXRpb24nLCAnJyk7XG4gICAgJCgnLm5vZmxhc2gtYWxlcnQnKS5yZW1vdmUoKTtcbiAgICAkKCcjQUNIdG1sNVBsYXllcl9sb2FkaW5nQ292ZXInKS5jc3MoJ2JhY2tncm91bmQtaW1hZ2UnLCBgdXJsKCR7Y292ZXJJbWFnZX0pYCk7XG5cbiAgICBjb25zdCBidWxsZXRTY3JlZW5TY3JvbGxiYXIgPSBuZXcgUGVyZmVjdFNjcm9sbGJhcignLkFDSHRtbDVQbGF5ZXItYnVsbGV0U2NyZWVuU2Nyb2xseScsIHtcbiAgICAgICAgc3VwcHJlc3NTY3JvbGxYOiB0cnVlXG4gICAgfSk7XG5cbiAgICBjb25zdCBib3hFbW90aWNvbnNTY3JvbGxiYXIgPSBuZXcgUGVyZmVjdFNjcm9sbGJhcignLkFDSHRtbDVQbGF5ZXItYm94RW1vdGljb25zU2Nyb2xseScsIHtcbiAgICAgICAgc3VwcHJlc3NTY3JvbGxYOiB0cnVlXG4gICAgfSk7XG5cbiAgICBjb25zdCB2b2x1bWVTbGlkZUJhciA9IG5ldyBTbGlkZUJhcignI0FDSHRtbDVQbGF5ZXJfdm9sdW1lU2xpZGVCYXJCb3gnLCB0cnVlLCB0cnVlKTtcblxuICAgIGNvbnN0IGJ1bGxldFNjcmVlbk9wYWNpdHlTbGlkZUJhciA9IG5ldyBTbGlkZUJhcignI0FDSHRtbDVQbGF5ZXJfYnVsbGV0U2NyZWVuT3BhY2l0eVNsaWRlQmFyQm94JywgdHJ1ZSwgZmFsc2UpO1xuICAgICQoJyNBQ0h0bWw1UGxheWVyX2J1bGxldFNjcmVlbk9wYWNpdHlTbGlkZUJhckJveCAuQUNIdG1sNVBsYXllci1zbGlkZUJhckhhbmRTaGFuaycpLmFwcGVuZCgnPHNwYW4+PHNwYW4gaWQ9XCJBQ0h0bWw1UGxheWVyX2J1bGxldFNjcmVlbk9wYWNpdHlOdW1iZXJcIj4wPC9zcGFuPiU8L3NwYW4+Jyk7XG5cbiAgICBwbGF5ZXIuYmluZCgnbG9hZHN1Y2Nlc3MnLCAoKSA9PiB7XG4gICAgICAgIGxvYWRRdWFsaXR5TGlzdCgpO1xuICAgICAgICBzZXRCdG5RdWFsaXR5KCk7XG4gICAgfSk7XG5cbiAgICBwbGF5ZXIuYmluZCgnYnVsbGV0c2NyZWVuZGVzdHJveScsICgpID0+IHtcbiAgICAgICAgJCgnI0FDSHRtbDVQbGF5ZXJfYnVsbGV0U2NyZWVuTGlzdCcpLmVtcHR5KCk7XG4gICAgICAgICQoJyNBQ0h0bWw1UGxheWVyX2J1bGxldFNjcmVlbkVtcHR5Jykuc2hvdygpO1xuICAgIH0pO1xuXG4gICAgcGxheWVyLmJpbmQoJ2FkYXB0ZXJkZXN0cm95JywgKCkgPT4ge1xuICAgICAgICAkKCcjQUNGbGFzaFBsYXllcicpLnJlbW92ZSgpO1xuICAgICAgICAkKCcjQUNIdG1sNVBsYXllcl9sb2FkaW5nU2hhZGUnKS5zaG93KCk7XG4gICAgfSk7XG5cbiAgICBwbGF5ZXIuYmluZCgnbG9hZGVkbWV0YWRhdGEnLCAoKSA9PiB7XG4gICAgICAgIHNldEJ0bk5leHQoKTtcbiAgICAgICAgJCgnI0FDSHRtbDVQbGF5ZXJfbG9hZGluZ1NoYWRlJykuaGlkZSgpO1xuICAgICAgICAkKCcjQUNIdG1sNVBsYXllcl9hY2Z1blBsYXlQYXVzZUFuaW1hdGUnKS5hZGRDbGFzcygnQUNIdG1sNVBsYXllci1hY2Z1blBsYXlQYXVzZUFuaW1hdGUtc2hvdycpO1xuICAgIH0pO1xuXG4gICAgcGxheWVyLmJpbmQoJ3BsYXknLCAoKSA9PiB7XG4gICAgICAgICQoJyNBQ0h0bWw1UGxheWVyX2J0blBsYXlQYXVzZScpLnJlbW92ZUNsYXNzKCdBQ0h0bWw1UGxheWVyLXJlc291cmNlLXBsYXknKTtcbiAgICAgICAgJCgnI0FDSHRtbDVQbGF5ZXJfYnRuUGxheVBhdXNlJykuYWRkQ2xhc3MoJ0FDSHRtbDVQbGF5ZXItcmVzb3VyY2UtcGF1c2UnKTtcbiAgICAgICAgJCgnI0FDSHRtbDVQbGF5ZXJfYWNmdW5QbGF5UGF1c2VBbmltYXRlJykucmVtb3ZlQ2xhc3MoJ0FDSHRtbDVQbGF5ZXItYWNmdW5QbGF5UGF1c2VBbmltYXRlLXNob3cnKTtcbiAgICAgICAgJCgnI0FDSHRtbDVQbGF5ZXJfYWNmdW5QbGF5UGF1c2VBbmltYXRlJykuYWRkQ2xhc3MoJ0FDSHRtbDVQbGF5ZXItYWNmdW5QbGF5UGF1c2VBbmltYXRlLWhpZGUnKTtcbiAgICB9KTtcblxuICAgIGxldCBfcGF1c2VFdmVudCA9ICgpID0+IHtcbiAgICAgICAgJCgnI0FDSHRtbDVQbGF5ZXJfYnRuUGxheVBhdXNlJykucmVtb3ZlQ2xhc3MoJ0FDSHRtbDVQbGF5ZXItcmVzb3VyY2UtcGF1c2UnKTtcbiAgICAgICAgJCgnI0FDSHRtbDVQbGF5ZXJfYnRuUGxheVBhdXNlJykuYWRkQ2xhc3MoJ0FDSHRtbDVQbGF5ZXItcmVzb3VyY2UtcGxheScpO1xuICAgICAgICAkKCcjQUNIdG1sNVBsYXllcl9hY2Z1blBsYXlQYXVzZUFuaW1hdGUnKS5yZW1vdmVDbGFzcygnQUNIdG1sNVBsYXllci1hY2Z1blBsYXlQYXVzZUFuaW1hdGUtaGlkZScpO1xuICAgICAgICAkKCcjQUNIdG1sNVBsYXllcl9hY2Z1blBsYXlQYXVzZUFuaW1hdGUnKS5hZGRDbGFzcygnQUNIdG1sNVBsYXllci1hY2Z1blBsYXlQYXVzZUFuaW1hdGUtc2hvdycpO1xuICAgIH1cblxuICAgIHBsYXllci5iaW5kKCdlbXB0aWVkJywgX3BhdXNlRXZlbnQpO1xuXG4gICAgcGxheWVyLmJpbmQoJ3BhdXNlJywgX3BhdXNlRXZlbnQpO1xuXG4gICAgcGxheWVyLmJpbmQoJ2N1cnJlbnR0aW1lY2hhbmdlZCcsIChlKSA9PiB7XG4gICAgICAgICQoJyNBQ0h0bWw1UGxheWVyX3RleHRDdXJyZW50VGltZScpLnRleHQoZS5jdXJyZW50VGltZVRleHQpO1xuICAgICAgICAkKCcjQUNIdG1sNVBsYXllcl90ZXh0RHVyYXRpb24nKS50ZXh0KGUuZHVyYXRpb25UZXh0KTtcbiAgICAgICAgJCgnI0FDSHRtbDVQbGF5ZXJfcHJvZ3Jlc3NCYXJCdWZmZXInKS5jc3MoJ3dpZHRoJywgYCR7ZS5idWZmZXJQZXJjZW50fSVgKTtcbiAgICAgICAgaWYgKHByb2dyZXNzTW91c2Vkb3duKSByZXR1cm47XG4gICAgICAgICQoJyNBQ0h0bWw1UGxheWVyX3Byb2dyZXNzQmFyQ29tcGxldGUnKS5jc3MoJ3dpZHRoJywgYCR7ZS5wZXJjZW50fSVgKTtcbiAgICB9KTtcblxuICAgIHBsYXllci5iaW5kKCdidWxsZXRzY3JlZW5jb3VudGNoYW5nZWQnLCAoZSkgPT4ge1xuICAgICAgICAkKCcuZGFubXUuZmwgPiAuc3AyJykudGV4dChlLmJ1bGxldFNjcmVlbkNvdW50VGV4dCk7XG4gICAgICAgICQoJyNBQ0h0bWw1UGxheWVyX2J1bGxldFNjcmVlbkNvdW50JykudGV4dChlLmJ1bGxldFNjcmVlbkNvdW50VGV4dCk7XG4gICAgfSk7XG5cbiAgICBwbGF5ZXIuYmluZCgnb25saW5ldXNlcnNjb3VudGNoYW5nZWQnLCAoZSkgPT4ge1xuICAgICAgICAkKCcjQUNIdG1sNVBsYXllcl9vbmxpbmVVc2Vyc0NvdW50JykudGV4dChlLm9ubGluZVVzZXJzQ291bnRUZXh0KTtcbiAgICB9KTtcblxuICAgIHBsYXllci5iaW5kKCdhY3dlYnNvY2tldHN0YXR1c2NoYW5nZWQnLCAoZSkgPT4ge1xuICAgICAgICBpZiAoZS5uZXdTdGF0dXMgPT09ICdjb25uZWN0ZWQnKSAkKCcjQUNIdG1sNVBsYXllcl9idG5CdWxsZXRTY3JlZW5TZW5kJykucmVtb3ZlQ2xhc3MoJ2Rpc2FibGUnKTtcbiAgICAgICAgZWxzZSAkKCcjQUNIdG1sNVBsYXllcl9idG5CdWxsZXRTY3JlZW5TZW5kJykuYWRkQ2xhc3MoJ2Rpc2FibGUnKTtcbiAgICB9KTtcblxuICAgIHBsYXllci5iaW5kKCdxdWFsaXR5c3dpdGNoaW5nJywgKGUpID0+IHtcbiAgICAgICAgc2V0QnRuUXVhbGl0eShlLnF1YWxpdHlJbmRleCk7XG4gICAgfSk7XG5cbiAgICBwbGF5ZXIuYmluZCgncXVhbGl0eXN3aXRjaGVkJywgKGUpID0+IHtcbiAgICAgICAgc2V0QnRuUXVhbGl0eShlLnF1YWxpdHlJbmRleCk7XG4gICAgfSk7XG40XG4gICAgcGxheWVyLmJpbmQoJ2FkZGJ1bGxldHNjcmVlbnMnLCAoZSkgPT4ge1xuICAgICAgICBpZiAoZS5jbGVhbk9sZCkge1xuICAgICAgICAgICAgJCgnI0FDSHRtbDVQbGF5ZXJfYnVsbGV0U2NyZWVuTGlzdCcpLmVtcHR5KCk7XG4gICAgICAgICAgICAkKCcjQUNIdG1sNVBsYXllcl9idWxsZXRTY3JlZW5FbXB0eScpLnNob3coKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS5uZXdCdWxsZXRTY3JlZW5zLmxlbmd0aCA+IDApICQoJyNBQ0h0bWw1UGxheWVyX2J1bGxldFNjcmVlbkVtcHR5JykuaGlkZSgpO1xuICAgICAgICBmb3IgKGxldCBidWxsZXRTY3JlZW4gb2YgZS5uZXdCdWxsZXRTY3JlZW5zKSB7XG4gICAgICAgICAgICBsZXQgdHIgPSAkKCc8dHI+PC90cj4nKTtcbiAgICAgICAgICAgIHRyLmF0dHIoJ2RhdGEtdXVpZCcsIGJ1bGxldFNjcmVlbi51dWlkKTtcbiAgICAgICAgICAgIHRyLmF0dHIoJ2RhdGEtdXNlcmlkJywgYnVsbGV0U2NyZWVuLnVzZXJpZCk7XG4gICAgICAgICAgICB0ci5hdHRyKCdkYXRhLXN0YXJ0dGltZScsIGJ1bGxldFNjcmVlbi5zdGFydFRpbWUpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0VGltZVRoID0gJCgnPHRoIHN0eWxlPVwid2lkdGg6NDVweDt0ZXh0LWFsaWduOmNlbnRlclwiIGNsYXNzPVwiQUNIdG1sNVBsYXllci10ZXh0VG9vbHRpcFwiPjwvdGg+Jyk7XG4gICAgICAgICAgICBzdGFydFRpbWVUaC50ZXh0KGJ1bGxldFNjcmVlbi5zdGFydFRpbWVUZXh0KTtcbiAgICAgICAgICAgIHN0YXJ0VGltZVRoLmF0dHIoJ3RpdGxlJywgYnVsbGV0U2NyZWVuLnN0YXJ0VGltZVRleHQpO1xuICAgICAgICAgICAgdHIuYXBwZW5kKHN0YXJ0VGltZVRoKTtcbiAgICAgICAgICAgIGxldCB0ZXh0VGggPSAkKCc8dGggY2xhc3M9XCJBQ0h0bWw1UGxheWVyLXRleHRUb29sdGlwXCI+PC90aD4nKTtcbiAgICAgICAgICAgIHRleHRUaC50ZXh0KGJ1bGxldFNjcmVlbi50ZXh0KTtcbiAgICAgICAgICAgIHRleHRUaC5hdHRyKCd0aXRsZScsIGJ1bGxldFNjcmVlbi50ZXh0KTtcbiAgICAgICAgICAgIHRyLmFwcGVuZCh0ZXh0VGgpO1xuICAgICAgICAgICAgJCgnI0FDSHRtbDVQbGF5ZXJfYnVsbGV0U2NyZWVuTGlzdCcpLnByZXBlbmQodHIpO1xuICAgICAgICB9XG4gICAgICAgIGJ1bGxldFNjcmVlblNjcm9sbGJhci51cGRhdGUoKTtcbiAgICAgICAgbG9hZFRleHRUb29sVGlwKCk7XG4gICAgfSk7XG5cbiAgICBwbGF5ZXIuYmluZCgndm9sdW1lb3JtdXRlZGNoYW5nZWQnLCAoZSkgPT4ge1xuICAgICAgICBzZXRWb2xtdWVBbmRNdXRlZChlLnZvbHVtZSwgZS5tdXRlZCk7XG4gICAgfSk7XG5cbiAgICBwbGF5ZXIuYmluZCgncmF0ZWNoYW5nZWQnLCAoZSkgPT4ge1xuICAgICAgICAkKCcjQUNIdG1sNVBsYXllcl9idG5TcGVlZCA+IHNwYW4nKS50ZXh0KGUucGxheWJhY2tSYXRlID09PSAxID8gJ+WAjemAnycgOiBgJHtlLnBsYXliYWNrUmF0ZX3lgI1gKTtcbiAgICB9KTtcblxuICAgIGJ1bGxldFNjcmVlbk9wYWNpdHlTbGlkZUJhci5iaW5kKCd2YWx1ZWNoYW5nZWQnLCAoZSkgPT4ge1xuICAgICAgICAkKCcjQUNIdG1sNVBsYXllcl9idWxsZXRTY3JlZW5PcGFjaXR5TnVtYmVyJykudGV4dChNYXRoLnJvdW5kKGUudmFsdWUgKiAxMDApKTtcbiAgICB9KTtcblxuICAgIGJ1bGxldFNjcmVlbk9wYWNpdHlTbGlkZUJhci5iaW5kKCd2YWx1ZWNoYW5nZWRieXVpJywgKGUpID0+IHtcbiAgICAgICAgcGxheWVyLnNldEJ1bGxldFNjcmVlbk9wYWNpdHkoZS52YWx1ZSk7XG4gICAgfSk7XG5cbiAgICB2b2x1bWVTbGlkZUJhci5iaW5kKCd2YWx1ZWNoYW5nZWQnLCAoZSkgPT4ge1xuICAgICAgICAkKCcjQUNIdG1sNVBsYXllcl92b2x1bWVOdW1iZXInKS50ZXh0KE1hdGgucm91bmQoZS52YWx1ZSAqIDEwMCkpO1xuICAgIH0pO1xuXG4gICAgdm9sdW1lU2xpZGVCYXIuYmluZCgndmFsdWVjaGFuZ2VkYnl1aScsIChlKSA9PiB7XG4gICAgICAgIHBsYXllci5zZXRWb2x1bWUoZS52YWx1ZSk7XG4gICAgfSk7XG5cbiAgICAvL+W/q+aNt+mUruaUr+aMgVxuICAgICQoJyNBQ0h0bWw1UGxheWVyJykua2V5cHJlc3MoKGUpID0+IHtcbiAgICAgICAgaWYgKGUudGFyZ2V0LmlkID09PSAnQUNIdG1sNVBsYXllcl9idWxsZXRTY3JlZW5JbnB1dCcpIHJldHVybiB0cnVlO1xuICAgICAgICBzd2l0Y2ggKGUud2hpY2gpIHtcbiAgICAgICAgICAgIGNhc2UgMzI6IC8v56m65qC8IOaaguWBnFxuICAgICAgICAgICAgICAgIHBsYXllci5jaGFuZ2VQbGF5U3RhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDEzOiAvL+Wbnui9piDlvLnluZXovpPlhaXnhKbngrlcbiAgICAgICAgICAgICAgICAkKCcjQUNIdG1sNVBsYXllcl9idWxsZXRTY3JlZW5JbnB1dCcpLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSA2NzogLy9DIOaYvuekui/pmpDol4/lvLnluZVcbiAgICAgICAgICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXIuY2hhbmdlQnVsbGV0U2NyZWVuVmlzaWJpbGl0eSgpO1xuICAgICAgICAgICAgICAgICAgICBzZXRCdG5CdWxsZXRTY3JlZW5JY29uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDc5OiAvL08g5byA5ZCvL+WFs+mXreW+queOr1xuICAgICAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci5zZXRMb29wKCFwbGF5ZXIuZ2V0TG9vcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0QnRuTG9vcEljb24oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNzc6IC8vTSDlvIDlkK8v5YWz6Zet6Z2Z6Z+zXG4gICAgICAgICAgICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyLnNldE11dGVkKCFwbGF5ZXIuZ2V0TXV0ZWQoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDcwOiAvL0Yg5omT5byAL+WFs+mXreWFqOWxj1xuICAgICAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUZ1bGxTY3JlZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgODE6IC8vUSDmuIXnqbrlsY/luZXlvLnluZVcbiAgICAgICAgICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXIuY2xlYW5CdWxsZXRTY3JlZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgOTA6IC8vWiDlsZXlvIAv5pS26LW35by55bmV5rGgXG4gICAgICAgICAgICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRm9sZFZpc2liaWxpdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICAkKCcjQUNIdG1sNVBsYXllcicpLmtleWRvd24oKGUpID0+IHtcbiAgICAgICAgaWYgKGUudGFyZ2V0LmlkID09PSAnQUNIdG1sNVBsYXllcl9idWxsZXRTY3JlZW5JbnB1dCcpIHJldHVybiB0cnVlO1xuICAgICAgICBzd2l0Y2ggKGUud2hpY2gpIHtcbiAgICAgICAgICAgIGNhc2UgMzc6IC8v5bem5pa55ZCR6ZSuIOW/q+mAgFxuICAgICAgICAgICAgICAgIGlmIChlLmN0cmxLZXkpIHBsYXllci5zZXRDdXJyZW50VGltZShwbGF5ZXIuZ2V0Q3VycmVudFRpbWUoKSAtIDIwKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlLnNoaWZ0S2V5KSBwbGF5ZXIuc2V0Q3VycmVudFRpbWUocGxheWVyLmdldEN1cnJlbnRUaW1lKCkgLSAzMCk7XG4gICAgICAgICAgICAgICAgZWxzZSBwbGF5ZXIuc2V0Q3VycmVudFRpbWUocGxheWVyLmdldEN1cnJlbnRUaW1lKCkgLSAxMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSAzOTogLy/lj7PmlrnlkJHplK4g5b+r6L+bXG4gICAgICAgICAgICAgICAgaWYgKGUuY3RybEtleSkgcGxheWVyLnNldEN1cnJlbnRUaW1lKHBsYXllci5nZXRDdXJyZW50VGltZSgpICsgMjApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGUuc2hpZnRLZXkpIHBsYXllci5zZXRDdXJyZW50VGltZShwbGF5ZXIuZ2V0Q3VycmVudFRpbWUoKSArIDMwKTtcbiAgICAgICAgICAgICAgICBlbHNlIHBsYXllci5zZXRDdXJyZW50VGltZShwbGF5ZXIuZ2V0Q3VycmVudFRpbWUoKSArIDEwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDM4OiAvL+S4iuaWueWQkemUriDlop7lpKfpn7Pph49cbiAgICAgICAgICAgICAgICBwbGF5ZXIuc2V0Vm9sdW1lKHBsYXllci5nZXRWb2x1bWUoKSArIDAuMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSA0MDogLy/kuIvmlrnlkJHplK4g5YeP5bCP6Z+z6YePXG4gICAgICAgICAgICAgICAgcGxheWVyLnNldFZvbHVtZShwbGF5ZXIuZ2V0Vm9sdW1lKCkgLSAwLjEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICAkKCcjQUNIdG1sNVBsYXllcl9idWxsZXRTY3JlZW5JbnB1dCcpLmtleWRvd24oKGUpID0+IHtcbiAgICAgICAgaWYgKGUud2hpY2ggPT09IDI3KSAvL0VzY1xuICAgICAgICB7XG4gICAgICAgICAgICAkKCcjQUNIdG1sNVBsYXllcicpLmZvY3VzKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICAkKCcjQUNIdG1sNVBsYXllcl9idG5Wb2x1bWUnKS5jbGljayhmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS50YXJnZXQgIT0gdGhpcykgcmV0dXJuO1xuICAgICAgICBwbGF5ZXIuc2V0TXV0ZWQoIXBsYXllci5nZXRNdXRlZCgpKTtcbiAgICB9KTtcblxuICAgICQoJyNBQ0h0bWw1UGxheWVyX2J1bGxldFNjcmVlbkxpc3QnKS5jbGljaygoZSkgPT4ge1xuICAgICAgICBpZiAoZS50YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndGgnKSBwbGF5ZXIuc2V0Q3VycmVudFRpbWUocGFyc2VGbG9hdCgkKGUudGFyZ2V0KS5wYXJlbnQoJ3RyJykuZGF0YSgnc3RhcnR0aW1lJykpKTtcbiAgICB9KTtcblxuICAgICQoJyNBQ0h0bWw1UGxheWVyX2FjZnVuUGxheVBhdXNlQW5pbWF0ZScpLmNsaWNrKChlKSA9PiB7XG4gICAgICAgIGlmICgkKGUudGFyZ2V0KS5oYXNDbGFzcygnQUNIdG1sNVBsYXllci1hY2Z1blBsYXlQYXVzZUFuaW1hdGUtc2hvdycpKSBwbGF5ZXIuY2hhbmdlUGxheVN0YXRlKCk7XG4gICAgfSk7XG5cbiAgICAkKCcjQUNIdG1sNVBsYXllcl9idG5QbGF5UGF1c2UnKS5jbGljaygoKSA9PiB7XG4gICAgICAgIHBsYXllci5jaGFuZ2VQbGF5U3RhdGUoKTtcbiAgICB9KTtcblxuICAgICQoJyNBQ0h0bWw1UGxheWVyX2J0bk5leHQnKS5jbGljaygoKSA9PiB7XG4gICAgICAgIHBsYXllci5wbGF5TmV4dFBhcnQoKTtcbiAgICB9KTtcblxuICAgIC8v5Yy65YiG5Y2V5Ye75ZKM5Y+M5Ye75LqL5Lu2XG4gICAgbGV0IGJ1bGxldFNjcmVlbnNDbGlja1RpbWVyID0gbnVsbDtcbiAgICAkKCcjQUNIdG1sNVBsYXllcl9idWxsZXRTY3JlZW5zJykuY2xpY2soKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQoYnVsbGV0U2NyZWVuc0NsaWNrVGltZXIpO1xuICAgICAgICBidWxsZXRTY3JlZW5zQ2xpY2tUaW1lciA9IHNldFRpbWVvdXQocGxheWVyLmNoYW5nZVBsYXlTdGF0ZSwgNTAwKTtcbiAgICB9KTtcblxuICAgICQoJyNBQ0h0bWw1UGxheWVyX2J1bGxldFNjcmVlbnMnKS5kYmxjbGljaygoZSkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQoYnVsbGV0U2NyZWVuc0NsaWNrVGltZXIpO1xuICAgICAgICBjaGFuZ2VGdWxsU2NyZWVuKCk7XG4gICAgfSk7XG5cbiAgICAkKCcjQUNIdG1sNVBsYXllcl9idG5CdWxsZXRTY3JlZW4nKS5jbGljayhmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLnRhcmdldCAhPSB0aGlzKSByZXR1cm47XG4gICAgICAgIHBsYXllci5jaGFuZ2VCdWxsZXRTY3JlZW5WaXNpYmlsaXR5KCk7XG4gICAgICAgIHNldEJ0bkJ1bGxldFNjcmVlbkljb24oKTtcbiAgICB9KTtcblxuICAgICQoJyNBQ0h0bWw1UGxheWVyX2J0bkxvb3AnKS5jbGljaygoKSA9PiB7XG4gICAgICAgIHBsYXllci5zZXRMb29wKCFwbGF5ZXIuZ2V0TG9vcCgpKTtcbiAgICAgICAgc2V0QnRuTG9vcEljb24oKTtcbiAgICB9KTtcblxuICAgICQoJyNBQ0h0bWw1UGxheWVyX2J1bGxldFNjcmVlblNlbmRGb3JtJykuc3VibWl0KChlKSA9PiB7XG4gICAgICAgIGxldCBidG4gPSAkKCcjQUNIdG1sNVBsYXllcl9idG5CdWxsZXRTY3JlZW5TZW5kJyk7XG4gICAgICAgIGlmIChidG4uaGFzQ2xhc3MoJ2Rpc2FibGUnKSB8fCBidG4uaGFzQ2xhc3MoJ2NvdW50ZG93bicpKSByZXR1cm47XG4gICAgICAgIGxldCBjb3VudGRvd25OdW1iZXIgPSAzO1xuICAgICAgICBsZXQgY291bnRkb3duID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvdW50ZG93bk51bWJlciA9PT0gMCkgYnRuLnJlbW92ZUNsYXNzKCdjb3VudGRvd24nKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICQoJyNBQ0h0bWw1UGxheWVyX2J0bkJ1bGxldFNjcmVlblNlbmRfY291bnRkb3duTnVtYmVyJykudGV4dChjb3VudGRvd25OdW1iZXItLSk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChjb3VudGRvd24sIDEwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJ0bi5hZGRDbGFzcygnY291bnRkb3duJyk7XG4gICAgICAgIGNvdW50ZG93bigpO1xuICAgICAgICBwbGF5ZXIuc2VuZGJ1bGxldFNjcmVlbihuZXcgRm9ybURhdGEoJCgnI0FDSHRtbDVQbGF5ZXJfYnVsbGV0U2NyZWVuU2VuZEZvcm0nKVswXSkpO1xuICAgICAgICAkKCcjQUNIdG1sNVBsYXllcl9idWxsZXRTY3JlZW5TZW5kRm9ybSBpbnB1dFtuYW1lPVwidGV4dFwiXScpLnZhbCgnJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcblxuICAgICQoJyNBQ0h0bWw1UGxheWVyX3F1YWxpdHlMaXN0JykuY2xpY2soKGUpID0+IHtcbiAgICAgICAgaWYgKGUudGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2xpJykge1xuICAgICAgICAgICAgbGV0IHF1YWxpdHlJbmRleCA9ICQoZS50YXJnZXQpLmRhdGEoJ2luZGV4Jyk7XG4gICAgICAgICAgICBwbGF5ZXIuc2V0UXVhbGl0eUluZGV4KHF1YWxpdHlJbmRleCk7XG4gICAgICAgICAgICAkKCcjQUNIdG1sNVBsYXllcl9idG5RdWFsaXR5ID4gc3BhbicpLnRleHQocXVhbGl0eUluZGV4ID09PSAtMSA/IGDoh6rliqjvvIgke3F1YWxpdHlOYW1lW3BsYXllci5nZXRRdWFsaXR5SW5kZXgoKV1977yJYCA6IHF1YWxpdHlOYW1lW3F1YWxpdHlJbmRleF0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkKCcjQUNIdG1sNVBsYXllcl9zcGVlZExpc3QnKS5jbGljaygoZSkgPT4ge1xuICAgICAgICBpZiAoZS50YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnbGknKSBwbGF5ZXIuc2V0UGxheWJhY2tSYXRlKCQoZS50YXJnZXQpLmRhdGEoJ3JhdGUnKSk7XG4gICAgfSk7XG5cbiAgICAkKCcjQUNIdG1sNVBsYXllcl9ib3hFbW90aWNvbnMnKS5jbGljaygoZSkgPT4ge1xuICAgICAgICBpZiAoJChlLnRhcmdldCkuaGFzQ2xhc3MoJ0FDSHRtbDVQbGF5ZXItYnRuRW1vdGljb25zJykpIHtcbiAgICAgICAgICAgIGxldCBpbnB1dCA9ICQoJyNBQ0h0bWw1UGxheWVyX2J1bGxldFNjcmVlblNlbmRGb3JtIGlucHV0W25hbWU9XCJ0ZXh0XCJdJyk7XG4gICAgICAgICAgICBpbnB1dC52YWwoaW5wdXQudmFsKCkgKyAkKGUudGFyZ2V0KS50ZXh0KCkpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkKCcjQUNIdG1sNVBsYXllcl9mb2xkQmFyJykuY2xpY2soY2hhbmdlRm9sZFZpc2liaWxpdHkpO1xuXG4gICAgJCgnI0FDSHRtbDVQbGF5ZXJfcG9wdXBCdWxsZXRTY3JlZW5Gb3JtJykuY2xpY2soKCkgPT4ge1xuICAgICAgICBsZXQgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoJCgnI0FDSHRtbDVQbGF5ZXJfcG9wdXBCdWxsZXRTY3JlZW5Gb3JtJylbMF0pO1xuICAgICAgICBsZXQgaGlkZGVuVHlwZXNMaXN0ID0gZm9ybURhdGEuZ2V0QWxsKCdoaWRkZW5UeXBlcycpO1xuICAgICAgICBsZXQgaGlkZGVuVHlwZXMgPSAwO1xuICAgICAgICBmb3IgKGxldCBpbmRleCBpbiBoaWRkZW5UeXBlc0xpc3QpIGhpZGRlblR5cGVzICs9IHBhcnNlSW50KGhpZGRlblR5cGVzTGlzdFtpbmRleF0pO1xuICAgICAgICBwbGF5ZXIuc2V0QnVsbGV0U2NyZWVuSGlkZGVuVHlwZXMoaGlkZGVuVHlwZXMpO1xuICAgIH0pO1xuXG4gICAgJCgnI0FDSHRtbDVQbGF5ZXJfcHJvZ3Jlc3NCYXInKS5jbGljaygoZSkgPT4ge1xuICAgICAgICBpZiAoJChlLnRhcmdldCkuaGFzQ2xhc3MoJ0FDSHRtbDVQbGF5ZXItcHJvZ3Jlc3NCYXJUaXAnKSB8fCAkKGUudGFyZ2V0KS5oYXNDbGFzcygnQUNIdG1sNVBsYXllci1wcm9ncmVzc0JhckhhbmRTaGFuaycpKSByZXR1cm47XG4gICAgICAgIGxldCB0aW1lID0gcGFyc2VGbG9hdCgkKCcjQUNIdG1sNVBsYXllcl9wcm9ncmVzc0JhclRpcCcpLmF0dHIoJ2RhdGEtdGltZScpKTtcbiAgICAgICAgaWYgKGlzTmFOKHRpbWUpKSByZXR1cm47XG4gICAgICAgIHBsYXllci5zZXRDdXJyZW50VGltZSh0aW1lKTtcbiAgICB9KTtcblxuICAgICQoJyNBQ0h0bWw1UGxheWVyX3Byb2dyZXNzQmFyJykubW91c2Vtb3ZlKChlKSA9PiB7XG4gICAgICAgIGlmICgkKGUudGFyZ2V0KS5oYXNDbGFzcygnQUNIdG1sNVBsYXllci1wcm9ncmVzc0JhclRpcCcpKSByZXR1cm47XG4gICAgICAgIGxldCBwcm9ncmVzc0JhckRpdiA9ICQoJyNBQ0h0bWw1UGxheWVyX3Byb2dyZXNzQmFyJyksIHByb2dyZXNzQmFyVGlwRGl2ID0gJCgnI0FDSHRtbDVQbGF5ZXJfcHJvZ3Jlc3NCYXJUaXAnKTtcbiAgICAgICAgbGV0IHByb2dyZXNzQmFyVGlwRGl2T3V0ZXJXaWR0aCA9IHByb2dyZXNzQmFyVGlwRGl2Lm91dGVyV2lkdGgoKSwgcHJvZ3Jlc3NCYXJEaXZXaWR0aCA9IHByb2dyZXNzQmFyRGl2LndpZHRoKCk7XG4gICAgICAgIGxldCBYID0gZS5wYWdlWCAtIHByb2dyZXNzQmFyRGl2Lm9mZnNldCgpLmxlZnQsIGxlZnQgPSBYIC0gcHJvZ3Jlc3NCYXJUaXBEaXZPdXRlcldpZHRoIC8gMiwgZHVyYXRpb24gPSBwbGF5ZXIuZ2V0RHVyYXRpb24oKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkdXJhdGlvbiAhPSAnbnVtYmVyJyB8fCBpc05hTihkdXJhdGlvbikgfHwgZHVyYXRpb24gPT09IDApIHByb2dyZXNzQmFyVGlwRGl2LnRleHQoJzAwOjAwJyk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHRpbWUgPSBkdXJhdGlvbiAqIFggLyBwcm9ncmVzc0JhckRpdldpZHRoO1xuICAgICAgICAgICAgcHJvZ3Jlc3NCYXJUaXBEaXYudGV4dChIZWxwZXIuZ2V0VGltZVRleHQodGltZSkpO1xuICAgICAgICAgICAgcHJvZ3Jlc3NCYXJUaXBEaXYuYXR0cignZGF0YS10aW1lJywgdGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvZ3Jlc3NCYXJUaXBEaXYuY3NzKCdsZWZ0JywgbGVmdCA8IDAgPyAwIDogbGVmdCArIHByb2dyZXNzQmFyVGlwRGl2T3V0ZXJXaWR0aCA+IHByb2dyZXNzQmFyRGl2V2lkdGggPyBwcm9ncmVzc0JhckRpdldpZHRoIC0gcHJvZ3Jlc3NCYXJUaXBEaXZPdXRlcldpZHRoIDogbGVmdCk7XG4gICAgfSk7XG5cbiAgICBsZXQgcHJvZ3Jlc3NNb3VzZWRvd247XG4gICAgJCgnI0FDSHRtbDVQbGF5ZXJfcHJvZ3Jlc3NCYXJIYW5kU2hhbmsnKS5tb3VzZWRvd24oKGUpID0+IHsgcHJvZ3Jlc3NNb3VzZWRvd24gPSB0cnVlOyBwcm9ncmVzc01vdXNlZG93bkxhc3RFdmVudCA9IGU7IH0pO1xuXG4gICAgJCgnYm9keScpLm1vdXNldXAoKCkgPT4geyBwcm9ncmVzc01vdXNlZG93biA9IGZhbHNlOyB9KTtcblxuICAgICQoJ2JvZHknKS5tb3VzZWxlYXZlKCgpID0+IHsgcHJvZ3Jlc3NNb3VzZWRvd24gPSBmYWxzZTsgfSk7XG5cbiAgICBsZXQgcHJvZ3Jlc3NNb3VzZWRvd25MYXN0RXZlbnQ7XG4gICAgJCgnYm9keScpLm1vdXNlbW92ZSgoZSkgPT4ge1xuICAgICAgICBpZiAocHJvZ3Jlc3NNb3VzZWRvd24pIHtcbiAgICAgICAgICAgIGxldCBwcm9ncmVzc0JhckRpdiA9ICQoJyNBQ0h0bWw1UGxheWVyX3Byb2dyZXNzQmFyJyk7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAoZS5wYWdlWCAtIHByb2dyZXNzQmFyRGl2Lm9mZnNldCgpLmxlZnQpIC8gcHJvZ3Jlc3NCYXJEaXYud2lkdGgoKTtcbiAgICAgICAgICAgICQoJyNBQ0h0bWw1UGxheWVyX3Byb2dyZXNzQmFyQ29tcGxldGUnKS5jc3MoJ3dpZHRoJywgYCR7dmFsdWUgKiAxMDB9JWApO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGUucGFnZVggLSBwcm9ncmVzc01vdXNlZG93bkxhc3RFdmVudC5wYWdlWCkgPD0gNSkgcmV0dXJuOyAvL+mYsum8oOagh+aKluWKqFxuICAgICAgICAgICAgcHJvZ3Jlc3NNb3VzZWRvd25MYXN0RXZlbnQgPSBlO1xuICAgICAgICAgICAgbGV0IGR1cmF0aW9uID0gcGxheWVyLmdldER1cmF0aW9uKCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGR1cmF0aW9uICE9ICdudW1iZXInIHx8IGlzTmFOKGR1cmF0aW9uKSB8fCBkdXJhdGlvbiA9PT0gMCkgcmV0dXJuO1xuICAgICAgICAgICAgcGxheWVyLnNldEN1cnJlbnRUaW1lKGR1cmF0aW9uICogdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkKCcjQUNIdG1sNVBsYXllcl9idG5GdWxsU2NyZWVuJykuY2xpY2soZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUudGFyZ2V0ICE9IHRoaXMgJiYgZS50YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9ICdpbnB1dCcpIHJldHVybjtcbiAgICAgICAgY2hhbmdlRnVsbFNjcmVlbigpO1xuICAgIH0pO1xuXG4gICAgJCgnLkFDSHRtbDVQbGF5ZXItYmFyQnV0dG9uLC5BQ0h0bWw1UGxheWVyLWJhckJ1dHRvblRvb2xUaXAnKS5jbGljayhmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS50YXJnZXQgIT0gdGhpcykgcmV0dXJuO1xuICAgICAgICBsZXQgY2xpY2tQb3B1cEJveERpdjtcbiAgICAgICAgaWYgKCQodGhpcykuaGFzQ2xhc3MoJ0FDSHRtbDVQbGF5ZXItYmFyQnV0dG9uVG9vbFRpcCcpKSBjbGlja1BvcHVwQm94RGl2ID0gJCh0aGlzKS5zaWJsaW5ncygnLkFDSHRtbDVQbGF5ZXItY2xpY2tQb3B1cEJveCcpO1xuICAgICAgICBlbHNlIGNsaWNrUG9wdXBCb3hEaXYgPSAkKHRoaXMpLmZpbmQoJy5BQ0h0bWw1UGxheWVyLWNsaWNrUG9wdXBCb3gnKTtcbiAgICAgICAgaWYgKGNsaWNrUG9wdXBCb3hEaXYubGVuZ3RoICE9IDEpIHJldHVybjtcbiAgICAgICAgaWYgKGNsaWNrUG9wdXBCb3hEaXYuY3NzKCdkaXNwbGF5JykgPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAkKCcuQUNIdG1sNVBsYXllci1jbGlja1BvcHVwQm94JykuaGlkZSgwKTtcbiAgICAgICAgICAgIGNsaWNrUG9wdXBCb3hEaXYuc2hvdygpO1xuICAgICAgICB9IGVsc2UgY2xpY2tQb3B1cEJveERpdi5oaWRlKDApO1xuICAgIH0pO1xuXG4gICAgJCgnLkFDSHRtbDVQbGF5ZXItY2xpY2tQb3B1cEJveCcpLm1vdXNlbGVhdmUoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUudGFyZ2V0ICE9IHRoaXMpIHJldHVybjtcbiAgICAgICAgJChlLnRhcmdldCkuZGVsYXkoNTAwKS5oaWRlKDApO1xuICAgIH0pO1xuXG4gICAgJCgnLkFDSHRtbDVQbGF5ZXItY2xpY2tQb3B1cEJveCcpLm1vdXNlZW50ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUudGFyZ2V0ICE9IHRoaXMpIHJldHVybjtcbiAgICAgICAgJChlLnRhcmdldCkuY2xlYXJRdWV1ZSgpO1xuICAgIH0pO1xuXG4gICAgbGV0IGNvbnRyb2xCYXJzSGlkZVRpbWVPdXQ7XG4gICAgSGVscGVyLmFkZFNjcmVlbmNoYW5nZUV2ZW50TGlzdGVuZXIoKCkgPT4ge1xuICAgICAgICBpZiAoSGVscGVyLmdldEZ1bGxzY3JlZW5FbGVtZW50KCkgPT09ICQoJyNBQ0h0bWw1UGxheWVyJylbMF0pIHtcbiAgICAgICAgICAgICQoJyNBQ0h0bWw1UGxheWVyX3Byb2dyZXNzQmFyJykucHJlcGVuZFRvKCcjQUNIdG1sNVBsYXllcl9jb250cm9sQmFycycpO1xuICAgICAgICAgICAgJCgnYm9keScpLmFkZENsYXNzKCdBQ0h0bWw1UGxheWVyLWZ1bGxTY3JlZW4nKTtcbiAgICAgICAgICAgICQoJyNBQ0h0bWw1UGxheWVyX2J1bGxldFNjcmVlblNlbmRGb3JtJykucHJlcGVuZFRvKCcjQUNIdG1sNVBsYXllcl9jb250cm9sQmFyX2NvbnRyb2wnKTtcbiAgICAgICAgICAgICQoJ2JvZHknKS5hZGRDbGFzcygnQUNIdG1sNVBsYXllci1mdWxsU2NyZWVuLWRlc2t0b3AnKTtcbiAgICAgICAgICAgICQoJyNBQ0h0bWw1UGxheWVyJykub24oJ21vdXNlbW92ZScsIGNvbnRyb2xCYXJzSGlkZU1vdXNlbW92ZUV2ZW50KTtcbiAgICAgICAgICAgIGNvbnRyb2xCYXJzSGlkZU1vdXNlbW92ZUV2ZW50KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZnVsbFNjcmVlblR5cGUgPSBuZXcgRm9ybURhdGEoJCgnI0FDSHRtbDVQbGF5ZXJfYnRuRnVsbFNjcmVlbiBmb3JtJylbMF0pLmdldCgnZnVsbFNjcmVlblR5cGUnKTtcbiAgICAgICAgICAgICQoJyNBQ0h0bWw1UGxheWVyJykub2ZmKCdtb3VzZW1vdmUnLCBjb250cm9sQmFyc0hpZGVNb3VzZW1vdmVFdmVudCk7XG4gICAgICAgICAgICBpZiAoY29udHJvbEJhcnNIaWRlVGltZU91dCkgY2xlYXJUaW1lb3V0KGNvbnRyb2xCYXJzSGlkZVRpbWVPdXQpO1xuICAgICAgICAgICAgJCgnI0FDSHRtbDVQbGF5ZXInKS5yZW1vdmVDbGFzcygnQUNIdG1sNVBsYXllci1oaWRlQ29udHJvbEJhcnMnKTtcbiAgICAgICAgICAgICQoJyNBQ0h0bWw1UGxheWVyX3Byb2dyZXNzQmFyJykuYXBwZW5kVG8oJyNBQ0h0bWw1UGxheWVyX21haW4nKTtcbiAgICAgICAgICAgICQoJ2JvZHknKS5yZW1vdmVDbGFzcygnQUNIdG1sNVBsYXllci1mdWxsU2NyZWVuLWRlc2t0b3AnKTtcbiAgICAgICAgICAgIGlmIChmdWxsU2NyZWVuVHlwZSA9PT0gJ2Rlc2t0b3AnKSB7XG4gICAgICAgICAgICAgICAgJCgnYm9keScpLnJlbW92ZUNsYXNzKCdBQ0h0bWw1UGxheWVyLWZ1bGxTY3JlZW4nKTtcbiAgICAgICAgICAgICAgICAkKCcjQUNIdG1sNVBsYXllcl9idWxsZXRTY3JlZW5TZW5kRm9ybScpLnByZXBlbmRUbygnI0FDSHRtbDVQbGF5ZXJfY29udHJvbEJhcl9idWxsZXRTY3JlZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gY29udHJvbEJhcnNIaWRlTW91c2Vtb3ZlRXZlbnQoKSB7XG4gICAgICAgICQoJyNBQ0h0bWw1UGxheWVyJykucmVtb3ZlQ2xhc3MoJ0FDSHRtbDVQbGF5ZXItaGlkZUNvbnRyb2xCYXJzJyk7XG4gICAgICAgIGlmIChjb250cm9sQmFyc0hpZGVUaW1lT3V0KSBjbGVhclRpbWVvdXQoY29udHJvbEJhcnNIaWRlVGltZU91dCk7XG4gICAgICAgIGNvbnRyb2xCYXJzSGlkZVRpbWVPdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChIZWxwZXIuZ2V0RnVsbHNjcmVlbkVsZW1lbnQoKSAhPSAkKCcjQUNIdG1sNVBsYXllcicpWzBdKSByZXR1cm47XG4gICAgICAgICAgICAkKCcjQUNIdG1sNVBsYXllcicpLmFkZENsYXNzKCdBQ0h0bWw1UGxheWVyLWhpZGVDb250cm9sQmFycycpO1xuICAgICAgICB9LCAyMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGFuZ2VGb2xkVmlzaWJpbGl0eSgpIHtcbiAgICAgICAgaWYgKCQoJyNBQ0h0bWw1UGxheWVyJykuaGFzQ2xhc3MoJ2ZvbGQnKSkgJCgnI0FDSHRtbDVQbGF5ZXInKS5yZW1vdmVDbGFzcygnZm9sZCcpO1xuICAgICAgICBlbHNlICQoJyNBQ0h0bWw1UGxheWVyJykuYWRkQ2xhc3MoJ2ZvbGQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRCdG5Mb29wSWNvbigpIHtcbiAgICAgICAgaWYgKHBsYXllci5nZXRMb29wKCkpIHtcbiAgICAgICAgICAgICQoJyNBQ0h0bWw1UGxheWVyX2J0bkxvb3AnKS5yZW1vdmVDbGFzcygnQUNIdG1sNVBsYXllci1yZXNvdXJjZS1sb29wT2ZmJyk7XG4gICAgICAgICAgICAkKCcjQUNIdG1sNVBsYXllcl9idG5Mb29wJykuYWRkQ2xhc3MoJ0FDSHRtbDVQbGF5ZXItcmVzb3VyY2UtbG9vcE9uJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkKCcjQUNIdG1sNVBsYXllcl9idG5Mb29wJykucmVtb3ZlQ2xhc3MoJ0FDSHRtbDVQbGF5ZXItcmVzb3VyY2UtbG9vcE9uJyk7XG4gICAgICAgICAgICAkKCcjQUNIdG1sNVBsYXllcl9idG5Mb29wJykuYWRkQ2xhc3MoJ0FDSHRtbDVQbGF5ZXItcmVzb3VyY2UtbG9vcE9mZicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0QnRuQnVsbGV0U2NyZWVuSWNvbigpIHtcbiAgICAgICAgaWYgKHBsYXllci5nZXRCdWxsZXRTY3JlZW5WaXNpYmlsaXR5KCkpIHtcbiAgICAgICAgICAgICQoJyNBQ0h0bWw1UGxheWVyX2J0bkJ1bGxldFNjcmVlbicpLnJlbW92ZUNsYXNzKCdBQ0h0bWw1UGxheWVyLXJlc291cmNlLWJ1bGxldFNjcmVlbk9mZicpO1xuICAgICAgICAgICAgJCgnI0FDSHRtbDVQbGF5ZXJfYnRuQnVsbGV0U2NyZWVuJykuYWRkQ2xhc3MoJ0FDSHRtbDVQbGF5ZXItcmVzb3VyY2UtYnVsbGV0U2NyZWVuT24nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQoJyNBQ0h0bWw1UGxheWVyX2J0bkJ1bGxldFNjcmVlbicpLnJlbW92ZUNsYXNzKCdBQ0h0bWw1UGxheWVyLXJlc291cmNlLWJ1bGxldFNjcmVlbk9uJyk7XG4gICAgICAgICAgICAkKCcjQUNIdG1sNVBsYXllcl9idG5CdWxsZXRTY3JlZW4nKS5hZGRDbGFzcygnQUNIdG1sNVBsYXllci1yZXNvdXJjZS1idWxsZXRTY3JlZW5PZmYnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEJ0bk5leHQoKSB7XG4gICAgICAgIGlmIChwbGF5ZXIuZ2V0SGFzTmV4dFBhcnQoKSkgJCgnI0FDSHRtbDVQbGF5ZXJfYnRuTmV4dCcpLnNob3coKTtcbiAgICAgICAgZWxzZSAkKCcjQUNIdG1sNVBsYXllcl9idG5OZXh0JykuaGlkZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFJhZGlvRnVsbFNjcmVlbigpIHtcbiAgICAgICAgJCgnI0FDSHRtbDVQbGF5ZXJfYnRuRnVsbFNjcmVlbiBmb3JtIGlucHV0W3ZhbHVlPVwiZGVza3RvcFwiXScpLnByb3AoeyBjaGVja2VkOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFZvbG11ZUFuZE11dGVkKHZvbHVtZSA9IHBsYXllci5nZXRWb2x1bWUoKSwgbXV0ZWQgPSBwbGF5ZXIuZ2V0TXV0ZWQoKSkge1xuICAgICAgICBpZiAobXV0ZWQpIHtcbiAgICAgICAgICAgICQoJyNBQ0h0bWw1UGxheWVyX2J0blZvbHVtZScpLnJlbW92ZUNsYXNzKCdBQ0h0bWw1UGxheWVyLXJlc291cmNlLXZvbHVtZScpO1xuICAgICAgICAgICAgJCgnI0FDSHRtbDVQbGF5ZXJfYnRuVm9sdW1lJykuYWRkQ2xhc3MoJ0FDSHRtbDVQbGF5ZXItcmVzb3VyY2UtbXV0ZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJCgnI0FDSHRtbDVQbGF5ZXJfYnRuVm9sdW1lJykucmVtb3ZlQ2xhc3MoJ0FDSHRtbDVQbGF5ZXItcmVzb3VyY2UtbXV0ZScpO1xuICAgICAgICAgICAgJCgnI0FDSHRtbDVQbGF5ZXJfYnRuVm9sdW1lJykuYWRkQ2xhc3MoJ0FDSHRtbDVQbGF5ZXItcmVzb3VyY2Utdm9sdW1lJyk7XG4gICAgICAgIH1cbiAgICAgICAgdm9sdW1lU2xpZGVCYXIuc2V0KHZvbHVtZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZEJ1bGxldFNjcmVlblNldHRpbmdzKCkge1xuICAgICAgICBidWxsZXRTY3JlZW5PcGFjaXR5U2xpZGVCYXIuc2V0KHBsYXllci5nZXRCdWxsZXRTY3JlZW5PcGFjaXR5KCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRRdWFsaXR5TGlzdCgpIHtcbiAgICAgICAgbGV0IHF1YWxpdHlJbmRleExpc3QgPSBwbGF5ZXIuZ2V0UXVhbGl0eUluZGV4TGlzdCgpO1xuICAgICAgICBsZXQgdWwgPSAkKCcjQUNIdG1sNVBsYXllcl9xdWFsaXR5TGlzdCcpO1xuICAgICAgICB1bC5lbXB0eSgpO1xuICAgICAgICB1bC5wcmVwZW5kKCc8bGkgZGF0YS1pbmRleD1cIi0xXCI+6Ieq5YqoPC9saT4nKTtcbiAgICAgICAgZm9yIChsZXQgcXVhbGl0eUluZGV4IG9mIHF1YWxpdHlJbmRleExpc3QpIHtcbiAgICAgICAgICAgIGxldCBsaSA9ICQoJzxsaT48L2xpPicpO1xuICAgICAgICAgICAgbGkudGV4dChxdWFsaXR5TmFtZVtxdWFsaXR5SW5kZXhdKTtcbiAgICAgICAgICAgIGxpLmF0dHIoJ2RhdGEtaW5kZXgnLCBxdWFsaXR5SW5kZXgpO1xuICAgICAgICAgICAgdWwucHJlcGVuZChsaSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkRW1vdGljb25zKCkge1xuICAgICAgICAkKCcjQUNIdG1sNVBsYXllcl9ib3hFbW90aWNvbnMnKS5lbXB0eSgpO1xuICAgICAgICBmb3IgKGxldCBlbW90aWNvbiBvZiBFbW90aWNvbnMpIHtcbiAgICAgICAgICAgIGxldCBkaXYgPSAkKCc8ZGl2IGNsYXNzPVwiQUNIdG1sNVBsYXllci1idG5FbW90aWNvbnMgQUNIdG1sNVBsYXllci10ZXh0VG9vbHRpcFwiPjwvZGl2PicpO1xuICAgICAgICAgICAgZGl2LmF0dHIoJ3RpdGxlJywgZW1vdGljb24pO1xuICAgICAgICAgICAgZGl2LnRleHQoZW1vdGljb24pO1xuICAgICAgICAgICAgJCgnI0FDSHRtbDVQbGF5ZXJfYm94RW1vdGljb25zJykuYXBwZW5kKGRpdik7XG4gICAgICAgIH1cbiAgICAgICAgbG9hZFRleHRUb29sVGlwKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0QnRuUXVhbGl0eShxdWFsaXR5SW5kZXggPSBwbGF5ZXIuZ2V0UXVhbGl0eUluZGV4KCkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBxdWFsaXR5SW5kZXggPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgICAgIGxldCBzcGFuID0gJCgnI0FDSHRtbDVQbGF5ZXJfYnRuUXVhbGl0eSA+IHNwYW4nKTtcbiAgICAgICAgaWYgKHBsYXllci5nZXRBdXRvUXVhbGl0eUVuYWJsZWQoKSkgc3Bhbi50ZXh0KGDoh6rliqjvvIgke3F1YWxpdHlOYW1lW3F1YWxpdHlJbmRleF1977yJYCk7XG4gICAgICAgIGVsc2Ugc3Bhbi50ZXh0KHF1YWxpdHlOYW1lW3F1YWxpdHlJbmRleF0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRUZXh0VG9vbFRpcCgpIHtcbiAgICAgICAgJCgnLkFDSHRtbDVQbGF5ZXItdGV4dFRvb2x0aXAnKS50b29sdGlwc3Rlcih7XG4gICAgICAgICAgICB0aGVtZTogJ3Rvb2x0aXBzdGVyLWFjZnVuJyxcbiAgICAgICAgICAgIGFycm93OiBmYWxzZSxcbiAgICAgICAgICAgIHNpZGU6ICdib3R0b20nLFxuICAgICAgICAgICAgZGVidWc6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRUb29sVGlwKCkge1xuICAgICAgICAkKCcuQUNIdG1sNVBsYXllci10b29sdGlwLC5BQ0h0bWw1UGxheWVyLWJhckJ1dHRvblRvb2xUaXAnKS50b29sdGlwc3Rlcih7XG4gICAgICAgICAgICB0aGVtZTogJ3Rvb2x0aXBzdGVyLWFjZnVuJyxcbiAgICAgICAgICAgIGFycm93OiBmYWxzZSxcbiAgICAgICAgICAgIHNpZGU6ICd0b3AnLFxuICAgICAgICAgICAgZGVidWc6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoYW5nZUZ1bGxTY3JlZW4oKSB7XG4gICAgICAgICQod2luZG93KS5zY3JvbGxUb3AoMCk7XG4gICAgICAgIGxldCBmdWxsU2NyZWVuVHlwZSA9IG5ldyBGb3JtRGF0YSgkKCcjQUNIdG1sNVBsYXllcl9idG5GdWxsU2NyZWVuIGZvcm0nKVswXSkuZ2V0KCdmdWxsU2NyZWVuVHlwZScpO1xuICAgICAgICBpZiAoZnVsbFNjcmVlblR5cGUgPT09ICdwYWdlJykge1xuICAgICAgICAgICAgaWYgKEhlbHBlci5nZXRGdWxsc2NyZWVuRWxlbWVudCgpID09PSAkKCcjQUNIdG1sNVBsYXllcicpWzBdKSBIZWxwZXIuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCQoJ2JvZHknKS5oYXNDbGFzcygnQUNIdG1sNVBsYXllci1mdWxsU2NyZWVuJykpIHtcbiAgICAgICAgICAgICAgICAkKCdib2R5JykucmVtb3ZlQ2xhc3MoJ0FDSHRtbDVQbGF5ZXItZnVsbFNjcmVlbicpXG4gICAgICAgICAgICAgICAgJCgnI0FDSHRtbDVQbGF5ZXJfYnVsbGV0U2NyZWVuU2VuZEZvcm0nKS5wcmVwZW5kVG8oJyNBQ0h0bWw1UGxheWVyX2NvbnRyb2xCYXJfYnVsbGV0U2NyZWVuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAkKCdib2R5JykuYWRkQ2xhc3MoJ0FDSHRtbDVQbGF5ZXItZnVsbFNjcmVlbicpO1xuICAgICAgICAgICAgICAgICQoJyNBQ0h0bWw1UGxheWVyX2J1bGxldFNjcmVlblNlbmRGb3JtJykucHJlcGVuZFRvKCcjQUNIdG1sNVBsYXllcl9jb250cm9sQmFyX2NvbnRyb2wnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmdWxsU2NyZWVuVHlwZSA9PT0gJ2Rlc2t0b3AnKSB7XG4gICAgICAgICAgICBpZiAoSGVscGVyLmdldEZ1bGxzY3JlZW5FbGVtZW50KCkgIT0gJCgnI0FDSHRtbDVQbGF5ZXInKVswXSkgSGVscGVyLnJlcXVlc3RGdWxsc2NyZWVuKCQoJyNBQ0h0bWw1UGxheWVyJylbMF0pO1xuICAgICAgICAgICAgZWxzZSBIZWxwZXIuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxvYWRUb29sVGlwKCk7XG4gICAgc2V0QnRuTG9vcEljb24oKTtcbiAgICBzZXRCdG5CdWxsZXRTY3JlZW5JY29uKCk7XG4gICAgc2V0UmFkaW9GdWxsU2NyZWVuKCk7XG4gICAgc2V0Vm9sbXVlQW5kTXV0ZWQoKTtcbiAgICBsb2FkRW1vdGljb25zKCk7XG4gICAgbG9hZEJ1bGxldFNjcmVlblNldHRpbmdzKCk7XG59XG5cbmV4cG9ydCB7IExvYWRVSSB9Il19
